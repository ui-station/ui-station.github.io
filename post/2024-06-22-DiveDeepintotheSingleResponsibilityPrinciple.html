<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>단일 책임 원칙SRP에 깊이 파고들기 더 좋은 코드 작성 방법 알아보기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-22-DiveDeepintotheSingleResponsibilityPrinciple" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="단일 책임 원칙SRP에 깊이 파고들기 더 좋은 코드 작성 방법 알아보기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="단일 책임 원칙SRP에 깊이 파고들기 더 좋은 코드 작성 방법 알아보기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-DiveDeepintotheSingleResponsibilityPrinciple_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-22-DiveDeepintotheSingleResponsibilityPrinciple" data-gatsby-head="true"/><meta name="twitter:title" content="단일 책임 원칙SRP에 깊이 파고들기 더 좋은 코드 작성 방법 알아보기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-DiveDeepintotheSingleResponsibilityPrinciple_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 23:04" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_buildManifest.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">단일 책임 원칙SRP에 깊이 파고들기 더 좋은 코드 작성 방법 알아보기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="단일 책임 원칙SRP에 깊이 파고들기 더 좋은 코드 작성 방법 알아보기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-DiveDeepintotheSingleResponsibilityPrinciple&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>SRP를 수용하는 것이 어떻게 코딩 방법을 변화시키고 확장 가능한 소프트웨어를 이끌어낼 수 있는지 알아보세요.</h2>
<p><img src="/assets/img/2024-06-22-DiveDeepintotheSingleResponsibilityPrinciple_0.png" alt="SRP"></p>
<h1>SOLID 원칙이란 무엇인가요?</h1>
<p>모든 직업에는 준수해야 할 표준과 엄격한 규칙이 있으며, 이를 어기는 경우 중요한 결과가 발생할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>예를 들어, 건축가가 건물 규정을 준수하여 구조물의 안전과 안정성을 보장해야 하는 방법을 생각해보세요.</p>
<p>이러한 기준들이 왜 만들어졌을까요?</p>
<ul>
<li>많은 사람들이 동일한 과정을 거쳤고 그 경험은 모범 사례에 대한 집단적인 이해를 기여합니다.</li>
<li>표준을 준수하는 것은 실수 가능성을 줄입니다. 전문가들이 따를 수 있는 명확하고 검증된 방법을 제공하여 일관성과 신뢰성을 보장합니다.</li>
<li>표준은 모든 잠재적인 문제 영역에 대한 지식을 포괄합니다. 이러한 문제를 다루고 완화하는 방식으로 정의되어 있습니다.</li>
</ul>
<p>마찬가지로, 소프트웨어 개발에서,</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>SOLID 원칙은 깨끗하고 유지보수가 쉽고 견고한 코드를 작성하기 위한 표준을 제공하기 위해 만들어졌어요.</p>
<ul>
<li>이러한 원칙은 많은 개발자들의 경험과 소프트웨어 설계에서 가장 잘 작동하는 것에 대한 지식을 바탕으로 합니다.</li>
</ul>
<p>SOLID 원칙을 준수함으로써, 개발자들은 오류를 최소화하고 잠재적인 문제를 해결하며 이해하기 쉽고 확장 및 유지보수가 쉬운 소프트웨어를 만들 수 있어요.</p>
<h1>단일 책임 원칙(SRP)란 무엇인가요?</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>이제 모든 개발자는 "책임"을 각자 다르게 해석할 수 있습니다</li>
<li>컴포넌트를 디자인할 때, 한 명의 개발자는 전체 컴포넌트의 생성을 단일 책임으로 간주할 수 있습니다</li>
<li>또 다른 개발자는 뷰 및 네트워크 호출을 별도의 관심사로 처리하도록 더 세분화된 책임 분할을 옹호할 수 있습니다</li>
</ul>
<p>명확하게 하기 위해, 우리는 종종 SRP를 클래스가 하나의 변경 이유만을 가져야 한다는 개념으로 표현합니다.</p>
<p>간단히 말해서, 클래스가 여러 이유로 수정이 필요한 경우 SRP를 위반합니다.</p>
<h2>이젠 ProfileVC가 이 원칙을 어기는지 살펴봅시다</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProfileVC</span>: <span class="hljs-title class_">UIViewController</span> {
  <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() {
    fetchImageFromAPI()
  }

  <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchImageFromAPI</span>() {
    <span class="hljs-type">APIService</span>.callAPI(with: url) { response <span class="hljs-keyword">in</span>
      handleResponse(response: response)
    }
  }

  <span class="hljs-keyword">func</span> <span class="hljs-title function_">handleResponse</span>(<span class="hljs-params">response</span>: <span class="hljs-type">Result</span>&#x3C;<span class="hljs-type">Data</span>, <span class="hljs-type">Error</span>>) {
    <span class="hljs-keyword">switch</span> response {
    <span class="hljs-keyword">case</span> .success(<span class="hljs-keyword">let</span> data):
      processImage(data: data)
    <span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):
      <span class="hljs-built_in">print</span>(<span class="hljs-string">"Failed to fetch data: <span class="hljs-subst">\(error)</span>"</span>)
   }
  }

  <span class="hljs-keyword">func</span> <span class="hljs-title function_">processImage</span>(<span class="hljs-params">data</span>: <span class="hljs-type">Data</span>) {
    <span class="hljs-comment">// process image</span>
    displayDataOnUI(data: data)
  }

  <span class="hljs-keyword">func</span> <span class="hljs-title function_">displayDataOnUI</span>(<span class="hljs-params">data</span>: <span class="hljs-type">Data</span>) {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Updating UI with data"</span>)
  }

}
</code></pre>
<p><code>ProfileVC</code>는 다음과 같은 책임을 갖습니다:</p>
<ul>
<li>서비스에서 데이터를 가져오기 [위반]</li>
<li>응답 처리하기 [위반]</li>
<li>이미지 처리하기 [위반]</li>
<li>이미지 표시하기 [유효]</li>
</ul>
<h1>ProfileVC에 단일 책임 원칙(SPR) 적용해보기</h1>
<ul>
<li>ImageLoader</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>// ImageLoader는 오직 한 가지 책임만을 가지고 있습니다.
// 네트워크에서 이미지를 로드하고 전달하는 것입니다.</p>
<p>class ImageLoader {</p>
<p>func fetchImageFromAPI(completion: @escaping ResultCompletion) {
APIService.callAPI(with: url) { response in
completion(response)
}
}</p>
<p>}</p>
<ul>
<li>ImageDecoder</li>
</ul>
<p>// ImageDecoder
// 사실상, base64 이미지를 파싱하거나
// 유사한 작업을 통해 다음 해당 인스턴스로 전달할 것입니다.
// 디코딩 로직이 다른 구성 요소에서 수행되어야 함을 보여주기 위한 예시입니다.</p>
<p>class ImageDecoder {
let result: ResultCompletion</p>
<p>init(...) {
self.result = result
}</p>
<p>func decodeImage(completion: ...) -> Void) {
switch result {
case .success(let data):
// 디코딩 처리
completion(success(data))
case .failure(let error):
completion (.failure(error))
}
}</p>
<p>}</p>
<ul>
<li>ImageProcessor</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-comment">// ImageProcessor</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageProcessor</span> {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">imageData</span>: <span class="hljs-title class_">Data</span>

  <span class="hljs-title function_">init</span>(<span class="hljs-params">...</span>) {
    self.<span class="hljs-property">imageData</span> = imageData
  }

  func <span class="hljs-title function_">processData</span>(<span class="hljs-attr">completion</span>: ...) -> <span class="hljs-title class_">Void</span>)  {
    <span class="hljs-comment">// Process image and pass further to the chain</span>
  }

}
</code></pre>
<ul>
<li>ProfileVC</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// ProfileVC</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProfileVC</span>: <span class="hljs-title class_">UIViewController</span> {

  <span class="hljs-keyword">var</span> <span class="hljs-attr">load</span>: (() -> <span class="hljs-title class_">Void</span>)?

  func <span class="hljs-title function_">viewDidLoad</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">load</span>()
  }

  func <span class="hljs-title function_">displayImage</span>(_ <span class="hljs-attr">data</span>: <span class="hljs-title class_">Data</span>) -> <span class="hljs-title class_">Void</span>)  {
    profileImage.<span class="hljs-property">image</span> = <span class="hljs-title class_">UIImageFromData</span>(data)
  }

}
</code></pre>
<p>ProfileVC now only has a display method that will present the changes to the user</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>이제 조립이 시작됩니다, 실제 작업</h2>
<p>여기에 모든 구성 요소가 결합됩니다</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// ProfileComposer</span>
<span class="hljs-comment">// 이것은 이해하기 쉽도록 가장 간단한 조합 형태입니다</span>
<span class="hljs-comment">// 권장하는 방법은 디자인 패턴을 사용하는 것입니다.</span>

final <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProfileComposer</span> {
  func <span class="hljs-title function_">makeProfileVC</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> profileVC = <span class="hljs-title class_">ProfileVC</span>()

    profileVC.<span class="hljs-property">load</span> = {
      imageLoader.<span class="hljs-title function_">loadImage</span>(<span class="hljs-params"></span>) {
         imageDecoder.<span class="hljs-title function_">decodeImage</span>(<span class="hljs-params"></span>) {
            imageProcessor.<span class="hljs-title function_">processImage</span>(<span class="hljs-params"></span>) { data <span class="hljs-keyword">in</span>
                profileVC.<span class="hljs-title function_">displayImage</span>(data)
            }
         }
      }
    }

    <span class="hljs-comment">// ProfileVC의 탐색 처리</span>

  }
}
</code></pre>
<h1>이점은 무엇인가요?</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>유지 관리성, 재사용성 및 명확성</h2>
<p>ImageLoader, ImageProcessor 및 ImageResponseHandler와 같은 개별 구성 요소로 기능을 분리하면 유지 관리성이 향상되고 재사용성이 높아지며 명확한 책임을 가지므로 코드 가독성이 향상됩니다.</p>
<h2>추상화</h2>
<p>ProfileVC는 특정 데이터 원본과 분리되어 있어 UI 표현에만 집중할 수 있도록 해 유지할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>향상된 테스트 용이성</h2>
<p>구성 요소가 격리되면 외부 종속성없이 개별 기능의 심층 테스트 또는 모의적 사용이 가능해집니다.</p>
<h2>결합도 감소</h2>
<p>SRP를 따르면 구성 요소 간 종속성이 최소화되어 의도하지 않은 상호 작용의 위험을 낮추고 시스템의 유연성과 견고함을 향상시킵니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"단일 책임 원칙SRP에 깊이 파고들기 더 좋은 코드 작성 방법 알아보기","description":"","date":"2024-06-22 23:04","slug":"2024-06-22-DiveDeepintotheSingleResponsibilityPrinciple","content":"\n## SRP를 수용하는 것이 어떻게 코딩 방법을 변화시키고 확장 가능한 소프트웨어를 이끌어낼 수 있는지 알아보세요.\n\n![SRP](/assets/img/2024-06-22-DiveDeepintotheSingleResponsibilityPrinciple_0.png)\n\n# SOLID 원칙이란 무엇인가요?\n\n모든 직업에는 준수해야 할 표준과 엄격한 규칙이 있으며, 이를 어기는 경우 중요한 결과가 발생할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 건축가가 건물 규정을 준수하여 구조물의 안전과 안정성을 보장해야 하는 방법을 생각해보세요.\n\n이러한 기준들이 왜 만들어졌을까요?\n\n- 많은 사람들이 동일한 과정을 거쳤고 그 경험은 모범 사례에 대한 집단적인 이해를 기여합니다.\n- 표준을 준수하는 것은 실수 가능성을 줄입니다. 전문가들이 따를 수 있는 명확하고 검증된 방법을 제공하여 일관성과 신뢰성을 보장합니다.\n- 표준은 모든 잠재적인 문제 영역에 대한 지식을 포괄합니다. 이러한 문제를 다루고 완화하는 방식으로 정의되어 있습니다.\n\n마찬가지로, 소프트웨어 개발에서,\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSOLID 원칙은 깨끗하고 유지보수가 쉽고 견고한 코드를 작성하기 위한 표준을 제공하기 위해 만들어졌어요.\n\n- 이러한 원칙은 많은 개발자들의 경험과 소프트웨어 설계에서 가장 잘 작동하는 것에 대한 지식을 바탕으로 합니다.\n\nSOLID 원칙을 준수함으로써, 개발자들은 오류를 최소화하고 잠재적인 문제를 해결하며 이해하기 쉽고 확장 및 유지보수가 쉬운 소프트웨어를 만들 수 있어요.\n\n# 단일 책임 원칙(SRP)란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이제 모든 개발자는 \"책임\"을 각자 다르게 해석할 수 있습니다\n- 컴포넌트를 디자인할 때, 한 명의 개발자는 전체 컴포넌트의 생성을 단일 책임으로 간주할 수 있습니다\n- 또 다른 개발자는 뷰 및 네트워크 호출을 별도의 관심사로 처리하도록 더 세분화된 책임 분할을 옹호할 수 있습니다\n\n명확하게 하기 위해, 우리는 종종 SRP를 클래스가 하나의 변경 이유만을 가져야 한다는 개념으로 표현합니다.\n\n간단히 말해서, 클래스가 여러 이유로 수정이 필요한 경우 SRP를 위반합니다.\n\n## 이젠 ProfileVC가 이 원칙을 어기는지 살펴봅시다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nclass ProfileVC: UIViewController {\n  override func viewDidLoad() {\n    fetchImageFromAPI()\n  }\n\n  func fetchImageFromAPI() {\n    APIService.callAPI(with: url) { response in\n      handleResponse(response: response)\n    }\n  }\n\n  func handleResponse(response: Result\u003cData, Error\u003e) {\n    switch response {\n    case .success(let data):\n      processImage(data: data)\n    case .failure(let error):\n      print(\"Failed to fetch data: \\(error)\")\n   }\n  }\n\n  func processImage(data: Data) {\n    // process image\n    displayDataOnUI(data: data)\n  }\n\n  func displayDataOnUI(data: Data) {\n    print(\"Updating UI with data\")\n  }\n\n}\n```\n\n`ProfileVC`는 다음과 같은 책임을 갖습니다:\n\n- 서비스에서 데이터를 가져오기 [위반]\n- 응답 처리하기 [위반]\n- 이미지 처리하기 [위반]\n- 이미지 표시하기 [유효]\n\n# ProfileVC에 단일 책임 원칙(SPR) 적용해보기\n\n- ImageLoader\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n// ImageLoader는 오직 한 가지 책임만을 가지고 있습니다.\n// 네트워크에서 이미지를 로드하고 전달하는 것입니다.\n\nclass ImageLoader {\n\nfunc fetchImageFromAPI(completion: @escaping ResultCompletion) {\nAPIService.callAPI(with: url) { response in\ncompletion(response)\n}\n}\n\n}\n\n- ImageDecoder\n\n// ImageDecoder\n// 사실상, base64 이미지를 파싱하거나\n// 유사한 작업을 통해 다음 해당 인스턴스로 전달할 것입니다.\n// 디코딩 로직이 다른 구성 요소에서 수행되어야 함을 보여주기 위한 예시입니다.\n\nclass ImageDecoder {\nlet result: ResultCompletion\n\ninit(...) {\nself.result = result\n}\n\nfunc decodeImage(completion: ...) -\u003e Void) {\nswitch result {\ncase .success(let data):\n// 디코딩 처리\ncompletion(success(data))\ncase .failure(let error):\ncompletion (.failure(error))\n}\n}\n\n}\n\n- ImageProcessor\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// ImageProcessor\n\nclass ImageProcessor {\n  let imageData: Data\n\n  init(...) {\n    self.imageData = imageData\n  }\n\n  func processData(completion: ...) -\u003e Void)  {\n    // Process image and pass further to the chain\n  }\n\n}\n```\n\n- ProfileVC\n\n```js\n// ProfileVC\n\nclass ProfileVC: UIViewController {\n\n  var load: (() -\u003e Void)?\n\n  func viewDidLoad() {\n    load()\n  }\n\n  func displayImage(_ data: Data) -\u003e Void)  {\n    profileImage.image = UIImageFromData(data)\n  }\n\n}\n```\n\nProfileVC now only has a display method that will present the changes to the user\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 이제 조립이 시작됩니다, 실제 작업\n\n여기에 모든 구성 요소가 결합됩니다\n\n```js\n// ProfileComposer\n// 이것은 이해하기 쉽도록 가장 간단한 조합 형태입니다\n// 권장하는 방법은 디자인 패턴을 사용하는 것입니다.\n\nfinal class ProfileComposer {\n  func makeProfileVC() {\n    let profileVC = ProfileVC()\n\n    profileVC.load = {\n      imageLoader.loadImage() {\n         imageDecoder.decodeImage() {\n            imageProcessor.processImage() { data in\n                profileVC.displayImage(data)\n            }\n         }\n      }\n    }\n\n    // ProfileVC의 탐색 처리\n\n  }\n}\n```\n\n# 이점은 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 유지 관리성, 재사용성 및 명확성\n\nImageLoader, ImageProcessor 및 ImageResponseHandler와 같은 개별 구성 요소로 기능을 분리하면 유지 관리성이 향상되고 재사용성이 높아지며 명확한 책임을 가지므로 코드 가독성이 향상됩니다.\n\n## 추상화\n\nProfileVC는 특정 데이터 원본과 분리되어 있어 UI 표현에만 집중할 수 있도록 해 유지할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 향상된 테스트 용이성\n\n구성 요소가 격리되면 외부 종속성없이 개별 기능의 심층 테스트 또는 모의적 사용이 가능해집니다.\n\n## 결합도 감소\n\nSRP를 따르면 구성 요소 간 종속성이 최소화되어 의도하지 않은 상호 작용의 위험을 낮추고 시스템의 유연성과 견고함을 향상시킵니다.\n","ogImage":{"url":"/assets/img/2024-06-22-DiveDeepintotheSingleResponsibilityPrinciple_0.png"},"coverImage":"/assets/img/2024-06-22-DiveDeepintotheSingleResponsibilityPrinciple_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003eSRP를 수용하는 것이 어떻게 코딩 방법을 변화시키고 확장 가능한 소프트웨어를 이끌어낼 수 있는지 알아보세요.\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-DiveDeepintotheSingleResponsibilityPrinciple_0.png\" alt=\"SRP\"\u003e\u003c/p\u003e\n\u003ch1\u003eSOLID 원칙이란 무엇인가요?\u003c/h1\u003e\n\u003cp\u003e모든 직업에는 준수해야 할 표준과 엄격한 규칙이 있으며, 이를 어기는 경우 중요한 결과가 발생할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e예를 들어, 건축가가 건물 규정을 준수하여 구조물의 안전과 안정성을 보장해야 하는 방법을 생각해보세요.\u003c/p\u003e\n\u003cp\u003e이러한 기준들이 왜 만들어졌을까요?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e많은 사람들이 동일한 과정을 거쳤고 그 경험은 모범 사례에 대한 집단적인 이해를 기여합니다.\u003c/li\u003e\n\u003cli\u003e표준을 준수하는 것은 실수 가능성을 줄입니다. 전문가들이 따를 수 있는 명확하고 검증된 방법을 제공하여 일관성과 신뢰성을 보장합니다.\u003c/li\u003e\n\u003cli\u003e표준은 모든 잠재적인 문제 영역에 대한 지식을 포괄합니다. 이러한 문제를 다루고 완화하는 방식으로 정의되어 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e마찬가지로, 소프트웨어 개발에서,\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eSOLID 원칙은 깨끗하고 유지보수가 쉽고 견고한 코드를 작성하기 위한 표준을 제공하기 위해 만들어졌어요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이러한 원칙은 많은 개발자들의 경험과 소프트웨어 설계에서 가장 잘 작동하는 것에 대한 지식을 바탕으로 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSOLID 원칙을 준수함으로써, 개발자들은 오류를 최소화하고 잠재적인 문제를 해결하며 이해하기 쉽고 확장 및 유지보수가 쉬운 소프트웨어를 만들 수 있어요.\u003c/p\u003e\n\u003ch1\u003e단일 책임 원칙(SRP)란 무엇인가요?\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e이제 모든 개발자는 \"책임\"을 각자 다르게 해석할 수 있습니다\u003c/li\u003e\n\u003cli\u003e컴포넌트를 디자인할 때, 한 명의 개발자는 전체 컴포넌트의 생성을 단일 책임으로 간주할 수 있습니다\u003c/li\u003e\n\u003cli\u003e또 다른 개발자는 뷰 및 네트워크 호출을 별도의 관심사로 처리하도록 더 세분화된 책임 분할을 옹호할 수 있습니다\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e명확하게 하기 위해, 우리는 종종 SRP를 클래스가 하나의 변경 이유만을 가져야 한다는 개념으로 표현합니다.\u003c/p\u003e\n\u003cp\u003e간단히 말해서, 클래스가 여러 이유로 수정이 필요한 경우 SRP를 위반합니다.\u003c/p\u003e\n\u003ch2\u003e이젠 ProfileVC가 이 원칙을 어기는지 살펴봅시다\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProfileVC\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUIViewController\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eoverride\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eviewDidLoad\u003c/span\u003e() {\n    fetchImageFromAPI()\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchImageFromAPI\u003c/span\u003e() {\n    \u003cspan class=\"hljs-type\"\u003eAPIService\u003c/span\u003e.callAPI(with: url) { response \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n      handleResponse(response: response)\n    }\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleResponse\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eResult\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-type\"\u003eData\u003c/span\u003e, \u003cspan class=\"hljs-type\"\u003eError\u003c/span\u003e\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e response {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .success(\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e data):\n      processImage(data: data)\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .failure(\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e error):\n      \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Failed to fetch data: \u003cspan class=\"hljs-subst\"\u003e\\(error)\u003c/span\u003e\"\u003c/span\u003e)\n   }\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprocessImage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eData\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// process image\u003c/span\u003e\n    displayDataOnUI(data: data)\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edisplayDataOnUI\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eData\u003c/span\u003e) {\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Updating UI with data\"\u003c/span\u003e)\n  }\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eProfileVC\u003c/code\u003e는 다음과 같은 책임을 갖습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e서비스에서 데이터를 가져오기 [위반]\u003c/li\u003e\n\u003cli\u003e응답 처리하기 [위반]\u003c/li\u003e\n\u003cli\u003e이미지 처리하기 [위반]\u003c/li\u003e\n\u003cli\u003e이미지 표시하기 [유효]\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eProfileVC에 단일 책임 원칙(SPR) 적용해보기\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eImageLoader\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e// ImageLoader는 오직 한 가지 책임만을 가지고 있습니다.\n// 네트워크에서 이미지를 로드하고 전달하는 것입니다.\u003c/p\u003e\n\u003cp\u003eclass ImageLoader {\u003c/p\u003e\n\u003cp\u003efunc fetchImageFromAPI(completion: @escaping ResultCompletion) {\nAPIService.callAPI(with: url) { response in\ncompletion(response)\n}\n}\u003c/p\u003e\n\u003cp\u003e}\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eImageDecoder\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e// ImageDecoder\n// 사실상, base64 이미지를 파싱하거나\n// 유사한 작업을 통해 다음 해당 인스턴스로 전달할 것입니다.\n// 디코딩 로직이 다른 구성 요소에서 수행되어야 함을 보여주기 위한 예시입니다.\u003c/p\u003e\n\u003cp\u003eclass ImageDecoder {\nlet result: ResultCompletion\u003c/p\u003e\n\u003cp\u003einit(...) {\nself.result = result\n}\u003c/p\u003e\n\u003cp\u003efunc decodeImage(completion: ...) -\u003e Void) {\nswitch result {\ncase .success(let data):\n// 디코딩 처리\ncompletion(success(data))\ncase .failure(let error):\ncompletion (.failure(error))\n}\n}\u003c/p\u003e\n\u003cp\u003e}\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eImageProcessor\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ImageProcessor\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImageProcessor\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eimageData\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eData\u003c/span\u003e\n\n  \u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e...\u003c/span\u003e) {\n    self.\u003cspan class=\"hljs-property\"\u003eimageData\u003c/span\u003e = imageData\n  }\n\n  func \u003cspan class=\"hljs-title function_\"\u003eprocessData\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ecompletion\u003c/span\u003e: ...) -\u003e \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e)  {\n    \u003cspan class=\"hljs-comment\"\u003e// Process image and pass further to the chain\u003c/span\u003e\n  }\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eProfileVC\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ProfileVC\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProfileVC\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUIViewController\u003c/span\u003e {\n\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eload\u003c/span\u003e: (() -\u003e \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e)?\n\n  func \u003cspan class=\"hljs-title function_\"\u003eviewDidLoad\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003eload\u003c/span\u003e()\n  }\n\n  func \u003cspan class=\"hljs-title function_\"\u003edisplayImage\u003c/span\u003e(_ \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eData\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e)  {\n    profileImage.\u003cspan class=\"hljs-property\"\u003eimage\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eUIImageFromData\u003c/span\u003e(data)\n  }\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eProfileVC now only has a display method that will present the changes to the user\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e이제 조립이 시작됩니다, 실제 작업\u003c/h2\u003e\n\u003cp\u003e여기에 모든 구성 요소가 결합됩니다\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ProfileComposer\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 이것은 이해하기 쉽도록 가장 간단한 조합 형태입니다\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 권장하는 방법은 디자인 패턴을 사용하는 것입니다.\u003c/span\u003e\n\nfinal \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProfileComposer\u003c/span\u003e {\n  func \u003cspan class=\"hljs-title function_\"\u003emakeProfileVC\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e profileVC = \u003cspan class=\"hljs-title class_\"\u003eProfileVC\u003c/span\u003e()\n\n    profileVC.\u003cspan class=\"hljs-property\"\u003eload\u003c/span\u003e = {\n      imageLoader.\u003cspan class=\"hljs-title function_\"\u003eloadImage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n         imageDecoder.\u003cspan class=\"hljs-title function_\"\u003edecodeImage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n            imageProcessor.\u003cspan class=\"hljs-title function_\"\u003eprocessImage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) { data \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n                profileVC.\u003cspan class=\"hljs-title function_\"\u003edisplayImage\u003c/span\u003e(data)\n            }\n         }\n      }\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// ProfileVC의 탐색 처리\u003c/span\u003e\n\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e이점은 무엇인가요?\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e유지 관리성, 재사용성 및 명확성\u003c/h2\u003e\n\u003cp\u003eImageLoader, ImageProcessor 및 ImageResponseHandler와 같은 개별 구성 요소로 기능을 분리하면 유지 관리성이 향상되고 재사용성이 높아지며 명확한 책임을 가지므로 코드 가독성이 향상됩니다.\u003c/p\u003e\n\u003ch2\u003e추상화\u003c/h2\u003e\n\u003cp\u003eProfileVC는 특정 데이터 원본과 분리되어 있어 UI 표현에만 집중할 수 있도록 해 유지할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e향상된 테스트 용이성\u003c/h2\u003e\n\u003cp\u003e구성 요소가 격리되면 외부 종속성없이 개별 기능의 심층 테스트 또는 모의적 사용이 가능해집니다.\u003c/p\u003e\n\u003ch2\u003e결합도 감소\u003c/h2\u003e\n\u003cp\u003eSRP를 따르면 구성 요소 간 종속성이 최소화되어 의도하지 않은 상호 작용의 위험을 낮추고 시스템의 유연성과 견고함을 향상시킵니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-DiveDeepintotheSingleResponsibilityPrinciple"},"buildId":"wOkGEDZCvEs3S_XaNsdwr","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>