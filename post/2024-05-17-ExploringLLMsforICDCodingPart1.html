<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ICD 코딩을 위한 LLM 탐험 - 파트 1 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-17-ExploringLLMsforICDCodingPart1" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ICD 코딩을 위한 LLM 탐험 - 파트 1 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="ICD 코딩을 위한 LLM 탐험 - 파트 1 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-17-ExploringLLMsforICDCodingPart1_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-17-ExploringLLMsforICDCodingPart1" data-gatsby-head="true"/><meta name="twitter:title" content="ICD 코딩을 위한 LLM 탐험 - 파트 1 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-17-ExploringLLMsforICDCodingPart1_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-17 19:38" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_buildManifest.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">ICD 코딩을 위한 LLM 탐험 - 파트 1</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="ICD 코딩을 위한 LLM 탐험 - 파트 1" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 17, 2024</span><span class="posts_reading_time__f7YPP">19<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-17-ExploringLLMsforICDCodingPart1&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>LLM(Large Language Model)을 활용한 자동 진단 코딩 시스템 구축</h2>
<p>임상 코딩은 흔히 쓰이는 용어는 아니지만, 대부분의 국가에서 건강 관리 체계와 상호작용하는 모든 사람에게 중대한 영향을 미칩니다. 임상 코딩은 환자 건강 기록에서 의학 정보(진단 및 수술 등)를 표준화된 숫자 또는 알파벳 코드로 번역하고 매핑하는 것을 포함합니다. 이러한 코드는 청구, 건강 관리 분석 및 환자가 적절한 치료를 받을 수 있도록 하는 데 중요합니다.</p>
<p><img src="/assets/img/2024-05-17-ExploringLLMsforICDCodingPart1_0.png" alt="image"></p>
<p>임상 코딩은 일반적으로 의료 전문가가 수행합니다. 이러한 코더들은 다양한 진단과 수술을 위한 특정 코드가 포함된 복잡하고 종종 계층적인 코딩 용어를 탐색합니다. 따라서 코더들은 사용된 코딩 용어에 대한 깊은 이해와 경험을 가져야 합니다. 그러나 문서를 수동으로 코딩하는 것은 느릴 수 있고, 오류가 발생할 수 있으며, 상당한 인적 전문 지식이 필요하여 병목 현상이 발생할 수 있습니다.</p>
<p>심층 학습은 임상 코딩 자동화에 중요한 역할을 할 수 있습니다. 복잡한 의료 정보를 코드로 추출하고 번역함으로써, 심층 학습 시스템은 인간 중심 시스템 내에서 가치 있는 도구로 작용할 수 있습니다. 이러한 시스템은 코더들을 지원하여 대량의 데이터를 신속하게 처리하고 정확성을 향상시킬 수 있습니다. 이는 행정 업무를 간소화하고 청구 오류를 줄이며 환자 치료 결과를 향상시킬 수 있습니다.</p>
<p>이 첫 번째 부분에서는 ICD 코딩이 무엇인지, 자동 코딩 시스템이 효과적으로 극복해야 하는 다양한 도전에 대해 설명합니다. 또한 대용량 언어 모델(LLM)이 이러한 문제를 극복하는 데 효과적으로 활용할 수 있는 방법을 분석하고, 최근 논문에서 LLM을 효과적으로 활용한 알고리즘을 적용하여 ICD 코딩에 성공적으로 적용하는 방법을 설명합니다.</p>
<h2>목차:</h2>
<ul>
<li>ICD 코딩이란 무엇인가?</li>
<li>자동 ICD 코딩의 도전 요소는 무엇인가?</li>
<li>LLM이 자동 ICD 코딩에 어떻게 도움이 될까?</li>
<li>"Off-the-shelf 대용량 언어 모델을 이용한 자동 임상 코딩" 논문 탐색</li>
<li>논문에 설명된 기법 구현</li>
<li>결론</li>
<li>참고문헌</li>
</ul>
<h1>ICD 코딩이란 무엇인가요?</h1>
<p>국제질병분류(ICD) 코딩은 세계보건기구에서 개발 및 유지보수하는 임상 용어 시스템입니다 [1]. 대부분의 국가에서 환자의 모든 진단, 증상 및 절차를 범주화하고 코딩하는 데 사용됩니다.</p>
<p>환자의 진단과 의료 절차를 기록하는 의료 기록은 ICD 코딩에 매우 중요합니다. ICD 용어는 대략 75,000가지 다른 코드로 구성된 트리 구조를 특징으로 하여 방대한 정보를 효율적으로 정리합니다. 이러한 문서를 정확하게 코딩하는 것이 중요합니다. 정확한 코딩은 적절한 청구를 보장하며 의료 분석 품질에 영향을 미치며 환자 치료 결과, 보상 및 의료 효율성에 직접적으로 영향을 줍니다.</p>
<h1>자동 ICD 코딩에서 어떤 도전들이 있을까요?</h1>
<p>ICD 코딩은 효과적으로 작동하기 위해 자동화된 시스템이 극복해야 할 여러 가지 도전이 있습니다.</p>
<h2>ICD 코딩의 레이블 다양성:</h2>
<p>중요한 도전 중 하나는 레이블의 광범위한 출력 공간입니다. ICD 코드는 많고 각 코드는 미세한 세부 사항에서 차이가 있을 수 있습니다. 예를 들어, 오른손에 영향을 주는 상태와 왼손에 영향을 주는 상태는 서로 다른 코드를 갖게 됩니다. 또한 의료 기록에서 드물게 나타나는 희귀 코드의 긴 꼬리가 존재하여, 이러한 코드를 학습하고 정확하게 예측하기 어렵게 만들 수 있습니다.</p>
<h2>새로운 ICD 코드에 대한 적응:</h2>
<p>번거로우시겠지만, 테이블 태그를 마크다운 형식으로 변경해드릴게요!</p>
<p>전통적인 데이터셋인 MIMIC-III [2] 같은 경우는 종합적이지만, 종종 ICD 코드의 범위를 훈련 말뭉치에 포함된 코드로 제한합니다. 이 제한은 의료 기록에서 ICD 코드로의 딥러닝 모델을 다중 레이블 분류 문제로 처리하는 데 새로운 코드가 도입된 경우 모형 훈련 이후에 어려움을 겪을 수 있음을 의미합니다. 이는 재훈련이 필요하고 잠재적으로 어려울 수 있게 만듭니다.</p>
<h2>정보 추출 및 문맥 활용:</h2>
<p>또 다른 주요 과제는 의료 기록에서 정보를 정확하게 추출하고 문맥에 맞게 처리하는 것입니다. ICD 코딩은 근본적으로 정보 검색 문제로, 의료 기록에서 진단을 식별하는 것 뿐만 아니라 이러한 진단을 해당 ICD 코드로 올바르게 매핑하는 데 필요한 모든 보완 정보를 포착해야 합니다. 따라서 자동화된 시스템이 의료 기록에서 여러 진단을 추출하고 적절히 문맥화하여 ICD 코드로 정확하게 매핑되도록 하는 것이 중요합니다.</p>
<p><img src="/assets/img/2024-05-17-ExploringLLMsforICDCodingPart1_1.png" alt="이미지"></p>
<p>"Contextualization"란 여기서 무엇을 의미할까요? 의학 노트를 다룰 때 진단을 맥락에 맞게 처리하는 것은 관련 세부사항과 관련된 정보 — 예를 들어 영향을 받는 신체 부위 및 질환의 증상 — 를 연결하여 진단을 완전히 특성화하는 것을 의미합니다. 일반적으로 이 작업은 관계 추출로 참조됩니다.</p>
<h1>대규모 언어 모델(LLMs)이 자동 ICD 코딩에 어떻게 도움이 되나요?</h1>
<p>자동 ICD 코딩의 과제를 다룰 때, 대규모 언어 모델 (LLMs)은 이러한 문제에 대처하는 데 적합하며, 특히 새로운 레이블에 대한 적응성과 복잡한 정보 추출 작업을 관리하는 능력으로 인해 잘 역할을 합니다. 그러나 여기서의 포인트는 LLMs가 자동 ICD 코딩에 대한 최상의 해결책이거나 이러한 문제를 해결할 수 있는 유일한 해결책인 것을 주장하는 것이 아니라, 자동 ICD 코딩 시스템이 극복해야 하는 주요 과제들을 설정함으로써 LLMs의 능력을 최대한 활용하여 이를 해결할 수 있는지를 분석하는 것입니다.</p>
<h2>새로운 및 드문 ICD 코드에 대한 적응:</h2>
<p>LLMs는 견고한 제로샷 및 퓨샷 학습 능력을 보여주며, 적은 예시와 프롬프트에서 제공된 지침으로 새로운 작업에 적응할 수 있습니다. 검색 증강 생성 (RAG)은 미세 조정 없이도 LLM이 새로운 작업에 적응하기 위해 더 많은 맥락 정보에 접근할 수 있는 패러다임입니다. 이는 특히 기존의 훈련 데이터셋에서 자주 나타나지 않을 수 있는 새로운 및/또는 희귀한 ICD 코드에 LLM을 조정하는 데 유용합니다. 이를 단지 몇 가지 설명 또는 사용 사례로부터 합니다.</p>
<h2>맥락 정보:</h2>
<p>LLMs는 임상 분야에서의 제로샷 관계 추출에서 효과적으로 확인되었습니다. 제로샷 관계 추출은 LLM이 해당 관계에 대해 이전에 구체적인 훈련을 받지 않고 텍스트에서 관계를 식별하고 분류할 수 있도록 합니다. 이를 통해 의료 코딩에서의 진단을 더 잘 맥락화하여 더 정확한 ICD 코드를 가져올 수 있습니다.</p>
<h1>"Automated clinical coding using off-the-shelf large language models" 논문 탐색하기:</h1>
<p>LLM을 ICD 코딩에 적용한 최근 연구를 탐색하다가, 특정한 세부 조정 없이 LLM을 활용한 ICD 코딩에 관한 매우 흥미로운 논문을 발견했습니다. 저자들은 LLM을 활용한 ICD 코딩을 위해 LLM-지도된 트리 탐색이라는 방법을 개발했습니다 [5].</p>
<h2>이 방법은 어떻게 작동하나요?</h2>
<p>ICD 용어는 계층적인 트리 구조입니다. 각 ICD 코드는 이 계층적 구조 내에 존재하며, 부모 코드는 더 일반적인 상태를 다루고, 자식 코드는 특정 질병을 상세히 설명합니다. ICD 트리를 탐색하면 더 구체적이고 세분화된 진단 코드로 이어집니다.</p>
<p>LLM-지도된 트리 탐색에서는 탐색이 루트에서 시작되고 LLM을 사용하여 탐색할 가지를 선택하며, 모든 경로가 고갈될 때까지 반복적으로 계속합니다. 실제로 이 과정은 트리의 임의의 수준에서 모든 코드의 설명과 의료 노트를 LLM에 프롬프트로 제공하고, 해당 의료 노트에 대한 관련 코드를 식별하도록 요청하는 것으로 구현됩니다. 각 인스턴스에서 LLM에 의해 선택된 코드는 더 구체적으로 탐색되고 조사됩니다. 이 방법을 사용하면 가장 관련성이 높은 ICD 코드가 식별되며, 이후 임상 노트에 대한 예측 레이블로 할당됩니다.</p>
<p>예시를 통해 이를 명확히 해보겠습니다. ICD 코드 1과 ICD 코드 2라는 두 개의 루트 노드를 가진 트리를 상상해보세요. 각 노드는 코드를 특성화하는 평문 설명을 가지고 있습니다. 초기 단계에서 LLM에게 의학 노트와 코드 설명이 제공되고 의학 노트와 관련된 코드를 식별하도록 요청됩니다.</p>
<p>이 시나리오에서 LLM은 의학 노트와 관련이 있는 것으로 판단된 ICD 코드 1과 ICD 코드 2를 식별합니다. 알고리즘은 각 코드의 자식 노드를 조사합니다. 각 부모 코드는 더 구체적인 ICD 코드를 나타내는 두 개의 자식 노드를 가지고 있습니다. ICD 코드 1부터 시작하여, LLM은 ICD 코드 1.1과 ICD 코드 1.2의 설명을 사용하여 의학 노트를 기반으로 관련 코드를 결정합니다. LLM은 ICD 코드 1.1이 관련이 있다고 결론 내리고, ICD 코드 1.2는 관련이 없다고 판단합니다. ICD 코드 1.1에는 더 이상의 자식 노드가 없으므로, 알고리즘은 할당 가능한 코드인지 확인하고 문서에 할당합니다. 그 다음 알고리즘은 ICD 코드 2의 자식 노드를 평가합니다. LLM을 호출하여, ICD 코드 2.1이 관련이 있는 것으로 판단합니다. 이것은 간단화된 예시이며, 실제로는 ICD 트리는 광범위하고 깊기 때문에 알고리즘은 각 관련된 노드의 자식을 탐색하거나 트리의 끝에 도달하거나 유효한 탐색을 소진할 때까지 계속됩니다.</p>
<h2>핵심</h2>
<ul>
<li>이 방법은 LLM의 세밀한 조정이 필요하지 않습니다. 대신, 제공된 설명을 기반으로 LLM의 의료 노트를 상황에 맞게 이해하고 관련 ICD 코드를 동적으로 식별할 수 있는 능력을 활용합니다.</li>
<li>더 나아가, 본 논문은 LLM이 프롬프트에 관련 정보가 주어질 때 대규모 출력 공간에 효과적으로 적응할 수 있으며, macro-average 지표 측면에서 드문 코드에서 PLM-ICD [6]를 앞지를 수 있다는 것을 보여줍니다.</li>
<li>이 기술은 또한 파라메트릭 지식에 기초하여 의학 노트의 ICD 코드를 예측하도록 LLM에 직접 요청하는 기준선을 능가합니다. 이는 LLM을 임상 코딩 작업을 해결하기 위한 도구나 외부 지식과 통합하는 잠재력을 강조합니다.</li>
</ul>
<h2>단점</h2>
<ul>
<li>알고리즘은 트리의 각 수준에서 LLM을 호출합니다. 이로 인해 트리를 탐색하는 동안 LLM 호출 횟수가 많아지며, ICD 트리의 광범위함이 이에 더해집니다. 이는 단일 문서를 처리하는 데 높은 대기 시간과 비용으로 이어집니다.</li>
<li>저자들이 논문에서 언급한 바와 같이, 관련 있는 코드를 정확하게 예측하려면 LLM이 모든 수준에서 부모 노드를 올바르게 식별해야 합니다. 한 수준에서 실수가 발생하더라도, LLM은 최종 관련 코드에 도달할 수 없게 됩니다.</li>
<li>저자들은 MIMIC-III와 같은 데이터셋을 사용하여 메소드를 평가할 수 없었습니다. 외부 서비스로의 데이터 전송을 금지하는 제한 사항으로 인하여 OpenAI의 GPT 엔드포인트와 같은 외부 서비스로의 데이터 전송이 불가능했습니다. 대신, 저자들은 CodiEsp 데이터셋 [7,8]의 테스트 세트를 사용하여 해당 방법을 평가했습니다. 해당 데이터셋은 250개의 의학 노트를 포함하고 있습니다. 이 데이터셋의 크기가 작은 것은 해당 방법이 대규모 임상 데이터셋에서의 성능을 아직 입증하지 못했음을 시사합니다.</li>
</ul>
<h1>논문에서 설명한 기술 구현하기</h1>
<p>이 기술을 구현하여 그 작동 방식을 더 잘 이해해 봅시다. 논문에서 언급했듯이, 해당 논문은 평가를 위해 CodiEsp 테스트 세트를 사용합니다. 이 데이터셋은 스페인어 의학 노트와 이에 대응하는 ICD 코드로 구성되어 있습니다. 데이터셋에는 영어로 번역된 버전도 포함되어 있지만, 저자들은 스페인어 의학 노트를 GPT-3.5를 사용하여 영어로 번역하였으며, 이를 통해 사전 번역된 버전을 사용하는 것보다 성능이 약간 향상되었다고 주장했습니다. 이 기능을 복제하고 노트를 영어로 번역해 봅시다.</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">construct_translation_prompt</span>(medical_note):
    <span class="hljs-string">""</span><span class="hljs-string">"
    Construct a prompt template for translating Spanish medical notes to English.
    
    Args:
        medical_note (str): The medical case note.
        
    Returns:
        str: A structured template ready to be used as input for a language model.
    "</span><span class="hljs-string">""</span>    
    translation_prompt = <span class="hljs-string">""</span><span class="hljs-string">"You are an expert Spanish-to-English translator. You are provided with a clinical note written in Spanish.
You must translate the note into English. You must ensure that you properly translate the medical and technical terms from Spanish to English without any mistakes.
Spanish Medical Note:
{medical_note}"</span><span class="hljs-string">""</span>
    
    <span class="hljs-keyword">return</span> translation_prompt.<span class="hljs-title function_">format</span>(medical_note = medical_note)
</code></pre>
<p>Now that we have the evaluation corpus ready, let’s implement the core logic for the tree-search algorithm. We define the functionality in get_icd_codes, which accepts the medical note to process, the model name, and the temperature setting. The model name must be either “gpt-3.5-turbo-0613” for GPT-3.5 or “meta-llama/Llama-2–70b-chat-hf” for Llama-2 70B Chat. This specification determines the LLM that the tree-search algorithm will invoke during its processing.</p>
<p>Evaluating GPT-4 is possible using the same code-base by providing the appropriate model name, but we choose to skip it as it is quite time-consuming.</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">get_icd_codes</span>(medical_note, model_name=<span class="hljs-string">"gpt-3.5-turbo-0613"</span>, temperature=<span class="hljs-number">0.0</span>):
    <span class="hljs-string">""</span><span class="hljs-string">"
    Identifies relevant ICD-10 codes for a given medical note by querying a language model.

    This function implements the tree-search algorithm for ICD coding described in https://openreview.net/forum?id=mqnR8rGWkn.

    Args:
        medical_note (str): The medical note for which ICD-10 codes are to be identified.
        model_name (str): The identifier for the language model used in the API (default is 'gpt-3.5-turbo-0613').

    Returns:
        list of str: A list of confirmed ICD-10 codes that are relevant to the medical note.
    "</span><span class="hljs-string">""</span>
    assigned_codes = []
    candidate_codes = [x.<span class="hljs-property">name</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-variable constant_">CHAPTER_LIST</span>]
    parent_codes = []
    prompt_count = <span class="hljs-number">0</span>

    <span class="hljs-keyword">while</span> prompt_count &#x3C; <span class="hljs-number">50</span>:
        code_descriptions = {}
        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-attr">candidate_codes</span>:
            description, code = <span class="hljs-title function_">get_name_and_description</span>(x, model_name)
            code_descriptions[description] = code

        prompt = <span class="hljs-title function_">build_zero_shot_prompt</span>(medical_note, <span class="hljs-title function_">list</span>(code_descriptions.<span class="hljs-title function_">keys</span>()), model_name=model_name)
        lm_response = <span class="hljs-title function_">get_response</span>(prompt, model_name, temperature=temperature, max_tokens=<span class="hljs-number">500</span>)
        predicted_codes = <span class="hljs-title function_">parse_outputs</span>(lm_response, code_descriptions, model_name=model_name)

        <span class="hljs-keyword">for</span> code <span class="hljs-keyword">in</span> <span class="hljs-attr">predicted_codes</span>:
            <span class="hljs-keyword">if</span> cm.<span class="hljs-title function_">is_leaf</span>(code[<span class="hljs-string">"code"</span>]):
                assigned_codes.<span class="hljs-title function_">append</span>(code[<span class="hljs-string">"code"</span>])
            <span class="hljs-attr">else</span>:
                parent_codes.<span class="hljs-title function_">append</span>(code)

        <span class="hljs-keyword">if</span> <span class="hljs-title function_">len</span>(parent_codes) > <span class="hljs-number">0</span>:
            parent_code = parent_codes.<span class="hljs-title function_">pop</span>(<span class="hljs-number">0</span>)
            candidate_codes = cm.<span class="hljs-title function_">get_children</span>(parent_code[<span class="hljs-string">"code"</span>])
        <span class="hljs-attr">else</span>:
            <span class="hljs-keyword">break</span>

        prompt_count += <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> assigned_codes
</code></pre>
<p>우리는 논문과 비슷하게, ICD-10 트리에 액세스하는 simple_icd_10_cm 라이브러리를 사용합니다. 이를 통해 트리를 탐색하고, 각 코드에 대한 설명에 액세스하며 유효한 코드를 식별할 수 있습니다. 먼저, 트리의 첫 번째 수준에서 노드를 가져옵니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> simple_icd_10_cm <span class="hljs-keyword">as</span> cm

def <span class="hljs-title function_">get_name_and_description</span>(code, model_name):
    <span class="hljs-string">""</span><span class="hljs-string">"
    ICD-10 코드의 이름과 설명을 검색합니다.
    
    Args:
        code (str): ICD-10 코드.
        
    Returns:
        tuple: 형식화된 설명과 코드의 이름이 포함된 튜플을 반환합니다.
    "</span><span class="hljs-string">""</span>
    full_data = cm.<span class="hljs-title function_">get_full_data</span>(code).<span class="hljs-title function_">split</span>(<span class="hljs-string">"\n"</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">format_code_descriptions</span>(full_data[<span class="hljs-number">3</span>], model_name), full_data[<span class="hljs-number">1</span>]
</code></pre>
<p>루프 내부에서 각 노드에 해당하는 설명을 얻습니다. 이제 의료 노트와 코드 설명을 기반으로 LLM을 위한 프롬프트를 작성해야 합니다. 우리는 논문에서 제공된 세부 정보를 기반으로 GPT-3.5와 Llama-2용 프롬프트를 작성합니다.</p>
<pre><code class="hljs language-js">prompt_template_dict = {<span class="hljs-string">"gpt-3.5-turbo-0613"</span> : <span class="hljs-string">""</span><span class="hljs-string">"[사례 노트]:
{note}
[예시]:
&#x3C;예시 프롬프트>
위식도 역류병
장전위

&#x3C;응답>
위식도 역류병: 예, 환자에게 오메프라졸 처방함.
장전위: 아니오.

[작업]:
다음 ICD-10 코드 설명 각각을 고려하고 사례 노트에 관련 언급이 있는지 평가하십시오.
예시의 형식을 정확히 따르십시오.

{code_descriptions}"</span><span class="hljs-string">""</span>,

<span class="hljs-string">"meta-llama/Llama-2-70b-chat-hf"</span>: <span class="hljs-string">""</span><span class="hljs-string">"[사례 노트]:
{note}

[예시]:
&#x3C;코드 설명>
* 위식도 역류병
* 장전위
* 급성비인두염 [감기]
&#x3C;/코드 설명>

&#x3C;응답>
* 위식도 역류병: 예, 환자에게 오메프라졸 처방함.
* 장전위: 아니오.
* 급성비인두염 [감기]: 아니오.
&#x3C;/응답>

[작업]:
예시 응답 형식을 정확히 따르십시오. (예) 판단하기 전에 전체 설명과 (예|아니오) 판단을 입력한 후에 새 줄을 추가하십시오. 
다음 ICD-10 코드 설명을 고려하고 사례 노트에서 관련 언급이 있는지 확인하십시오.

{code_descriptions}"</span><span class="hljs-string">""</span>
}
</code></pre>
<p>의료 기록과 코드 설명에 기반한 프롬프트를 지금 만들어 보겠습니다. 프롬프트 및 코딩에서 우리에게 이점은 GPT-3.5 및 Llama 2 모두와 상호 작용하기 위해 동일한 openai 라이브러리를 사용할 수 있다는 것입니다. 단, Llama-2가 deepinfra를 통해 배포되어야 합니다. deepinfra는 LLM에 요청을 보내기 위한 openai 형식도 지원합니다.</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">construct_prompt_template</span>(case_note, code_descriptions, model_name):
    <span class="hljs-string">""</span><span class="hljs-string">"
    주어진 케이스 노트와 ICD-10 코드 설명을 평가하는 프롬프트 템플릿 구성
    
    Args:
        case_note (str): 의료 케이스 노트
        code_descriptions (str): ICD-10 코드 설명을 단일 문자열로 포맷팅
        
    Returns:
        str: 언어 모델에 입력으로 사용할 준비된 구조화된 템플릿
    "</span><span class="hljs-string">""</span>
    template = prompt_template_dict[model_name]

    <span class="hljs-keyword">return</span> template.<span class="hljs-title function_">format</span>(note=case_note, code_descriptions=code_descriptions)

def <span class="hljs-title function_">build_zero_shot_prompt</span>(input_note, descriptions, model_name, system_prompt=<span class="hljs-string">""</span>):
    <span class="hljs-string">""</span><span class="hljs-string">"
    시스템 및 사용자 역할에 대한 제로샷 분류용 프롬프트 빌드
    
    Args:
        input_note (str): 입력 노트 또는 질의
        descriptions (list of str): ICD-10 코드 설명 리스트
        system_prompt (str): 선택적 초기 시스템 프롬프트 또는 지시
    
    Returns:
        list of dict: 각 메시지의 역할 및 내용을 정의하는 구조화된 사전 목록
    "</span><span class="hljs-string">""</span>
    <span class="hljs-keyword">if</span> model_name == <span class="hljs-string">"meta-llama/Llama-2-70b-chat-hf"</span>:
        code_descriptions = <span class="hljs-string">"\n"</span>.<span class="hljs-title function_">join</span>([<span class="hljs-string">"* "</span> + x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> descriptions])
    <span class="hljs-attr">else</span>:
        code_descriptions = <span class="hljs-string">"\n"</span>.<span class="hljs-title function_">join</span>(descriptions)

    input_prompt = <span class="hljs-title function_">construct_prompt_template</span>(input_note, code_descriptions, model_name)
    <span class="hljs-keyword">return</span> [{<span class="hljs-string">"role"</span>: <span class="hljs-string">"system"</span>, <span class="hljs-string">"content"</span>: system_prompt}, {<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: input_prompt}]
</code></pre>
<p>프롬프트를 구성한 후, 이제 LLM을 호출하여 응답을 받겠습니다:</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">get_response</span>(messages, model_name, temperature=<span class="hljs-number">0.0</span>, max_tokens=<span class="hljs-number">500</span>):
    <span class="hljs-string">""</span><span class="hljs-string">"
    채팅-완성 API를 통해 지정된 모델로부터 응답을 획득
    
    Args:
        messages (list of dict): API 입력용 구조화된 메시지 목록
        model_name (str): 쿼리할 모델의 식별자
        temperature (float): 응답의 무작위성을 제어하는 값, 0이면 결정론적
        max_tokens (int): 응답의 토큰 수 제한
        
    Returns:
        str: 모델에서의 응답 메시지 내용
    "</span><span class="hljs-string">""</span>
    response = client.<span class="hljs-property">chat</span>.<span class="hljs-property">completions</span>.<span class="hljs-title function_">create</span>(
        model=model_name,
        messages=messages,
        temperature=temperature,
        max_tokens=max_tokens
    )
    <span class="hljs-keyword">return</span> response.<span class="hljs-property">choices</span>[<span class="hljs-number">0</span>].<span class="hljs-property">message</span>.<span class="hljs-property">content</span>
</code></pre>
<p>좋아요, 우리가 출력물을 얻었어요! 이 응답으로부터, 이제 LLM이 추가적인 탐색을 위해 관련있는 노드들과 거부한 노드들을 식별하기 위해 각 코드 설명을 구문 분석합니다. 우리는 출력 응답을 새 줄로 나누고 각 응답을 분할하여 LLM의 각 코드 설명에 대한 예측을 식별합니다.</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">remove_noisy_prefix</span>(text):
    # 문자 또는 숫자가 뒤따르고 점과 선택적 공백으로 시작하는 문자열의 제일 앞에 있는 숫자나 문자를 제거합니다.
    cleaned_text = text.<span class="hljs-title function_">replace</span>(<span class="hljs-string">"* "</span>, <span class="hljs-string">""</span>).<span class="hljs-title function_">strip</span>()
    cleaned_text = re.<span class="hljs-title function_">sub</span>(r<span class="hljs-string">"^\s*\w+\.\s*"</span>, <span class="hljs-string">""</span>, cleaned_text)
    <span class="hljs-keyword">return</span> cleaned_text.<span class="hljs-title function_">strip</span>()

def <span class="hljs-title function_">parse_outputs</span>(output, code_description_map, model_name):
    <span class="hljs-string">""</span><span class="hljs-string">"
    모델 출력을 구문 분석하여 주어진 설명 매핑에 따른 ICD-10 코드를 확인합니다.
    
    Args:
        output (str): 확인을 포함하는 모델 출력입니다.
        code_description_map (dict): 설명과 ICD-10 코드의 매핑입니다.
        
    Returns:
        list of dict: 확인된 코드 및 해당 설명의 목록입니다.
    "</span><span class="hljs-string">""</span>
    confirmed_codes = []
    split_outputs = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> output.<span class="hljs-title function_">split</span>(<span class="hljs-string">"\n"</span>) <span class="hljs-keyword">if</span> x]
    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-attr">split_outputs</span>:
        <span class="hljs-attr">try</span>:                
            code_description, confirmation = item.<span class="hljs-title function_">split</span>(<span class="hljs-string">":"</span>, <span class="hljs-number">1</span>)
            <span class="hljs-keyword">if</span> model_name == <span class="hljs-string">"meta-llama/Llama-2-70b-chat-hf"</span>:
                code_description = <span class="hljs-title function_">remove_noisy_prefix</span>(code_description)

            <span class="hljs-keyword">if</span> confirmation.<span class="hljs-title function_">lower</span>().<span class="hljs-title function_">strip</span>().<span class="hljs-title function_">startswith</span>(<span class="hljs-string">"yes"</span>):
                <span class="hljs-attr">try</span>:
                    code = code_description_map[code_description]
                    confirmed_codes.<span class="hljs-title function_">append</span>({<span class="hljs-string">"code"</span>: code, <span class="hljs-string">"description"</span>: code_description})
                except <span class="hljs-title class_">Exception</span> <span class="hljs-keyword">as</span> <span class="hljs-attr">e</span>:
                    <span class="hljs-title function_">print</span>(<span class="hljs-title function_">str</span>(e) + <span class="hljs-string">" Here"</span>)
                    <span class="hljs-keyword">continue</span>
        <span class="hljs-attr">except</span>:
            <span class="hljs-keyword">continue</span>
    <span class="hljs-keyword">return</span> confirmed_codes
</code></pre>
<p>이제 루프의 나머지를 살펴봅시다. 지금까지 우리는 프롬프트를 구성했고, LLM으로부터 응답을 받았으며, 출력을 구문 분석하여 LLM에 의해 관련이 있다고 판단된 코드를 식별했습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">while</span> prompt_count &#x3C; <span class="hljs-number">50</span>:
    code_descriptions = {}
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-attr">candidate_codes</span>:
        description, code = <span class="hljs-title function_">get_name_and_description</span>(x, model_name)
        code_descriptions[description] = code

    prompt = <span class="hljs-title function_">build_zero_shot_prompt</span>(medical_note, <span class="hljs-title function_">list</span>(code_descriptions.<span class="hljs-title function_">keys</span>()), model_name=model_name)
    lm_response = <span class="hljs-title function_">get_response</span>(prompt, model_name, temperature=temperature, max_tokens=<span class="hljs-number">500</span>)
    predicted_codes = <span class="hljs-title function_">parse_outputs</span>(lm_response, code_descriptions, model_name=model_name)

    <span class="hljs-keyword">for</span> code <span class="hljs-keyword">in</span> <span class="hljs-attr">predicted_codes</span>:
        <span class="hljs-keyword">if</span> cm.<span class="hljs-title function_">is_leaf</span>(code[<span class="hljs-string">"code"</span>]):
            assigned_codes.<span class="hljs-title function_">append</span>(code[<span class="hljs-string">"code"</span>])
        <span class="hljs-attr">else</span>:
            parent_codes.<span class="hljs-title function_">append</span>(code)

    <span class="hljs-keyword">if</span> <span class="hljs-title function_">len</span>(parent_codes) > <span class="hljs-number">0</span>:
        parent_code = parent_codes.<span class="hljs-title function_">pop</span>(<span class="hljs-number">0</span>)
        candidate_codes = cm.<span class="hljs-title function_">get_children</span>(parent_code[<span class="hljs-string">"code"</span>])
    <span class="hljs-attr">else</span>:
        <span class="hljs-keyword">break</span>

    prompt_count += <span class="hljs-number">1</span>
</code></pre>
<p>이제 예측된 코드를 반복하며 각 코드가 "leaf" 코드인지 확인합니다. 이는 코드가 유효하고 할당 가능한 ICD 코드임을 보증하는 것입니다. 예측된 코드가 유효하면 LLM이 그 의료 노트에 대한 예측으로 간주합니다. 유효하지 않으면 상위 코드에 추가하여 ICD 트리를 더 탐색하기 위해 자식 노드를 얻습니다. 더 이상 탐색할 상위 코드가 없을 경우 루프를 탈출합니다.</p>
<p>이론적으로 의료 노트 당 LLM 호출 수는 임의로 높을 수 있으며, 알고리즘이 많은 노드를 탐색하는 경우 지연 시간이 증가할 수 있습니다. 저자는 의료 노트 당 최대 50회 프롬프트/LLM 호출로 처리를 종료하는 최대 수를 시행했습니다. 이 한계는 우리가 구현에서도 채택합니다.</p>
<h2>결과</h2>
<p>이제 GPT-3.5와 Llama-2를 LLM으로 사용하여 트리 탐색 알고리즘의 결과를 평가할 수 있습니다. 우리는 알고리즘의 성능을 마이크로-평균 및 매크로-평균 정밀도, 재현율 및 F1 점수를 통해 평가합니다.</p>
<p><img src="/assets/img/2024-05-17-ExploringLLMsforICDCodingPart1_2.png" alt="ExploringLLMsforICDCodingPart1_2"></p>
<p>구현 결과는 논문에 보고된 점수와 대략적으로 일치하지만 주목할 만한 차이점이 있습니다.</p>
<ul>
<li>이 구현에서 GPT-3.5의 마이크로 평균 측정 지표는 보고된 값보다 약간 뛰어나지만, 매크로 평균 측정 지표는 보고된 값보다 조금 부족합니다.</li>
<li>마찬가지로 Llama-70B의 마이크로 평균 측정 지표는 보고된 값과 일치하거나 조금 뛰어나지만, 매크로 평균 측정 지표는 보고된 값보다 낮습니다.</li>
</ul>
<p>앞서 언급했듯이, 이 구현은 몇 가지 미세한 차이점을 가지고 있어 최종 성능에 영향을 미칩니다. 이 구현이 원본 논문과 어떻게 다른지에 대한 보다 자세한 내용은 링크된 저장소를 참조해 주세요.</p>
<h1>결론</h1>
<p>이 방법을 이해하고 구현하는 것은 여러 측면에서 나에게 매우 유익했습니다. 이를 통해 대규모 언어 모델(LLMs)의 강점과 약점에 대해 보다 세밀하게 이해할 수 있었고 임상 코딩 사례에서 그것을 구현할 수 있었습니다. 구체적으로, 코드에 관련된 중요한 정보에 동적으로 접근할 수 있는 경우 LLMs는 임상 문맥을 효과적으로 이해하고 관련 코드를 정확하게 식별할 수 있다는 것이 분명해졌습니다.</p>
<p>LLMs를 임상 코딩을 위한 대리자로 활용하는 것이 성능을 더욱 향상시킬 수 있는지 탐구하는 것이 흥미로울 것입니다. 생명공학 및 임상 텍스트에 대한 외부 지식 소스가 논문이나 지식 그래프 형태로 풍부하게 제공되는 상황에서 LLM 대리자는 의료 문서를 보다 세밀한 단위로 분석하는 워크플로에 활용될 수 있습니다. 또한 필요한 경우 외부 지식을 참고하여 최종 코드에 도달할 수 있도록 동적으로 도구를 활용할 수도 있습니다.</p>
<h2>감사의 글</h2>
<p>이 방법을 평가하는 데 도움을 준 이 논문의 주 저자 Joseph에게 큰 감사를 표합니다!</p>
<ul>
<li>참고 자료:</li>
</ul>
<p>[1] <a href="https://www.who.int/standards/classifications/classification-of-diseases" rel="nofollow" target="_blank">https://www.who.int/standards/classifications/classification-of-diseases</a></p>
<p>[2] Johnson, A. E., Pollard, T. J., Shen, L., Lehman, L. W. H., Feng, M., Ghassemi, M., … &#x26; Mark, R. G. (2016). MIMIC-III, a freely accessible critical care database Sci. Data, 3(1), 1.</p>
<p>[3] Agrawal, M., Hegselmann, S., Lang, H., Kim, Y., &#x26; Sontag, D. (2022). 대형 언어 모델은 소수의 적은 데이터로도 임상 정보를 추출합니다. arXiv 사전 인쇄 arXiv:2205.12689.</p>
<p>[4] Zhou, H., Li, M., Xiao, Y., Yang, H., &#x26; Zhang, R. (2023). 임상 관계 추출을 위한 LLM Instruction-Example Adaptive Prompting (LEAP) 프레임워크. medRxiv : 의학과학 사전 인쇄 서버, 2023.12.15.23300059. <a href="https://doi.org/10.1101/2023.12.15.23300059" rel="nofollow" target="_blank">https://doi.org/10.1101/2023.12.15.23300059</a></p>
<p>[5] Boyle, J. S., Kascenas, A., Lok, P., Liakata, M., &#x26; O’Neil, A. Q. (2023, 10월). 상업용 대형 언어 모델을 사용한 자동 임상 코딩. NeurIPS 2023에서 Deep Generative Models for Health Workshop 발표.</p>
<p>[6] Huang, C. W., Tsai, S. C., &#x26; Chen, Y. N. (2022). 사전 훈련된 언어 모델로 자동 ICD 코딩하기: PLM-ICD. arXiv 사전 인쇄 arXiv:2207.05289.</p>
<p>Miranda-Escalada, A., Gonzalez-Agirre, A., Armengol-Estapé, J., &#x26; Krallinger, M. (2020). CLEF (Working Notes), 2020에서 CodiEsp Track의 비영어 임상 사례에 대한 주석, 가이드라인 및 솔루션에 대한 개요.</p>
<p>Miranda-Escalada, A., Gonzalez-Agirre, A., &#x26; Krallinger, M. (2020). CodiEsp corpus: ICD10 (CIE10)로 코드화된 골드 표준 스페인어 임상 사례 - eHealth CLEF2020 (1.4) [데이터 세트]. Zenodo. <a href="https://doi.org/10.5281/zenodo.3837305" rel="nofollow" target="_blank">https://doi.org/10.5281/zenodo.3837305</a> (CC BY 4.0)</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"ICD 코딩을 위한 LLM 탐험 - 파트 1","description":"","date":"2024-05-17 19:38","slug":"2024-05-17-ExploringLLMsforICDCodingPart1","content":"\n\n## LLM(Large Language Model)을 활용한 자동 진단 코딩 시스템 구축\n\n임상 코딩은 흔히 쓰이는 용어는 아니지만, 대부분의 국가에서 건강 관리 체계와 상호작용하는 모든 사람에게 중대한 영향을 미칩니다. 임상 코딩은 환자 건강 기록에서 의학 정보(진단 및 수술 등)를 표준화된 숫자 또는 알파벳 코드로 번역하고 매핑하는 것을 포함합니다. 이러한 코드는 청구, 건강 관리 분석 및 환자가 적절한 치료를 받을 수 있도록 하는 데 중요합니다.\n\n![image](/assets/img/2024-05-17-ExploringLLMsforICDCodingPart1_0.png)\n\n임상 코딩은 일반적으로 의료 전문가가 수행합니다. 이러한 코더들은 다양한 진단과 수술을 위한 특정 코드가 포함된 복잡하고 종종 계층적인 코딩 용어를 탐색합니다. 따라서 코더들은 사용된 코딩 용어에 대한 깊은 이해와 경험을 가져야 합니다. 그러나 문서를 수동으로 코딩하는 것은 느릴 수 있고, 오류가 발생할 수 있으며, 상당한 인적 전문 지식이 필요하여 병목 현상이 발생할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n심층 학습은 임상 코딩 자동화에 중요한 역할을 할 수 있습니다. 복잡한 의료 정보를 코드로 추출하고 번역함으로써, 심층 학습 시스템은 인간 중심 시스템 내에서 가치 있는 도구로 작용할 수 있습니다. 이러한 시스템은 코더들을 지원하여 대량의 데이터를 신속하게 처리하고 정확성을 향상시킬 수 있습니다. 이는 행정 업무를 간소화하고 청구 오류를 줄이며 환자 치료 결과를 향상시킬 수 있습니다.\n\n이 첫 번째 부분에서는 ICD 코딩이 무엇인지, 자동 코딩 시스템이 효과적으로 극복해야 하는 다양한 도전에 대해 설명합니다. 또한 대용량 언어 모델(LLM)이 이러한 문제를 극복하는 데 효과적으로 활용할 수 있는 방법을 분석하고, 최근 논문에서 LLM을 효과적으로 활용한 알고리즘을 적용하여 ICD 코딩에 성공적으로 적용하는 방법을 설명합니다.\n\n## 목차:\n\n- ICD 코딩이란 무엇인가?\n- 자동 ICD 코딩의 도전 요소는 무엇인가?\n- LLM이 자동 ICD 코딩에 어떻게 도움이 될까?\n- \"Off-the-shelf 대용량 언어 모델을 이용한 자동 임상 코딩\" 논문 탐색\n- 논문에 설명된 기법 구현\n- 결론\n- 참고문헌\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# ICD 코딩이란 무엇인가요?\n\n국제질병분류(ICD) 코딩은 세계보건기구에서 개발 및 유지보수하는 임상 용어 시스템입니다 [1]. 대부분의 국가에서 환자의 모든 진단, 증상 및 절차를 범주화하고 코딩하는 데 사용됩니다.\n\n환자의 진단과 의료 절차를 기록하는 의료 기록은 ICD 코딩에 매우 중요합니다. ICD 용어는 대략 75,000가지 다른 코드로 구성된 트리 구조를 특징으로 하여 방대한 정보를 효율적으로 정리합니다. 이러한 문서를 정확하게 코딩하는 것이 중요합니다. 정확한 코딩은 적절한 청구를 보장하며 의료 분석 품질에 영향을 미치며 환자 치료 결과, 보상 및 의료 효율성에 직접적으로 영향을 줍니다.\n\n# 자동 ICD 코딩에서 어떤 도전들이 있을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nICD 코딩은 효과적으로 작동하기 위해 자동화된 시스템이 극복해야 할 여러 가지 도전이 있습니다.\n\n## ICD 코딩의 레이블 다양성:\n\n중요한 도전 중 하나는 레이블의 광범위한 출력 공간입니다. ICD 코드는 많고 각 코드는 미세한 세부 사항에서 차이가 있을 수 있습니다. 예를 들어, 오른손에 영향을 주는 상태와 왼손에 영향을 주는 상태는 서로 다른 코드를 갖게 됩니다. 또한 의료 기록에서 드물게 나타나는 희귀 코드의 긴 꼬리가 존재하여, 이러한 코드를 학습하고 정확하게 예측하기 어렵게 만들 수 있습니다.\n\n## 새로운 ICD 코드에 대한 적응:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n번거로우시겠지만, 테이블 태그를 마크다운 형식으로 변경해드릴게요!\n\n전통적인 데이터셋인 MIMIC-III [2] 같은 경우는 종합적이지만, 종종 ICD 코드의 범위를 훈련 말뭉치에 포함된 코드로 제한합니다. 이 제한은 의료 기록에서 ICD 코드로의 딥러닝 모델을 다중 레이블 분류 문제로 처리하는 데 새로운 코드가 도입된 경우 모형 훈련 이후에 어려움을 겪을 수 있음을 의미합니다. 이는 재훈련이 필요하고 잠재적으로 어려울 수 있게 만듭니다.\n\n## 정보 추출 및 문맥 활용:\n\n또 다른 주요 과제는 의료 기록에서 정보를 정확하게 추출하고 문맥에 맞게 처리하는 것입니다. ICD 코딩은 근본적으로 정보 검색 문제로, 의료 기록에서 진단을 식별하는 것 뿐만 아니라 이러한 진단을 해당 ICD 코드로 올바르게 매핑하는 데 필요한 모든 보완 정보를 포착해야 합니다. 따라서 자동화된 시스템이 의료 기록에서 여러 진단을 추출하고 적절히 문맥화하여 ICD 코드로 정확하게 매핑되도록 하는 것이 중요합니다.\n\n![이미지](/assets/img/2024-05-17-ExploringLLMsforICDCodingPart1_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"Contextualization\"란 여기서 무엇을 의미할까요? 의학 노트를 다룰 때 진단을 맥락에 맞게 처리하는 것은 관련 세부사항과 관련된 정보 — 예를 들어 영향을 받는 신체 부위 및 질환의 증상 — 를 연결하여 진단을 완전히 특성화하는 것을 의미합니다. 일반적으로 이 작업은 관계 추출로 참조됩니다.\n\n# 대규모 언어 모델(LLMs)이 자동 ICD 코딩에 어떻게 도움이 되나요?\n\n자동 ICD 코딩의 과제를 다룰 때, 대규모 언어 모델 (LLMs)은 이러한 문제에 대처하는 데 적합하며, 특히 새로운 레이블에 대한 적응성과 복잡한 정보 추출 작업을 관리하는 능력으로 인해 잘 역할을 합니다. 그러나 여기서의 포인트는 LLMs가 자동 ICD 코딩에 대한 최상의 해결책이거나 이러한 문제를 해결할 수 있는 유일한 해결책인 것을 주장하는 것이 아니라, 자동 ICD 코딩 시스템이 극복해야 하는 주요 과제들을 설정함으로써 LLMs의 능력을 최대한 활용하여 이를 해결할 수 있는지를 분석하는 것입니다.\n\n## 새로운 및 드문 ICD 코드에 대한 적응:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLLMs는 견고한 제로샷 및 퓨샷 학습 능력을 보여주며, 적은 예시와 프롬프트에서 제공된 지침으로 새로운 작업에 적응할 수 있습니다. 검색 증강 생성 (RAG)은 미세 조정 없이도 LLM이 새로운 작업에 적응하기 위해 더 많은 맥락 정보에 접근할 수 있는 패러다임입니다. 이는 특히 기존의 훈련 데이터셋에서 자주 나타나지 않을 수 있는 새로운 및/또는 희귀한 ICD 코드에 LLM을 조정하는 데 유용합니다. 이를 단지 몇 가지 설명 또는 사용 사례로부터 합니다.\n\n## 맥락 정보:\n\nLLMs는 임상 분야에서의 제로샷 관계 추출에서 효과적으로 확인되었습니다. 제로샷 관계 추출은 LLM이 해당 관계에 대해 이전에 구체적인 훈련을 받지 않고 텍스트에서 관계를 식별하고 분류할 수 있도록 합니다. 이를 통해 의료 코딩에서의 진단을 더 잘 맥락화하여 더 정확한 ICD 코드를 가져올 수 있습니다.\n\n# \"Automated clinical coding using off-the-shelf large language models\" 논문 탐색하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLLM을 ICD 코딩에 적용한 최근 연구를 탐색하다가, 특정한 세부 조정 없이 LLM을 활용한 ICD 코딩에 관한 매우 흥미로운 논문을 발견했습니다. 저자들은 LLM을 활용한 ICD 코딩을 위해 LLM-지도된 트리 탐색이라는 방법을 개발했습니다 [5].\n\n## 이 방법은 어떻게 작동하나요?\n\nICD 용어는 계층적인 트리 구조입니다. 각 ICD 코드는 이 계층적 구조 내에 존재하며, 부모 코드는 더 일반적인 상태를 다루고, 자식 코드는 특정 질병을 상세히 설명합니다. ICD 트리를 탐색하면 더 구체적이고 세분화된 진단 코드로 이어집니다.\n\nLLM-지도된 트리 탐색에서는 탐색이 루트에서 시작되고 LLM을 사용하여 탐색할 가지를 선택하며, 모든 경로가 고갈될 때까지 반복적으로 계속합니다. 실제로 이 과정은 트리의 임의의 수준에서 모든 코드의 설명과 의료 노트를 LLM에 프롬프트로 제공하고, 해당 의료 노트에 대한 관련 코드를 식별하도록 요청하는 것으로 구현됩니다. 각 인스턴스에서 LLM에 의해 선택된 코드는 더 구체적으로 탐색되고 조사됩니다. 이 방법을 사용하면 가장 관련성이 높은 ICD 코드가 식별되며, 이후 임상 노트에 대한 예측 레이블로 할당됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시를 통해 이를 명확히 해보겠습니다. ICD 코드 1과 ICD 코드 2라는 두 개의 루트 노드를 가진 트리를 상상해보세요. 각 노드는 코드를 특성화하는 평문 설명을 가지고 있습니다. 초기 단계에서 LLM에게 의학 노트와 코드 설명이 제공되고 의학 노트와 관련된 코드를 식별하도록 요청됩니다.\n\n이 시나리오에서 LLM은 의학 노트와 관련이 있는 것으로 판단된 ICD 코드 1과 ICD 코드 2를 식별합니다. 알고리즘은 각 코드의 자식 노드를 조사합니다. 각 부모 코드는 더 구체적인 ICD 코드를 나타내는 두 개의 자식 노드를 가지고 있습니다. ICD 코드 1부터 시작하여, LLM은 ICD 코드 1.1과 ICD 코드 1.2의 설명을 사용하여 의학 노트를 기반으로 관련 코드를 결정합니다. LLM은 ICD 코드 1.1이 관련이 있다고 결론 내리고, ICD 코드 1.2는 관련이 없다고 판단합니다. ICD 코드 1.1에는 더 이상의 자식 노드가 없으므로, 알고리즘은 할당 가능한 코드인지 확인하고 문서에 할당합니다. 그 다음 알고리즘은 ICD 코드 2의 자식 노드를 평가합니다. LLM을 호출하여, ICD 코드 2.1이 관련이 있는 것으로 판단합니다. 이것은 간단화된 예시이며, 실제로는 ICD 트리는 광범위하고 깊기 때문에 알고리즘은 각 관련된 노드의 자식을 탐색하거나 트리의 끝에 도달하거나 유효한 탐색을 소진할 때까지 계속됩니다.\n\n## 핵심\n\n- 이 방법은 LLM의 세밀한 조정이 필요하지 않습니다. 대신, 제공된 설명을 기반으로 LLM의 의료 노트를 상황에 맞게 이해하고 관련 ICD 코드를 동적으로 식별할 수 있는 능력을 활용합니다.\n- 더 나아가, 본 논문은 LLM이 프롬프트에 관련 정보가 주어질 때 대규모 출력 공간에 효과적으로 적응할 수 있으며, macro-average 지표 측면에서 드문 코드에서 PLM-ICD [6]를 앞지를 수 있다는 것을 보여줍니다.\n- 이 기술은 또한 파라메트릭 지식에 기초하여 의학 노트의 ICD 코드를 예측하도록 LLM에 직접 요청하는 기준선을 능가합니다. 이는 LLM을 임상 코딩 작업을 해결하기 위한 도구나 외부 지식과 통합하는 잠재력을 강조합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단점\n\n- 알고리즘은 트리의 각 수준에서 LLM을 호출합니다. 이로 인해 트리를 탐색하는 동안 LLM 호출 횟수가 많아지며, ICD 트리의 광범위함이 이에 더해집니다. 이는 단일 문서를 처리하는 데 높은 대기 시간과 비용으로 이어집니다.\n- 저자들이 논문에서 언급한 바와 같이, 관련 있는 코드를 정확하게 예측하려면 LLM이 모든 수준에서 부모 노드를 올바르게 식별해야 합니다. 한 수준에서 실수가 발생하더라도, LLM은 최종 관련 코드에 도달할 수 없게 됩니다.\n- 저자들은 MIMIC-III와 같은 데이터셋을 사용하여 메소드를 평가할 수 없었습니다. 외부 서비스로의 데이터 전송을 금지하는 제한 사항으로 인하여 OpenAI의 GPT 엔드포인트와 같은 외부 서비스로의 데이터 전송이 불가능했습니다. 대신, 저자들은 CodiEsp 데이터셋 [7,8]의 테스트 세트를 사용하여 해당 방법을 평가했습니다. 해당 데이터셋은 250개의 의학 노트를 포함하고 있습니다. 이 데이터셋의 크기가 작은 것은 해당 방법이 대규모 임상 데이터셋에서의 성능을 아직 입증하지 못했음을 시사합니다.\n\n# 논문에서 설명한 기술 구현하기\n\n이 기술을 구현하여 그 작동 방식을 더 잘 이해해 봅시다. 논문에서 언급했듯이, 해당 논문은 평가를 위해 CodiEsp 테스트 세트를 사용합니다. 이 데이터셋은 스페인어 의학 노트와 이에 대응하는 ICD 코드로 구성되어 있습니다. 데이터셋에는 영어로 번역된 버전도 포함되어 있지만, 저자들은 스페인어 의학 노트를 GPT-3.5를 사용하여 영어로 번역하였으며, 이를 통해 사전 번역된 버전을 사용하는 것보다 성능이 약간 향상되었다고 주장했습니다. 이 기능을 복제하고 노트를 영어로 번역해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndef construct_translation_prompt(medical_note):\n    \"\"\"\n    Construct a prompt template for translating Spanish medical notes to English.\n    \n    Args:\n        medical_note (str): The medical case note.\n        \n    Returns:\n        str: A structured template ready to be used as input for a language model.\n    \"\"\"    \n    translation_prompt = \"\"\"You are an expert Spanish-to-English translator. You are provided with a clinical note written in Spanish.\nYou must translate the note into English. You must ensure that you properly translate the medical and technical terms from Spanish to English without any mistakes.\nSpanish Medical Note:\n{medical_note}\"\"\"\n    \n    return translation_prompt.format(medical_note = medical_note)\n```\n\nNow that we have the evaluation corpus ready, let’s implement the core logic for the tree-search algorithm. We define the functionality in get_icd_codes, which accepts the medical note to process, the model name, and the temperature setting. The model name must be either “gpt-3.5-turbo-0613” for GPT-3.5 or “meta-llama/Llama-2–70b-chat-hf” for Llama-2 70B Chat. This specification determines the LLM that the tree-search algorithm will invoke during its processing.\n\nEvaluating GPT-4 is possible using the same code-base by providing the appropriate model name, but we choose to skip it as it is quite time-consuming.\n\n```js\ndef get_icd_codes(medical_note, model_name=\"gpt-3.5-turbo-0613\", temperature=0.0):\n    \"\"\"\n    Identifies relevant ICD-10 codes for a given medical note by querying a language model.\n\n    This function implements the tree-search algorithm for ICD coding described in https://openreview.net/forum?id=mqnR8rGWkn.\n\n    Args:\n        medical_note (str): The medical note for which ICD-10 codes are to be identified.\n        model_name (str): The identifier for the language model used in the API (default is 'gpt-3.5-turbo-0613').\n\n    Returns:\n        list of str: A list of confirmed ICD-10 codes that are relevant to the medical note.\n    \"\"\"\n    assigned_codes = []\n    candidate_codes = [x.name for x in CHAPTER_LIST]\n    parent_codes = []\n    prompt_count = 0\n\n    while prompt_count \u003c 50:\n        code_descriptions = {}\n        for x in candidate_codes:\n            description, code = get_name_and_description(x, model_name)\n            code_descriptions[description] = code\n\n        prompt = build_zero_shot_prompt(medical_note, list(code_descriptions.keys()), model_name=model_name)\n        lm_response = get_response(prompt, model_name, temperature=temperature, max_tokens=500)\n        predicted_codes = parse_outputs(lm_response, code_descriptions, model_name=model_name)\n\n        for code in predicted_codes:\n            if cm.is_leaf(code[\"code\"]):\n                assigned_codes.append(code[\"code\"])\n            else:\n                parent_codes.append(code)\n\n        if len(parent_codes) \u003e 0:\n            parent_code = parent_codes.pop(0)\n            candidate_codes = cm.get_children(parent_code[\"code\"])\n        else:\n            break\n\n        prompt_count += 1\n\n    return assigned_codes\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 논문과 비슷하게, ICD-10 트리에 액세스하는 simple_icd_10_cm 라이브러리를 사용합니다. 이를 통해 트리를 탐색하고, 각 코드에 대한 설명에 액세스하며 유효한 코드를 식별할 수 있습니다. 먼저, 트리의 첫 번째 수준에서 노드를 가져옵니다.\n\n```js\nimport simple_icd_10_cm as cm\n\ndef get_name_and_description(code, model_name):\n    \"\"\"\n    ICD-10 코드의 이름과 설명을 검색합니다.\n    \n    Args:\n        code (str): ICD-10 코드.\n        \n    Returns:\n        tuple: 형식화된 설명과 코드의 이름이 포함된 튜플을 반환합니다.\n    \"\"\"\n    full_data = cm.get_full_data(code).split(\"\\n\")\n    return format_code_descriptions(full_data[3], model_name), full_data[1]\n```\n\n루프 내부에서 각 노드에 해당하는 설명을 얻습니다. 이제 의료 노트와 코드 설명을 기반으로 LLM을 위한 프롬프트를 작성해야 합니다. 우리는 논문에서 제공된 세부 정보를 기반으로 GPT-3.5와 Llama-2용 프롬프트를 작성합니다.\n\n```js\nprompt_template_dict = {\"gpt-3.5-turbo-0613\" : \"\"\"[사례 노트]:\n{note}\n[예시]:\n\u003c예시 프롬프트\u003e\n위식도 역류병\n장전위\n\n\u003c응답\u003e\n위식도 역류병: 예, 환자에게 오메프라졸 처방함.\n장전위: 아니오.\n\n[작업]:\n다음 ICD-10 코드 설명 각각을 고려하고 사례 노트에 관련 언급이 있는지 평가하십시오.\n예시의 형식을 정확히 따르십시오.\n\n{code_descriptions}\"\"\",\n\n\"meta-llama/Llama-2-70b-chat-hf\": \"\"\"[사례 노트]:\n{note}\n\n[예시]:\n\u003c코드 설명\u003e\n* 위식도 역류병\n* 장전위\n* 급성비인두염 [감기]\n\u003c/코드 설명\u003e\n\n\u003c응답\u003e\n* 위식도 역류병: 예, 환자에게 오메프라졸 처방함.\n* 장전위: 아니오.\n* 급성비인두염 [감기]: 아니오.\n\u003c/응답\u003e\n\n[작업]:\n예시 응답 형식을 정확히 따르십시오. (예) 판단하기 전에 전체 설명과 (예|아니오) 판단을 입력한 후에 새 줄을 추가하십시오. \n다음 ICD-10 코드 설명을 고려하고 사례 노트에서 관련 언급이 있는지 확인하십시오.\n\n{code_descriptions}\"\"\"\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n의료 기록과 코드 설명에 기반한 프롬프트를 지금 만들어 보겠습니다. 프롬프트 및 코딩에서 우리에게 이점은 GPT-3.5 및 Llama 2 모두와 상호 작용하기 위해 동일한 openai 라이브러리를 사용할 수 있다는 것입니다. 단, Llama-2가 deepinfra를 통해 배포되어야 합니다. deepinfra는 LLM에 요청을 보내기 위한 openai 형식도 지원합니다.\n\n```js\ndef construct_prompt_template(case_note, code_descriptions, model_name):\n    \"\"\"\n    주어진 케이스 노트와 ICD-10 코드 설명을 평가하는 프롬프트 템플릿 구성\n    \n    Args:\n        case_note (str): 의료 케이스 노트\n        code_descriptions (str): ICD-10 코드 설명을 단일 문자열로 포맷팅\n        \n    Returns:\n        str: 언어 모델에 입력으로 사용할 준비된 구조화된 템플릿\n    \"\"\"\n    template = prompt_template_dict[model_name]\n\n    return template.format(note=case_note, code_descriptions=code_descriptions)\n\ndef build_zero_shot_prompt(input_note, descriptions, model_name, system_prompt=\"\"):\n    \"\"\"\n    시스템 및 사용자 역할에 대한 제로샷 분류용 프롬프트 빌드\n    \n    Args:\n        input_note (str): 입력 노트 또는 질의\n        descriptions (list of str): ICD-10 코드 설명 리스트\n        system_prompt (str): 선택적 초기 시스템 프롬프트 또는 지시\n    \n    Returns:\n        list of dict: 각 메시지의 역할 및 내용을 정의하는 구조화된 사전 목록\n    \"\"\"\n    if model_name == \"meta-llama/Llama-2-70b-chat-hf\":\n        code_descriptions = \"\\n\".join([\"* \" + x for x in descriptions])\n    else:\n        code_descriptions = \"\\n\".join(descriptions)\n\n    input_prompt = construct_prompt_template(input_note, code_descriptions, model_name)\n    return [{\"role\": \"system\", \"content\": system_prompt}, {\"role\": \"user\", \"content\": input_prompt}]\n```\n\n프롬프트를 구성한 후, 이제 LLM을 호출하여 응답을 받겠습니다:\n\n```js\ndef get_response(messages, model_name, temperature=0.0, max_tokens=500):\n    \"\"\"\n    채팅-완성 API를 통해 지정된 모델로부터 응답을 획득\n    \n    Args:\n        messages (list of dict): API 입력용 구조화된 메시지 목록\n        model_name (str): 쿼리할 모델의 식별자\n        temperature (float): 응답의 무작위성을 제어하는 값, 0이면 결정론적\n        max_tokens (int): 응답의 토큰 수 제한\n        \n    Returns:\n        str: 모델에서의 응답 메시지 내용\n    \"\"\"\n    response = client.chat.completions.create(\n        model=model_name,\n        messages=messages,\n        temperature=temperature,\n        max_tokens=max_tokens\n    )\n    return response.choices[0].message.content\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋아요, 우리가 출력물을 얻었어요! 이 응답으로부터, 이제 LLM이 추가적인 탐색을 위해 관련있는 노드들과 거부한 노드들을 식별하기 위해 각 코드 설명을 구문 분석합니다. 우리는 출력 응답을 새 줄로 나누고 각 응답을 분할하여 LLM의 각 코드 설명에 대한 예측을 식별합니다.\n\n```js\ndef remove_noisy_prefix(text):\n    # 문자 또는 숫자가 뒤따르고 점과 선택적 공백으로 시작하는 문자열의 제일 앞에 있는 숫자나 문자를 제거합니다.\n    cleaned_text = text.replace(\"* \", \"\").strip()\n    cleaned_text = re.sub(r\"^\\s*\\w+\\.\\s*\", \"\", cleaned_text)\n    return cleaned_text.strip()\n\ndef parse_outputs(output, code_description_map, model_name):\n    \"\"\"\n    모델 출력을 구문 분석하여 주어진 설명 매핑에 따른 ICD-10 코드를 확인합니다.\n    \n    Args:\n        output (str): 확인을 포함하는 모델 출력입니다.\n        code_description_map (dict): 설명과 ICD-10 코드의 매핑입니다.\n        \n    Returns:\n        list of dict: 확인된 코드 및 해당 설명의 목록입니다.\n    \"\"\"\n    confirmed_codes = []\n    split_outputs = [x for x in output.split(\"\\n\") if x]\n    for item in split_outputs:\n        try:                \n            code_description, confirmation = item.split(\":\", 1)\n            if model_name == \"meta-llama/Llama-2-70b-chat-hf\":\n                code_description = remove_noisy_prefix(code_description)\n\n            if confirmation.lower().strip().startswith(\"yes\"):\n                try:\n                    code = code_description_map[code_description]\n                    confirmed_codes.append({\"code\": code, \"description\": code_description})\n                except Exception as e:\n                    print(str(e) + \" Here\")\n                    continue\n        except:\n            continue\n    return confirmed_codes\n```\n\n이제 루프의 나머지를 살펴봅시다. 지금까지 우리는 프롬프트를 구성했고, LLM으로부터 응답을 받았으며, 출력을 구문 분석하여 LLM에 의해 관련이 있다고 판단된 코드를 식별했습니다.\n\n```js\nwhile prompt_count \u003c 50:\n    code_descriptions = {}\n    for x in candidate_codes:\n        description, code = get_name_and_description(x, model_name)\n        code_descriptions[description] = code\n\n    prompt = build_zero_shot_prompt(medical_note, list(code_descriptions.keys()), model_name=model_name)\n    lm_response = get_response(prompt, model_name, temperature=temperature, max_tokens=500)\n    predicted_codes = parse_outputs(lm_response, code_descriptions, model_name=model_name)\n\n    for code in predicted_codes:\n        if cm.is_leaf(code[\"code\"]):\n            assigned_codes.append(code[\"code\"])\n        else:\n            parent_codes.append(code)\n\n    if len(parent_codes) \u003e 0:\n        parent_code = parent_codes.pop(0)\n        candidate_codes = cm.get_children(parent_code[\"code\"])\n    else:\n        break\n\n    prompt_count += 1\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 예측된 코드를 반복하며 각 코드가 \"leaf\" 코드인지 확인합니다. 이는 코드가 유효하고 할당 가능한 ICD 코드임을 보증하는 것입니다. 예측된 코드가 유효하면 LLM이 그 의료 노트에 대한 예측으로 간주합니다. 유효하지 않으면 상위 코드에 추가하여 ICD 트리를 더 탐색하기 위해 자식 노드를 얻습니다. 더 이상 탐색할 상위 코드가 없을 경우 루프를 탈출합니다. \n\n이론적으로 의료 노트 당 LLM 호출 수는 임의로 높을 수 있으며, 알고리즘이 많은 노드를 탐색하는 경우 지연 시간이 증가할 수 있습니다. 저자는 의료 노트 당 최대 50회 프롬프트/LLM 호출로 처리를 종료하는 최대 수를 시행했습니다. 이 한계는 우리가 구현에서도 채택합니다.\n\n## 결과\n\n이제 GPT-3.5와 Llama-2를 LLM으로 사용하여 트리 탐색 알고리즘의 결과를 평가할 수 있습니다. 우리는 알고리즘의 성능을 마이크로-평균 및 매크로-평균 정밀도, 재현율 및 F1 점수를 통해 평가합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![ExploringLLMsforICDCodingPart1_2](/assets/img/2024-05-17-ExploringLLMsforICDCodingPart1_2.png)\n\n구현 결과는 논문에 보고된 점수와 대략적으로 일치하지만 주목할 만한 차이점이 있습니다.\n\n- 이 구현에서 GPT-3.5의 마이크로 평균 측정 지표는 보고된 값보다 약간 뛰어나지만, 매크로 평균 측정 지표는 보고된 값보다 조금 부족합니다.\n- 마찬가지로 Llama-70B의 마이크로 평균 측정 지표는 보고된 값과 일치하거나 조금 뛰어나지만, 매크로 평균 측정 지표는 보고된 값보다 낮습니다.\n\n앞서 언급했듯이, 이 구현은 몇 가지 미세한 차이점을 가지고 있어 최종 성능에 영향을 미칩니다. 이 구현이 원본 논문과 어떻게 다른지에 대한 보다 자세한 내용은 링크된 저장소를 참조해 주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n이 방법을 이해하고 구현하는 것은 여러 측면에서 나에게 매우 유익했습니다. 이를 통해 대규모 언어 모델(LLMs)의 강점과 약점에 대해 보다 세밀하게 이해할 수 있었고 임상 코딩 사례에서 그것을 구현할 수 있었습니다. 구체적으로, 코드에 관련된 중요한 정보에 동적으로 접근할 수 있는 경우 LLMs는 임상 문맥을 효과적으로 이해하고 관련 코드를 정확하게 식별할 수 있다는 것이 분명해졌습니다.\n\nLLMs를 임상 코딩을 위한 대리자로 활용하는 것이 성능을 더욱 향상시킬 수 있는지 탐구하는 것이 흥미로울 것입니다. 생명공학 및 임상 텍스트에 대한 외부 지식 소스가 논문이나 지식 그래프 형태로 풍부하게 제공되는 상황에서 LLM 대리자는 의료 문서를 보다 세밀한 단위로 분석하는 워크플로에 활용될 수 있습니다. 또한 필요한 경우 외부 지식을 참고하여 최종 코드에 도달할 수 있도록 동적으로 도구를 활용할 수도 있습니다.\n\n## 감사의 글\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법을 평가하는 데 도움을 준 이 논문의 주 저자 Joseph에게 큰 감사를 표합니다!\n\n- 참고 자료:\n\n[1] https://www.who.int/standards/classifications/classification-of-diseases\n\n[2] Johnson, A. E., Pollard, T. J., Shen, L., Lehman, L. W. H., Feng, M., Ghassemi, M., … \u0026 Mark, R. G. (2016). MIMIC-III, a freely accessible critical care database Sci. Data, 3(1), 1.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[3] Agrawal, M., Hegselmann, S., Lang, H., Kim, Y., \u0026 Sontag, D. (2022). 대형 언어 모델은 소수의 적은 데이터로도 임상 정보를 추출합니다. arXiv 사전 인쇄 arXiv:2205.12689.\n\n[4] Zhou, H., Li, M., Xiao, Y., Yang, H., \u0026 Zhang, R. (2023). 임상 관계 추출을 위한 LLM Instruction-Example Adaptive Prompting (LEAP) 프레임워크. medRxiv : 의학과학 사전 인쇄 서버, 2023.12.15.23300059. https://doi.org/10.1101/2023.12.15.23300059\n\n[5] Boyle, J. S., Kascenas, A., Lok, P., Liakata, M., \u0026 O’Neil, A. Q. (2023, 10월). 상업용 대형 언어 모델을 사용한 자동 임상 코딩. NeurIPS 2023에서 Deep Generative Models for Health Workshop 발표.\n\n[6] Huang, C. W., Tsai, S. C., \u0026 Chen, Y. N. (2022). 사전 훈련된 언어 모델로 자동 ICD 코딩하기: PLM-ICD. arXiv 사전 인쇄 arXiv:2207.05289.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMiranda-Escalada, A., Gonzalez-Agirre, A., Armengol-Estapé, J., \u0026 Krallinger, M. (2020). CLEF (Working Notes), 2020에서 CodiEsp Track의 비영어 임상 사례에 대한 주석, 가이드라인 및 솔루션에 대한 개요.\n\nMiranda-Escalada, A., Gonzalez-Agirre, A., \u0026 Krallinger, M. (2020). CodiEsp corpus: ICD10 (CIE10)로 코드화된 골드 표준 스페인어 임상 사례 - eHealth CLEF2020 (1.4) [데이터 세트]. Zenodo. https://doi.org/10.5281/zenodo.3837305 (CC BY 4.0)","ogImage":{"url":"/assets/img/2024-05-17-ExploringLLMsforICDCodingPart1_0.png"},"coverImage":"/assets/img/2024-05-17-ExploringLLMsforICDCodingPart1_0.png","tag":["Tech"],"readingTime":19},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003eLLM(Large Language Model)을 활용한 자동 진단 코딩 시스템 구축\u003c/h2\u003e\n\u003cp\u003e임상 코딩은 흔히 쓰이는 용어는 아니지만, 대부분의 국가에서 건강 관리 체계와 상호작용하는 모든 사람에게 중대한 영향을 미칩니다. 임상 코딩은 환자 건강 기록에서 의학 정보(진단 및 수술 등)를 표준화된 숫자 또는 알파벳 코드로 번역하고 매핑하는 것을 포함합니다. 이러한 코드는 청구, 건강 관리 분석 및 환자가 적절한 치료를 받을 수 있도록 하는 데 중요합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-ExploringLLMsforICDCodingPart1_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e임상 코딩은 일반적으로 의료 전문가가 수행합니다. 이러한 코더들은 다양한 진단과 수술을 위한 특정 코드가 포함된 복잡하고 종종 계층적인 코딩 용어를 탐색합니다. 따라서 코더들은 사용된 코딩 용어에 대한 깊은 이해와 경험을 가져야 합니다. 그러나 문서를 수동으로 코딩하는 것은 느릴 수 있고, 오류가 발생할 수 있으며, 상당한 인적 전문 지식이 필요하여 병목 현상이 발생할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e심층 학습은 임상 코딩 자동화에 중요한 역할을 할 수 있습니다. 복잡한 의료 정보를 코드로 추출하고 번역함으로써, 심층 학습 시스템은 인간 중심 시스템 내에서 가치 있는 도구로 작용할 수 있습니다. 이러한 시스템은 코더들을 지원하여 대량의 데이터를 신속하게 처리하고 정확성을 향상시킬 수 있습니다. 이는 행정 업무를 간소화하고 청구 오류를 줄이며 환자 치료 결과를 향상시킬 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 첫 번째 부분에서는 ICD 코딩이 무엇인지, 자동 코딩 시스템이 효과적으로 극복해야 하는 다양한 도전에 대해 설명합니다. 또한 대용량 언어 모델(LLM)이 이러한 문제를 극복하는 데 효과적으로 활용할 수 있는 방법을 분석하고, 최근 논문에서 LLM을 효과적으로 활용한 알고리즘을 적용하여 ICD 코딩에 성공적으로 적용하는 방법을 설명합니다.\u003c/p\u003e\n\u003ch2\u003e목차:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eICD 코딩이란 무엇인가?\u003c/li\u003e\n\u003cli\u003e자동 ICD 코딩의 도전 요소는 무엇인가?\u003c/li\u003e\n\u003cli\u003eLLM이 자동 ICD 코딩에 어떻게 도움이 될까?\u003c/li\u003e\n\u003cli\u003e\"Off-the-shelf 대용량 언어 모델을 이용한 자동 임상 코딩\" 논문 탐색\u003c/li\u003e\n\u003cli\u003e논문에 설명된 기법 구현\u003c/li\u003e\n\u003cli\u003e결론\u003c/li\u003e\n\u003cli\u003e참고문헌\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eICD 코딩이란 무엇인가요?\u003c/h1\u003e\n\u003cp\u003e국제질병분류(ICD) 코딩은 세계보건기구에서 개발 및 유지보수하는 임상 용어 시스템입니다 [1]. 대부분의 국가에서 환자의 모든 진단, 증상 및 절차를 범주화하고 코딩하는 데 사용됩니다.\u003c/p\u003e\n\u003cp\u003e환자의 진단과 의료 절차를 기록하는 의료 기록은 ICD 코딩에 매우 중요합니다. ICD 용어는 대략 75,000가지 다른 코드로 구성된 트리 구조를 특징으로 하여 방대한 정보를 효율적으로 정리합니다. 이러한 문서를 정확하게 코딩하는 것이 중요합니다. 정확한 코딩은 적절한 청구를 보장하며 의료 분석 품질에 영향을 미치며 환자 치료 결과, 보상 및 의료 효율성에 직접적으로 영향을 줍니다.\u003c/p\u003e\n\u003ch1\u003e자동 ICD 코딩에서 어떤 도전들이 있을까요?\u003c/h1\u003e\n\u003cp\u003eICD 코딩은 효과적으로 작동하기 위해 자동화된 시스템이 극복해야 할 여러 가지 도전이 있습니다.\u003c/p\u003e\n\u003ch2\u003eICD 코딩의 레이블 다양성:\u003c/h2\u003e\n\u003cp\u003e중요한 도전 중 하나는 레이블의 광범위한 출력 공간입니다. ICD 코드는 많고 각 코드는 미세한 세부 사항에서 차이가 있을 수 있습니다. 예를 들어, 오른손에 영향을 주는 상태와 왼손에 영향을 주는 상태는 서로 다른 코드를 갖게 됩니다. 또한 의료 기록에서 드물게 나타나는 희귀 코드의 긴 꼬리가 존재하여, 이러한 코드를 학습하고 정확하게 예측하기 어렵게 만들 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e새로운 ICD 코드에 대한 적응:\u003c/h2\u003e\n\u003cp\u003e번거로우시겠지만, 테이블 태그를 마크다운 형식으로 변경해드릴게요!\u003c/p\u003e\n\u003cp\u003e전통적인 데이터셋인 MIMIC-III [2] 같은 경우는 종합적이지만, 종종 ICD 코드의 범위를 훈련 말뭉치에 포함된 코드로 제한합니다. 이 제한은 의료 기록에서 ICD 코드로의 딥러닝 모델을 다중 레이블 분류 문제로 처리하는 데 새로운 코드가 도입된 경우 모형 훈련 이후에 어려움을 겪을 수 있음을 의미합니다. 이는 재훈련이 필요하고 잠재적으로 어려울 수 있게 만듭니다.\u003c/p\u003e\n\u003ch2\u003e정보 추출 및 문맥 활용:\u003c/h2\u003e\n\u003cp\u003e또 다른 주요 과제는 의료 기록에서 정보를 정확하게 추출하고 문맥에 맞게 처리하는 것입니다. ICD 코딩은 근본적으로 정보 검색 문제로, 의료 기록에서 진단을 식별하는 것 뿐만 아니라 이러한 진단을 해당 ICD 코드로 올바르게 매핑하는 데 필요한 모든 보완 정보를 포착해야 합니다. 따라서 자동화된 시스템이 의료 기록에서 여러 진단을 추출하고 적절히 문맥화하여 ICD 코드로 정확하게 매핑되도록 하는 것이 중요합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-ExploringLLMsforICDCodingPart1_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e\"Contextualization\"란 여기서 무엇을 의미할까요? 의학 노트를 다룰 때 진단을 맥락에 맞게 처리하는 것은 관련 세부사항과 관련된 정보 — 예를 들어 영향을 받는 신체 부위 및 질환의 증상 — 를 연결하여 진단을 완전히 특성화하는 것을 의미합니다. 일반적으로 이 작업은 관계 추출로 참조됩니다.\u003c/p\u003e\n\u003ch1\u003e대규모 언어 모델(LLMs)이 자동 ICD 코딩에 어떻게 도움이 되나요?\u003c/h1\u003e\n\u003cp\u003e자동 ICD 코딩의 과제를 다룰 때, 대규모 언어 모델 (LLMs)은 이러한 문제에 대처하는 데 적합하며, 특히 새로운 레이블에 대한 적응성과 복잡한 정보 추출 작업을 관리하는 능력으로 인해 잘 역할을 합니다. 그러나 여기서의 포인트는 LLMs가 자동 ICD 코딩에 대한 최상의 해결책이거나 이러한 문제를 해결할 수 있는 유일한 해결책인 것을 주장하는 것이 아니라, 자동 ICD 코딩 시스템이 극복해야 하는 주요 과제들을 설정함으로써 LLMs의 능력을 최대한 활용하여 이를 해결할 수 있는지를 분석하는 것입니다.\u003c/p\u003e\n\u003ch2\u003e새로운 및 드문 ICD 코드에 대한 적응:\u003c/h2\u003e\n\u003cp\u003eLLMs는 견고한 제로샷 및 퓨샷 학습 능력을 보여주며, 적은 예시와 프롬프트에서 제공된 지침으로 새로운 작업에 적응할 수 있습니다. 검색 증강 생성 (RAG)은 미세 조정 없이도 LLM이 새로운 작업에 적응하기 위해 더 많은 맥락 정보에 접근할 수 있는 패러다임입니다. 이는 특히 기존의 훈련 데이터셋에서 자주 나타나지 않을 수 있는 새로운 및/또는 희귀한 ICD 코드에 LLM을 조정하는 데 유용합니다. 이를 단지 몇 가지 설명 또는 사용 사례로부터 합니다.\u003c/p\u003e\n\u003ch2\u003e맥락 정보:\u003c/h2\u003e\n\u003cp\u003eLLMs는 임상 분야에서의 제로샷 관계 추출에서 효과적으로 확인되었습니다. 제로샷 관계 추출은 LLM이 해당 관계에 대해 이전에 구체적인 훈련을 받지 않고 텍스트에서 관계를 식별하고 분류할 수 있도록 합니다. 이를 통해 의료 코딩에서의 진단을 더 잘 맥락화하여 더 정확한 ICD 코드를 가져올 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e\"Automated clinical coding using off-the-shelf large language models\" 논문 탐색하기:\u003c/h1\u003e\n\u003cp\u003eLLM을 ICD 코딩에 적용한 최근 연구를 탐색하다가, 특정한 세부 조정 없이 LLM을 활용한 ICD 코딩에 관한 매우 흥미로운 논문을 발견했습니다. 저자들은 LLM을 활용한 ICD 코딩을 위해 LLM-지도된 트리 탐색이라는 방법을 개발했습니다 [5].\u003c/p\u003e\n\u003ch2\u003e이 방법은 어떻게 작동하나요?\u003c/h2\u003e\n\u003cp\u003eICD 용어는 계층적인 트리 구조입니다. 각 ICD 코드는 이 계층적 구조 내에 존재하며, 부모 코드는 더 일반적인 상태를 다루고, 자식 코드는 특정 질병을 상세히 설명합니다. ICD 트리를 탐색하면 더 구체적이고 세분화된 진단 코드로 이어집니다.\u003c/p\u003e\n\u003cp\u003eLLM-지도된 트리 탐색에서는 탐색이 루트에서 시작되고 LLM을 사용하여 탐색할 가지를 선택하며, 모든 경로가 고갈될 때까지 반복적으로 계속합니다. 실제로 이 과정은 트리의 임의의 수준에서 모든 코드의 설명과 의료 노트를 LLM에 프롬프트로 제공하고, 해당 의료 노트에 대한 관련 코드를 식별하도록 요청하는 것으로 구현됩니다. 각 인스턴스에서 LLM에 의해 선택된 코드는 더 구체적으로 탐색되고 조사됩니다. 이 방법을 사용하면 가장 관련성이 높은 ICD 코드가 식별되며, 이후 임상 노트에 대한 예측 레이블로 할당됩니다.\u003c/p\u003e\n\u003cp\u003e예시를 통해 이를 명확히 해보겠습니다. ICD 코드 1과 ICD 코드 2라는 두 개의 루트 노드를 가진 트리를 상상해보세요. 각 노드는 코드를 특성화하는 평문 설명을 가지고 있습니다. 초기 단계에서 LLM에게 의학 노트와 코드 설명이 제공되고 의학 노트와 관련된 코드를 식별하도록 요청됩니다.\u003c/p\u003e\n\u003cp\u003e이 시나리오에서 LLM은 의학 노트와 관련이 있는 것으로 판단된 ICD 코드 1과 ICD 코드 2를 식별합니다. 알고리즘은 각 코드의 자식 노드를 조사합니다. 각 부모 코드는 더 구체적인 ICD 코드를 나타내는 두 개의 자식 노드를 가지고 있습니다. ICD 코드 1부터 시작하여, LLM은 ICD 코드 1.1과 ICD 코드 1.2의 설명을 사용하여 의학 노트를 기반으로 관련 코드를 결정합니다. LLM은 ICD 코드 1.1이 관련이 있다고 결론 내리고, ICD 코드 1.2는 관련이 없다고 판단합니다. ICD 코드 1.1에는 더 이상의 자식 노드가 없으므로, 알고리즘은 할당 가능한 코드인지 확인하고 문서에 할당합니다. 그 다음 알고리즘은 ICD 코드 2의 자식 노드를 평가합니다. LLM을 호출하여, ICD 코드 2.1이 관련이 있는 것으로 판단합니다. 이것은 간단화된 예시이며, 실제로는 ICD 트리는 광범위하고 깊기 때문에 알고리즘은 각 관련된 노드의 자식을 탐색하거나 트리의 끝에 도달하거나 유효한 탐색을 소진할 때까지 계속됩니다.\u003c/p\u003e\n\u003ch2\u003e핵심\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e이 방법은 LLM의 세밀한 조정이 필요하지 않습니다. 대신, 제공된 설명을 기반으로 LLM의 의료 노트를 상황에 맞게 이해하고 관련 ICD 코드를 동적으로 식별할 수 있는 능력을 활용합니다.\u003c/li\u003e\n\u003cli\u003e더 나아가, 본 논문은 LLM이 프롬프트에 관련 정보가 주어질 때 대규모 출력 공간에 효과적으로 적응할 수 있으며, macro-average 지표 측면에서 드문 코드에서 PLM-ICD [6]를 앞지를 수 있다는 것을 보여줍니다.\u003c/li\u003e\n\u003cli\u003e이 기술은 또한 파라메트릭 지식에 기초하여 의학 노트의 ICD 코드를 예측하도록 LLM에 직접 요청하는 기준선을 능가합니다. 이는 LLM을 임상 코딩 작업을 해결하기 위한 도구나 외부 지식과 통합하는 잠재력을 강조합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e단점\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e알고리즘은 트리의 각 수준에서 LLM을 호출합니다. 이로 인해 트리를 탐색하는 동안 LLM 호출 횟수가 많아지며, ICD 트리의 광범위함이 이에 더해집니다. 이는 단일 문서를 처리하는 데 높은 대기 시간과 비용으로 이어집니다.\u003c/li\u003e\n\u003cli\u003e저자들이 논문에서 언급한 바와 같이, 관련 있는 코드를 정확하게 예측하려면 LLM이 모든 수준에서 부모 노드를 올바르게 식별해야 합니다. 한 수준에서 실수가 발생하더라도, LLM은 최종 관련 코드에 도달할 수 없게 됩니다.\u003c/li\u003e\n\u003cli\u003e저자들은 MIMIC-III와 같은 데이터셋을 사용하여 메소드를 평가할 수 없었습니다. 외부 서비스로의 데이터 전송을 금지하는 제한 사항으로 인하여 OpenAI의 GPT 엔드포인트와 같은 외부 서비스로의 데이터 전송이 불가능했습니다. 대신, 저자들은 CodiEsp 데이터셋 [7,8]의 테스트 세트를 사용하여 해당 방법을 평가했습니다. 해당 데이터셋은 250개의 의학 노트를 포함하고 있습니다. 이 데이터셋의 크기가 작은 것은 해당 방법이 대규모 임상 데이터셋에서의 성능을 아직 입증하지 못했음을 시사합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e논문에서 설명한 기술 구현하기\u003c/h1\u003e\n\u003cp\u003e이 기술을 구현하여 그 작동 방식을 더 잘 이해해 봅시다. 논문에서 언급했듯이, 해당 논문은 평가를 위해 CodiEsp 테스트 세트를 사용합니다. 이 데이터셋은 스페인어 의학 노트와 이에 대응하는 ICD 코드로 구성되어 있습니다. 데이터셋에는 영어로 번역된 버전도 포함되어 있지만, 저자들은 스페인어 의학 노트를 GPT-3.5를 사용하여 영어로 번역하였으며, 이를 통해 사전 번역된 버전을 사용하는 것보다 성능이 약간 향상되었다고 주장했습니다. 이 기능을 복제하고 노트를 영어로 번역해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003econstruct_translation_prompt\u003c/span\u003e(medical_note):\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n    Construct a prompt template for translating Spanish medical notes to English.\n    \n    Args:\n        medical_note (str): The medical case note.\n        \n    Returns:\n        str: A structured template ready to be used as input for a language model.\n    \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e    \n    translation_prompt = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"You are an expert Spanish-to-English translator. You are provided with a clinical note written in Spanish.\nYou must translate the note into English. You must ensure that you properly translate the medical and technical terms from Spanish to English without any mistakes.\nSpanish Medical Note:\n{medical_note}\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e translation_prompt.\u003cspan class=\"hljs-title function_\"\u003eformat\u003c/span\u003e(medical_note = medical_note)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow that we have the evaluation corpus ready, let’s implement the core logic for the tree-search algorithm. We define the functionality in get_icd_codes, which accepts the medical note to process, the model name, and the temperature setting. The model name must be either “gpt-3.5-turbo-0613” for GPT-3.5 or “meta-llama/Llama-2–70b-chat-hf” for Llama-2 70B Chat. This specification determines the LLM that the tree-search algorithm will invoke during its processing.\u003c/p\u003e\n\u003cp\u003eEvaluating GPT-4 is possible using the same code-base by providing the appropriate model name, but we choose to skip it as it is quite time-consuming.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003eget_icd_codes\u003c/span\u003e(medical_note, model_name=\u003cspan class=\"hljs-string\"\u003e\"gpt-3.5-turbo-0613\"\u003c/span\u003e, temperature=\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e):\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n    Identifies relevant ICD-10 codes for a given medical note by querying a language model.\n\n    This function implements the tree-search algorithm for ICD coding described in https://openreview.net/forum?id=mqnR8rGWkn.\n\n    Args:\n        medical_note (str): The medical note for which ICD-10 codes are to be identified.\n        model_name (str): The identifier for the language model used in the API (default is 'gpt-3.5-turbo-0613').\n\n    Returns:\n        list of str: A list of confirmed ICD-10 codes that are relevant to the medical note.\n    \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    assigned_codes = []\n    candidate_codes = [x.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e x \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCHAPTER_LIST\u003c/span\u003e]\n    parent_codes = []\n    prompt_count = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e prompt_count \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e:\n        code_descriptions = {}\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e x \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecandidate_codes\u003c/span\u003e:\n            description, code = \u003cspan class=\"hljs-title function_\"\u003eget_name_and_description\u003c/span\u003e(x, model_name)\n            code_descriptions[description] = code\n\n        prompt = \u003cspan class=\"hljs-title function_\"\u003ebuild_zero_shot_prompt\u003c/span\u003e(medical_note, \u003cspan class=\"hljs-title function_\"\u003elist\u003c/span\u003e(code_descriptions.\u003cspan class=\"hljs-title function_\"\u003ekeys\u003c/span\u003e()), model_name=model_name)\n        lm_response = \u003cspan class=\"hljs-title function_\"\u003eget_response\u003c/span\u003e(prompt, model_name, temperature=temperature, max_tokens=\u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e)\n        predicted_codes = \u003cspan class=\"hljs-title function_\"\u003eparse_outputs\u003c/span\u003e(lm_response, code_descriptions, model_name=model_name)\n\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e code \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epredicted_codes\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e cm.\u003cspan class=\"hljs-title function_\"\u003eis_leaf\u003c/span\u003e(code[\u003cspan class=\"hljs-string\"\u003e\"code\"\u003c/span\u003e]):\n                assigned_codes.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(code[\u003cspan class=\"hljs-string\"\u003e\"code\"\u003c/span\u003e])\n            \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n                parent_codes.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(code)\n\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(parent_codes) \u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\n            parent_code = parent_codes.\u003cspan class=\"hljs-title function_\"\u003epop\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n            candidate_codes = cm.\u003cspan class=\"hljs-title function_\"\u003eget_children\u003c/span\u003e(parent_code[\u003cspan class=\"hljs-string\"\u003e\"code\"\u003c/span\u003e])\n        \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e\n\n        prompt_count += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e assigned_codes\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 논문과 비슷하게, ICD-10 트리에 액세스하는 simple_icd_10_cm 라이브러리를 사용합니다. 이를 통해 트리를 탐색하고, 각 코드에 대한 설명에 액세스하며 유효한 코드를 식별할 수 있습니다. 먼저, 트리의 첫 번째 수준에서 노드를 가져옵니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e simple_icd_10_cm \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e cm\n\ndef \u003cspan class=\"hljs-title function_\"\u003eget_name_and_description\u003c/span\u003e(code, model_name):\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n    ICD-10 코드의 이름과 설명을 검색합니다.\n    \n    Args:\n        code (str): ICD-10 코드.\n        \n    Returns:\n        tuple: 형식화된 설명과 코드의 이름이 포함된 튜플을 반환합니다.\n    \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    full_data = cm.\u003cspan class=\"hljs-title function_\"\u003eget_full_data\u003c/span\u003e(code).\u003cspan class=\"hljs-title function_\"\u003esplit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eformat_code_descriptions\u003c/span\u003e(full_data[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e], model_name), full_data[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e루프 내부에서 각 노드에 해당하는 설명을 얻습니다. 이제 의료 노트와 코드 설명을 기반으로 LLM을 위한 프롬프트를 작성해야 합니다. 우리는 논문에서 제공된 세부 정보를 기반으로 GPT-3.5와 Llama-2용 프롬프트를 작성합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eprompt_template_dict = {\u003cspan class=\"hljs-string\"\u003e\"gpt-3.5-turbo-0613\"\u003c/span\u003e : \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"[사례 노트]:\n{note}\n[예시]:\n\u0026#x3C;예시 프롬프트\u003e\n위식도 역류병\n장전위\n\n\u0026#x3C;응답\u003e\n위식도 역류병: 예, 환자에게 오메프라졸 처방함.\n장전위: 아니오.\n\n[작업]:\n다음 ICD-10 코드 설명 각각을 고려하고 사례 노트에 관련 언급이 있는지 평가하십시오.\n예시의 형식을 정확히 따르십시오.\n\n{code_descriptions}\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e,\n\n\u003cspan class=\"hljs-string\"\u003e\"meta-llama/Llama-2-70b-chat-hf\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"[사례 노트]:\n{note}\n\n[예시]:\n\u0026#x3C;코드 설명\u003e\n* 위식도 역류병\n* 장전위\n* 급성비인두염 [감기]\n\u0026#x3C;/코드 설명\u003e\n\n\u0026#x3C;응답\u003e\n* 위식도 역류병: 예, 환자에게 오메프라졸 처방함.\n* 장전위: 아니오.\n* 급성비인두염 [감기]: 아니오.\n\u0026#x3C;/응답\u003e\n\n[작업]:\n예시 응답 형식을 정확히 따르십시오. (예) 판단하기 전에 전체 설명과 (예|아니오) 판단을 입력한 후에 새 줄을 추가하십시오. \n다음 ICD-10 코드 설명을 고려하고 사례 노트에서 관련 언급이 있는지 확인하십시오.\n\n{code_descriptions}\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e의료 기록과 코드 설명에 기반한 프롬프트를 지금 만들어 보겠습니다. 프롬프트 및 코딩에서 우리에게 이점은 GPT-3.5 및 Llama 2 모두와 상호 작용하기 위해 동일한 openai 라이브러리를 사용할 수 있다는 것입니다. 단, Llama-2가 deepinfra를 통해 배포되어야 합니다. deepinfra는 LLM에 요청을 보내기 위한 openai 형식도 지원합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003econstruct_prompt_template\u003c/span\u003e(case_note, code_descriptions, model_name):\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n    주어진 케이스 노트와 ICD-10 코드 설명을 평가하는 프롬프트 템플릿 구성\n    \n    Args:\n        case_note (str): 의료 케이스 노트\n        code_descriptions (str): ICD-10 코드 설명을 단일 문자열로 포맷팅\n        \n    Returns:\n        str: 언어 모델에 입력으로 사용할 준비된 구조화된 템플릿\n    \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    template = prompt_template_dict[model_name]\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e template.\u003cspan class=\"hljs-title function_\"\u003eformat\u003c/span\u003e(note=case_note, code_descriptions=code_descriptions)\n\ndef \u003cspan class=\"hljs-title function_\"\u003ebuild_zero_shot_prompt\u003c/span\u003e(input_note, descriptions, model_name, system_prompt=\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e):\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n    시스템 및 사용자 역할에 대한 제로샷 분류용 프롬프트 빌드\n    \n    Args:\n        input_note (str): 입력 노트 또는 질의\n        descriptions (list of str): ICD-10 코드 설명 리스트\n        system_prompt (str): 선택적 초기 시스템 프롬프트 또는 지시\n    \n    Returns:\n        list of dict: 각 메시지의 역할 및 내용을 정의하는 구조화된 사전 목록\n    \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e model_name == \u003cspan class=\"hljs-string\"\u003e\"meta-llama/Llama-2-70b-chat-hf\"\u003c/span\u003e:\n        code_descriptions = \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e([\u003cspan class=\"hljs-string\"\u003e\"* \"\u003c/span\u003e + x \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e x \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e descriptions])\n    \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n        code_descriptions = \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(descriptions)\n\n    input_prompt = \u003cspan class=\"hljs-title function_\"\u003econstruct_prompt_template\u003c/span\u003e(input_note, code_descriptions, model_name)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [{\u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"system\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: system_prompt}, {\u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: input_prompt}]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e프롬프트를 구성한 후, 이제 LLM을 호출하여 응답을 받겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003eget_response\u003c/span\u003e(messages, model_name, temperature=\u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e, max_tokens=\u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e):\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n    채팅-완성 API를 통해 지정된 모델로부터 응답을 획득\n    \n    Args:\n        messages (list of dict): API 입력용 구조화된 메시지 목록\n        model_name (str): 쿼리할 모델의 식별자\n        temperature (float): 응답의 무작위성을 제어하는 값, 0이면 결정론적\n        max_tokens (int): 응답의 토큰 수 제한\n        \n    Returns:\n        str: 모델에서의 응답 메시지 내용\n    \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    response = client.\u003cspan class=\"hljs-property\"\u003echat\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecompletions\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(\n        model=model_name,\n        messages=messages,\n        temperature=temperature,\n        max_tokens=max_tokens\n    )\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response.\u003cspan class=\"hljs-property\"\u003echoices\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003emessage\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003econtent\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e좋아요, 우리가 출력물을 얻었어요! 이 응답으로부터, 이제 LLM이 추가적인 탐색을 위해 관련있는 노드들과 거부한 노드들을 식별하기 위해 각 코드 설명을 구문 분석합니다. 우리는 출력 응답을 새 줄로 나누고 각 응답을 분할하여 LLM의 각 코드 설명에 대한 예측을 식별합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003eremove_noisy_prefix\u003c/span\u003e(text):\n    # 문자 또는 숫자가 뒤따르고 점과 선택적 공백으로 시작하는 문자열의 제일 앞에 있는 숫자나 문자를 제거합니다.\n    cleaned_text = text.\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"* \"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003estrip\u003c/span\u003e()\n    cleaned_text = re.\u003cspan class=\"hljs-title function_\"\u003esub\u003c/span\u003e(r\u003cspan class=\"hljs-string\"\u003e\"^\\s*\\w+\\.\\s*\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e, cleaned_text)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e cleaned_text.\u003cspan class=\"hljs-title function_\"\u003estrip\u003c/span\u003e()\n\ndef \u003cspan class=\"hljs-title function_\"\u003eparse_outputs\u003c/span\u003e(output, code_description_map, model_name):\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n    모델 출력을 구문 분석하여 주어진 설명 매핑에 따른 ICD-10 코드를 확인합니다.\n    \n    Args:\n        output (str): 확인을 포함하는 모델 출력입니다.\n        code_description_map (dict): 설명과 ICD-10 코드의 매핑입니다.\n        \n    Returns:\n        list of dict: 확인된 코드 및 해당 설명의 목록입니다.\n    \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    confirmed_codes = []\n    split_outputs = [x \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e x \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e output.\u003cspan class=\"hljs-title function_\"\u003esplit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e x]\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e item \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esplit_outputs\u003c/span\u003e:\n        \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:                \n            code_description, confirmation = item.\u003cspan class=\"hljs-title function_\"\u003esplit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\":\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e model_name == \u003cspan class=\"hljs-string\"\u003e\"meta-llama/Llama-2-70b-chat-hf\"\u003c/span\u003e:\n                code_description = \u003cspan class=\"hljs-title function_\"\u003eremove_noisy_prefix\u003c/span\u003e(code_description)\n\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e confirmation.\u003cspan class=\"hljs-title function_\"\u003elower\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003estrip\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003estartswith\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"yes\"\u003c/span\u003e):\n                \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n                    code = code_description_map[code_description]\n                    confirmed_codes.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e({\u003cspan class=\"hljs-string\"\u003e\"code\"\u003c/span\u003e: code, \u003cspan class=\"hljs-string\"\u003e\"description\"\u003c/span\u003e: code_description})\n                except \u003cspan class=\"hljs-title class_\"\u003eException\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ee\u003c/span\u003e:\n                    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003estr\u003c/span\u003e(e) + \u003cspan class=\"hljs-string\"\u003e\" Here\"\u003c/span\u003e)\n                    \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eexcept\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e confirmed_codes\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 루프의 나머지를 살펴봅시다. 지금까지 우리는 프롬프트를 구성했고, LLM으로부터 응답을 받았으며, 출력을 구문 분석하여 LLM에 의해 관련이 있다고 판단된 코드를 식별했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e prompt_count \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e:\n    code_descriptions = {}\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e x \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecandidate_codes\u003c/span\u003e:\n        description, code = \u003cspan class=\"hljs-title function_\"\u003eget_name_and_description\u003c/span\u003e(x, model_name)\n        code_descriptions[description] = code\n\n    prompt = \u003cspan class=\"hljs-title function_\"\u003ebuild_zero_shot_prompt\u003c/span\u003e(medical_note, \u003cspan class=\"hljs-title function_\"\u003elist\u003c/span\u003e(code_descriptions.\u003cspan class=\"hljs-title function_\"\u003ekeys\u003c/span\u003e()), model_name=model_name)\n    lm_response = \u003cspan class=\"hljs-title function_\"\u003eget_response\u003c/span\u003e(prompt, model_name, temperature=temperature, max_tokens=\u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e)\n    predicted_codes = \u003cspan class=\"hljs-title function_\"\u003eparse_outputs\u003c/span\u003e(lm_response, code_descriptions, model_name=model_name)\n\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e code \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epredicted_codes\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e cm.\u003cspan class=\"hljs-title function_\"\u003eis_leaf\u003c/span\u003e(code[\u003cspan class=\"hljs-string\"\u003e\"code\"\u003c/span\u003e]):\n            assigned_codes.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(code[\u003cspan class=\"hljs-string\"\u003e\"code\"\u003c/span\u003e])\n        \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n            parent_codes.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(code)\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(parent_codes) \u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\n        parent_code = parent_codes.\u003cspan class=\"hljs-title function_\"\u003epop\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n        candidate_codes = cm.\u003cspan class=\"hljs-title function_\"\u003eget_children\u003c/span\u003e(parent_code[\u003cspan class=\"hljs-string\"\u003e\"code\"\u003c/span\u003e])\n    \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e\n\n    prompt_count += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 예측된 코드를 반복하며 각 코드가 \"leaf\" 코드인지 확인합니다. 이는 코드가 유효하고 할당 가능한 ICD 코드임을 보증하는 것입니다. 예측된 코드가 유효하면 LLM이 그 의료 노트에 대한 예측으로 간주합니다. 유효하지 않으면 상위 코드에 추가하여 ICD 트리를 더 탐색하기 위해 자식 노드를 얻습니다. 더 이상 탐색할 상위 코드가 없을 경우 루프를 탈출합니다.\u003c/p\u003e\n\u003cp\u003e이론적으로 의료 노트 당 LLM 호출 수는 임의로 높을 수 있으며, 알고리즘이 많은 노드를 탐색하는 경우 지연 시간이 증가할 수 있습니다. 저자는 의료 노트 당 최대 50회 프롬프트/LLM 호출로 처리를 종료하는 최대 수를 시행했습니다. 이 한계는 우리가 구현에서도 채택합니다.\u003c/p\u003e\n\u003ch2\u003e결과\u003c/h2\u003e\n\u003cp\u003e이제 GPT-3.5와 Llama-2를 LLM으로 사용하여 트리 탐색 알고리즘의 결과를 평가할 수 있습니다. 우리는 알고리즘의 성능을 마이크로-평균 및 매크로-평균 정밀도, 재현율 및 F1 점수를 통해 평가합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-ExploringLLMsforICDCodingPart1_2.png\" alt=\"ExploringLLMsforICDCodingPart1_2\"\u003e\u003c/p\u003e\n\u003cp\u003e구현 결과는 논문에 보고된 점수와 대략적으로 일치하지만 주목할 만한 차이점이 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이 구현에서 GPT-3.5의 마이크로 평균 측정 지표는 보고된 값보다 약간 뛰어나지만, 매크로 평균 측정 지표는 보고된 값보다 조금 부족합니다.\u003c/li\u003e\n\u003cli\u003e마찬가지로 Llama-70B의 마이크로 평균 측정 지표는 보고된 값과 일치하거나 조금 뛰어나지만, 매크로 평균 측정 지표는 보고된 값보다 낮습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e앞서 언급했듯이, 이 구현은 몇 가지 미세한 차이점을 가지고 있어 최종 성능에 영향을 미칩니다. 이 구현이 원본 논문과 어떻게 다른지에 대한 보다 자세한 내용은 링크된 저장소를 참조해 주세요.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 방법을 이해하고 구현하는 것은 여러 측면에서 나에게 매우 유익했습니다. 이를 통해 대규모 언어 모델(LLMs)의 강점과 약점에 대해 보다 세밀하게 이해할 수 있었고 임상 코딩 사례에서 그것을 구현할 수 있었습니다. 구체적으로, 코드에 관련된 중요한 정보에 동적으로 접근할 수 있는 경우 LLMs는 임상 문맥을 효과적으로 이해하고 관련 코드를 정확하게 식별할 수 있다는 것이 분명해졌습니다.\u003c/p\u003e\n\u003cp\u003eLLMs를 임상 코딩을 위한 대리자로 활용하는 것이 성능을 더욱 향상시킬 수 있는지 탐구하는 것이 흥미로울 것입니다. 생명공학 및 임상 텍스트에 대한 외부 지식 소스가 논문이나 지식 그래프 형태로 풍부하게 제공되는 상황에서 LLM 대리자는 의료 문서를 보다 세밀한 단위로 분석하는 워크플로에 활용될 수 있습니다. 또한 필요한 경우 외부 지식을 참고하여 최종 코드에 도달할 수 있도록 동적으로 도구를 활용할 수도 있습니다.\u003c/p\u003e\n\u003ch2\u003e감사의 글\u003c/h2\u003e\n\u003cp\u003e이 방법을 평가하는 데 도움을 준 이 논문의 주 저자 Joseph에게 큰 감사를 표합니다!\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e참고 자료:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e[1] \u003ca href=\"https://www.who.int/standards/classifications/classification-of-diseases\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.who.int/standards/classifications/classification-of-diseases\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e[2] Johnson, A. E., Pollard, T. J., Shen, L., Lehman, L. W. H., Feng, M., Ghassemi, M., … \u0026#x26; Mark, R. G. (2016). MIMIC-III, a freely accessible critical care database Sci. Data, 3(1), 1.\u003c/p\u003e\n\u003cp\u003e[3] Agrawal, M., Hegselmann, S., Lang, H., Kim, Y., \u0026#x26; Sontag, D. (2022). 대형 언어 모델은 소수의 적은 데이터로도 임상 정보를 추출합니다. arXiv 사전 인쇄 arXiv:2205.12689.\u003c/p\u003e\n\u003cp\u003e[4] Zhou, H., Li, M., Xiao, Y., Yang, H., \u0026#x26; Zhang, R. (2023). 임상 관계 추출을 위한 LLM Instruction-Example Adaptive Prompting (LEAP) 프레임워크. medRxiv : 의학과학 사전 인쇄 서버, 2023.12.15.23300059. \u003ca href=\"https://doi.org/10.1101/2023.12.15.23300059\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://doi.org/10.1101/2023.12.15.23300059\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e[5] Boyle, J. S., Kascenas, A., Lok, P., Liakata, M., \u0026#x26; O’Neil, A. Q. (2023, 10월). 상업용 대형 언어 모델을 사용한 자동 임상 코딩. NeurIPS 2023에서 Deep Generative Models for Health Workshop 발표.\u003c/p\u003e\n\u003cp\u003e[6] Huang, C. W., Tsai, S. C., \u0026#x26; Chen, Y. N. (2022). 사전 훈련된 언어 모델로 자동 ICD 코딩하기: PLM-ICD. arXiv 사전 인쇄 arXiv:2207.05289.\u003c/p\u003e\n\u003cp\u003eMiranda-Escalada, A., Gonzalez-Agirre, A., Armengol-Estapé, J., \u0026#x26; Krallinger, M. (2020). CLEF (Working Notes), 2020에서 CodiEsp Track의 비영어 임상 사례에 대한 주석, 가이드라인 및 솔루션에 대한 개요.\u003c/p\u003e\n\u003cp\u003eMiranda-Escalada, A., Gonzalez-Agirre, A., \u0026#x26; Krallinger, M. (2020). CodiEsp corpus: ICD10 (CIE10)로 코드화된 골드 표준 스페인어 임상 사례 - eHealth CLEF2020 (1.4) [데이터 세트]. Zenodo. \u003ca href=\"https://doi.org/10.5281/zenodo.3837305\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://doi.org/10.5281/zenodo.3837305\u003c/a\u003e (CC BY 4.0)\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-17-ExploringLLMsforICDCodingPart1"},"buildId":"o1YmnmSuZvAX2O4TI9r41","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>