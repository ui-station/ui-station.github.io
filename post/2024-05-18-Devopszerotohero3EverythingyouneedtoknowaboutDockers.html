<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>데브옵스 제로 투 히어로 3  도커에 대해 알아야 할 모든 것 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="데브옵스 제로 투 히어로 3  도커에 대해 알아야 할 모든 것 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="데브옵스 제로 투 히어로 3  도커에 대해 알아야 할 모든 것 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers" data-gatsby-head="true"/><meta name="twitter:title" content="데브옵스 제로 투 히어로 3  도커에 대해 알아야 할 모든 것 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-18 16:42" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_buildManifest.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">데브옵스 제로 투 히어로 3  도커에 대해 알아야 할 모든 것</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="데브옵스 제로 투 히어로 3  도커에 대해 알아야 할 모든 것" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 18, 2024</span><span class="posts_reading_time__f7YPP">27<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>데브옵스 업무 흐름에서 도커 사용을 시작하는 완벽한 가이드</h2>
<h3>이 블로그 포스트에서 무엇을 기대해야 하는가?</h3>
<h3>왜 Docker를 사용해야 하는가?</h3>
<p>20~30년 전으로 돌아가면, 하드웨어와 설치된 운영 체제(커널 및 UI)가 있었습니다. 어플리케이션을 실행하기 위해서 코드를 컴파일하고 모든 앱 의존성을 정렬해야 했습니다. 다른 어플리케이션이나 어플리케이션 작업량의 증가를 수용하기 위해 새 하드웨어를 구매하고 설치 및 구성해야 했습니다.</p>
<p></p>
<p>가상화는 하드웨어와 운영 체제 사이에 추가 계층인 하이퍼바이저라는 것을 추가했습니다. 이를 통해 사용자들은 독립된 여러 애플리케이션을 실행하여 가상 머신을 자체 운영 체제와 함께 실행할 수 있었습니다.</p>
<p>그럼에도 불구하고, 우리는 모든 가상 머신에 소프트웨어를 설치하고 종속성을 설정해주어야 했습니다. 애플리케이션이 휴대 가능하지 않았습니다. 일부 기기에서는 작동하지만 다른 기기에서는 작동하지 않았습니다.</p>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_0.png" alt="이미지"></p>
<h1>도커란 무엇인가요?</h1>
<p></p>
<p>도커는 마이크로서비스 기반 응용 프로그램 개발이 가능하도록 함으로써 소프트웨어 빌드 방법을 혁신했습니다.</p>
<h1>도커는 어떻게 작동하나요?</h1>
<p>도커 엔진은 호스트 운영 체제 위에서 실행됩니다. 도커 엔진에는 호스트 시스템에서 도커 컨테이너를 관리하는 서버 프로세스(dockerd)가 포함되어 있습니다. 도커 컨테이너는 응용 프로그램과 그 의존성을 격리시켜 다른 환경에서도 일관되게 실행할 수 있도록 설계되었습니다.</p>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_1.png" alt="이미지"></p>
<p></p>
<p>도커를 사용하려면 Dockerfile, Docker 이미지, Docker 컨테이너라는 세 가지 개념을 이해해야 합니다.</p>
<h2>Docker 파일(Dockerfile)이란?</h2>
<h2>Docker 이미지란 무엇인가요?</h2>
<p>Docker 이미지에는 컨테이너 내에서 코드를 실행하는 데 필요한 모든 종속성이 포함되어 있습니다.</p>
<p></p>
<h2>Docker 컨테이너란 무엇인가요?</h2>
<h1>Docker로 시작하기</h1>
<h2>사전 요구 사항</h2>
<p>Docker는 로컬 머신 또는 클라우드 VM에 설치되어 있어야 합니다.</p>
<p></p>
<p>Linux:</p>
<p>로컬 노트북, 가상 머신 또는 클라우드 VM에서 Linux를 실행 중이라면 패키지 관리자를 사용하여 Docker를 설치할 수 있습니다. 이 블로그 포스트의 지시사항을 따라주세요.</p>
<p>Mac 및 Windows:</p>
<p>로컬 머신에서 Docker를 실행할 수 있게 해주는 Docker Desktop을 설치할 수 있습니다.</p>
<p></p>
<p>도커를 시작하는 것은 쉬운 일이에요. 아래 명령을 실행하기만 하면 돼요</p>
<pre><code class="hljs language-js">도커 런 -d -t --name <span class="hljs-title class_">Thor</span> alpine
도커 런 -d -t busybox
</code></pre>
<p>이 명령은 도커 이미지 alpine과 busybox로부터 2개의 컨테이너를 생성할 거에요. 이 둘은 도커 허브에 저장된 미니멀리스트이면서 퍼블릭인 리눅스 도커 이미지에요.</p>
<ul>
<li>-d 옵션은 컨테이너를 백그라운드에서 실행(detach mode)</li>
<li>-t 옵션은 tty 터미널을 연결해 줘요.</li>
<li>--name 옵션은 컨테이너에 이름을 부여할 수 있어요. 제공하지 않으면 컨테이너는 랜덤 이름을 받게 돼요</li>
</ul>
<p></p>
<p>참고: 위에 언급된 이미지로 처음 docker run을 실행하면 도커가 로컬 머신에서 이미지를 다운로드(풀)해야 합니다.</p>
<h2>로컬 머신에서 실행 중인/중지된 컨테이너 목록</h2>
<pre><code class="hljs language-js">docker ps # 실행 중인 컨테이너 확인
docker ps -a # 모든 컨테이너 목록
</code></pre>
<p></p>
<h2>로컬 머신에 있는 도커 이미지 목록</h2>
<pre><code class="hljs language-js">docker image ls
</code></pre>
<p></p>
<p>Linux 기반 도커 컨테이너에 사용된 이미지 크기를 확인할 수 있어요. 우분투, 아마존 리눅스, CentOS 등과 같은 일반적인 Linux 기반 머신과 비교하면 작아요.</p>
<p>실행 중인 컨테이너와 상호 작용하는 방법은 명령을 전달하거나 대화형 세션을 여는 두 가지 방법이 있어요.</p>
<pre><code class="hljs language-js"># docker exec -it &#x3C;컨테이너 <span class="hljs-variable constant_">ID</span>> &#x3C;셸>
</code></pre>
<ul>
<li>docker exec를 사용하면 실행 중인 도커 컨테이너 내부로 진입할 수 있어요.</li>
<li>--it는 도커와 대화형 세션을 열어줘요.</li>
<li>셸은 sh, bash, zsh 등을 사용할 수 있어요.</li>
</ul>
<p></p>
<p>컨테이너 정보를 얻기 위해 몇 가지 명령을 실행해 봅시다.</p>
<pre><code class="hljs language-js">docker exec -t <span class="hljs-title class_">Thor</span> ls ; ps
# -t는 tty 세션을 열기 위한 옵션입니다.
# <span class="hljs-title class_">Thor</span>는 컨테이너 이름입니다.
# ls ; ps는 ls와 ps 두 개의 명령을 실행합니다.

docker exec -t 8ad10d1d0660 free -m
# 8ad10d1d0660은 컨테이너 <span class="hljs-variable constant_">ID</span>이며, free -m은 메모리 사용량을 확인하는 명령입니다.
</code></pre>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_5.png" alt="이미지"></p>
<p>이제 -it 옵션을 사용하여 컨테이너와 대화형 쉘 세션을 열어보겠습니다.</p>
<p></p>
<pre><code class="hljs language-js">도커 exec -it 16fb1c59fbea sh
# 세션을 종료하려면 <span class="hljs-string">"exit"</span>을 입력하세요
</code></pre>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_6.png" alt="이미지"></p>
<h1>컨테이너 시작, 중지, 삭제</h1>
<pre><code class="hljs language-js"># 실행 중인 컨테이너를 중지하는 방법
docker stop &#x3C;컨테이너 이름 또는 <span class="hljs-variable constant_">ID</span>>

# 중지된 컨테이너를 시작하는 방법
docker start &#x3C;컨테이너 이름 또는 <span class="hljs-variable constant_">ID</span>>
</code></pre>
<p></p>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_7.png" alt="Image"></p>
<pre><code class="hljs language-js"># 실행 중인 컨테이너를 종료한 후에 삭제하려면 다음과 같이 명령을 사용합니다.
# docker stop &#x3C;컨테이너 이름 또는 <span class="hljs-variable constant_">ID</span>>
# docker rm &#x3C;컨테이너 이름 또는 <span class="hljs-variable constant_">ID</span>>
docker stop 16fb1c59fbea
docker rm 16fb1c59fbea

# 아니면 -f 플래그를 사용하여 강제로 컨테이너를 삭제합니다.
docker rm -f <span class="hljs-title class_">Thor</span>
</code></pre>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_8.png" alt="Image"></p>
<h1>도커 이미지 빌드하기</h1>
<p></p>
<h1>Docker 네트워킹</h1>
<p>도커는 다양한 종류의 네트워크를 제공합니다.</p>
<h2>1. 기본 브릿지</h2>
<p>만약 도커허브에서 nginx 이미지를 사용하여 nginx 컨테이너를 실행 중이고 웹 서버에 액세스하려고 한다면요.</p>
<p></p>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_9.png" alt="screenshot"></p>
<p>스크린샷을 통해 Nginx 웹 서버가 80번 포트에서 실행 중임을 확인할 수 있습니다. NGINX 컨테이너에 로그인하여 curl 127.0.0.1:80을 실행하면 웹 서버에서 HTML 응답을 반환합니다.</p>
<ul>
<li>127.0.0.1은 루프백 주소로 현재 장치(로컬호스트)를 항상 가리킵니다.</li>
</ul>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_10.png" alt="screenshot"></p>
<p></p>
<p>위에서 본 것처럼, 컨테이너 내부의 웹 서버가 우리가 기대한 대로 작동했습니다.</p>
<p>이제 호스트 머신 (랩톱/가상 머신)에서 웹 서버에 연결해 보겠습니다.</p>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_11.png" alt="이미지"></p>
<p>컨테이너에서 실행 중인 nginx 웹 서버에 연결할 수 없었습니다.</p>
<p></p>
<p>네트워크 깊이 파고들기</p>
<p>도커 컨테이너를 검사하려면 docker inspect 명령을 실행하고 맨 아래로 스크롤하면 도커가 브릿지 네트워크를 사용하고 네트워크에 대한 자세한 내용을 볼 수 있습니다.</p>
<pre><code class="hljs language-js">docker inspect nginx-container
</code></pre>
<p></p>
<pre><code class="hljs language-js">도커 네트워크 목록
</code></pre>
<p>네트워크를 검사하면 기본 브릿지 네트워크를 사용하는 컨테이너를 찾을 수 있습니다.</p>
<pre><code class="hljs language-js">도커 네트워크 검사 브릿지
</code></pre>
<p></p>
<h2>포트 전달</h2>
<pre><code class="hljs language-js">도커 실행 -d -p &#x3C;호스트 포트>:&#x3C;컨테이너 포트> --name &#x3C;컨테이너 이름> 이미지

# 포트 전달 -> 컨테이너의 포트 <span class="hljs-number">80</span>을 호스트 머신의 포트 <span class="hljs-number">5000</span>으로 전달
도커 실행 -t -d -p <span class="hljs-number">5000</span>:<span class="hljs-number">80</span> --name nginx-container <span class="hljs-attr">nginx</span>:latest
</code></pre>
<p></p>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_16.png" alt=""></p>
<p>도커는 기본 네트워크를 사용하지 말라고 권장하고 대신에 우리만의 네트워크를 생성하도록 하고 있습니다.</p>
<p>busybox 이미지를 사용하여 2개의 컨테이너를 생성해 봅시다. 컨테이너를 실행한 후, 컨테이너 내부에서 서로 핑을 시도해 봅시다.</p>
<p>2개의 컨테이너를 생성하고, 각 컨테이너의 IP 주소를 얻기 위해 docker inspect를 사용해 보세요.</p>
<p></p>
<p>아래는 두 컨테이너의 IP 주소가 동일한 네트워크에 있음을 확인할 수 있습니다(기본 브리지 네트워크).</p>
<p>이름과 IP 주소로 서로 핑을 보내 봅시다.</p>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_17.png" alt="image1"></p>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_18.png" alt="image2"></p>
<p></p>
<p>위 스크린샷을 보면 두 컨테이너 모두 서로 통신할 수 있지만 이름으로는 연결할 수 없습니다.</p>
<h2>2. 사용자 정의 브리지 네트워크</h2>
<p>네트워크 생성</p>
<pre><code class="hljs language-js">docker network create blog-network
</code></pre>
<p></p>
<p>새로운 네트워크를 사용하여 이름이 nginx-con인 nginx 컨테이너를 만들어보세요.</p>
<pre><code class="hljs language-bash">docker run -itd --network blog-network --name nginx-con nginx
docker ps
</code></pre>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_19.png" alt="이미지"></p>
<p>도커 컨테이너와 네트워크를 검사해봅시다.</p>
<p></p>
<pre><code class="hljs language-js">도커 네트워크를 검사하는 방법:


![사진](<span class="hljs-regexp">/assets/img</span><span class="hljs-regexp">/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_20.png)

Nginx 컨테이너를 검사하는 방법:


![사진](/</span>assets/img/<span class="hljs-number">2024</span>-<span class="hljs-number">05</span>-<span class="hljs-number">18</span>-<span class="hljs-title class_">Devopszerotohero3EverythingyouneedtoknowaboutDockers</span>_21.<span class="hljs-property">png</span>)

&#x3C;!-- ui-station 사각형 -->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ins</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"adsbygoogle"</span>
<span class="hljs-attr">style</span>=<span class="hljs-string">"display:block"</span>
<span class="hljs-attr">data-ad-client</span>=<span class="hljs-string">"ca-pub-4877378276818686"</span>
<span class="hljs-attr">data-ad-slot</span>=<span class="hljs-string">"7249294152"</span>
<span class="hljs-attr">data-ad-format</span>=<span class="hljs-string">"auto"</span>
<span class="hljs-attr">data-full-width-responsive</span>=<span class="hljs-string">"true"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">ins</span>></span></span>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
(adsbygoogle = <span class="hljs-variable language_">window</span>.<span class="hljs-property">adsbygoogle</span> || []).<span class="hljs-title function_">push</span>({});
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span></span>

이제 호스트 포트를 통해 컨테이너에서 실행 중인 nginx 웹 서버에 액세스하려고 하면 작동하지 않을 것입니다. 여전히 컨테이너에서 실행 중인 웹 서버에 액세스하려면 호스트 포트로의 포트 포워딩을 수행해야 합니다.

그러나 하나가 정리되었습니다 — 이름 해결입니다. 이제 사용자 정의 브리지 네트워크에서 컨테이너를 핑하면 작동해야 합니다.

한 가지 busybox 컨테이너를 만들고 nginx-con 컨테이너를 핑해 보겠습니다.

![이미지](<span class="hljs-regexp">/assets/img</span><span class="hljs-regexp">/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_22.png)

&#x3C;!-- ui-station 사각형 -->
&#x3C;ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-4877378276818686"
data-ad-slot="7249294152"
data-ad-format="auto"
data-full-width-responsive="true">&#x3C;/i</span>ns>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
(adsbygoogle = <span class="hljs-variable language_">window</span>.<span class="hljs-property">adsbygoogle</span> || []).<span class="hljs-title function_">push</span>({});
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span></span>

## <span class="hljs-number">3.</span> 호스트 네트워크

docker run -td --network host --name nginx-server <span class="hljs-attr">nginx</span>:latest
docker ps

![image](<span class="hljs-regexp">/assets/img</span><span class="hljs-regexp">/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_23.png)

이렇게 하면 nginx 컨테이너가 호스트 네트워크에서 실행됩니다.

&#x3C;!-- ui-station 사각형 -->
&#x3C;ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-4877378276818686"
data-ad-slot="7249294152"
data-ad-format="auto"
data-full-width-responsive="true">&#x3C;/i</span>ns>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
(adsbygoogle = <span class="hljs-variable language_">window</span>.<span class="hljs-property">adsbygoogle</span> || []).<span class="hljs-title function_">push</span>({});
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span></span>

만약 로컬 호스트에서 nginx 서버에 접근하려고 하면, 작동해야 합니다.

만약 컨테이너의 <span class="hljs-variable constant_">IP</span> 주소를 확인하려면

docker inspect nginx-server | grep <span class="hljs-title class_">IPAddress</span>

아래 그림을 참고하세요:

![이미지](<span class="hljs-regexp">/assets/img</span><span class="hljs-regexp">/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_24.png)

&#x3C;!-- ui-station 사각형 -->
&#x3C;ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-4877378276818686"
data-ad-slot="7249294152"
data-ad-format="auto"
data-full-width-responsive="true">&#x3C;/i</span>ns>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
(adsbygoogle = <span class="hljs-variable language_">window</span>.<span class="hljs-property">adsbygoogle</span> || []).<span class="hljs-title function_">push</span>({});
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span></span>

뭐라구요? 해당 <span class="hljs-variable constant_">IP</span> 주소가 없나봐요. 호스트 머신의 <span class="hljs-variable constant_">IP</span> 주소를 사용한 모양이에요.

다른 종류의 네트워크에 대해 더 알려드릴게요. 하지만 블로그가 너무 길어지고 있네요.

# 도커 볼륨

도커는 로컬 파일 시스템에서 컨테이너의 모든 콘텐츠, 코드 및 데이터를 분리합니다. 이는 도커 데스크탑에서 컨테이너를 삭제하면 그 안의 모든 콘텐츠가 삭제된다는 뜻이에요.

&#x3C;!-- ui-station 사각형 -->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ins</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"adsbygoogle"</span>
<span class="hljs-attr">style</span>=<span class="hljs-string">"display:block"</span>
<span class="hljs-attr">data-ad-client</span>=<span class="hljs-string">"ca-pub-4877378276818686"</span>
<span class="hljs-attr">data-ad-slot</span>=<span class="hljs-string">"7249294152"</span>
<span class="hljs-attr">data-ad-format</span>=<span class="hljs-string">"auto"</span>
<span class="hljs-attr">data-full-width-responsive</span>=<span class="hljs-string">"true"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">ins</span>></span></span>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
(adsbygoogle = <span class="hljs-variable language_">window</span>.<span class="hljs-property">adsbygoogle</span> || []).<span class="hljs-title function_">push</span>({});
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span></span>

가끔은 컨테이너가 생성한 데이터를 유지하기를 원할 수 있습니다. 이때 볼륨을 사용할 수 있습니다.

## 바인드 마운트

바인드 마운트를 사용하면 호스트 머신의 파일 또는 디렉토리가 컨테이너로 마운트됩니다.

## 도커 볼륨

&#x3C;!-- ui-station 사각형 -->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ins</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"adsbygoogle"</span>
<span class="hljs-attr">style</span>=<span class="hljs-string">"display:block"</span>
<span class="hljs-attr">data-ad-client</span>=<span class="hljs-string">"ca-pub-4877378276818686"</span>
<span class="hljs-attr">data-ad-slot</span>=<span class="hljs-string">"7249294152"</span>
<span class="hljs-attr">data-ad-format</span>=<span class="hljs-string">"auto"</span>
<span class="hljs-attr">data-full-width-responsive</span>=<span class="hljs-string">"true"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">ins</span>></span></span>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
(adsbygoogle = <span class="hljs-variable language_">window</span>.<span class="hljs-property">adsbygoogle</span> || []).<span class="hljs-title function_">push</span>({});
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span></span>

체적은 도커에서 관리하는 로컬 파일 시스템의 위치입니다.

체적은 사용 중인 컨테이너의 크기를 늘리지 않으며, 체적의 내용은 특정 컨테이너의 생명 주기 외부에 존재합니다.

# 도커에서 체적 사용하는 방법

도커에서 체적을 사용하는 방법에는 --mount 및 -v (또는 --volume ) 두 가지가 있습니다. -v 구문은 모든 옵션을 하나의 필드에 결합하며, --mount 구문은 옵션을 분리합니다.

&#x3C;!-- ui-station 사각형 -->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ins</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"adsbygoogle"</span>
<span class="hljs-attr">style</span>=<span class="hljs-string">"display:block"</span>
<span class="hljs-attr">data-ad-client</span>=<span class="hljs-string">"ca-pub-4877378276818686"</span>
<span class="hljs-attr">data-ad-slot</span>=<span class="hljs-string">"7249294152"</span>
<span class="hljs-attr">data-ad-format</span>=<span class="hljs-string">"auto"</span>
<span class="hljs-attr">data-full-width-responsive</span>=<span class="hljs-string">"true"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">ins</span>></span></span>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
(adsbygoogle = <span class="hljs-variable language_">window</span>.<span class="hljs-property">adsbygoogle</span> || []).<span class="hljs-title function_">push</span>({});
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span></span>

- -v 또는 --<span class="hljs-attr">volume</span>: 콜론 문자(:)로 구분된 세 개의 필드로 구성됩니다.

   - 첫 번째 필드는 바인드 마운트의 경우 호스트 머신의 파일 또는 디렉터리 경로이거나 볼륨의 이름입니다.
   - 두 번째 필드는 컨테이너 내에서 파일 또는 디렉터리가 마운트된 경로입니다.
   - 세 번째 필드는 선택 사항입니다. ro, z, Z와 같은 옵션들의 쉼표로 구분된 목록입니다.

--<span class="hljs-attr">mount</span>: 쉼표로 구분된 여러 개의 키-값 페어로 구성됩니다.

   - 마운트의 유형(bind, volume 또는 tmpfs).
   - 마운트의 소스.
   - 목적지는 파일 또는 디렉터리가 컨테이너 내에서 마운트된 경로로 값을 취합니다.

&#x3C;!-- ui-station 사각형 -->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ins</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"adsbygoogle"</span>
<span class="hljs-attr">style</span>=<span class="hljs-string">"display:block"</span>
<span class="hljs-attr">data-ad-client</span>=<span class="hljs-string">"ca-pub-4877378276818686"</span>
<span class="hljs-attr">data-ad-slot</span>=<span class="hljs-string">"7249294152"</span>
<span class="hljs-attr">data-ad-format</span>=<span class="hljs-string">"auto"</span>
<span class="hljs-attr">data-full-width-responsive</span>=<span class="hljs-string">"true"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">ins</span>></span></span>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
(adsbygoogle = <span class="hljs-variable language_">window</span>.<span class="hljs-property">adsbygoogle</span> || []).<span class="hljs-title function_">push</span>({});
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span></span>

# 예시: <span class="hljs-title class_">Docker</span> 컨테이너와 바인드 마운트

우리는 호스트 머신의 동일한 디렉토리/폴더를 <span class="hljs-number">4</span>개의 컨테이너에 마운트했습니다.

mkdir docker-bind-mount
docker run -t -d  -v docker-bind-<span class="hljs-attr">mount</span>:<span class="hljs-regexp">/app/</span>log  --name captain-america busybox
docker run -t -d  -v docker-bind-<span class="hljs-attr">mount</span>:<span class="hljs-regexp">/app/</span>log  --name thor busybox
docker run -t -d  -v docker-bind-<span class="hljs-attr">mount</span>:<span class="hljs-regexp">/app/</span>log  --name hulk  busybox
docker run -t -d  -v docker-bind-<span class="hljs-attr">mount</span>:<span class="hljs-regexp">/app/</span>log  --name iron-man  alpine

# --mount 옵션을 사용한 명령어
docker run -t -d --mount type=bind,source=docker-bind-mount,target=<span class="hljs-regexp">/app/</span>log \
  --name captain-america busybox

&#x3C;img src=<span class="hljs-string">"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_25.png"</span> />

&#x3C;!-- ui-station 사각형 -->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ins</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"adsbygoogle"</span>
<span class="hljs-attr">style</span>=<span class="hljs-string">"display:block"</span>
<span class="hljs-attr">data-ad-client</span>=<span class="hljs-string">"ca-pub-4877378276818686"</span>
<span class="hljs-attr">data-ad-slot</span>=<span class="hljs-string">"7249294152"</span>
<span class="hljs-attr">data-ad-format</span>=<span class="hljs-string">"auto"</span>
<span class="hljs-attr">data-full-width-responsive</span>=<span class="hljs-string">"true"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">ins</span>></span></span>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
(adsbygoogle = <span class="hljs-variable language_">window</span>.<span class="hljs-property">adsbygoogle</span> || []).<span class="hljs-title function_">push</span>({});
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span></span>


![image](<span class="hljs-regexp">/assets/img</span><span class="hljs-regexp">/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_26.png)

각 컨테이너 안에 저장된 로그를 작성해봅시다. 바인드-마운트가 연결된 경로인 /</span>app/log에

![image](<span class="hljs-regexp">/assets/img</span><span class="hljs-regexp">/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_27.png)

자세히 살펴보면, 1번째와 2번째 컨테이너에서 생성한 파일들이 3번째 컨테이너에서 보이며, 1번째에서 3번째 컨테이너에서 생성한 파일이 4번째(Captain-America) 컨테이너에서도 보인다는 점을 알 수 있습니다.


&#x3C;!-- ui-station 사각형 -->
&#x3C;ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-4877378276818686"
data-ad-slot="7249294152"
data-ad-format="auto"
data-full-width-responsive="true">&#x3C;/i</span>ns>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
(adsbygoogle = <span class="hljs-variable language_">window</span>.<span class="hljs-property">adsbygoogle</span> || []).<span class="hljs-title function_">push</span>({});
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span></span>

일반적으로 도커 데이터 파일에는 다른 컨테이너의 내용이 포함되어 있습니다.

이 예시는 우리가 어떻게 간단하게 여러 컨테이너 간에 파일/로그를 공유할 수 있는지 보여줍니다.

하지만, 한 가지 주의할 점이 있습니다. 만약 우리가 로컬 호스트로 이동하여 모든 컨테이너에 바인드 마운트한 디렉터리를 목록으로 보면 아무것도 찾을 수 없을 것입니다.

이것은 즉, 도커가 바인드 마운트한 데이터를 다른 컨테이너와 공유할 수 있었지만 데이터가 로컬 호스트에서는 보이지 않는다는 것을 의미합니다.

&#x3C;!-- ui-station 사각형 -->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ins</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"adsbygoogle"</span>
<span class="hljs-attr">style</span>=<span class="hljs-string">"display:block"</span>
<span class="hljs-attr">data-ad-client</span>=<span class="hljs-string">"ca-pub-4877378276818686"</span>
<span class="hljs-attr">data-ad-slot</span>=<span class="hljs-string">"7249294152"</span>
<span class="hljs-attr">data-ad-format</span>=<span class="hljs-string">"auto"</span>
<span class="hljs-attr">data-full-width-responsive</span>=<span class="hljs-string">"true"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">ins</span>></span></span>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
(adsbygoogle = <span class="hljs-variable language_">window</span>.<span class="hljs-property">adsbygoogle</span> || []).<span class="hljs-title function_">push</span>({});
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span></span>

이 파일들은 바인드 마운트 시 도커 컨테이너 간에 저장되고 공유됩니다.

![<span class="hljs-title class_">Image</span>](<span class="hljs-regexp">/assets/img</span><span class="hljs-regexp">/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_28.png)

도커 컨테이너 중 하나를 검사하고 마운트 섹션으로 이동하면 마운트에 관련된 세부 정보를 볼 수 있습니다.

참고: 도커 inspect 명령은 도커 컨테이너에 대해 더 많은 정보를 제공합니다.

&#x3C;!-- ui-station 사각형 -->
&#x3C;ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-4877378276818686"
data-ad-slot="7249294152"
data-ad-format="auto"
data-full-width-responsive="true">&#x3C;/i</span>ns>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
(adsbygoogle = <span class="hljs-variable language_">window</span>.<span class="hljs-property">adsbygoogle</span> || []).<span class="hljs-title function_">push</span>({});
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span></span>

# 도커 컨테이너 조회 명령어: docker inspect &#x3C;컨테이너 이름 또는 컨테이너 <span class="hljs-variable constant_">ID</span>>
docker inspect hulk

![도커 컨테이너 및 볼륨에 대한 자세한 정보](<span class="hljs-regexp">/assets/img</span><span class="hljs-regexp">/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_29.png)

# 예제: 볼륨을 사용하는 Docker 컨테이너

볼륨 생성하기


&#x3C;!-- ui-station 사각형 -->
&#x3C;ins class="adsbygoogle"
style="display:block"
data-ad-client="ca-pub-4877378276818686"
data-ad-slot="7249294152"
data-ad-format="auto"
data-full-width-responsive="true">&#x3C;/i</span>ns>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
(adsbygoogle = <span class="hljs-variable language_">window</span>.<span class="hljs-property">adsbygoogle</span> || []).<span class="hljs-title function_">push</span>({});
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span></span>

</code></pre>
<h1>도커 볼륨 생성하기</h1>
<p>도커 볼륨 생성 thor-vol
도커 볼륨 생성 hulk-vol</p>
<h1>도커 볼륨 목록 확인</h1>
<p>도커 볼륨 목록 보기</p>
<h1>도커 볼륨</h1>
<h1>명령어:</h1>
<h1>create 볼륨 생성</h1>
<h1>inspect 한 개 이상의 볼륨에 대한 자세한 정보 표시</h1>
<h1>ls 볼륨 목록 보기</h1>
<h1>prune 사용하지 않는 로컬 볼륨 제거</h1>
<h1>rm 한 개 이상의 볼륨 제거</h1>
<p>볼륨 검사하기</p>
<p>도커 볼륨 inspect thor-vol</p>
<p></p>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_31.png" alt="이미지"></p>
<p>새 컨테이너를 생성하는 동안 이 볼륨을 마운트해 봅시다. 이번에는 — — mount 옵션을 사용할 거에요.</p>
<pre><code class="hljs language-js">docker run -d \
  --name thor-container \
  --mount type=volume,source=thor-vol,target=/app \
  <span class="hljs-attr">nginx</span>:latest

# 볼륨을 source로 명시할 때 type의 기본 값은 volume입니다.
docker run -d \
  --name hulk-container \
  --mount source=thor-vol,target=/app \
  <span class="hljs-attr">nginx</span>:latest
</code></pre>
<pre><code class="hljs language-js">docker inspect hulk-container
</code></pre>
<p></p>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_32.png" alt="Image 1"></p>
<p>Let’s create some logs in both containers and see if the files/logs are visible to both containers.</p>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_33.png" alt="Image 2"></p>
<p>As you can see from the above screenshot, we can share data/logs across containers.</p>
<p></p>
<h1>도커 볼륨 삭제</h1>
<pre><code class="hljs language-js"># 도커 볼륨을 제거하기
# 한 번에 하나 이상의 볼륨을 삭제할 수 있습니다
docker volume rm &#x3C;volume-names>
</code></pre>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_34.png" alt="이미지"></p>
<h1>도커 이미지 빌드</h1>
<p></p>
<p>이제 기본적인 도커 개념을 살펴 보았으니, 실습 예제를 해 봅시다.</p>
<h2>여기서 무엇을 할 건가요?</h2>
<p>도커 이미지를 만들어 기본적인 Flask 애플리케이션을 내장시킬 거에요. 그리고 만든 도커 이미지를 도커 허브에 푸시할 거에요.</p>
<p>한 폴더를 만들고 app.py, requirements.txt, 그리고 Dockerfile 이라는 3개의 파일을 생성해 볼까요?</p>
<p></p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Dockerfile</span>, app.<span class="hljs-property">py</span>, requirements.<span class="hljs-property">txt</span> 파일들을 만들었습니다.

&#x3C;img src=<span class="hljs-string">"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_35.png"</span> />

각 파일에 아래 코드를 붙여 넣어주세요.

app.<span class="hljs-property">py</span>
</code></pre>
<p></p>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask

app = Flask(__name__)

<span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">'/'</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_docker</span>():
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello, Docker!'</span>

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    app.run(debug=<span class="hljs-literal">True</span>, host=<span class="hljs-string">'0.0.0.0'</span>)
</code></pre>
<p>requirements.txt</p>
<pre><code class="hljs language-python">Flask
</code></pre>
<p>이제 Docker 이미지를 빌드하기 위한 Dockerfile을 생성할 것입니다.</p>
<p></p>
<p>Dockerfile</p>
<pre><code class="hljs language-js"># 부모 이미지로 공식 <span class="hljs-title class_">Python</span> 실행 환경 사용
<span class="hljs-variable constant_">FROM</span> <span class="hljs-attr">python</span>:<span class="hljs-number">3.11</span>

# 작업 디렉토리를 /app으로 설정
<span class="hljs-variable constant_">WORKDIR</span> /app

# <span class="hljs-title class_">Python</span> 종속성 파일을 컨테이너의 /app 디렉토리로 복사
<span class="hljs-variable constant_">COPY</span> requirements.<span class="hljs-property">txt</span> /app

# requirements.<span class="hljs-property">txt</span>에 명시된 필요한 패키지 설치
<span class="hljs-variable constant_">RUN</span> pip install --no-cache-dir -r requirements.<span class="hljs-property">txt</span>

# flask 앱 파일을 컨테이너의 /app 디렉토리로 복사
<span class="hljs-variable constant_">COPY</span> app.<span class="hljs-property">py</span> /app

# 포트 <span class="hljs-number">5000</span>을 이 컨테이너 외부에 노출
<span class="hljs-variable constant_">EXPOSE</span> <span class="hljs-number">5000</span>

# 컨테이너가 시작될 때 app.<span class="hljs-property">py</span> 실행
<span class="hljs-variable constant_">CMD</span> [<span class="hljs-string">"python"</span>, <span class="hljs-string">"app.py"</span>]
</code></pre>
<p>도커 이미지 생성</p>
<pre><code class="hljs language-js"># docker build -t &#x3C;이미지-이름> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Dockerfile</span> <span class="hljs-attr">경로</span>></span>
docker build -t flask-image .
</span></code></pre>
<p></p>
<p>아래는 Markdown 형식으로 변경되었습니다:</p>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_36.png" alt="Docker Image"></p>
<p>Docker Hub repository를 만들어보겠습니다. 아직 계정이 없다면 만드세요 - livingdevopswithakhilesh라는 이름으로 만들었어요.</p>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_37.png" alt="Image 태깅"></p>
<p></p>
<h1>docker tag  /:</h1>
<p>docker tag flask-image livingdevopswithakhilesh/docker-demo-docker:1.0</p>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_38.png" alt="Image"></p>
<p>도커 허브에 이미지를 푸시하세요. 이미지를 푸시하기 전에 docker login을 실행해주세요.</p>
<pre><code class="hljs language-sh">docker login
<span class="hljs-comment"># docker push &#x3C;tagged-image></span>
docker push livingdevopswithakhilesh/docker-demo-docker:1.0
</code></pre>
<p></p>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_39.png" alt="Image"></p>
<p>로컬 이미지를 삭제하고 Docker Hub에서 이미지를 가져와서 해당 이미지를 사용하여 컨테이너를 실행합니다.</p>
<pre><code class="hljs language-js">docker pull livingdevopswithakhilesh/docker-demo-<span class="hljs-attr">docker</span>:<span class="hljs-number">1.0</span>
</code></pre>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_40.png" alt="Image"></p>
<p></p>
<pre><code class="hljs language-js">docker run -td -p <span class="hljs-number">8080</span>:<span class="hljs-number">5000</span> --name flask livingdevopswithakhilesh/docker-demo-<span class="hljs-attr">docker</span>:<span class="hljs-number">1.0</span>
</code></pre>
<p><img src="/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_41.png" alt="Image"></p>
<p>이 블로그는 여기까지입니다. 다음 블로그에서 뵙겠습니다. 저와 함께 더 유용한 콘텐츠를 확인하려면 팔로우해주세요.</p>
<p>Linkedin에서 연락하기: <a href="https://www.linkedin.com/in/akhilesh-mishra-0ab886124/" rel="nofollow" target="_blank">https://www.linkedin.com/in/akhilesh-mishra-0ab886124/</a></p>
<p></p>
<p>시리즈 Devops Zero to Hero의 세 번째 블로그였습니다. 첫 두 개 블로그를 확인해보세요 —</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"데브옵스 제로 투 히어로 3  도커에 대해 알아야 할 모든 것","description":"","date":"2024-05-18 16:42","slug":"2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers","content":"\n## 데브옵스 업무 흐름에서 도커 사용을 시작하는 완벽한 가이드\n\n### 이 블로그 포스트에서 무엇을 기대해야 하는가?\n\n### 왜 Docker를 사용해야 하는가?\n\n20~30년 전으로 돌아가면, 하드웨어와 설치된 운영 체제(커널 및 UI)가 있었습니다. 어플리케이션을 실행하기 위해서 코드를 컴파일하고 모든 앱 의존성을 정렬해야 했습니다. 다른 어플리케이션이나 어플리케이션 작업량의 증가를 수용하기 위해 새 하드웨어를 구매하고 설치 및 구성해야 했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가상화는 하드웨어와 운영 체제 사이에 추가 계층인 하이퍼바이저라는 것을 추가했습니다. 이를 통해 사용자들은 독립된 여러 애플리케이션을 실행하여 가상 머신을 자체 운영 체제와 함께 실행할 수 있었습니다.\n\n그럼에도 불구하고, 우리는 모든 가상 머신에 소프트웨어를 설치하고 종속성을 설정해주어야 했습니다. 애플리케이션이 휴대 가능하지 않았습니다. 일부 기기에서는 작동하지만 다른 기기에서는 작동하지 않았습니다.\n\n![이미지](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_0.png)\n\n# 도커란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커는 마이크로서비스 기반 응용 프로그램 개발이 가능하도록 함으로써 소프트웨어 빌드 방법을 혁신했습니다.\n\n# 도커는 어떻게 작동하나요?\n\n도커 엔진은 호스트 운영 체제 위에서 실행됩니다. 도커 엔진에는 호스트 시스템에서 도커 컨테이너를 관리하는 서버 프로세스(dockerd)가 포함되어 있습니다. 도커 컨테이너는 응용 프로그램과 그 의존성을 격리시켜 다른 환경에서도 일관되게 실행할 수 있도록 설계되었습니다.\n\n![이미지](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커를 사용하려면 Dockerfile, Docker 이미지, Docker 컨테이너라는 세 가지 개념을 이해해야 합니다.\n\n## Docker 파일(Dockerfile)이란?\n\n## Docker 이미지란 무엇인가요?\n\nDocker 이미지에는 컨테이너 내에서 코드를 실행하는 데 필요한 모든 종속성이 포함되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Docker 컨테이너란 무엇인가요?\n\n# Docker로 시작하기\n\n## 사전 요구 사항\n\nDocker는 로컬 머신 또는 클라우드 VM에 설치되어 있어야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLinux:\n\n로컬 노트북, 가상 머신 또는 클라우드 VM에서 Linux를 실행 중이라면 패키지 관리자를 사용하여 Docker를 설치할 수 있습니다. 이 블로그 포스트의 지시사항을 따라주세요.\n\nMac 및 Windows:\n\n로컬 머신에서 Docker를 실행할 수 있게 해주는 Docker Desktop을 설치할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커를 시작하는 것은 쉬운 일이에요. 아래 명령을 실행하기만 하면 돼요\n\n```js\n도커 런 -d -t --name Thor alpine\n도커 런 -d -t busybox\n```\n\n이 명령은 도커 이미지 alpine과 busybox로부터 2개의 컨테이너를 생성할 거에요. 이 둘은 도커 허브에 저장된 미니멀리스트이면서 퍼블릭인 리눅스 도커 이미지에요.\n\n- -d 옵션은 컨테이너를 백그라운드에서 실행(detach mode)\n- -t 옵션은 tty 터미널을 연결해 줘요.\n- --name 옵션은 컨테이너에 이름을 부여할 수 있어요. 제공하지 않으면 컨테이너는 랜덤 이름을 받게 돼요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_2.png\" /\u003e\n\n참고: 위에 언급된 이미지로 처음 docker run을 실행하면 도커가 로컬 머신에서 이미지를 다운로드(풀)해야 합니다.\n\n## 로컬 머신에서 실행 중인/중지된 컨테이너 목록\n\n```js\ndocker ps # 실행 중인 컨테이너 확인\ndocker ps -a # 모든 컨테이너 목록\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_3.png\" /\u003e\n\n## 로컬 머신에 있는 도커 이미지 목록\n\n```js\ndocker image ls\n```\n\n\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_4.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLinux 기반 도커 컨테이너에 사용된 이미지 크기를 확인할 수 있어요. 우분투, 아마존 리눅스, CentOS 등과 같은 일반적인 Linux 기반 머신과 비교하면 작아요.\n\n실행 중인 컨테이너와 상호 작용하는 방법은 명령을 전달하거나 대화형 세션을 여는 두 가지 방법이 있어요.\n\n```js\n# docker exec -it \u003c컨테이너 ID\u003e \u003c셸\u003e\n```\n\n- docker exec를 사용하면 실행 중인 도커 컨테이너 내부로 진입할 수 있어요.\n- --it는 도커와 대화형 세션을 열어줘요.\n- 셸은 sh, bash, zsh 등을 사용할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n컨테이너 정보를 얻기 위해 몇 가지 명령을 실행해 봅시다.\n\n```js\ndocker exec -t Thor ls ; ps\n# -t는 tty 세션을 열기 위한 옵션입니다.\n# Thor는 컨테이너 이름입니다.\n# ls ; ps는 ls와 ps 두 개의 명령을 실행합니다.\n\ndocker exec -t 8ad10d1d0660 free -m\n# 8ad10d1d0660은 컨테이너 ID이며, free -m은 메모리 사용량을 확인하는 명령입니다.\n```\n\n![이미지](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_5.png)\n\n이제 -it 옵션을 사용하여 컨테이너와 대화형 쉘 세션을 열어보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n도커 exec -it 16fb1c59fbea sh\n# 세션을 종료하려면 \"exit\"을 입력하세요\n```\n\n![이미지](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_6.png)\n\n# 컨테이너 시작, 중지, 삭제\n\n```js\n# 실행 중인 컨테이너를 중지하는 방법\ndocker stop \u003c컨테이너 이름 또는 ID\u003e\n\n# 중지된 컨테이너를 시작하는 방법\ndocker start \u003c컨테이너 이름 또는 ID\u003e\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_7.png)\n\n```js\n# 실행 중인 컨테이너를 종료한 후에 삭제하려면 다음과 같이 명령을 사용합니다.\n# docker stop \u003c컨테이너 이름 또는 ID\u003e\n# docker rm \u003c컨테이너 이름 또는 ID\u003e\ndocker stop 16fb1c59fbea\ndocker rm 16fb1c59fbea\n\n# 아니면 -f 플래그를 사용하여 강제로 컨테이너를 삭제합니다.\ndocker rm -f Thor\n```\n\n![Image](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_8.png)\n\n# 도커 이미지 빌드하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Docker 네트워킹\n\n도커는 다양한 종류의 네트워크를 제공합니다.\n\n## 1. 기본 브릿지\n\n만약 도커허브에서 nginx 이미지를 사용하여 nginx 컨테이너를 실행 중이고 웹 서버에 액세스하려고 한다면요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![screenshot](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_9.png)\n\n스크린샷을 통해 Nginx 웹 서버가 80번 포트에서 실행 중임을 확인할 수 있습니다. NGINX 컨테이너에 로그인하여 curl 127.0.0.1:80을 실행하면 웹 서버에서 HTML 응답을 반환합니다.\n\n- 127.0.0.1은 루프백 주소로 현재 장치(로컬호스트)를 항상 가리킵니다.\n\n![screenshot](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_10.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위에서 본 것처럼, 컨테이너 내부의 웹 서버가 우리가 기대한 대로 작동했습니다.\n\n이제 호스트 머신 (랩톱/가상 머신)에서 웹 서버에 연결해 보겠습니다.\n\n![이미지](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_11.png)\n\n컨테이너에서 실행 중인 nginx 웹 서버에 연결할 수 없었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n네트워크 깊이 파고들기\n\n도커 컨테이너를 검사하려면 docker inspect 명령을 실행하고 맨 아래로 스크롤하면 도커가 브릿지 네트워크를 사용하고 네트워크에 대한 자세한 내용을 볼 수 있습니다.\n\n```js\ndocker inspect nginx-container\n```\n\n\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_12.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n도커 네트워크 목록\n```\n\n\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_13.png\" /\u003e\n\n네트워크를 검사하면 기본 브릿지 네트워크를 사용하는 컨테이너를 찾을 수 있습니다.\n\n```js\n도커 네트워크 검사 브릿지\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_14.png\" /\u003e\n\n## 포트 전달\n\n```js\n도커 실행 -d -p \u003c호스트 포트\u003e:\u003c컨테이너 포트\u003e --name \u003c컨테이너 이름\u003e 이미지\n\n# 포트 전달 -\u003e 컨테이너의 포트 80을 호스트 머신의 포트 5000으로 전달\n도커 실행 -t -d -p 5000:80 --name nginx-container nginx:latest\n```\n\n\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_15.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_16.png)\n\n도커는 기본 네트워크를 사용하지 말라고 권장하고 대신에 우리만의 네트워크를 생성하도록 하고 있습니다.\n\nbusybox 이미지를 사용하여 2개의 컨테이너를 생성해 봅시다. 컨테이너를 실행한 후, 컨테이너 내부에서 서로 핑을 시도해 봅시다.\n\n2개의 컨테이너를 생성하고, 각 컨테이너의 IP 주소를 얻기 위해 docker inspect를 사용해 보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 두 컨테이너의 IP 주소가 동일한 네트워크에 있음을 확인할 수 있습니다(기본 브리지 네트워크).\n\n이름과 IP 주소로 서로 핑을 보내 봅시다.\n\n![image1](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_17.png)\n\n![image2](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_18.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 스크린샷을 보면 두 컨테이너 모두 서로 통신할 수 있지만 이름으로는 연결할 수 없습니다.\n\n## 2. 사용자 정의 브리지 네트워크\n\n네트워크 생성\n\n```js\ndocker network create blog-network\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n새로운 네트워크를 사용하여 이름이 nginx-con인 nginx 컨테이너를 만들어보세요.\n\n```bash\ndocker run -itd --network blog-network --name nginx-con nginx\ndocker ps\n```\n\n![이미지](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_19.png)\n\n도커 컨테이너와 네트워크를 검사해봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n도커 네트워크를 검사하는 방법:\n\n\n![사진](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_20.png)\n\nNginx 컨테이너를 검사하는 방법:\n\n\n![사진](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_21.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 호스트 포트를 통해 컨테이너에서 실행 중인 nginx 웹 서버에 액세스하려고 하면 작동하지 않을 것입니다. 여전히 컨테이너에서 실행 중인 웹 서버에 액세스하려면 호스트 포트로의 포트 포워딩을 수행해야 합니다.\n\n그러나 하나가 정리되었습니다 — 이름 해결입니다. 이제 사용자 정의 브리지 네트워크에서 컨테이너를 핑하면 작동해야 합니다.\n\n한 가지 busybox 컨테이너를 만들고 nginx-con 컨테이너를 핑해 보겠습니다.\n\n![이미지](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_22.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 3. 호스트 네트워크\n\ndocker run -td --network host --name nginx-server nginx:latest\ndocker ps\n\n![image](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_23.png)\n\n이렇게 하면 nginx 컨테이너가 호스트 네트워크에서 실행됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 로컬 호스트에서 nginx 서버에 접근하려고 하면, 작동해야 합니다.\n\n만약 컨테이너의 IP 주소를 확인하려면\n\ndocker inspect nginx-server | grep IPAddress\n\n아래 그림을 참고하세요:\n\n![이미지](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_24.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n뭐라구요? 해당 IP 주소가 없나봐요. 호스트 머신의 IP 주소를 사용한 모양이에요.\n\n다른 종류의 네트워크에 대해 더 알려드릴게요. 하지만 블로그가 너무 길어지고 있네요.\n\n# 도커 볼륨\n\n도커는 로컬 파일 시스템에서 컨테이너의 모든 콘텐츠, 코드 및 데이터를 분리합니다. 이는 도커 데스크탑에서 컨테이너를 삭제하면 그 안의 모든 콘텐츠가 삭제된다는 뜻이에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가끔은 컨테이너가 생성한 데이터를 유지하기를 원할 수 있습니다. 이때 볼륨을 사용할 수 있습니다.\n\n## 바인드 마운트\n\n바인드 마운트를 사용하면 호스트 머신의 파일 또는 디렉토리가 컨테이너로 마운트됩니다.\n\n## 도커 볼륨\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n체적은 도커에서 관리하는 로컬 파일 시스템의 위치입니다.\n\n체적은 사용 중인 컨테이너의 크기를 늘리지 않으며, 체적의 내용은 특정 컨테이너의 생명 주기 외부에 존재합니다.\n\n# 도커에서 체적 사용하는 방법\n\n도커에서 체적을 사용하는 방법에는 --mount 및 -v (또는 --volume ) 두 가지가 있습니다. -v 구문은 모든 옵션을 하나의 필드에 결합하며, --mount 구문은 옵션을 분리합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- -v 또는 --volume: 콜론 문자(:)로 구분된 세 개의 필드로 구성됩니다.\n\n   - 첫 번째 필드는 바인드 마운트의 경우 호스트 머신의 파일 또는 디렉터리 경로이거나 볼륨의 이름입니다.\n   - 두 번째 필드는 컨테이너 내에서 파일 또는 디렉터리가 마운트된 경로입니다.\n   - 세 번째 필드는 선택 사항입니다. ro, z, Z와 같은 옵션들의 쉼표로 구분된 목록입니다.\n\n--mount: 쉼표로 구분된 여러 개의 키-값 페어로 구성됩니다.\n\n   - 마운트의 유형(bind, volume 또는 tmpfs).\n   - 마운트의 소스.\n   - 목적지는 파일 또는 디렉터리가 컨테이너 내에서 마운트된 경로로 값을 취합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 예시: Docker 컨테이너와 바인드 마운트\n\n우리는 호스트 머신의 동일한 디렉토리/폴더를 4개의 컨테이너에 마운트했습니다.\n\nmkdir docker-bind-mount\ndocker run -t -d  -v docker-bind-mount:/app/log  --name captain-america busybox\ndocker run -t -d  -v docker-bind-mount:/app/log  --name thor busybox\ndocker run -t -d  -v docker-bind-mount:/app/log  --name hulk  busybox\ndocker run -t -d  -v docker-bind-mount:/app/log  --name iron-man  alpine\n\n# --mount 옵션을 사용한 명령어\ndocker run -t -d --mount type=bind,source=docker-bind-mount,target=/app/log \\\n  --name captain-america busybox\n\n\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_25.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_26.png)\n\n각 컨테이너 안에 저장된 로그를 작성해봅시다. 바인드-마운트가 연결된 경로인 /app/log에\n\n![image](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_27.png)\n\n자세히 살펴보면, 1번째와 2번째 컨테이너에서 생성한 파일들이 3번째 컨테이너에서 보이며, 1번째에서 3번째 컨테이너에서 생성한 파일이 4번째(Captain-America) 컨테이너에서도 보인다는 점을 알 수 있습니다.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적으로 도커 데이터 파일에는 다른 컨테이너의 내용이 포함되어 있습니다.\n\n이 예시는 우리가 어떻게 간단하게 여러 컨테이너 간에 파일/로그를 공유할 수 있는지 보여줍니다.\n\n하지만, 한 가지 주의할 점이 있습니다. 만약 우리가 로컬 호스트로 이동하여 모든 컨테이너에 바인드 마운트한 디렉터리를 목록으로 보면 아무것도 찾을 수 없을 것입니다.\n\n이것은 즉, 도커가 바인드 마운트한 데이터를 다른 컨테이너와 공유할 수 있었지만 데이터가 로컬 호스트에서는 보이지 않는다는 것을 의미합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 파일들은 바인드 마운트 시 도커 컨테이너 간에 저장되고 공유됩니다.\n\n![Image](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_28.png)\n\n도커 컨테이너 중 하나를 검사하고 마운트 섹션으로 이동하면 마운트에 관련된 세부 정보를 볼 수 있습니다.\n\n참고: 도커 inspect 명령은 도커 컨테이너에 대해 더 많은 정보를 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 도커 컨테이너 조회 명령어: docker inspect \u003c컨테이너 이름 또는 컨테이너 ID\u003e\ndocker inspect hulk\n\n![도커 컨테이너 및 볼륨에 대한 자세한 정보](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_29.png)\n\n# 예제: 볼륨을 사용하는 Docker 컨테이너\n\n볼륨 생성하기\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```\n\n# 도커 볼륨 생성하기\n\n도커 볼륨 생성 thor-vol\n도커 볼륨 생성 hulk-vol\n\n# 도커 볼륨 목록 확인\n\n도커 볼륨 목록 보기\n\n# 도커 볼륨\n\n# 명령어:\n\n# create 볼륨 생성\n\n# inspect 한 개 이상의 볼륨에 대한 자세한 정보 표시\n\n# ls 볼륨 목록 보기\n\n# prune 사용하지 않는 로컬 볼륨 제거\n\n# rm 한 개 이상의 볼륨 제거\n\n\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_30.png\" /\u003e\n\n볼륨 검사하기\n\n도커 볼륨 inspect thor-vol\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_31.png)\n\n새 컨테이너를 생성하는 동안 이 볼륨을 마운트해 봅시다. 이번에는 — — mount 옵션을 사용할 거에요.\n\n```js\ndocker run -d \\\n  --name thor-container \\\n  --mount type=volume,source=thor-vol,target=/app \\\n  nginx:latest\n\n# 볼륨을 source로 명시할 때 type의 기본 값은 volume입니다.\ndocker run -d \\\n  --name hulk-container \\\n  --mount source=thor-vol,target=/app \\\n  nginx:latest\n```\n\n```js\ndocker inspect hulk-container\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image 1](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_32.png)\n\nLet’s create some logs in both containers and see if the files/logs are visible to both containers.\n\n![Image 2](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_33.png)\n\nAs you can see from the above screenshot, we can share data/logs across containers.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 도커 볼륨 삭제\n\n```js\n# 도커 볼륨을 제거하기\n# 한 번에 하나 이상의 볼륨을 삭제할 수 있습니다\ndocker volume rm \u003cvolume-names\u003e\n```\n\n![이미지](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_34.png)\n\n# 도커 이미지 빌드\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 기본적인 도커 개념을 살펴 보았으니, 실습 예제를 해 봅시다.\n\n## 여기서 무엇을 할 건가요?\n\n도커 이미지를 만들어 기본적인 Flask 애플리케이션을 내장시킬 거에요. 그리고 만든 도커 이미지를 도커 허브에 푸시할 거에요.\n\n한 폴더를 만들고 app.py, requirements.txt, 그리고 Dockerfile 이라는 3개의 파일을 생성해 볼까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nDockerfile, app.py, requirements.txt 파일들을 만들었습니다.\n\n\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_35.png\" /\u003e\n\n각 파일에 아래 코드를 붙여 넣어주세요.\n\napp.py\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_docker():\n    return 'Hello, Docker!'\n\nif __name__ == '__main__':\n    app.run(debug=True, host='0.0.0.0')\n```\n\nrequirements.txt\n\n```python\nFlask\n```\n\n이제 Docker 이미지를 빌드하기 위한 Dockerfile을 생성할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDockerfile\n\n```js\n# 부모 이미지로 공식 Python 실행 환경 사용\nFROM python:3.11\n\n# 작업 디렉토리를 /app으로 설정\nWORKDIR /app\n\n# Python 종속성 파일을 컨테이너의 /app 디렉토리로 복사\nCOPY requirements.txt /app\n\n# requirements.txt에 명시된 필요한 패키지 설치\nRUN pip install --no-cache-dir -r requirements.txt\n\n# flask 앱 파일을 컨테이너의 /app 디렉토리로 복사\nCOPY app.py /app\n\n# 포트 5000을 이 컨테이너 외부에 노출\nEXPOSE 5000\n\n# 컨테이너가 시작될 때 app.py 실행\nCMD [\"python\", \"app.py\"]\n```\n\n도커 이미지 생성\n\n```js\n# docker build -t \u003c이미지-이름\u003e \u003cDockerfile 경로\u003e\ndocker build -t flask-image .\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Markdown 형식으로 변경되었습니다:\n\n![Docker Image](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_36.png)\n\nDocker Hub repository를 만들어보겠습니다. 아직 계정이 없다면 만드세요 - livingdevopswithakhilesh라는 이름으로 만들었어요.\n\n![Image 태깅](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_37.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# docker tag \u003clocal image\u003e \u003cdocker hub username\u003e/\u003crepository name\u003e:\u003ctag\u003e\n\ndocker tag flask-image livingdevopswithakhilesh/docker-demo-docker:1.0\n\n![Image](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_38.png)\n\n도커 허브에 이미지를 푸시하세요. 이미지를 푸시하기 전에 docker login을 실행해주세요.\n\n```sh\ndocker login\n# docker push \u003ctagged-image\u003e\ndocker push livingdevopswithakhilesh/docker-demo-docker:1.0\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_39.png)\n\n로컬 이미지를 삭제하고 Docker Hub에서 이미지를 가져와서 해당 이미지를 사용하여 컨테이너를 실행합니다.\n\n```js\ndocker pull livingdevopswithakhilesh/docker-demo-docker:1.0\n```\n\n![Image](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_40.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndocker run -td -p 8080:5000 --name flask livingdevopswithakhilesh/docker-demo-docker:1.0\n```\n\n![Image](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_41.png)\n\n이 블로그는 여기까지입니다. 다음 블로그에서 뵙겠습니다. 저와 함께 더 유용한 콘텐츠를 확인하려면 팔로우해주세요.\n\nLinkedin에서 연락하기: [https://www.linkedin.com/in/akhilesh-mishra-0ab886124/](https://www.linkedin.com/in/akhilesh-mishra-0ab886124/)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n시리즈 Devops Zero to Hero의 세 번째 블로그였습니다. 첫 두 개 블로그를 확인해보세요 —\n","ogImage":{"url":"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_0.png"},"coverImage":"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_0.png","tag":["Tech"],"readingTime":27},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e데브옵스 업무 흐름에서 도커 사용을 시작하는 완벽한 가이드\u003c/h2\u003e\n\u003ch3\u003e이 블로그 포스트에서 무엇을 기대해야 하는가?\u003c/h3\u003e\n\u003ch3\u003e왜 Docker를 사용해야 하는가?\u003c/h3\u003e\n\u003cp\u003e20~30년 전으로 돌아가면, 하드웨어와 설치된 운영 체제(커널 및 UI)가 있었습니다. 어플리케이션을 실행하기 위해서 코드를 컴파일하고 모든 앱 의존성을 정렬해야 했습니다. 다른 어플리케이션이나 어플리케이션 작업량의 증가를 수용하기 위해 새 하드웨어를 구매하고 설치 및 구성해야 했습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e가상화는 하드웨어와 운영 체제 사이에 추가 계층인 하이퍼바이저라는 것을 추가했습니다. 이를 통해 사용자들은 독립된 여러 애플리케이션을 실행하여 가상 머신을 자체 운영 체제와 함께 실행할 수 있었습니다.\u003c/p\u003e\n\u003cp\u003e그럼에도 불구하고, 우리는 모든 가상 머신에 소프트웨어를 설치하고 종속성을 설정해주어야 했습니다. 애플리케이션이 휴대 가능하지 않았습니다. 일부 기기에서는 작동하지만 다른 기기에서는 작동하지 않았습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e도커란 무엇인가요?\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e도커는 마이크로서비스 기반 응용 프로그램 개발이 가능하도록 함으로써 소프트웨어 빌드 방법을 혁신했습니다.\u003c/p\u003e\n\u003ch1\u003e도커는 어떻게 작동하나요?\u003c/h1\u003e\n\u003cp\u003e도커 엔진은 호스트 운영 체제 위에서 실행됩니다. 도커 엔진에는 호스트 시스템에서 도커 컨테이너를 관리하는 서버 프로세스(dockerd)가 포함되어 있습니다. 도커 컨테이너는 응용 프로그램과 그 의존성을 격리시켜 다른 환경에서도 일관되게 실행할 수 있도록 설계되었습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e도커를 사용하려면 Dockerfile, Docker 이미지, Docker 컨테이너라는 세 가지 개념을 이해해야 합니다.\u003c/p\u003e\n\u003ch2\u003eDocker 파일(Dockerfile)이란?\u003c/h2\u003e\n\u003ch2\u003eDocker 이미지란 무엇인가요?\u003c/h2\u003e\n\u003cp\u003eDocker 이미지에는 컨테이너 내에서 코드를 실행하는 데 필요한 모든 종속성이 포함되어 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003eDocker 컨테이너란 무엇인가요?\u003c/h2\u003e\n\u003ch1\u003eDocker로 시작하기\u003c/h1\u003e\n\u003ch2\u003e사전 요구 사항\u003c/h2\u003e\n\u003cp\u003eDocker는 로컬 머신 또는 클라우드 VM에 설치되어 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eLinux:\u003c/p\u003e\n\u003cp\u003e로컬 노트북, 가상 머신 또는 클라우드 VM에서 Linux를 실행 중이라면 패키지 관리자를 사용하여 Docker를 설치할 수 있습니다. 이 블로그 포스트의 지시사항을 따라주세요.\u003c/p\u003e\n\u003cp\u003eMac 및 Windows:\u003c/p\u003e\n\u003cp\u003e로컬 머신에서 Docker를 실행할 수 있게 해주는 Docker Desktop을 설치할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e도커를 시작하는 것은 쉬운 일이에요. 아래 명령을 실행하기만 하면 돼요\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e도커 런 -d -t --name \u003cspan class=\"hljs-title class_\"\u003eThor\u003c/span\u003e alpine\n도커 런 -d -t busybox\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 명령은 도커 이미지 alpine과 busybox로부터 2개의 컨테이너를 생성할 거에요. 이 둘은 도커 허브에 저장된 미니멀리스트이면서 퍼블릭인 리눅스 도커 이미지에요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e-d 옵션은 컨테이너를 백그라운드에서 실행(detach mode)\u003c/li\u003e\n\u003cli\u003e-t 옵션은 tty 터미널을 연결해 줘요.\u003c/li\u003e\n\u003cli\u003e--name 옵션은 컨테이너에 이름을 부여할 수 있어요. 제공하지 않으면 컨테이너는 랜덤 이름을 받게 돼요\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e참고: 위에 언급된 이미지로 처음 docker run을 실행하면 도커가 로컬 머신에서 이미지를 다운로드(풀)해야 합니다.\u003c/p\u003e\n\u003ch2\u003e로컬 머신에서 실행 중인/중지된 컨테이너 목록\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker ps # 실행 중인 컨테이너 확인\ndocker ps -a # 모든 컨테이너 목록\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e로컬 머신에 있는 도커 이미지 목록\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker image ls\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eLinux 기반 도커 컨테이너에 사용된 이미지 크기를 확인할 수 있어요. 우분투, 아마존 리눅스, CentOS 등과 같은 일반적인 Linux 기반 머신과 비교하면 작아요.\u003c/p\u003e\n\u003cp\u003e실행 중인 컨테이너와 상호 작용하는 방법은 명령을 전달하거나 대화형 세션을 여는 두 가지 방법이 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# docker exec -it \u0026#x3C;컨테이너 \u003cspan class=\"hljs-variable constant_\"\u003eID\u003c/span\u003e\u003e \u0026#x3C;셸\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003edocker exec를 사용하면 실행 중인 도커 컨테이너 내부로 진입할 수 있어요.\u003c/li\u003e\n\u003cli\u003e--it는 도커와 대화형 세션을 열어줘요.\u003c/li\u003e\n\u003cli\u003e셸은 sh, bash, zsh 등을 사용할 수 있어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e컨테이너 정보를 얻기 위해 몇 가지 명령을 실행해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker exec -t \u003cspan class=\"hljs-title class_\"\u003eThor\u003c/span\u003e ls ; ps\n# -t는 tty 세션을 열기 위한 옵션입니다.\n# \u003cspan class=\"hljs-title class_\"\u003eThor\u003c/span\u003e는 컨테이너 이름입니다.\n# ls ; ps는 ls와 ps 두 개의 명령을 실행합니다.\n\ndocker exec -t 8ad10d1d0660 free -m\n# 8ad10d1d0660은 컨테이너 \u003cspan class=\"hljs-variable constant_\"\u003eID\u003c/span\u003e이며, free -m은 메모리 사용량을 확인하는 명령입니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 -it 옵션을 사용하여 컨테이너와 대화형 쉘 세션을 열어보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e도커 exec -it 16fb1c59fbea sh\n# 세션을 종료하려면 \u003cspan class=\"hljs-string\"\u003e\"exit\"\u003c/span\u003e을 입력하세요\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e컨테이너 시작, 중지, 삭제\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 실행 중인 컨테이너를 중지하는 방법\ndocker stop \u0026#x3C;컨테이너 이름 또는 \u003cspan class=\"hljs-variable constant_\"\u003eID\u003c/span\u003e\u003e\n\n# 중지된 컨테이너를 시작하는 방법\ndocker start \u0026#x3C;컨테이너 이름 또는 \u003cspan class=\"hljs-variable constant_\"\u003eID\u003c/span\u003e\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_7.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 실행 중인 컨테이너를 종료한 후에 삭제하려면 다음과 같이 명령을 사용합니다.\n# docker stop \u0026#x3C;컨테이너 이름 또는 \u003cspan class=\"hljs-variable constant_\"\u003eID\u003c/span\u003e\u003e\n# docker rm \u0026#x3C;컨테이너 이름 또는 \u003cspan class=\"hljs-variable constant_\"\u003eID\u003c/span\u003e\u003e\ndocker stop 16fb1c59fbea\ndocker rm 16fb1c59fbea\n\n# 아니면 -f 플래그를 사용하여 강제로 컨테이너를 삭제합니다.\ndocker rm -f \u003cspan class=\"hljs-title class_\"\u003eThor\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_8.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003ch1\u003e도커 이미지 빌드하기\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003eDocker 네트워킹\u003c/h1\u003e\n\u003cp\u003e도커는 다양한 종류의 네트워크를 제공합니다.\u003c/p\u003e\n\u003ch2\u003e1. 기본 브릿지\u003c/h2\u003e\n\u003cp\u003e만약 도커허브에서 nginx 이미지를 사용하여 nginx 컨테이너를 실행 중이고 웹 서버에 액세스하려고 한다면요.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_9.png\" alt=\"screenshot\"\u003e\u003c/p\u003e\n\u003cp\u003e스크린샷을 통해 Nginx 웹 서버가 80번 포트에서 실행 중임을 확인할 수 있습니다. NGINX 컨테이너에 로그인하여 curl 127.0.0.1:80을 실행하면 웹 서버에서 HTML 응답을 반환합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e127.0.0.1은 루프백 주소로 현재 장치(로컬호스트)를 항상 가리킵니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_10.png\" alt=\"screenshot\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e위에서 본 것처럼, 컨테이너 내부의 웹 서버가 우리가 기대한 대로 작동했습니다.\u003c/p\u003e\n\u003cp\u003e이제 호스트 머신 (랩톱/가상 머신)에서 웹 서버에 연결해 보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_11.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e컨테이너에서 실행 중인 nginx 웹 서버에 연결할 수 없었습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e네트워크 깊이 파고들기\u003c/p\u003e\n\u003cp\u003e도커 컨테이너를 검사하려면 docker inspect 명령을 실행하고 맨 아래로 스크롤하면 도커가 브릿지 네트워크를 사용하고 네트워크에 대한 자세한 내용을 볼 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker inspect nginx-container\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e도커 네트워크 목록\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e네트워크를 검사하면 기본 브릿지 네트워크를 사용하는 컨테이너를 찾을 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e도커 네트워크 검사 브릿지\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e포트 전달\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e도커 실행 -d -p \u0026#x3C;호스트 포트\u003e:\u0026#x3C;컨테이너 포트\u003e --name \u0026#x3C;컨테이너 이름\u003e 이미지\n\n# 포트 전달 -\u003e 컨테이너의 포트 \u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e을 호스트 머신의 포트 \u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e으로 전달\n도커 실행 -t -d -p \u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e --name nginx-container \u003cspan class=\"hljs-attr\"\u003enginx\u003c/span\u003e:latest\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_16.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e도커는 기본 네트워크를 사용하지 말라고 권장하고 대신에 우리만의 네트워크를 생성하도록 하고 있습니다.\u003c/p\u003e\n\u003cp\u003ebusybox 이미지를 사용하여 2개의 컨테이너를 생성해 봅시다. 컨테이너를 실행한 후, 컨테이너 내부에서 서로 핑을 시도해 봅시다.\u003c/p\u003e\n\u003cp\u003e2개의 컨테이너를 생성하고, 각 컨테이너의 IP 주소를 얻기 위해 docker inspect를 사용해 보세요.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e아래는 두 컨테이너의 IP 주소가 동일한 네트워크에 있음을 확인할 수 있습니다(기본 브리지 네트워크).\u003c/p\u003e\n\u003cp\u003e이름과 IP 주소로 서로 핑을 보내 봅시다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_17.png\" alt=\"image1\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_18.png\" alt=\"image2\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e위 스크린샷을 보면 두 컨테이너 모두 서로 통신할 수 있지만 이름으로는 연결할 수 없습니다.\u003c/p\u003e\n\u003ch2\u003e2. 사용자 정의 브리지 네트워크\u003c/h2\u003e\n\u003cp\u003e네트워크 생성\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker network create blog-network\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e새로운 네트워크를 사용하여 이름이 nginx-con인 nginx 컨테이너를 만들어보세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003edocker run -itd --network blog-network --name nginx-con nginx\ndocker ps\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_19.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e도커 컨테이너와 네트워크를 검사해봅시다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e도커 네트워크를 검사하는 방법:\n\n\n![사진](\u003cspan class=\"hljs-regexp\"\u003e/assets/img\u003c/span\u003e\u003cspan class=\"hljs-regexp\"\u003e/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_20.png)\n\nNginx 컨테이너를 검사하는 방법:\n\n\n![사진](/\u003c/span\u003eassets/img/\u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e05\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e18\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eDevopszerotohero3EverythingyouneedtoknowaboutDockers\u003c/span\u003e_21.\u003cspan class=\"hljs-property\"\u003epng\u003c/span\u003e)\n\n\u0026#x3C;!-- ui-station 사각형 --\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"adsbygoogle\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"display:block\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-client\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ca-pub-4877378276818686\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-slot\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"7249294152\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-format\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"auto\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-full-width-responsive\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"true\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"javascript\"\u003e\n(adsbygoogle = \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eadsbygoogle\u003c/span\u003e || []).\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e({});\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n이제 호스트 포트를 통해 컨테이너에서 실행 중인 nginx 웹 서버에 액세스하려고 하면 작동하지 않을 것입니다. 여전히 컨테이너에서 실행 중인 웹 서버에 액세스하려면 호스트 포트로의 포트 포워딩을 수행해야 합니다.\n\n그러나 하나가 정리되었습니다 — 이름 해결입니다. 이제 사용자 정의 브리지 네트워크에서 컨테이너를 핑하면 작동해야 합니다.\n\n한 가지 busybox 컨테이너를 만들고 nginx-con 컨테이너를 핑해 보겠습니다.\n\n![이미지](\u003cspan class=\"hljs-regexp\"\u003e/assets/img\u003c/span\u003e\u003cspan class=\"hljs-regexp\"\u003e/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_22.png)\n\n\u0026#x3C;!-- ui-station 사각형 --\u003e\n\u0026#x3C;ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u0026#x3C;/i\u003c/span\u003ens\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"javascript\"\u003e\n(adsbygoogle = \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eadsbygoogle\u003c/span\u003e || []).\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e({});\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n## \u003cspan class=\"hljs-number\"\u003e3.\u003c/span\u003e 호스트 네트워크\n\ndocker run -td --network host --name nginx-server \u003cspan class=\"hljs-attr\"\u003enginx\u003c/span\u003e:latest\ndocker ps\n\n![image](\u003cspan class=\"hljs-regexp\"\u003e/assets/img\u003c/span\u003e\u003cspan class=\"hljs-regexp\"\u003e/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_23.png)\n\n이렇게 하면 nginx 컨테이너가 호스트 네트워크에서 실행됩니다.\n\n\u0026#x3C;!-- ui-station 사각형 --\u003e\n\u0026#x3C;ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u0026#x3C;/i\u003c/span\u003ens\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"javascript\"\u003e\n(adsbygoogle = \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eadsbygoogle\u003c/span\u003e || []).\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e({});\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n만약 로컬 호스트에서 nginx 서버에 접근하려고 하면, 작동해야 합니다.\n\n만약 컨테이너의 \u003cspan class=\"hljs-variable constant_\"\u003eIP\u003c/span\u003e 주소를 확인하려면\n\ndocker inspect nginx-server | grep \u003cspan class=\"hljs-title class_\"\u003eIPAddress\u003c/span\u003e\n\n아래 그림을 참고하세요:\n\n![이미지](\u003cspan class=\"hljs-regexp\"\u003e/assets/img\u003c/span\u003e\u003cspan class=\"hljs-regexp\"\u003e/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_24.png)\n\n\u0026#x3C;!-- ui-station 사각형 --\u003e\n\u0026#x3C;ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u0026#x3C;/i\u003c/span\u003ens\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"javascript\"\u003e\n(adsbygoogle = \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eadsbygoogle\u003c/span\u003e || []).\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e({});\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n뭐라구요? 해당 \u003cspan class=\"hljs-variable constant_\"\u003eIP\u003c/span\u003e 주소가 없나봐요. 호스트 머신의 \u003cspan class=\"hljs-variable constant_\"\u003eIP\u003c/span\u003e 주소를 사용한 모양이에요.\n\n다른 종류의 네트워크에 대해 더 알려드릴게요. 하지만 블로그가 너무 길어지고 있네요.\n\n# 도커 볼륨\n\n도커는 로컬 파일 시스템에서 컨테이너의 모든 콘텐츠, 코드 및 데이터를 분리합니다. 이는 도커 데스크탑에서 컨테이너를 삭제하면 그 안의 모든 콘텐츠가 삭제된다는 뜻이에요.\n\n\u0026#x3C;!-- ui-station 사각형 --\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"adsbygoogle\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"display:block\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-client\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ca-pub-4877378276818686\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-slot\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"7249294152\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-format\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"auto\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-full-width-responsive\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"true\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"javascript\"\u003e\n(adsbygoogle = \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eadsbygoogle\u003c/span\u003e || []).\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e({});\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n가끔은 컨테이너가 생성한 데이터를 유지하기를 원할 수 있습니다. 이때 볼륨을 사용할 수 있습니다.\n\n## 바인드 마운트\n\n바인드 마운트를 사용하면 호스트 머신의 파일 또는 디렉토리가 컨테이너로 마운트됩니다.\n\n## 도커 볼륨\n\n\u0026#x3C;!-- ui-station 사각형 --\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"adsbygoogle\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"display:block\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-client\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ca-pub-4877378276818686\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-slot\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"7249294152\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-format\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"auto\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-full-width-responsive\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"true\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"javascript\"\u003e\n(adsbygoogle = \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eadsbygoogle\u003c/span\u003e || []).\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e({});\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n체적은 도커에서 관리하는 로컬 파일 시스템의 위치입니다.\n\n체적은 사용 중인 컨테이너의 크기를 늘리지 않으며, 체적의 내용은 특정 컨테이너의 생명 주기 외부에 존재합니다.\n\n# 도커에서 체적 사용하는 방법\n\n도커에서 체적을 사용하는 방법에는 --mount 및 -v (또는 --volume ) 두 가지가 있습니다. -v 구문은 모든 옵션을 하나의 필드에 결합하며, --mount 구문은 옵션을 분리합니다.\n\n\u0026#x3C;!-- ui-station 사각형 --\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"adsbygoogle\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"display:block\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-client\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ca-pub-4877378276818686\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-slot\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"7249294152\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-format\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"auto\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-full-width-responsive\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"true\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"javascript\"\u003e\n(adsbygoogle = \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eadsbygoogle\u003c/span\u003e || []).\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e({});\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n- -v 또는 --\u003cspan class=\"hljs-attr\"\u003evolume\u003c/span\u003e: 콜론 문자(:)로 구분된 세 개의 필드로 구성됩니다.\n\n   - 첫 번째 필드는 바인드 마운트의 경우 호스트 머신의 파일 또는 디렉터리 경로이거나 볼륨의 이름입니다.\n   - 두 번째 필드는 컨테이너 내에서 파일 또는 디렉터리가 마운트된 경로입니다.\n   - 세 번째 필드는 선택 사항입니다. ro, z, Z와 같은 옵션들의 쉼표로 구분된 목록입니다.\n\n--\u003cspan class=\"hljs-attr\"\u003emount\u003c/span\u003e: 쉼표로 구분된 여러 개의 키-값 페어로 구성됩니다.\n\n   - 마운트의 유형(bind, volume 또는 tmpfs).\n   - 마운트의 소스.\n   - 목적지는 파일 또는 디렉터리가 컨테이너 내에서 마운트된 경로로 값을 취합니다.\n\n\u0026#x3C;!-- ui-station 사각형 --\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"adsbygoogle\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"display:block\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-client\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ca-pub-4877378276818686\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-slot\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"7249294152\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-format\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"auto\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-full-width-responsive\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"true\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"javascript\"\u003e\n(adsbygoogle = \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eadsbygoogle\u003c/span\u003e || []).\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e({});\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n# 예시: \u003cspan class=\"hljs-title class_\"\u003eDocker\u003c/span\u003e 컨테이너와 바인드 마운트\n\n우리는 호스트 머신의 동일한 디렉토리/폴더를 \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e개의 컨테이너에 마운트했습니다.\n\nmkdir docker-bind-mount\ndocker run -t -d  -v docker-bind-\u003cspan class=\"hljs-attr\"\u003emount\u003c/span\u003e:\u003cspan class=\"hljs-regexp\"\u003e/app/\u003c/span\u003elog  --name captain-america busybox\ndocker run -t -d  -v docker-bind-\u003cspan class=\"hljs-attr\"\u003emount\u003c/span\u003e:\u003cspan class=\"hljs-regexp\"\u003e/app/\u003c/span\u003elog  --name thor busybox\ndocker run -t -d  -v docker-bind-\u003cspan class=\"hljs-attr\"\u003emount\u003c/span\u003e:\u003cspan class=\"hljs-regexp\"\u003e/app/\u003c/span\u003elog  --name hulk  busybox\ndocker run -t -d  -v docker-bind-\u003cspan class=\"hljs-attr\"\u003emount\u003c/span\u003e:\u003cspan class=\"hljs-regexp\"\u003e/app/\u003c/span\u003elog  --name iron-man  alpine\n\n# --mount 옵션을 사용한 명령어\ndocker run -t -d --mount type=bind,source=docker-bind-mount,target=\u003cspan class=\"hljs-regexp\"\u003e/app/\u003c/span\u003elog \\\n  --name captain-america busybox\n\n\u0026#x3C;img src=\u003cspan class=\"hljs-string\"\u003e\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_25.png\"\u003c/span\u003e /\u003e\n\n\u0026#x3C;!-- ui-station 사각형 --\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"adsbygoogle\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"display:block\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-client\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ca-pub-4877378276818686\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-slot\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"7249294152\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-format\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"auto\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-full-width-responsive\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"true\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"javascript\"\u003e\n(adsbygoogle = \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eadsbygoogle\u003c/span\u003e || []).\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e({});\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n\n![image](\u003cspan class=\"hljs-regexp\"\u003e/assets/img\u003c/span\u003e\u003cspan class=\"hljs-regexp\"\u003e/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_26.png)\n\n각 컨테이너 안에 저장된 로그를 작성해봅시다. 바인드-마운트가 연결된 경로인 /\u003c/span\u003eapp/log에\n\n![image](\u003cspan class=\"hljs-regexp\"\u003e/assets/img\u003c/span\u003e\u003cspan class=\"hljs-regexp\"\u003e/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_27.png)\n\n자세히 살펴보면, 1번째와 2번째 컨테이너에서 생성한 파일들이 3번째 컨테이너에서 보이며, 1번째에서 3번째 컨테이너에서 생성한 파일이 4번째(Captain-America) 컨테이너에서도 보인다는 점을 알 수 있습니다.\n\n\n\u0026#x3C;!-- ui-station 사각형 --\u003e\n\u0026#x3C;ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u0026#x3C;/i\u003c/span\u003ens\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"javascript\"\u003e\n(adsbygoogle = \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eadsbygoogle\u003c/span\u003e || []).\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e({});\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n일반적으로 도커 데이터 파일에는 다른 컨테이너의 내용이 포함되어 있습니다.\n\n이 예시는 우리가 어떻게 간단하게 여러 컨테이너 간에 파일/로그를 공유할 수 있는지 보여줍니다.\n\n하지만, 한 가지 주의할 점이 있습니다. 만약 우리가 로컬 호스트로 이동하여 모든 컨테이너에 바인드 마운트한 디렉터리를 목록으로 보면 아무것도 찾을 수 없을 것입니다.\n\n이것은 즉, 도커가 바인드 마운트한 데이터를 다른 컨테이너와 공유할 수 있었지만 데이터가 로컬 호스트에서는 보이지 않는다는 것을 의미합니다.\n\n\u0026#x3C;!-- ui-station 사각형 --\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"adsbygoogle\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"display:block\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-client\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ca-pub-4877378276818686\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-slot\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"7249294152\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-format\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"auto\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-full-width-responsive\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"true\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"javascript\"\u003e\n(adsbygoogle = \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eadsbygoogle\u003c/span\u003e || []).\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e({});\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n이 파일들은 바인드 마운트 시 도커 컨테이너 간에 저장되고 공유됩니다.\n\n![\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e](\u003cspan class=\"hljs-regexp\"\u003e/assets/img\u003c/span\u003e\u003cspan class=\"hljs-regexp\"\u003e/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_28.png)\n\n도커 컨테이너 중 하나를 검사하고 마운트 섹션으로 이동하면 마운트에 관련된 세부 정보를 볼 수 있습니다.\n\n참고: 도커 inspect 명령은 도커 컨테이너에 대해 더 많은 정보를 제공합니다.\n\n\u0026#x3C;!-- ui-station 사각형 --\u003e\n\u0026#x3C;ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u0026#x3C;/i\u003c/span\u003ens\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"javascript\"\u003e\n(adsbygoogle = \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eadsbygoogle\u003c/span\u003e || []).\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e({});\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n# 도커 컨테이너 조회 명령어: docker inspect \u0026#x3C;컨테이너 이름 또는 컨테이너 \u003cspan class=\"hljs-variable constant_\"\u003eID\u003c/span\u003e\u003e\ndocker inspect hulk\n\n![도커 컨테이너 및 볼륨에 대한 자세한 정보](\u003cspan class=\"hljs-regexp\"\u003e/assets/img\u003c/span\u003e\u003cspan class=\"hljs-regexp\"\u003e/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_29.png)\n\n# 예제: 볼륨을 사용하는 Docker 컨테이너\n\n볼륨 생성하기\n\n\n\u0026#x3C;!-- ui-station 사각형 --\u003e\n\u0026#x3C;ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u0026#x3C;/i\u003c/span\u003ens\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"javascript\"\u003e\n(adsbygoogle = \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eadsbygoogle\u003c/span\u003e || []).\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e({});\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e도커 볼륨 생성하기\u003c/h1\u003e\n\u003cp\u003e도커 볼륨 생성 thor-vol\n도커 볼륨 생성 hulk-vol\u003c/p\u003e\n\u003ch1\u003e도커 볼륨 목록 확인\u003c/h1\u003e\n\u003cp\u003e도커 볼륨 목록 보기\u003c/p\u003e\n\u003ch1\u003e도커 볼륨\u003c/h1\u003e\n\u003ch1\u003e명령어:\u003c/h1\u003e\n\u003ch1\u003ecreate 볼륨 생성\u003c/h1\u003e\n\u003ch1\u003einspect 한 개 이상의 볼륨에 대한 자세한 정보 표시\u003c/h1\u003e\n\u003ch1\u003els 볼륨 목록 보기\u003c/h1\u003e\n\u003ch1\u003eprune 사용하지 않는 로컬 볼륨 제거\u003c/h1\u003e\n\u003ch1\u003erm 한 개 이상의 볼륨 제거\u003c/h1\u003e\n\u003cp\u003e볼륨 검사하기\u003c/p\u003e\n\u003cp\u003e도커 볼륨 inspect thor-vol\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_31.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e새 컨테이너를 생성하는 동안 이 볼륨을 마운트해 봅시다. 이번에는 — — mount 옵션을 사용할 거에요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker run -d \\\n  --name thor-container \\\n  --mount type=volume,source=thor-vol,target=/app \\\n  \u003cspan class=\"hljs-attr\"\u003enginx\u003c/span\u003e:latest\n\n# 볼륨을 source로 명시할 때 type의 기본 값은 volume입니다.\ndocker run -d \\\n  --name hulk-container \\\n  --mount source=thor-vol,target=/app \\\n  \u003cspan class=\"hljs-attr\"\u003enginx\u003c/span\u003e:latest\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker inspect hulk-container\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_32.png\" alt=\"Image 1\"\u003e\u003c/p\u003e\n\u003cp\u003eLet’s create some logs in both containers and see if the files/logs are visible to both containers.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_33.png\" alt=\"Image 2\"\u003e\u003c/p\u003e\n\u003cp\u003eAs you can see from the above screenshot, we can share data/logs across containers.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003e도커 볼륨 삭제\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 도커 볼륨을 제거하기\n# 한 번에 하나 이상의 볼륨을 삭제할 수 있습니다\ndocker volume rm \u0026#x3C;volume-names\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_34.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e도커 이미지 빌드\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e이제 기본적인 도커 개념을 살펴 보았으니, 실습 예제를 해 봅시다.\u003c/p\u003e\n\u003ch2\u003e여기서 무엇을 할 건가요?\u003c/h2\u003e\n\u003cp\u003e도커 이미지를 만들어 기본적인 Flask 애플리케이션을 내장시킬 거에요. 그리고 만든 도커 이미지를 도커 허브에 푸시할 거에요.\u003c/p\u003e\n\u003cp\u003e한 폴더를 만들고 app.py, requirements.txt, 그리고 Dockerfile 이라는 3개의 파일을 생성해 볼까요?\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eDockerfile\u003c/span\u003e, app.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e, requirements.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e 파일들을 만들었습니다.\n\n\u0026#x3C;img src=\u003cspan class=\"hljs-string\"\u003e\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_35.png\"\u003c/span\u003e /\u003e\n\n각 파일에 아래 코드를 붙여 넣어주세요.\n\napp.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e flask \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e Flask\n\napp = Flask(__name__)\n\n\u003cspan class=\"hljs-meta\"\u003e@app.route(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e\u003c/span\u003e)\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehello_docker\u003c/span\u003e():\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'Hello, Docker!'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e __name__ == \u003cspan class=\"hljs-string\"\u003e'__main__'\u003c/span\u003e:\n    app.run(debug=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e, host=\u003cspan class=\"hljs-string\"\u003e'0.0.0.0'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003erequirements.txt\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003eFlask\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 Docker 이미지를 빌드하기 위한 Dockerfile을 생성할 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eDockerfile\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 부모 이미지로 공식 \u003cspan class=\"hljs-title class_\"\u003ePython\u003c/span\u003e 실행 환경 사용\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epython\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e3.11\u003c/span\u003e\n\n# 작업 디렉토리를 /app으로 설정\n\u003cspan class=\"hljs-variable constant_\"\u003eWORKDIR\u003c/span\u003e /app\n\n# \u003cspan class=\"hljs-title class_\"\u003ePython\u003c/span\u003e 종속성 파일을 컨테이너의 /app 디렉토리로 복사\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e requirements.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e /app\n\n# requirements.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e에 명시된 필요한 패키지 설치\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e pip install --no-cache-dir -r requirements.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e\n\n# flask 앱 파일을 컨테이너의 /app 디렉토리로 복사\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e app.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e /app\n\n# 포트 \u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e을 이 컨테이너 외부에 노출\n\u003cspan class=\"hljs-variable constant_\"\u003eEXPOSE\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e\n\n# 컨테이너가 시작될 때 app.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e 실행\n\u003cspan class=\"hljs-variable constant_\"\u003eCMD\u003c/span\u003e [\u003cspan class=\"hljs-string\"\u003e\"python\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"app.py\"\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e도커 이미지 생성\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# docker build -t \u0026#x3C;이미지-이름\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eDockerfile\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e경로\u003c/span\u003e\u003e\u003c/span\u003e\ndocker build -t flask-image .\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e아래는 Markdown 형식으로 변경되었습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_36.png\" alt=\"Docker Image\"\u003e\u003c/p\u003e\n\u003cp\u003eDocker Hub repository를 만들어보겠습니다. 아직 계정이 없다면 만드세요 - livingdevopswithakhilesh라는 이름으로 만들었어요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_37.png\" alt=\"Image 태깅\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003edocker tag  /:\u003c/h1\u003e\n\u003cp\u003edocker tag flask-image livingdevopswithakhilesh/docker-demo-docker:1.0\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_38.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e도커 허브에 이미지를 푸시하세요. 이미지를 푸시하기 전에 docker login을 실행해주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sh\"\u003edocker login\n\u003cspan class=\"hljs-comment\"\u003e# docker push \u0026#x3C;tagged-image\u003e\u003c/span\u003e\ndocker push livingdevopswithakhilesh/docker-demo-docker:1.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_39.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e로컬 이미지를 삭제하고 Docker Hub에서 이미지를 가져와서 해당 이미지를 사용하여 컨테이너를 실행합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker pull livingdevopswithakhilesh/docker-demo-\u003cspan class=\"hljs-attr\"\u003edocker\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_40.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker run -td -p \u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e --name flask livingdevopswithakhilesh/docker-demo-\u003cspan class=\"hljs-attr\"\u003edocker\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_41.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e이 블로그는 여기까지입니다. 다음 블로그에서 뵙겠습니다. 저와 함께 더 유용한 콘텐츠를 확인하려면 팔로우해주세요.\u003c/p\u003e\n\u003cp\u003eLinkedin에서 연락하기: \u003ca href=\"https://www.linkedin.com/in/akhilesh-mishra-0ab886124/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.linkedin.com/in/akhilesh-mishra-0ab886124/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e시리즈 Devops Zero to Hero의 세 번째 블로그였습니다. 첫 두 개 블로그를 확인해보세요 —\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers"},"buildId":"bb_yO9GbCvdfc_n71SfUf","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>