<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>RecyclerView 항목을 payloads로 효율적으로 업데이트하는 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-22-EfficientlyupdatingRecyclerViewitemsusingpayloads" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="RecyclerView 항목을 payloads로 효율적으로 업데이트하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="RecyclerView 항목을 payloads로 효율적으로 업데이트하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-EfficientlyupdatingRecyclerViewitemsusingpayloads_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-22-EfficientlyupdatingRecyclerViewitemsusingpayloads" data-gatsby-head="true"/><meta name="twitter:title" content="RecyclerView 항목을 payloads로 효율적으로 업데이트하는 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-EfficientlyupdatingRecyclerViewitemsusingpayloads_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 22:47" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/-dPCbnM2yhdKNgXe92VJV/_buildManifest.js" defer=""></script><script src="/_next/static/-dPCbnM2yhdKNgXe92VJV/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">RecyclerView 항목을 payloads로 효율적으로 업데이트하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="RecyclerView 항목을 payloads로 효율적으로 업데이트하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-EfficientlyupdatingRecyclerViewitemsusingpayloads&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>요즘 대부분의 앱은 사용자에게 수직이나 수평 목록으로 정보를 표시합니다. 종종, 정보는 동적이며 조회수, 좋아요 수 등과 같이 자주 업데이트해야 하는 정보입니다. 또한 목록에는 네트워크에서 로드된 이미지가 포함될 수도 있습니다. 이것이 RecyclerView를 효율적으로 업데이트하는 것이 중요한 이유이며, 성능이 우수한 앱을 갖고 좋은 사용자 경험을 제공하는 중요한 측면입니다.</p>
<p>이 게시물은 얼마 전에 쓰여졌지만, 이미 다루어진 주제이고 Jetpack Compose가 현재 선호되는 UI 툴킷이기 때문에 발행할 지 말 지 고민하고 있었습니다. 그러나 이 정보가 누군가에게 도움이 될 수 있기를 바라며 게시하기로 결정했습니다.</p>
<h2>DiffUtil과 ListAdapter 사용하기</h2>
<p>새 데이터로 RecyclerView를 효율적으로 업데이트하려면 notifyItemInserted(position: Int), notifyItemChanged(position: Int), notifyItemRemoved(position: Int) 등과 같은 함수를 호출해야 합니다 (docs에서는 효율적이지 않으며 최후의 수단으로만 사용해야 한다고 명시한 notifyDataSetChanged()는 피하시기 바랍니다). 이러한 함수를 호출하면 RecyclerView Adapter에 기본 데이터가 변경되었음을 알리고 뷰를 업데이트하여 새 상태를 반영해야 한다는 사실을 알리게 됩니다. 이러한 함수 호출은 RecyclerView가 모든 변경 사항을 애니메이션으로 처리하는 이점도 함께 제공됩니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>수동으로 그 모든 작업을 하지 않도록 하기 위해 DiffUtil을 사용할 수 있습니다 (공식 문서). DiffUtil은 이전 데이터와 새 데이터를 비교하고 차이점을 계산한 다음 RecyclerView.Adapter에 변경 사항을 알려주어 새 상태를 반영하기 위해 수행해야 하는 변경 사항을 선언합니다. 이후 사용할 DiffUtil.ItemCallback의 예시가 여기 있습니다.</p>
<p>Function areItemsTheSame(oldItem: Item, newItem: Item): Boolean은 id 또는 uuid와 같은 고유 속성을 기준으로 두 항목이 동일한지 확인합니다. 항목이 다를 경우 어댑터는 이전 항목을 새 항목으로 바꿔야 한다는 것을 알게 됩니다. 이 함수가 true를 반환하면 함수 areContentsTheSame(oldItem: Item, newItem: Item): Boolean이 호출되는데, 여기서 데이터 모델의 다른 속성 중 어떤 것이 변경되었는지 확인할 수 있습니다.</p>
<p>중요한 점은 DiffUtil 결과를 백그라운드 스레드에서 계산하는 것이 권장된다는 것입니다. 더 큰 데이터 집합이 있는 경우에는 요구가 많을 수 있고 주 스레드를 차단할 수 있기 때문입니다. Coroutine 또는 RxJava를 사용하여 계산을 다른 스레드로 옮기거나 ListAdapter(공식 문서)를 사용하여 백그라운드 스레드에서 계산할 수 있습니다.</p>
<p>ListAdapter는 AsyncListDiffer (공식 문서)를 사용하여 백그라운드 스레드에서 차이를 계산하는 논리를 포함하고 RecyclerView.Adapter를 확장하여 코드를 더욱 간결하게 만듭니다. 할 일은 새 데이터를 함수 submitList(list: List)를 사용하여 전달하는 것뿐입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>샘플 앱에서 모두 함께 사용해보기</h2>
<p>지금까지 배운 내용을 모아 간단한 앱으로 만들어보겠습니다. 이 앱은 기사 목록을 표시하는데, 각 기사에는 제목, 부제목, URL에서 로드된 표지 이미지, 좌측 하단에 표시되는 코멘트 수가 포함되어 있습니다. 사용자는 각 기사 오른쪽 상단의 북마크 버튼을 눌러 해당 기사를 즐겨찾기에 추가할 수도 있습니다. 툴바에는 두 개의 버튼이 있습니다. 코멘트 수를 업데이트하는 새로고침 버튼과 애니메이션 데모 목적으로 기사의 순서를 임의로 변경하는 재정렬 버튼입니다.</p>
<p>아래는 소스 코드와 앱이 동작하는 모습을 보여주는 동영상입니다.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:640/1*kRBq0EXx36YlMoTCuulNuw.gif" alt="앱 동작 예시"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우리는 재정렬 애니메이션이 원하는 대로 동작하는 것을 볼 수 있습니다. 그러나 사용자가 기사를 북마크하거나 댓글 수를 새로고침할 때의 애니메이션을 살펴보겠습니다.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:640/1*fWIvJ-K4PoONrlIZNzys1Q.gif" alt="이미지"></p>
<h2>기사가 업데이트될 때 "깜빡이" 효과가 나타나는 이유는 무엇인가요?</h2>
<p>기본적으로 두 항목(우리의 경우 기사)이 동일하지만 다른 콘텐츠(우리의 경우 댓글 수 또는 기사 북마크 여부)를 가질 때 RecyclerView는 새 항목 보기를 렌더링한 다음 이전 항목 보기와 새 항목 보기 사이에 크로스 페이드를 수행하여 GIF에서 볼 수 있는 "깜빡임" 효과를 초래합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>특히 더 어두운 배경이 사용되거나 사용자 상호작용의 결과로 업데이트될 때 이 기능은 이상하게 보일 수 있습니다. 이는 북마크 또는 북마크 취소와 같은 사용자 상호작용으로 인한 업데이트가 발생할 때 더 문제가 됩니다.</p>
<h2>성능은 어떻게 해결할까요?</h2>
<p>"깜빡"이 발생하는 애니메이션 외에 다른 문제는 항목 뷰를 완전히 다시 바인딩한다는 점입니다. 이 방법은 효율적이지 않습니다. 우리는 댓글 수를 업데이트하거나 북마크 아이콘을 변경하기를 원할 뿐이지만, 대신 전체 항목 뷰를 다시 그리고 다시 렌더링하고 있습니다. 이는 이미 필요하지 않은 이미지를 다시로드 하는 것을 포함합니다.</p>
<h2>이 문제를 어떻게 해결할 수 있을까요?</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>"“RecyclerViewanimation”을 비활성화하는 방법을 검색 중이라면 나타나는 해결책 중 하나는 RecyclerView. itemAnimator에 supportsChangeAnimation = false를 설정하거나 itemAnimator = null로 설정하는 것입니다.</p>
<p>그러나 이 방법은 항목의 순서가 변경되거나 새 항목이 예전 항목을 대체할 때 발생하는 모든 애니메이션도 비활성화되어 우리가 원하는 대상이 아닐 수 있습니다. 우리는 기존 항목의 속성이 변경될 때 교차 페이드 애니메이션을 제외한 모든 애니메이션을 유지하고 싶습니다. 또한, 이 해결책은 우리가 언급한 효율성/성능 문제를 다루지 않습니다.</p>
<h2>Payloads</h2>
<p>페이로드를 사용하여 애니메이션 및 효율성 문제를 모두 해결할 수 있습니다. 페이로드는 이미 정의한 객체로, 이미 존재하는 항목 뷰를 완전히 다시 바인딩하는 대신 일부만 업데이트할 수 있게 해줍니다."</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>RecyclerView.Adapter의 함수들을 좀 더 자세히 살펴보면, onBindViewHolder(holder: ViewHolder, position: Int, payloads: MutableList<code>Any</code>)라는 추가 함수를 오버라이드할 수 있는데, 이 함수는 onBindViewHolder(holder: ViewHolder, position: Int) 함수를 오버로딩한 것으로 payloads라는 추가 인수가 있습니다. 이 함수에 대한 문서를 살펴보면 다음과 같이 설명되어 있습니다:</p>
<p>변화 페이로드를 어떻게 얻을 수 있을까요? DiffUtil.ItemCallback에서 사용 가능한 함수들을 좀 더 자세히 살펴보면 기존의 함수인 areItemsTheSame(oldItem: Item, newItem: Item): Boolean과 areContentsTheSame(oldtItem: Item, newItem: Item): Boolean 외에도 fun getChangePayload(oldItem: Item, newItem: Item): Any?라는 추가 함수를 오버라이드할 수 있습니다.
이 함수는 이전 항목과 새 항목이 동일하지만 내용이 다른 경우 호출됩니다. 항목의 어떤 속성이 다른지 감지하고, 항목 뷰를 부분적으로 업데이트할 수 있는 객체를 반환할 수 있게 해줍니다.</p>
<p>여기서 우리는 이전 항목과 새 항목을 비교하고, 댓글 수가 다른 경우에는 ArticleChangePayload.Comments의 인스턴스를 반환하여 나중에 어떤 뷰를 업데이트해야 하는지 알 수 있게 합니다. 북마크 상태에 대해서도 동일한 작업을 수행하고, ArticleChangePayload.Bookmark를 반환합니다. 그리고 다른 변경 사항의 경우에는 간단히 super 함수를 호출하여 null을 반환하게 하여 전체 재바인딩이 되도록 합니다.</p>
<p>이렇게하면 이제 onBindViewHolder 함수에서 payloads 인수를 확인할 수 있습니다. 이 것은 여러 스레드에서 병합된 여러 업데이트가 될 수 있기 때문에 리스트 형태로 제공됩니다. 문서에서 언급된 것처럼요:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>각 리스트를 하나하나 처리할지 아니면 리스트에서 마지막 항목만 가져올지 결정할 수 있어요.</p>
<p>우리 경우에는 마지막 항목을 확인하고, 만약 그것이 ArticleChangePayload.Comments 유형이라면 댓글 수 TextView를 업데이트하고, ArticleChangePayload.Bookmark 유형이라면 북마크 이미지 버튼을 업데이트할 거에요. 또한 페이로드가 비어 있거나 알 수 없는 유형인 경우를 처리하는 것이 중요해요. 그런 경우에는 원래의 onBindViewHolder(holder: ViewHolder, position: Int) 함수를 호출하여 완전히 다시 바인딩해야 해요. 이는 오버로드된 onBindViewHolder 함수의 기본 구현입니다.</p>
<p>이 기능을 추가한 후에 이제 데이터가 변경된 부분만 뷰에 업데이트되고 깜박거림 효과가 없어졌다는 것을 확인할 수 있어요. 완벽해요.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:640/1*OevReNMqnU9pngRAEUxmWQ.gif" alt="이미지"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그리고 여기에 업데이트된 어댑터 구현이 있습니다.</p>
<h2>결론</h2>
<p>저희는 DiffUtil, ListAdapter 및 payloads를 사용하여 RecyclerView 콘텐츠를 가장 효율적으로 업데이트하는 방법을 살펴보았습니다. 우리가 글 목록을 보여주는 앱을 가지고 있고 좋아요 수나 조회수를 자주 업데이트하려는 경우, payloads를 사용하면 전체 항목을 다시 부풀리고 다시 그리는 대신 변경된 뷰만 효율적으로 업데이트할 수 있습니다.</p>
<p>샘플 앱의 소스 코드는 여기에서 확인할 수 있습니다: <a href="https://github.com/landomen/recyclerview-payloads-sample" rel="nofollow" target="_blank">https://github.com/landomen/recyclerview-payloads-sample</a></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"RecyclerView 항목을 payloads로 효율적으로 업데이트하는 방법","description":"","date":"2024-06-22 22:47","slug":"2024-06-22-EfficientlyupdatingRecyclerViewitemsusingpayloads","content":"\n요즘 대부분의 앱은 사용자에게 수직이나 수평 목록으로 정보를 표시합니다. 종종, 정보는 동적이며 조회수, 좋아요 수 등과 같이 자주 업데이트해야 하는 정보입니다. 또한 목록에는 네트워크에서 로드된 이미지가 포함될 수도 있습니다. 이것이 RecyclerView를 효율적으로 업데이트하는 것이 중요한 이유이며, 성능이 우수한 앱을 갖고 좋은 사용자 경험을 제공하는 중요한 측면입니다.\n\n이 게시물은 얼마 전에 쓰여졌지만, 이미 다루어진 주제이고 Jetpack Compose가 현재 선호되는 UI 툴킷이기 때문에 발행할 지 말 지 고민하고 있었습니다. 그러나 이 정보가 누군가에게 도움이 될 수 있기를 바라며 게시하기로 결정했습니다.\n\n## DiffUtil과 ListAdapter 사용하기\n\n새 데이터로 RecyclerView를 효율적으로 업데이트하려면 notifyItemInserted(position: Int), notifyItemChanged(position: Int), notifyItemRemoved(position: Int) 등과 같은 함수를 호출해야 합니다 (docs에서는 효율적이지 않으며 최후의 수단으로만 사용해야 한다고 명시한 notifyDataSetChanged()는 피하시기 바랍니다). 이러한 함수를 호출하면 RecyclerView Adapter에 기본 데이터가 변경되었음을 알리고 뷰를 업데이트하여 새 상태를 반영해야 한다는 사실을 알리게 됩니다. 이러한 함수 호출은 RecyclerView가 모든 변경 사항을 애니메이션으로 처리하는 이점도 함께 제공됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n수동으로 그 모든 작업을 하지 않도록 하기 위해 DiffUtil을 사용할 수 있습니다 (공식 문서). DiffUtil은 이전 데이터와 새 데이터를 비교하고 차이점을 계산한 다음 RecyclerView.Adapter에 변경 사항을 알려주어 새 상태를 반영하기 위해 수행해야 하는 변경 사항을 선언합니다. 이후 사용할 DiffUtil.ItemCallback의 예시가 여기 있습니다.\n\nFunction areItemsTheSame(oldItem: Item, newItem: Item): Boolean은 id 또는 uuid와 같은 고유 속성을 기준으로 두 항목이 동일한지 확인합니다. 항목이 다를 경우 어댑터는 이전 항목을 새 항목으로 바꿔야 한다는 것을 알게 됩니다. 이 함수가 true를 반환하면 함수 areContentsTheSame(oldItem: Item, newItem: Item): Boolean이 호출되는데, 여기서 데이터 모델의 다른 속성 중 어떤 것이 변경되었는지 확인할 수 있습니다.\n\n중요한 점은 DiffUtil 결과를 백그라운드 스레드에서 계산하는 것이 권장된다는 것입니다. 더 큰 데이터 집합이 있는 경우에는 요구가 많을 수 있고 주 스레드를 차단할 수 있기 때문입니다. Coroutine 또는 RxJava를 사용하여 계산을 다른 스레드로 옮기거나 ListAdapter(공식 문서)를 사용하여 백그라운드 스레드에서 계산할 수 있습니다.\n\nListAdapter는 AsyncListDiffer (공식 문서)를 사용하여 백그라운드 스레드에서 차이를 계산하는 논리를 포함하고 RecyclerView.Adapter를 확장하여 코드를 더욱 간결하게 만듭니다. 할 일은 새 데이터를 함수 submitList(list: List)를 사용하여 전달하는 것뿐입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 샘플 앱에서 모두 함께 사용해보기\n\n지금까지 배운 내용을 모아 간단한 앱으로 만들어보겠습니다. 이 앱은 기사 목록을 표시하는데, 각 기사에는 제목, 부제목, URL에서 로드된 표지 이미지, 좌측 하단에 표시되는 코멘트 수가 포함되어 있습니다. 사용자는 각 기사 오른쪽 상단의 북마크 버튼을 눌러 해당 기사를 즐겨찾기에 추가할 수도 있습니다. 툴바에는 두 개의 버튼이 있습니다. 코멘트 수를 업데이트하는 새로고침 버튼과 애니메이션 데모 목적으로 기사의 순서를 임의로 변경하는 재정렬 버튼입니다.\n\n아래는 소스 코드와 앱이 동작하는 모습을 보여주는 동영상입니다.\n\n![앱 동작 예시](https://miro.medium.com/v2/resize:fit:640/1*kRBq0EXx36YlMoTCuulNuw.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 재정렬 애니메이션이 원하는 대로 동작하는 것을 볼 수 있습니다. 그러나 사용자가 기사를 북마크하거나 댓글 수를 새로고침할 때의 애니메이션을 살펴보겠습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:640/1*fWIvJ-K4PoONrlIZNzys1Q.gif)\n\n## 기사가 업데이트될 때 \"깜빡이\" 효과가 나타나는 이유는 무엇인가요?\n\n기본적으로 두 항목(우리의 경우 기사)이 동일하지만 다른 콘텐츠(우리의 경우 댓글 수 또는 기사 북마크 여부)를 가질 때 RecyclerView는 새 항목 보기를 렌더링한 다음 이전 항목 보기와 새 항목 보기 사이에 크로스 페이드를 수행하여 GIF에서 볼 수 있는 \"깜빡임\" 효과를 초래합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n특히 더 어두운 배경이 사용되거나 사용자 상호작용의 결과로 업데이트될 때 이 기능은 이상하게 보일 수 있습니다. 이는 북마크 또는 북마크 취소와 같은 사용자 상호작용으로 인한 업데이트가 발생할 때 더 문제가 됩니다.\n\n## 성능은 어떻게 해결할까요?\n\n\"깜빡\"이 발생하는 애니메이션 외에 다른 문제는 항목 뷰를 완전히 다시 바인딩한다는 점입니다. 이 방법은 효율적이지 않습니다. 우리는 댓글 수를 업데이트하거나 북마크 아이콘을 변경하기를 원할 뿐이지만, 대신 전체 항목 뷰를 다시 그리고 다시 렌더링하고 있습니다. 이는 이미 필요하지 않은 이미지를 다시로드 하는 것을 포함합니다.\n\n## 이 문제를 어떻게 해결할 수 있을까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"“RecyclerViewanimation”을 비활성화하는 방법을 검색 중이라면 나타나는 해결책 중 하나는 RecyclerView. itemAnimator에 supportsChangeAnimation = false를 설정하거나 itemAnimator = null로 설정하는 것입니다.\n\n그러나 이 방법은 항목의 순서가 변경되거나 새 항목이 예전 항목을 대체할 때 발생하는 모든 애니메이션도 비활성화되어 우리가 원하는 대상이 아닐 수 있습니다. 우리는 기존 항목의 속성이 변경될 때 교차 페이드 애니메이션을 제외한 모든 애니메이션을 유지하고 싶습니다. 또한, 이 해결책은 우리가 언급한 효율성/성능 문제를 다루지 않습니다.\n\n## Payloads\n\n페이로드를 사용하여 애니메이션 및 효율성 문제를 모두 해결할 수 있습니다. 페이로드는 이미 정의한 객체로, 이미 존재하는 항목 뷰를 완전히 다시 바인딩하는 대신 일부만 업데이트할 수 있게 해줍니다.\"\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nRecyclerView.Adapter의 함수들을 좀 더 자세히 살펴보면, onBindViewHolder(holder: ViewHolder, position: Int, payloads: MutableList`Any`)라는 추가 함수를 오버라이드할 수 있는데, 이 함수는 onBindViewHolder(holder: ViewHolder, position: Int) 함수를 오버로딩한 것으로 payloads라는 추가 인수가 있습니다. 이 함수에 대한 문서를 살펴보면 다음과 같이 설명되어 있습니다:\n\n변화 페이로드를 어떻게 얻을 수 있을까요? DiffUtil.ItemCallback에서 사용 가능한 함수들을 좀 더 자세히 살펴보면 기존의 함수인 areItemsTheSame(oldItem: Item, newItem: Item): Boolean과 areContentsTheSame(oldtItem: Item, newItem: Item): Boolean 외에도 fun getChangePayload(oldItem: Item, newItem: Item): Any?라는 추가 함수를 오버라이드할 수 있습니다.\n이 함수는 이전 항목과 새 항목이 동일하지만 내용이 다른 경우 호출됩니다. 항목의 어떤 속성이 다른지 감지하고, 항목 뷰를 부분적으로 업데이트할 수 있는 객체를 반환할 수 있게 해줍니다.\n\n여기서 우리는 이전 항목과 새 항목을 비교하고, 댓글 수가 다른 경우에는 ArticleChangePayload.Comments의 인스턴스를 반환하여 나중에 어떤 뷰를 업데이트해야 하는지 알 수 있게 합니다. 북마크 상태에 대해서도 동일한 작업을 수행하고, ArticleChangePayload.Bookmark를 반환합니다. 그리고 다른 변경 사항의 경우에는 간단히 super 함수를 호출하여 null을 반환하게 하여 전체 재바인딩이 되도록 합니다.\n\n이렇게하면 이제 onBindViewHolder 함수에서 payloads 인수를 확인할 수 있습니다. 이 것은 여러 스레드에서 병합된 여러 업데이트가 될 수 있기 때문에 리스트 형태로 제공됩니다. 문서에서 언급된 것처럼요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각 리스트를 하나하나 처리할지 아니면 리스트에서 마지막 항목만 가져올지 결정할 수 있어요.\n\n우리 경우에는 마지막 항목을 확인하고, 만약 그것이 ArticleChangePayload.Comments 유형이라면 댓글 수 TextView를 업데이트하고, ArticleChangePayload.Bookmark 유형이라면 북마크 이미지 버튼을 업데이트할 거에요. 또한 페이로드가 비어 있거나 알 수 없는 유형인 경우를 처리하는 것이 중요해요. 그런 경우에는 원래의 onBindViewHolder(holder: ViewHolder, position: Int) 함수를 호출하여 완전히 다시 바인딩해야 해요. 이는 오버로드된 onBindViewHolder 함수의 기본 구현입니다.\n\n이 기능을 추가한 후에 이제 데이터가 변경된 부분만 뷰에 업데이트되고 깜박거림 효과가 없어졌다는 것을 확인할 수 있어요. 완벽해요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:640/1*OevReNMqnU9pngRAEUxmWQ.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그리고 여기에 업데이트된 어댑터 구현이 있습니다.\n\n## 결론\n\n저희는 DiffUtil, ListAdapter 및 payloads를 사용하여 RecyclerView 콘텐츠를 가장 효율적으로 업데이트하는 방법을 살펴보았습니다. 우리가 글 목록을 보여주는 앱을 가지고 있고 좋아요 수나 조회수를 자주 업데이트하려는 경우, payloads를 사용하면 전체 항목을 다시 부풀리고 다시 그리는 대신 변경된 뷰만 효율적으로 업데이트할 수 있습니다.\n\n샘플 앱의 소스 코드는 여기에서 확인할 수 있습니다: https://github.com/landomen/recyclerview-payloads-sample\n","ogImage":{"url":"/assets/img/2024-06-22-EfficientlyupdatingRecyclerViewitemsusingpayloads_0.png"},"coverImage":"/assets/img/2024-06-22-EfficientlyupdatingRecyclerViewitemsusingpayloads_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e요즘 대부분의 앱은 사용자에게 수직이나 수평 목록으로 정보를 표시합니다. 종종, 정보는 동적이며 조회수, 좋아요 수 등과 같이 자주 업데이트해야 하는 정보입니다. 또한 목록에는 네트워크에서 로드된 이미지가 포함될 수도 있습니다. 이것이 RecyclerView를 효율적으로 업데이트하는 것이 중요한 이유이며, 성능이 우수한 앱을 갖고 좋은 사용자 경험을 제공하는 중요한 측면입니다.\u003c/p\u003e\n\u003cp\u003e이 게시물은 얼마 전에 쓰여졌지만, 이미 다루어진 주제이고 Jetpack Compose가 현재 선호되는 UI 툴킷이기 때문에 발행할 지 말 지 고민하고 있었습니다. 그러나 이 정보가 누군가에게 도움이 될 수 있기를 바라며 게시하기로 결정했습니다.\u003c/p\u003e\n\u003ch2\u003eDiffUtil과 ListAdapter 사용하기\u003c/h2\u003e\n\u003cp\u003e새 데이터로 RecyclerView를 효율적으로 업데이트하려면 notifyItemInserted(position: Int), notifyItemChanged(position: Int), notifyItemRemoved(position: Int) 등과 같은 함수를 호출해야 합니다 (docs에서는 효율적이지 않으며 최후의 수단으로만 사용해야 한다고 명시한 notifyDataSetChanged()는 피하시기 바랍니다). 이러한 함수를 호출하면 RecyclerView Adapter에 기본 데이터가 변경되었음을 알리고 뷰를 업데이트하여 새 상태를 반영해야 한다는 사실을 알리게 됩니다. 이러한 함수 호출은 RecyclerView가 모든 변경 사항을 애니메이션으로 처리하는 이점도 함께 제공됩니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e수동으로 그 모든 작업을 하지 않도록 하기 위해 DiffUtil을 사용할 수 있습니다 (공식 문서). DiffUtil은 이전 데이터와 새 데이터를 비교하고 차이점을 계산한 다음 RecyclerView.Adapter에 변경 사항을 알려주어 새 상태를 반영하기 위해 수행해야 하는 변경 사항을 선언합니다. 이후 사용할 DiffUtil.ItemCallback의 예시가 여기 있습니다.\u003c/p\u003e\n\u003cp\u003eFunction areItemsTheSame(oldItem: Item, newItem: Item): Boolean은 id 또는 uuid와 같은 고유 속성을 기준으로 두 항목이 동일한지 확인합니다. 항목이 다를 경우 어댑터는 이전 항목을 새 항목으로 바꿔야 한다는 것을 알게 됩니다. 이 함수가 true를 반환하면 함수 areContentsTheSame(oldItem: Item, newItem: Item): Boolean이 호출되는데, 여기서 데이터 모델의 다른 속성 중 어떤 것이 변경되었는지 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e중요한 점은 DiffUtil 결과를 백그라운드 스레드에서 계산하는 것이 권장된다는 것입니다. 더 큰 데이터 집합이 있는 경우에는 요구가 많을 수 있고 주 스레드를 차단할 수 있기 때문입니다. Coroutine 또는 RxJava를 사용하여 계산을 다른 스레드로 옮기거나 ListAdapter(공식 문서)를 사용하여 백그라운드 스레드에서 계산할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eListAdapter는 AsyncListDiffer (공식 문서)를 사용하여 백그라운드 스레드에서 차이를 계산하는 논리를 포함하고 RecyclerView.Adapter를 확장하여 코드를 더욱 간결하게 만듭니다. 할 일은 새 데이터를 함수 submitList(list: List)를 사용하여 전달하는 것뿐입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e샘플 앱에서 모두 함께 사용해보기\u003c/h2\u003e\n\u003cp\u003e지금까지 배운 내용을 모아 간단한 앱으로 만들어보겠습니다. 이 앱은 기사 목록을 표시하는데, 각 기사에는 제목, 부제목, URL에서 로드된 표지 이미지, 좌측 하단에 표시되는 코멘트 수가 포함되어 있습니다. 사용자는 각 기사 오른쪽 상단의 북마크 버튼을 눌러 해당 기사를 즐겨찾기에 추가할 수도 있습니다. 툴바에는 두 개의 버튼이 있습니다. 코멘트 수를 업데이트하는 새로고침 버튼과 애니메이션 데모 목적으로 기사의 순서를 임의로 변경하는 재정렬 버튼입니다.\u003c/p\u003e\n\u003cp\u003e아래는 소스 코드와 앱이 동작하는 모습을 보여주는 동영상입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:640/1*kRBq0EXx36YlMoTCuulNuw.gif\" alt=\"앱 동작 예시\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우리는 재정렬 애니메이션이 원하는 대로 동작하는 것을 볼 수 있습니다. 그러나 사용자가 기사를 북마크하거나 댓글 수를 새로고침할 때의 애니메이션을 살펴보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:640/1*fWIvJ-K4PoONrlIZNzys1Q.gif\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e기사가 업데이트될 때 \"깜빡이\" 효과가 나타나는 이유는 무엇인가요?\u003c/h2\u003e\n\u003cp\u003e기본적으로 두 항목(우리의 경우 기사)이 동일하지만 다른 콘텐츠(우리의 경우 댓글 수 또는 기사 북마크 여부)를 가질 때 RecyclerView는 새 항목 보기를 렌더링한 다음 이전 항목 보기와 새 항목 보기 사이에 크로스 페이드를 수행하여 GIF에서 볼 수 있는 \"깜빡임\" 효과를 초래합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e특히 더 어두운 배경이 사용되거나 사용자 상호작용의 결과로 업데이트될 때 이 기능은 이상하게 보일 수 있습니다. 이는 북마크 또는 북마크 취소와 같은 사용자 상호작용으로 인한 업데이트가 발생할 때 더 문제가 됩니다.\u003c/p\u003e\n\u003ch2\u003e성능은 어떻게 해결할까요?\u003c/h2\u003e\n\u003cp\u003e\"깜빡\"이 발생하는 애니메이션 외에 다른 문제는 항목 뷰를 완전히 다시 바인딩한다는 점입니다. 이 방법은 효율적이지 않습니다. 우리는 댓글 수를 업데이트하거나 북마크 아이콘을 변경하기를 원할 뿐이지만, 대신 전체 항목 뷰를 다시 그리고 다시 렌더링하고 있습니다. 이는 이미 필요하지 않은 이미지를 다시로드 하는 것을 포함합니다.\u003c/p\u003e\n\u003ch2\u003e이 문제를 어떻게 해결할 수 있을까요?\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\"“RecyclerViewanimation”을 비활성화하는 방법을 검색 중이라면 나타나는 해결책 중 하나는 RecyclerView. itemAnimator에 supportsChangeAnimation = false를 설정하거나 itemAnimator = null로 설정하는 것입니다.\u003c/p\u003e\n\u003cp\u003e그러나 이 방법은 항목의 순서가 변경되거나 새 항목이 예전 항목을 대체할 때 발생하는 모든 애니메이션도 비활성화되어 우리가 원하는 대상이 아닐 수 있습니다. 우리는 기존 항목의 속성이 변경될 때 교차 페이드 애니메이션을 제외한 모든 애니메이션을 유지하고 싶습니다. 또한, 이 해결책은 우리가 언급한 효율성/성능 문제를 다루지 않습니다.\u003c/p\u003e\n\u003ch2\u003ePayloads\u003c/h2\u003e\n\u003cp\u003e페이로드를 사용하여 애니메이션 및 효율성 문제를 모두 해결할 수 있습니다. 페이로드는 이미 정의한 객체로, 이미 존재하는 항목 뷰를 완전히 다시 바인딩하는 대신 일부만 업데이트할 수 있게 해줍니다.\"\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eRecyclerView.Adapter의 함수들을 좀 더 자세히 살펴보면, onBindViewHolder(holder: ViewHolder, position: Int, payloads: MutableList\u003ccode\u003eAny\u003c/code\u003e)라는 추가 함수를 오버라이드할 수 있는데, 이 함수는 onBindViewHolder(holder: ViewHolder, position: Int) 함수를 오버로딩한 것으로 payloads라는 추가 인수가 있습니다. 이 함수에 대한 문서를 살펴보면 다음과 같이 설명되어 있습니다:\u003c/p\u003e\n\u003cp\u003e변화 페이로드를 어떻게 얻을 수 있을까요? DiffUtil.ItemCallback에서 사용 가능한 함수들을 좀 더 자세히 살펴보면 기존의 함수인 areItemsTheSame(oldItem: Item, newItem: Item): Boolean과 areContentsTheSame(oldtItem: Item, newItem: Item): Boolean 외에도 fun getChangePayload(oldItem: Item, newItem: Item): Any?라는 추가 함수를 오버라이드할 수 있습니다.\n이 함수는 이전 항목과 새 항목이 동일하지만 내용이 다른 경우 호출됩니다. 항목의 어떤 속성이 다른지 감지하고, 항목 뷰를 부분적으로 업데이트할 수 있는 객체를 반환할 수 있게 해줍니다.\u003c/p\u003e\n\u003cp\u003e여기서 우리는 이전 항목과 새 항목을 비교하고, 댓글 수가 다른 경우에는 ArticleChangePayload.Comments의 인스턴스를 반환하여 나중에 어떤 뷰를 업데이트해야 하는지 알 수 있게 합니다. 북마크 상태에 대해서도 동일한 작업을 수행하고, ArticleChangePayload.Bookmark를 반환합니다. 그리고 다른 변경 사항의 경우에는 간단히 super 함수를 호출하여 null을 반환하게 하여 전체 재바인딩이 되도록 합니다.\u003c/p\u003e\n\u003cp\u003e이렇게하면 이제 onBindViewHolder 함수에서 payloads 인수를 확인할 수 있습니다. 이 것은 여러 스레드에서 병합된 여러 업데이트가 될 수 있기 때문에 리스트 형태로 제공됩니다. 문서에서 언급된 것처럼요:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e각 리스트를 하나하나 처리할지 아니면 리스트에서 마지막 항목만 가져올지 결정할 수 있어요.\u003c/p\u003e\n\u003cp\u003e우리 경우에는 마지막 항목을 확인하고, 만약 그것이 ArticleChangePayload.Comments 유형이라면 댓글 수 TextView를 업데이트하고, ArticleChangePayload.Bookmark 유형이라면 북마크 이미지 버튼을 업데이트할 거에요. 또한 페이로드가 비어 있거나 알 수 없는 유형인 경우를 처리하는 것이 중요해요. 그런 경우에는 원래의 onBindViewHolder(holder: ViewHolder, position: Int) 함수를 호출하여 완전히 다시 바인딩해야 해요. 이는 오버로드된 onBindViewHolder 함수의 기본 구현입니다.\u003c/p\u003e\n\u003cp\u003e이 기능을 추가한 후에 이제 데이터가 변경된 부분만 뷰에 업데이트되고 깜박거림 효과가 없어졌다는 것을 확인할 수 있어요. 완벽해요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:640/1*OevReNMqnU9pngRAEUxmWQ.gif\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그리고 여기에 업데이트된 어댑터 구현이 있습니다.\u003c/p\u003e\n\u003ch2\u003e결론\u003c/h2\u003e\n\u003cp\u003e저희는 DiffUtil, ListAdapter 및 payloads를 사용하여 RecyclerView 콘텐츠를 가장 효율적으로 업데이트하는 방법을 살펴보았습니다. 우리가 글 목록을 보여주는 앱을 가지고 있고 좋아요 수나 조회수를 자주 업데이트하려는 경우, payloads를 사용하면 전체 항목을 다시 부풀리고 다시 그리는 대신 변경된 뷰만 효율적으로 업데이트할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e샘플 앱의 소스 코드는 여기에서 확인할 수 있습니다: \u003ca href=\"https://github.com/landomen/recyclerview-payloads-sample\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/landomen/recyclerview-payloads-sample\u003c/a\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-EfficientlyupdatingRecyclerViewitemsusingpayloads"},"buildId":"-dPCbnM2yhdKNgXe92VJV","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>