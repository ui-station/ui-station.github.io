<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Coroutines, RxJava, Executor 뭐가 더 빠를까 각 작업별 성능 비교 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Coroutines, RxJava, Executor 뭐가 더 빠를까 각 작업별 성능 비교 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Coroutines, RxJava, Executor 뭐가 더 빠를까 각 작업별 성능 비교 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor" data-gatsby-head="true"/><meta name="twitter:title" content="Coroutines, RxJava, Executor 뭐가 더 빠를까 각 작업별 성능 비교 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 01:21" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_buildManifest.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Coroutines, RxJava, Executor 뭐가 더 빠를까 각 작업별 성능 비교</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Coroutines, RxJava, Executor 뭐가 더 빠를까 각 작업별 성능 비교" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">30<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>저는 가끔 다중 스레딩 프레임워크 중 어떤 것이 제일 빠른지 궁금했던 적이 있었어요. 어느 날 운명이 저를 이 질문을 조사하도록 이끌었죠. 만약 여러분도 궁금하시다면, 전 테스트를 해보고 비교한 결과를 여러분과 공유해 보았습니다.</p>
<h1>문제</h1>
<p>우선, 왜 이를 해보게 되었는지부터 알아봅시다. 제게는 간단한 작업이 있었어요: 수백 개의 콜백을 호출하는 시스템이 있었죠. 모든 콜백은 가능한 빨리 완료되어야 했죠.</p>
<p></p>
<p>각 콜백에 소요되는 복잡성이나 시간을 알지 못했어요. 콜백은 객체를 생성하거나 서버나 데이터베이스에 긴 요청을 할 수도 있어요. 이 경우에는 데이터베이스나 서버에 요청하기 때문에 멀티스레딩을 사용해야 하죠.</p>
<p>이 문제를 해결하려고 할 때, 어떤 상황에서 어떤 멀티스레딩 프레임워크가 더 빠른지 정확히 모르는 것을 깨달았어요.</p>
<h1>동기부여</h1>
<p>하지만 당장 떠오르는 질문이 있죠: "아직 아무도 테스트해보지 않은 건가요?" 의외로 제 요구사항을 충족시키는 테스트를 찾을 수 없었어요.</p>
<p></p>
<p>일부 테스트는 Rx 대 Coroutines와 같이 두 기술 간의 간단한 비교였습니다. 다른 일부는 내 의견으로는 너무 구체적한 테스트 케이스를 가졌는데, 예를 들어 산술 연산이나 데이터베이스 요청만을 테스트하는 것 등이 그러했습니다.</p>
<p>어쨌든, 이에 대해 매우 만족스럽지 않았고 나만의 테스트를 하기로 결정했습니다.</p>
<p>멀티스레드 프레임워크의 모든 사용 사례를 커버할 수는 없다는 것은 합리적입니다. 내 작업과 관련이 있는 것들만 테스트할 것입니다... 그래서 이게 완벽한 테스트가 아니지만 꽤 철저할 것입니다.</p>
<h1>도구</h1>
<p></p>
<p>측정 도구로 시작해 봅시다. 안드로이드 개발자이기 때문에 안드로이드 도구를 사용하겠습니다. 이론적으로는 컴퓨터에서 JVM에서 멀티스레딩 테스트를 실행하는 것이 안드로이드 장치에서 실행하는 것과 다를 수 있지만, 실제로는 큰 차이가 없으며 전체 테스트 결과에 영향을 미치지 않습니다.</p>
<p>그리고 안드로이드 장치에서 코드 성능을 테스트하기 위해 사용할 수 있는 Jetpack Microbenchmark 도구가 있습니다.</p>
<p>Microbenchmark 측정 테스트는 보통의 인스트루먼테이션 테스트와 유사하지만, 차이점은 BenchmarkRule이라는 특정 Rule을 사용한다는 것뿐입니다.</p>
<pre><code class="hljs language-js">@<span class="hljs-attr">get</span>:<span class="hljs-title class_">Rule</span>
val benchmarkRule = <span class="hljs-title class_">BenchmarkRule</span>()

@<span class="hljs-title class_">Test</span>
fun <span class="hljs-title function_">sampleTest</span>(<span class="hljs-params"></span>) {
   benchmarkRule.<span class="hljs-property">measureRepeated</span> {
       <span class="hljs-comment">// 여기에서 측정할 것입니다</span>
   }
}
</code></pre>
<p></p>
<p>결과적으로 실행에 대한 정보가 포함된 JSON을 얻게 됩니다: 최소 및 최대 시간, 그리고 가장 중요한 중앙값 시간.</p>
<pre><code class="hljs language-js">    <span class="hljs-string">"benchmarks"</span>: [
        {
            <span class="hljs-string">"name"</span>: <span class="hljs-string">"sampleTest"</span>,
            <span class="hljs-string">"params"</span>: {},
            <span class="hljs-string">"className"</span>: <span class="hljs-string">"com.test.benchmark.ExampleBenchmark"</span>,
            <span class="hljs-string">"totalRunTimeNs"</span>: <span class="hljs-number">85207217833</span>,
            <span class="hljs-string">"metrics"</span>: {
                <span class="hljs-string">"timeNs"</span>: {
                    <span class="hljs-string">"minimum"</span>: <span class="hljs-number">9.82149833E8</span>,
                    <span class="hljs-string">"maximum"</span>: <span class="hljs-number">1.019338584E9</span>,
                    <span class="hljs-string">"median"</span>: <span class="hljs-number">1.004151917E9</span>,
                    <span class="hljs-string">"runs"</span>: [...]
                },
                <span class="hljs-string">"allocationCount"</span>: {
                    <span class="hljs-string">"minimum"</span>: <span class="hljs-number">324.0</span>,
                    <span class="hljs-string">"maximum"</span>: <span class="hljs-number">324.0</span>,
                    <span class="hljs-string">"median"</span>: <span class="hljs-number">324.0</span>,
                    <span class="hljs-string">"runs"</span>: [...]
                }
            },
            <span class="hljs-string">"sampledMetrics"</span>: {},
            <span class="hljs-string">"warmupIterations"</span>: <span class="hljs-number">3200</span>,
            <span class="hljs-string">"repeatIterations"</span>: <span class="hljs-number">5000</span>,
            <span class="hljs-string">"thermalThrottleSleepSeconds"</span>: <span class="hljs-number">0</span>
        }
    ]
</code></pre>
<p>이 JSON은 반복 횟수, 객체 할당 횟수 등을 포함한 기타 정보를 담고 있습니다. 현재는 이것이 우선 순위가 아닙니다.</p>
<h1>벤치마크 테스트 케이스</h1>
<p></p>
<p>프레임워크 간 주요 차이점은:</p>
<ul>
<li>단일 스레드 생성에 소요되는 시간</li>
<li>프레임워크가 작업을 효율적이고 빠르게 스레드 간에 분배할 수 있는 능력</li>
</ul>
<p>우리는 이러한 프레임워크 간 차이를 평가하기 위해 테스트 케이스 결과를 탐색할 것입니다.</p>
<p>이제 우리는 무엇을 테스트하고 싶은지 결정해야 합니다. 테스트 데이터부터 시작해봅시다.</p>
<p></p>
<h1>테스트 데이터</h1>
<p>별거 아닌 거에요. 0부터 99까지 범위의 100개 항목을 포함하는 ArrayList를 만들어봤어요.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createTestList</span><span class="hljs-params">()</span></span>: List&#x3C;<span class="hljs-built_in">Int</span>> {
   <span class="hljs-keyword">return</span> List(<span class="hljs-number">100</span>) { it }
}
</code></pre>
<p>그런 다음 각 항목에 대해 몇 가지 작업을 수행할 거예요.</p>
<p></p>
<p>이제 테스트 케이스를 살펴보겠습니다.</p>
<h1>단일 스레드</h1>
<p>단일 스레드 테스트 케이스부터 시작해 보죠. 이러한 테스트 케이스의 결과를 비교할 때는 프레임워크가 단일 스레드를 생성하는 데 걸리는 시간을 주의 깊게 살펴볼 것입니다. 하나의 스레드만 있는 경우, 프레임워크가 스레드를 초기화하고 생성하는 데 걸리는 시간을 확인할 수 있습니다.</p>
<h2>직접 호출</h2>
<p></p>
<p>첫 번째 테스트 케이스는 간단히 메서드를 직접 호출하는 것입니다. 어떤 프레임워크도 사용하지 않습니다.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">directInvoke</span><span class="hljs-params">()</span></span> {
   <span class="hljs-keyword">val</span> list = createTestList()
   benchmarkRule.measureRepeated {
       list.forEach { action(it) }
   }
}
</code></pre>
<h2>RxJava</h2>
<p>두 번째 테스트 케이스는 Rx입니다. Completable 내에서 작업을 수행할 것입니다. 각 작업에 대해 별도의 Completable이 생성될 것입니다. Scheduler는 모든 작업이 단일 스레드에서 실행되도록 보장하는 Scheduler.single이 될 것입니다.</p>
<p></p>
<p>그리고 작업 완료를 기다려야 하기 때문에 결과 Completable에서 blockingAwait를 호출합니다.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">rxOne</span><span class="hljs-params">()</span></span> {
   <span class="hljs-keyword">val</span> list = createTestList()
   <span class="hljs-keyword">val</span> scheduler = Schedulers.single()
   benchmarkRule.measureRepeated {
       <span class="hljs-keyword">val</span> completables = list.map {
           Completable.fromAction {
               action(it)
           }.subscribeOn(scheduler)
       }
       Completable.merge(completables).blockingAwait()
   }
}
</code></pre>
<h2>코틀린 코루틴</h2>
<p>어딜 가나 젊고 유망한 코틀린 코루틴 프레임워크가 없었던 우리들이 어디에 있겠어요? 코루틴이 실행될 때까지 기다리려면 async를 통해 작업을 실행하고 완료를 기다리기 위해 await을 사용합니다. 따라서 각 작업을 위한 별도의 코루틴이 있을 것입니다. 모든 것을 단일 스레드에서 실행하도록 하려면 단순히 runBlocking을 사용하면 됩니다.</p>
<p></p>
<pre><code class="hljs language-kt"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">coroutineOne</span><span class="hljs-params">()</span></span> {
   <span class="hljs-keyword">val</span> list = createTestList()
   benchmarkRule.measureRepeated {
       runBlocking {
           list.map {
               async {
                   action(it)
               }
           }.forEach { it.await() }
       }
   }
}
</code></pre>
<h2>Kotlin Flow</h2>
<p>Flow에서 비교해보겠습니다. 코루틴과 Rx를 직접적으로 비교하는 것은 좋은 방법이 아닐 수 있습니다. 둘 다 다른 방식으로 사용되고 다른 개념을 적용하기 때문에 멀티쓰레딩과 관련이 있다고 해도 다릅니다.</p>
<p>각 액션에 대한 Flow를 생성하고 모두 결합한 다음 간단히 수집합니다. 각 액션에 대해 별도의 Flow가 있을 것입니다. 한편, 디스패처를 어디에도 지정하지 않았기 때문에 모든 작업이 동일한 스레드에서 수행됩니다.</p>
<p></p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">flowOne</span><span class="hljs-params">()</span></span> {
   <span class="hljs-keyword">val</span> list = createTestList()
   benchmarkRule.measureRepeated {
       runBlocking {
           <span class="hljs-keyword">val</span> flows = list.map {
               flow {
                   <span class="hljs-keyword">val</span> result = action(it)
                   emit(result)
               }
           }
           flows.merge().collect()
       }
   }
}
</code></pre>
<h1>스레드 수는 CPU 스레드 수와 같음</h1>
<p>물론, 한 스레드만 사용하는 것은 최선의 선택처럼 보이지 않습니다. 왜냐하면 멀티스레딩을 위한 프레임워크가 있기 때문이죠.</p>
<p>스레드 풀에 있는 스레드 수가 CPU 스레드 수와 같은 상황을 고려해 봅시다. 이상적으로는 이러한 테스트 케이스의 결과를 비교하여 두 번째 차이(프레임워크가 작업을 효율적으로 빠르게 스레드 간에 분배하는 능력)를 볼 수 있습니다. 각 작업에 대해 충분한 스레드가 없기 때문에 프레임워크가 그런 작업들을 어쨌든 분배해야 하게 될 것입니다.</p>
<p></p>
<p>프로세서 코어 간 작업의 균등한 분배를 기대해서는 안 됩니다. 운영 체제와 CPU가 결정하는 것은:</p>
<ul>
<li>무엇이 실행되는지,</li>
<li>언제 실행되는지,</li>
<li>누가 실행하는지입니다.</li>
</ul>
<p>현대의 "큰" CPU는 SMT/HyperThreading을 사용하여 각 CPU 코어마다 여러 논리 스레드를 생성할 수 있습니다. CPU 코어는 독립적으로 명령을 실행할 수 있는 물리적 단위입니다. 반면 스레드는 한 코어에서 실행할 수 있는 논리적 소프트웨어 단위입니다. 또한 이동형 CPU와 최신 인텔 CPU는 다양한 유형의 CPU 코어를 사용합니다. 대형 코어는 복잡한 작업에 적합하며, 중형 및 절전 코어는 성능에서 상당히 차이가 있습니다.</p>
<p>그래서, 우리는 이 풀을 적은 수의 스레드를 갖는 풀로 간주할 수 있습니다.</p>
<p></p>
<p>CPU 쓰레드 수를 결정하는 훌륭한 방법이 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Runtime</span>.<span class="hljs-title function_">getRuntime</span>().<span class="hljs-title function_">availableProcessors</span>();
</code></pre>
<p>제 테스트 기기에서는 이 값이 여덟이에요.</p>
<h2>RxJava</h2>
<p></p>
<p>Rx를 시작해보겠습니다. Rx에는 원하는 동작을 구현하는 Scheduler.Computation이 있어요. 사실 코드는 단일 스레드를 사용할 때와 똑같이 유지됩니다. 유일한 차이점은 각 개별 Completable에 대해 Scheduler.computation()을 사용하여 subscribeOn을 만든다는 것이에요.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">rxCPU</span><span class="hljs-params">()</span></span> {
   <span class="hljs-keyword">val</span> list = createTestList()
   <span class="hljs-keyword">val</span> scheduler = Schedulers.computation()
   benchmarkRule.measureRepeated {
       <span class="hljs-keyword">val</span> completables = list.map {
           Completable.fromAction {
               action(it)
           }.subscribeOn(scheduler)
       }
       Completable.merge(completables).blockingAwait()
   }
}
</code></pre>
<h2>Kotlin 코루틴</h2>
<p>이제 코루틴을 살펴보죠. Dispatchers.Default라는 것을 가지고 있어요. 해당 문서에는:</p>
<p></p>
<p>기본적으로 "병렬성"의 최대 수준은 CPU 코어 수와 동일합니다. 우리가 필요한 것이 바로 그겁니다.</p>
<p>코드는 싱글 코어 버전과 유사합니다. 이제 액션들은 Dispatchers.Default 내부에서 withContext를 사용하여 실행됩니다.</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Test</span>
fun <span class="hljs-title function_">coroutineCPU</span>(<span class="hljs-params"></span>) {
   val list = <span class="hljs-title function_">createTestList</span>()
   val dispatcher = <span class="hljs-title class_">Dispatchers</span>.<span class="hljs-property">Default</span>
   benchmarkRule.<span class="hljs-property">measureRepeated</span> {
       runBlocking {
           list.<span class="hljs-property">map</span> {
               <span class="hljs-keyword">async</span> {
                   <span class="hljs-title function_">withContext</span>(<span class="hljs-params">dispatcher</span>) {
                       <span class="hljs-title function_">action</span>(it)
                   }
               }
           }.<span class="hljs-property">forEach</span> { it.<span class="hljs-title function_">await</span>() }
       }
   }
}
</code></pre>
<p>하지만 중요한 세부 사항이 있습니다... Dispatchers.Default를 좀 더 자세히 살펴보면이 생성자를 찾을 수 있습니다.</p>
<p></p>
<pre><code class="hljs language-kotlin">내부 객체 DefaultScheduler는 SchedulerCoroutineDispatcher를 상속합니다(
   CORE_POOL_SIZE, MAX_POOL_SIZE,
   IDLE_WORKER_KEEP_ALIVE_NS, DEFAULT_SCHEDULER_NAME
)
</code></pre>
<p>CPU 스레드 수인 CORE_POOL_SIZE와 MAX_POOL_SIZE(이 경우 200만이라고합니다) 두 개의 상수를 전달하는 것이 의심스럽습니다.</p>
<p>더 자세히 조사해보니 이러한 변수들은 CoroutineScheduler를 만들기 위해 사용된다는 것을 알 수 있습니다.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createScheduler</span><span class="hljs-params">()</span></span> = CoroutineScheduler(
   corePoolSize, maxPoolSize, idleWorkerKeepAliveNs, schedulerName
)
</code></pre>
<p></p>
<p>그리고 문서에는 다음과 같이 나와 있습니다:</p>
<p>그래서 Dispatchers.Default는 CPU 스레드 수에 제한 받지 않습니다.</p>
<p>Dispatchers.Default와 Scheduler.Computation을 직접 비교하는 것은 잘못된 접근입니다. 경우에 따라 Dispatchers.Default는 추가적인 스레드를 사용할 수 있습니다. 다행히 문서는 비교를 더 공정하게 하기 위한 정보도 제공합니다. 단순히 LimitingDispatcher를 사용하면 됩니다. 이를 위해 Dispatchers.Default의 limitedParallelism 메서드를 CPU 스레드 수와 함께 호출하면 됩니다.</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Test</span>
fun <span class="hljs-title function_">coroutineCPULimit</span>(<span class="hljs-params"></span>) {
   val list = <span class="hljs-title function_">createTestList</span>()
   val threadCount = <span class="hljs-title class_">Runtime</span>.<span class="hljs-title function_">getRuntime</span>().<span class="hljs-title function_">availableProcessors</span>()
   val dispatcher = <span class="hljs-title class_">Dispatchers</span>.<span class="hljs-property">Default</span>.<span class="hljs-title function_">limitedParallelism</span>(threadCount)
   benchmarkRule.<span class="hljs-property">measureRepeated</span> {
       runBlocking {
           list.<span class="hljs-property">map</span> {
               <span class="hljs-keyword">async</span> {
                   <span class="hljs-title function_">withContext</span>(<span class="hljs-params">dispatcher</span>) {
                       <span class="hljs-title function_">action</span>(it)
                   }
               }
           }.<span class="hljs-property">forEach</span> { it.<span class="hljs-title function_">await</span>() }
       }
   }
}
</code></pre>
<p></p>
<h2>코틀린 Flow</h2>
<p>flow에 대해 동일한 작업을 합시다. Dispatchers.Default를 사용하세요.</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Test</span>
fun <span class="hljs-title function_">flowCPU</span>(<span class="hljs-params"></span>) {
   val list = <span class="hljs-title function_">createTestList</span>()
   val dispatcher = <span class="hljs-title class_">Dispatchers</span>.<span class="hljs-property">Default</span>
   benchmarkRule.<span class="hljs-property">measureRepeated</span> {
       runBlocking {
           val flows = list.<span class="hljs-property">map</span> {
               flow {
                   val result = <span class="hljs-title function_">action</span>(it)
                   <span class="hljs-title function_">emit</span>(result)
               }.<span class="hljs-title function_">flowOn</span>(dispatcher)
           }
           flows.<span class="hljs-title function_">merge</span>().<span class="hljs-title function_">collect</span>()
       }
   }
}
</code></pre>
<p>그리고 제한을 두고 Dispatchers.Default를 사용하세요.</p>
<p></p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Test</span>
fun <span class="hljs-title function_">flowCPULimit</span>(<span class="hljs-params"></span>) {
   val list = <span class="hljs-title function_">createTestList</span>()
   val threadCount = <span class="hljs-title class_">Runtime</span>.<span class="hljs-title function_">getRuntime</span>().<span class="hljs-title function_">availableProcessors</span>()
   val dispatcher = <span class="hljs-title class_">Dispatchers</span>.<span class="hljs-property">Default</span>.<span class="hljs-title function_">limitedParallelism</span>(threadCount)
   benchmarkRule.<span class="hljs-property">measureRepeated</span> {
       runBlocking {
           val flows = list.<span class="hljs-property">map</span> {
               flow {
                   val result = <span class="hljs-title function_">action</span>(it)
                   <span class="hljs-title function_">emit</span>(result)
               }.<span class="hljs-title function_">flowOn</span>(dispatcher)
           }
           flows.<span class="hljs-title function_">merge</span>().<span class="hljs-title function_">collect</span>()
       }
   }
}
</code></pre>
<h2>Java Executor</h2>
<p>코루틴의 모든 복잡성을 탐구해야 했기 때문에, 이러한 복잡성을 사용해볼까요? 따라서 Executor를 사용해보려고 합니다.</p>
<p>먼저, Executors.newFixedThreadPool을 사용하여 Executor를 생성해 보겠습니다. 이렇게 함으로써, 단순히 쓰레드 수로 제한된 Executor가 생성되며, 우리의 경우에는 CPU 코어의 수입니다.</p>
<p></p>
<p>measureRepeated 메소드 이전에 Executor를 생성하니 Executor를 만드는 것은 쉬운 작업이 아닙니다. 그런 다음, 작업을 수행하는 Executor에서 submit을 호출합니다. 완료를 기다리기 위해 get 메소드를 사용해 보겠습니다.</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Test</span>
fun <span class="hljs-title function_">executorFixedCPU</span>(<span class="hljs-params"></span>) {
   val list = <span class="hljs-title function_">createTestList</span>()
   val threadCount = <span class="hljs-title class_">Runtime</span>.<span class="hljs-title function_">getRuntime</span>().<span class="hljs-title function_">availableProcessors</span>()
   val executorService = <span class="hljs-title class_">Executors</span>.<span class="hljs-title function_">newFixedThreadPool</span>(threadCount)
   benchmarkRule.<span class="hljs-property">measureRepeated</span> {
       val futures = list.<span class="hljs-property">map</span> { executorService.<span class="hljs-property">submit</span> { <span class="hljs-title function_">action</span>(it) } }
       futures.<span class="hljs-property">forEach</span> { it.<span class="hljs-title function_">get</span>() }
   }
}
</code></pre>
<p>Executors.newWorkStealingPool 메소드를 사용하여 관심 있는 두 번째 유형의 Executor를 생성할 것입니다. 실제로, 이 또한 제한된 수의 스레드로 Executor를 생성합니다. 그러나 메소드 이름에 "Stealing"이 포함된 것은 우연이 아닙니다. 이 Executor의 스레드는 현재 스레드가 비어 있어 다른 스레드에게 큐에 대기 중인 작업이 있는 경우 현재 스레드가 idle 상태가 되었을 때 다른 스레드로부터 작업을 훔칠 수 있습니다. 이는 최종적으로 공통 큐를 비울 수 있도록 도와줄 수 있습니다.</p>
<p>코드적으로는 이전과 동일합니다. 단, Executor를 만드는 방법이 다를 뿐입니다.</p>
<p></p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">executorStealCPU</span><span class="hljs-params">()</span></span> {
   <span class="hljs-keyword">val</span> list = createTestList()
   <span class="hljs-keyword">val</span> threadCount = Runtime.getRuntime().availableProcessors()
   <span class="hljs-keyword">val</span> executorService = Executors.newWorkStealingPool(threadCount)
   benchmarkRule.measureRepeated {
       <span class="hljs-keyword">val</span> futures = list.map { executorService.submit { action(it) } }
       futures.forEach { it.<span class="hljs-keyword">get</span>() }
   }
}
</code></pre>
<h1>각 작업에 대한 스레드</h1>
<p>이제 거의 무제한(실제로는 많은 수, 많다고 할 정도)으로 스레드를 할당하는 가능성을 탐색해 보겠습니다. 100개의 작업만 있기 때문에 100개의 스레드를 할당할 수 있습니다. 더 이상 필요하지 않습니다.</p>
<h2>RxJava</h2>
<p></p>
<p>Rx를 시작합니다. Scheduler.io는 이러한 역할을 맡습니다. Scheduler.io에는 스레드 캐시가 있습니다. 사용 가능한 빈 스레드가 있다면 캐시에서 하나를 가져옵니다. 그렇지 않으면 새로운 스레드를 생성합니다. 코드는 Scheduler.computation과 동일하지만 다른 스케줄러를 사용합니다.</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Test</span>
fun <span class="hljs-title function_">rxIo</span>(<span class="hljs-params"></span>) {
   val list = <span class="hljs-title function_">createTestList</span>()
   val scheduler = <span class="hljs-title class_">Schedulers</span>.<span class="hljs-title function_">io</span>()
   benchmarkRule.<span class="hljs-property">measureRepeated</span> {
       val completables = list.<span class="hljs-property">map</span> {
           <span class="hljs-title class_">Completable</span>.<span class="hljs-property">fromAction</span> {
               <span class="hljs-title function_">action</span>(it)
           }.<span class="hljs-title function_">subscribeOn</span>(scheduler)
       }
       <span class="hljs-title class_">Completable</span>.<span class="hljs-title function_">merge</span>(completables).<span class="hljs-title function_">blockingAwait</span>()
   }
}
</code></pre>
<h2>Kotlin 코루틴</h2>
<p>코루틴에서 유사한 작업은 Dispatchers.IO의 책임이므로 익숙한 코드에 삽입하기만 하면 됩니다.</p>
<p></p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">coroutineIo</span><span class="hljs-params">()</span></span> {
   <span class="hljs-keyword">val</span> list = createTestList()
   <span class="hljs-keyword">val</span> dispatcher = Dispatchers.IO
   benchmarkRule.measureRepeated {
       runBlocking {
           list.map {
               async {
                   withContext(dispatcher) {
                       action(it)
                   }
               }
           }.forEach { it.await() }
       }
   }
}
</code></pre>
<h2>Kotlin Flow</h2>
<p>Repeat the same for Flow.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">flowIo</span><span class="hljs-params">()</span></span> {
   <span class="hljs-keyword">val</span> list = createTestList()
   <span class="hljs-keyword">val</span> dispatcher = Dispatchers.IO
   benchmarkRule.measureRepeated {
       runBlocking {
           <span class="hljs-keyword">val</span> flows = list.map {
               flow {
                   <span class="hljs-keyword">val</span> result = action(it)
                   emit(result)
               }.flowOn(dispatcher)
           }
           flows.merge().collect()
       }
   }
}
</code></pre>
<p></p>
<h2>자바 Executor</h2>
<p>안타깝게도 Executor는 그다지 좋은 API가 없어요. 따라서 우리는 그에게 100개의 스레드를 할당할 거예요. 100개의 작업만 있으면 충분하니까 더 많이 필요하지 않을 거에요.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">executorFixedIo</span><span class="hljs-params">()</span></span> {
   <span class="hljs-keyword">val</span> list = createTestList()
   <span class="hljs-keyword">val</span> executorService = Executors.newFixedThreadPool(<span class="hljs-number">100</span>)
   benchmarkRule.measureRepeated {
       <span class="hljs-keyword">val</span> futures = list.map { executorService.submit { action(it) } }
       futures.forEach { it.<span class="hljs-keyword">get</span>() }
   }
}
</code></pre>
<p>newWorkStealingPool도 같은 방식으로 할 거에요.</p>
<p></p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">executorStealIo</span><span class="hljs-params">()</span></span> {
   <span class="hljs-keyword">val</span> list = createTestList()
   <span class="hljs-keyword">val</span> executorService = Executors.newWorkStealingPool(<span class="hljs-number">100</span>)
   benchmarkRule.measureRepeated {
       <span class="hljs-keyword">val</span> futures = list.map { executorService.submit { action(it) } }
       futures.forEach { it.<span class="hljs-keyword">get</span>() }
   }
}
</code></pre>
<p>이것은 모든 테스트 케이스를 프레임워크별로 나열한 표입니다.</p>
<p>그리고 마지막으로, 테스트를 실행합니다.</p>
<p></p>
<h1>테스트</h1>
<p>하하, 조금 속았죠. 먼저, 행동의 카테고리를 고려해 봅시다.</p>
<p>이 중에 단 5가지가 있습니다:</p>
<ul>
<li>산술 — 간단한 산술 연산;</li>
<li>listsManipulation — 객체 조작;</li>
<li>저장 — 저장소와의 작업 시뮬레이션;</li>
<li>네트워크 — 네트워크와의 작업 시뮬레이션;</li>
<li>혼합 — 이전 스크립트 모두의 조합, 원본 작업에서 행동의 복잡성을 알 수 없기 때문에.</li>
</ul>
<p></p>
<p>간단한 것부터 시작해 봅시다.</p>
<h1>산술</h1>
<p>제가 여러분에게 상기시키고 싶은 점은 0부터 99까지의 각 항목에 대해 작업을 수행할 것이라는 것입니다. 이 경우 연산을 조금 더 복잡하게 만들기 위해 숫자를 Float로 변환하고 해당 숫자를 그 자신의 값의 제곱으로 올립니다. 0의 제곱부터 99의 제곱까지입니다. 물론 어느 시점에서는 Float의 한계에 도달하겠지만, 괜찮습니다.</p>
<pre><code class="hljs language-js">private fun <span class="hljs-title function_">arithmetic</span>(<span class="hljs-attr">seed</span>: <span class="hljs-title class_">Int</span>): <span class="hljs-title class_">Int</span> {
   <span class="hljs-keyword">return</span> seed.<span class="hljs-title function_">toFloat</span>().<span class="hljs-title function_">pow</span>(seed.<span class="hljs-title function_">toFloat</span>()).<span class="hljs-title function_">toInt</span>()
}
</code></pre>
<p></p>
<p>일반적으로, 이 범주로 분류할 수 있는 작업에는 생성자를 사용하여 객체를 생성하거나 속성에 액세스하는 것이 포함됩니다. 이러한 작업은 완료하는 데 오랜 시간이 걸리지 않습니다.</p>
<p>결과는 무엇인가요?</p>
<p><img src="/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_2.png" alt="그림"></p>
<p>예상대로, directInvoke가 최고의 결과를 보였습니다. 가장 가까운 경쟁 상대보다 70배 빨랐습니다. 이는 이러한 작업이 매우 간단하며 멀티스레딩 프레임워크를 사용하는 데 추가적인 오버헤드가 작업 자체 비용의 10배 더 높을 수 있다는 이치를 따랐기 때문입니다.</p>
<p></p>
<p>그러나 뜻밖의 충격은 두 번째와 세 번째 자리에서 일어났습니다. 두 자리 다 Executors로 고정된 스레드 수를 가진 것들이었어요. 처음에는 directInvoke가 제일일 것으로 예상했는데, 그 다음에는 단일 스레드의 테스트 케이스, 그리고 CPU, 그리고 마지막으로 IO가 실행될 것으로 기대했어요. 그런데 고정된 스레드 수를 가진 Executors가 이러한 로직을 완전히 무너뜨리는 모습을 볼 수 있었어요. 한편으로는 Executors.newWorkStealingPool을 이용하여 만든 Executor는 "무한" 스레드 수를 가질 때 성능이 더 좋아 보입니다.</p>
<p>Dispatchers.Default를 한정하고 한정하지 않았을 때의 시간이 다른 것을 볼 수 있습니다. 그래서 한정을 한 이유가 있습니다.</p>
<p>하나의 동작을 처리하는 데 가장 많은 오버헤드를 가진 것은 Flow입니다. 모든 경쟁자들보다 느립니다. 그리고 코루틴은 한 스레드에서 Rx보다 나은 경우가 있지만, 스레드 수가 증가할수록 Rx가 선두 주자로 우뚝 서는 것을 볼 수 있습니다.</p>
<p>요약하면, 이 카테고리의 동작에서 directInvoke가 가장 효과적임을 알 수 있습니다. 따라서 이러한 작업에는 멀티스레딩 프레임워크를 사용하지 않는 것이 더 나은 방법입니다. 대신에 하나의 스레드나 적은 수의 스레드를 가진 풀을 사용하세요.</p>
<p></p>
<h1>리스트 조작</h1>
<p>자, 이제 더 복잡한 내용을 살펴보겠습니다 — 객체 조작입니다. 객체를 리스트에 추가하면 객체를 다루기가 더 쉬워집니다. 이 카테고리의 작업에는 예를 들어 POJO 매핑이 포함될 수 있습니다.</p>
<p>작업 내에서 우리는 매개변수로 받은 숫자와 같은 크기를 갖는 새로운 리스트를 만들기만 하면 됩니다. 다음으로 몇 가지 작업을 수행하고, 리스트를 맵으로 변환한 다음 다시 몇 가지 작업을 수행한 후 이 컬렉션을 필터링합니다... 일반적으로 리스트를 조작합니다.</p>
<p>이곳에서의 복잡성 기본은 실제 작업 그 자체가 아닙니다. 이것은 정규 불변 리스트이며, 시퀀스가 아닙니다. 이것은 각 작업 후 새로운 리스트가 생성된다는 것을 의미합니다.</p>
<p></p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">listsManipulation</span><span class="hljs-params">(seed: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> {
    List(seed) { it }
        .map { it.toFloat() }
        .map { it + <span class="hljs-number">0.3f</span> }
        .associateBy { it.toString() }
        .mapValues { it.value * it.value }
        .filter { it.value > <span class="hljs-number">5f</span> }
    <span class="hljs-keyword">return</span> seed
}
</code></pre>
<p>어땠어요?</p>
<p><img src="/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_3.png" alt="image"></p>
<p>directInvoke는 빠르게 선두에서 물러났어요. 객체 조작 같은 기본 작업조차 어려움이 있군요.</p>
<p></p>
<p>Executor를 생성하여 리드가 됩니다. Executors.newWorkStealingPool을 사용하면 더 효율적입니다. 간단한 대안인 Executors.newFixedThreadPool보다 더욱 효율적입니다.</p>
<p>Rx는 조금 앞으로 나아갑니다. 앞에는 Scheduler.computation이 있습니다. 원칙적으로 이 작업에 대한 우선 선택지입니다. 왜냐하면 더 적은 자원을 사용하기 때문입니다.</p>
<p>단일 스레드 테스트 케이스는 목록의 끝에 있지만, directInvoke는 여전히 중간에 남아 있습니다.</p>
<p>flowCPU와 coroutineCPU는 목록의 맨 아래에 있습니다. 이러한 테스트 케이스들은 CPU 코어의 수와 같은 수의 스레드를 가지고 있으며 제한이 없습니다. 테스트를 다시 실행했지만 결과는 동일했습니다. 버그가 있을 수 있다고 생각하여 코루틴을 업데이트했지만 변한 점은 없습니다.</p>
<p></p>
<p>총론적으로, 이 복잡성 수준에서 CPU 테스트 케이스가 실행 시간 측면에서 IO보다 빠릅니다.</p>
<h1>저장공간</h1>
<p>데이터베이스나 작은 파일에 액세스하는 것은 블로킹 작업이기 때문에 단순히 스레드를 휴면 상태로 두기만 하면 됩니다. 휴면 시간은 500에서 1,490 마이크로초 또는 0.5에서 1.5 밀리초 사이입니다. 그러나 흔한 Thread.sleep 메서드는 "바쁜 대기(busy waiting)"로 인해 정확하지 않은 결과를 나타냅니다. 그래서 LockSupport.parkNanos를 사용하여 스레드를 휴면 상태로 만들겠습니다.</p>
<pre><code class="hljs language-js">private fun <span class="hljs-title function_">storage</span>(<span class="hljs-attr">seed</span>: <span class="hljs-title class_">Int</span>): <span class="hljs-title class_">Int</span> {
   val timeInMicroseconds = <span class="hljs-number">500</span> + <span class="hljs-number">10</span> * seed.<span class="hljs-title function_">toLong</span>()
   <span class="hljs-title class_">LockSupport</span>.<span class="hljs-title function_">parkNanos</span>(<span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">MICROSECONDS</span>.<span class="hljs-title function_">toNanos</span>(timeInMicroseconds))
   <span class="hljs-keyword">return</span> seed
}
</code></pre>
<p></p>
<p>마침내 결과가 나왔어요.</p>
<p><img src="/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_4.png" alt="image"></p>
<p>IO 테스트 케이스를 먼저 실행한 후 CPU를 실행하고 마지막으로 싱글 스레드를 실행했어요. 텍스트북에서 직접 나온 것처럼 들리죠? "IO 스레드 풀이 IO 작업에 가장 좋아요."</p>
<p>rxIO 테스트 케이스가 flowsIO 및 coroutinesIO보다 더 빠르다는군요. 아마 쓰레드를 생성하는 데 필요한 자원이 가장 적게 사용되는 것 같아요만... 그런 작업에서는 그렇게 중요한 점은 아니에요. 차이는 딱 한 밀리초뿐이에요. 프레임워크 간의 구별은 거의 사라진 것 같아요.</p>
<p></p>
<h1>네트워크</h1>
<p>음, 네트워크 케이스를 테스트하지 않을 수가 없어요. 모든 것은 이전 테스트랑 똑같죠. 이번에는 쓰레드가 잠시 동안 0에서 99밀리초 사이에 쉬도록 만들었어요. 이 테스트에서는 "바쁜 대기"에 의한 지연이 더 이상 중요한 역할을 하지 않아요. 그래서 우리는 Thread.sleep을 사용할 거예요.</p>
<pre><code class="hljs language-js">private fun <span class="hljs-title function_">network</span>(<span class="hljs-attr">seed</span>: <span class="hljs-title class_">Int</span>): <span class="hljs-title class_">Int</span> {
   <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">MILLISECONDS</span>.<span class="hljs-title function_">sleep</span>(seed.<span class="hljs-title function_">toLong</span>())
   <span class="hljs-keyword">return</span> seed
}
</code></pre>
<p>다음 결과에 주의하세요.</p>
<p></p>
<p>아래는 테이블 태그를 Markdown 형식으로 변경하십시오.</p>
<p></p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mixed</span><span class="hljs-params">(seed: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> {
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> {
       seed % <span class="hljs-number">5</span> == <span class="hljs-number">0</span> -> network(seed)
       seed % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> -> storage(seed)
       seed % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> -> listsManipulation(seed)
       <span class="hljs-keyword">else</span> -> arithmetic(seed)
   }
}
</code></pre>
<p>가장 오랜 시간이 걸리는 작업은 코드에서 확인할 수 있듯이 90밀리초입니다.</p>
<p>그래서 여기에 결과가 있습니다.</p>
<p><img src="/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_6.png" alt="Image"></p>
<p></p>
<p>일반적으로, 세 개의 블록으로 분할하는 패턴이 동일하게 나타납니다: IO, CPU, One.</p>
<p>차이점은 Executors.newWorkStealingPool로 생성된 Executor가 작은 작업들을 추가하여 선두를 선점한다는 것입니다. 이는 작업을 "도둑질"하기 때문으로 보입니다.</p>
<h1>결론</h1>
<p>파일 시스템과 네트워크 작업을 처리할 때는 멀티스레딩의 역할이 거의 사라진 것을 알 수 있습니다. 대부분의 멀티스레딩 사용은 IO 작업을 위한 것입니다. 따라서 성능을 기반으로한 멀티스레딩 프레임워크 선택은 이상합니다. 편의성 및 중요한 요소 등의 기준을 바탕으로 선택하는 것이 더 나을 것입니다.</p>
<p></p>
<p>그러나 0.5밀리초 동안 스레드를 차단하는 것보다 더 간단한 작업을 수행한다면 작은 스레드 풀을 사용하는 것이 좋습니다. 예를 들어 CPU 코어 수를 풀의 크기로 사용할 수 있습니다.</p>
<p>Executors와 Rx는 이러한 작업에 가장 적합합니다.</p>
<p>예외는 산술, 객체 생성 등과 같이 매우 간단한 작업에 해당합니다. 이러한 경우에는 모든 작업을 완료하는 데 필요한 시간보다 프레임워크에 의한 스레드 생성에 필요한 시간이 더 많이 걸리므로 멀티스레딩을 사용하지 않는 것이 좋습니다.</p>
<p>문제를 해결하기 위해 제가 따랐던 단계는 다음과 같습니다:</p>
<p></p>
<ul>
<li>모든 간단한 작업을 별도의 작업 풀에 분리하여 directInvoke를 사용하여 실행했습니다.</li>
<li>다른 모든 작업은 Dispatchers.IO를 사용하여 코루틴에서 실행되었는데, 이는 동기 및 비동기 코드를 동시에 작성하기 쉽게 해줬습니다.</li>
</ul>
<p>그리고 어떻게 생각하세요? 현재 어떤 프레임워크를 사용하고 있나요?</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Coroutines, RxJava, Executor 뭐가 더 빠를까 각 작업별 성능 비교","description":"","date":"2024-06-23 01:21","slug":"2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor","content":"\n\u003cimg src=\"/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_0.png\" /\u003e\n\n저는 가끔 다중 스레딩 프레임워크 중 어떤 것이 제일 빠른지 궁금했던 적이 있었어요. 어느 날 운명이 저를 이 질문을 조사하도록 이끌었죠. 만약 여러분도 궁금하시다면, 전 테스트를 해보고 비교한 결과를 여러분과 공유해 보았습니다.\n\n# 문제\n\n우선, 왜 이를 해보게 되었는지부터 알아봅시다. 제게는 간단한 작업이 있었어요: 수백 개의 콜백을 호출하는 시스템이 있었죠. 모든 콜백은 가능한 빨리 완료되어야 했죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각 콜백에 소요되는 복잡성이나 시간을 알지 못했어요. 콜백은 객체를 생성하거나 서버나 데이터베이스에 긴 요청을 할 수도 있어요. 이 경우에는 데이터베이스나 서버에 요청하기 때문에 멀티스레딩을 사용해야 하죠.\n\n이 문제를 해결하려고 할 때, 어떤 상황에서 어떤 멀티스레딩 프레임워크가 더 빠른지 정확히 모르는 것을 깨달았어요.\n\n# 동기부여\n\n하지만 당장 떠오르는 질문이 있죠: \"아직 아무도 테스트해보지 않은 건가요?\" 의외로 제 요구사항을 충족시키는 테스트를 찾을 수 없었어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일부 테스트는 Rx 대 Coroutines와 같이 두 기술 간의 간단한 비교였습니다. 다른 일부는 내 의견으로는 너무 구체적한 테스트 케이스를 가졌는데, 예를 들어 산술 연산이나 데이터베이스 요청만을 테스트하는 것 등이 그러했습니다.\n\n어쨌든, 이에 대해 매우 만족스럽지 않았고 나만의 테스트를 하기로 결정했습니다.\n\n멀티스레드 프레임워크의 모든 사용 사례를 커버할 수는 없다는 것은 합리적입니다. 내 작업과 관련이 있는 것들만 테스트할 것입니다... 그래서 이게 완벽한 테스트가 아니지만 꽤 철저할 것입니다.\n\n# 도구\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n측정 도구로 시작해 봅시다. 안드로이드 개발자이기 때문에 안드로이드 도구를 사용하겠습니다. 이론적으로는 컴퓨터에서 JVM에서 멀티스레딩 테스트를 실행하는 것이 안드로이드 장치에서 실행하는 것과 다를 수 있지만, 실제로는 큰 차이가 없으며 전체 테스트 결과에 영향을 미치지 않습니다.\n\n그리고 안드로이드 장치에서 코드 성능을 테스트하기 위해 사용할 수 있는 Jetpack Microbenchmark 도구가 있습니다.\n\nMicrobenchmark 측정 테스트는 보통의 인스트루먼테이션 테스트와 유사하지만, 차이점은 BenchmarkRule이라는 특정 Rule을 사용한다는 것뿐입니다.\n\n```js\n@get:Rule\nval benchmarkRule = BenchmarkRule()\n\n@Test\nfun sampleTest() {\n   benchmarkRule.measureRepeated {\n       // 여기에서 측정할 것입니다\n   }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결과적으로 실행에 대한 정보가 포함된 JSON을 얻게 됩니다: 최소 및 최대 시간, 그리고 가장 중요한 중앙값 시간.\n\n```js\n    \"benchmarks\": [\n        {\n            \"name\": \"sampleTest\",\n            \"params\": {},\n            \"className\": \"com.test.benchmark.ExampleBenchmark\",\n            \"totalRunTimeNs\": 85207217833,\n            \"metrics\": {\n                \"timeNs\": {\n                    \"minimum\": 9.82149833E8,\n                    \"maximum\": 1.019338584E9,\n                    \"median\": 1.004151917E9,\n                    \"runs\": [...]\n                },\n                \"allocationCount\": {\n                    \"minimum\": 324.0,\n                    \"maximum\": 324.0,\n                    \"median\": 324.0,\n                    \"runs\": [...]\n                }\n            },\n            \"sampledMetrics\": {},\n            \"warmupIterations\": 3200,\n            \"repeatIterations\": 5000,\n            \"thermalThrottleSleepSeconds\": 0\n        }\n    ]\n```\n\n이 JSON은 반복 횟수, 객체 할당 횟수 등을 포함한 기타 정보를 담고 있습니다. 현재는 이것이 우선 순위가 아닙니다.\n\n# 벤치마크 테스트 케이스\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프레임워크 간 주요 차이점은:\n\n- 단일 스레드 생성에 소요되는 시간\n- 프레임워크가 작업을 효율적이고 빠르게 스레드 간에 분배할 수 있는 능력\n\n우리는 이러한 프레임워크 간 차이를 평가하기 위해 테스트 케이스 결과를 탐색할 것입니다.\n\n이제 우리는 무엇을 테스트하고 싶은지 결정해야 합니다. 테스트 데이터부터 시작해봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 테스트 데이터\n\n별거 아닌 거에요. 0부터 99까지 범위의 100개 항목을 포함하는 ArrayList를 만들어봤어요.\n\n```kotlin\nprivate fun createTestList(): List\u003cInt\u003e {\n   return List(100) { it }\n}\n```\n\n그런 다음 각 항목에 대해 몇 가지 작업을 수행할 거예요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 테스트 케이스를 살펴보겠습니다.\n\n# 단일 스레드\n\n단일 스레드 테스트 케이스부터 시작해 보죠. 이러한 테스트 케이스의 결과를 비교할 때는 프레임워크가 단일 스레드를 생성하는 데 걸리는 시간을 주의 깊게 살펴볼 것입니다. 하나의 스레드만 있는 경우, 프레임워크가 스레드를 초기화하고 생성하는 데 걸리는 시간을 확인할 수 있습니다.\n\n## 직접 호출\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 테스트 케이스는 간단히 메서드를 직접 호출하는 것입니다. 어떤 프레임워크도 사용하지 않습니다.\n\n```kotlin\n@Test\nfun directInvoke() {\n   val list = createTestList()\n   benchmarkRule.measureRepeated {\n       list.forEach { action(it) }\n   }\n}\n```\n\n## RxJava\n\n두 번째 테스트 케이스는 Rx입니다. Completable 내에서 작업을 수행할 것입니다. 각 작업에 대해 별도의 Completable이 생성될 것입니다. Scheduler는 모든 작업이 단일 스레드에서 실행되도록 보장하는 Scheduler.single이 될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그리고 작업 완료를 기다려야 하기 때문에 결과 Completable에서 blockingAwait를 호출합니다.\n\n```kotlin\n@Test\nfun rxOne() {\n   val list = createTestList()\n   val scheduler = Schedulers.single()\n   benchmarkRule.measureRepeated {\n       val completables = list.map {\n           Completable.fromAction {\n               action(it)\n           }.subscribeOn(scheduler)\n       }\n       Completable.merge(completables).blockingAwait()\n   }\n}\n```\n\n## 코틀린 코루틴\n\n어딜 가나 젊고 유망한 코틀린 코루틴 프레임워크가 없었던 우리들이 어디에 있겠어요? 코루틴이 실행될 때까지 기다리려면 async를 통해 작업을 실행하고 완료를 기다리기 위해 await을 사용합니다. 따라서 각 작업을 위한 별도의 코루틴이 있을 것입니다. 모든 것을 단일 스레드에서 실행하도록 하려면 단순히 runBlocking을 사용하면 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kt\n@Test\nfun coroutineOne() {\n   val list = createTestList()\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           list.map {\n               async {\n                   action(it)\n               }\n           }.forEach { it.await() }\n       }\n   }\n}\n```\n\n## Kotlin Flow\n\nFlow에서 비교해보겠습니다. 코루틴과 Rx를 직접적으로 비교하는 것은 좋은 방법이 아닐 수 있습니다. 둘 다 다른 방식으로 사용되고 다른 개념을 적용하기 때문에 멀티쓰레딩과 관련이 있다고 해도 다릅니다.\n\n각 액션에 대한 Flow를 생성하고 모두 결합한 다음 간단히 수집합니다. 각 액션에 대해 별도의 Flow가 있을 것입니다. 한편, 디스패처를 어디에도 지정하지 않았기 때문에 모든 작업이 동일한 스레드에서 수행됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Test\nfun flowOne() {\n   val list = createTestList()\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           val flows = list.map {\n               flow {\n                   val result = action(it)\n                   emit(result)\n               }\n           }\n           flows.merge().collect()\n       }\n   }\n}\n```\n\n# 스레드 수는 CPU 스레드 수와 같음\n\n물론, 한 스레드만 사용하는 것은 최선의 선택처럼 보이지 않습니다. 왜냐하면 멀티스레딩을 위한 프레임워크가 있기 때문이죠.\n\n스레드 풀에 있는 스레드 수가 CPU 스레드 수와 같은 상황을 고려해 봅시다. 이상적으로는 이러한 테스트 케이스의 결과를 비교하여 두 번째 차이(프레임워크가 작업을 효율적으로 빠르게 스레드 간에 분배하는 능력)를 볼 수 있습니다. 각 작업에 대해 충분한 스레드가 없기 때문에 프레임워크가 그런 작업들을 어쨌든 분배해야 하게 될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로세서 코어 간 작업의 균등한 분배를 기대해서는 안 됩니다. 운영 체제와 CPU가 결정하는 것은:\n\n- 무엇이 실행되는지,\n- 언제 실행되는지,\n- 누가 실행하는지입니다.\n\n현대의 \"큰\" CPU는 SMT/HyperThreading을 사용하여 각 CPU 코어마다 여러 논리 스레드를 생성할 수 있습니다. CPU 코어는 독립적으로 명령을 실행할 수 있는 물리적 단위입니다. 반면 스레드는 한 코어에서 실행할 수 있는 논리적 소프트웨어 단위입니다. 또한 이동형 CPU와 최신 인텔 CPU는 다양한 유형의 CPU 코어를 사용합니다. 대형 코어는 복잡한 작업에 적합하며, 중형 및 절전 코어는 성능에서 상당히 차이가 있습니다.\n\n그래서, 우리는 이 풀을 적은 수의 스레드를 갖는 풀로 간주할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCPU 쓰레드 수를 결정하는 훌륭한 방법이 있어요:\n\n```js\nRuntime.getRuntime().availableProcessors();\n```\n\n제 테스트 기기에서는 이 값이 여덟이에요.\n\n## RxJava\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nRx를 시작해보겠습니다. Rx에는 원하는 동작을 구현하는 Scheduler.Computation이 있어요. 사실 코드는 단일 스레드를 사용할 때와 똑같이 유지됩니다. 유일한 차이점은 각 개별 Completable에 대해 Scheduler.computation()을 사용하여 subscribeOn을 만든다는 것이에요.\n\n```kotlin\n@Test\nfun rxCPU() {\n   val list = createTestList()\n   val scheduler = Schedulers.computation()\n   benchmarkRule.measureRepeated {\n       val completables = list.map {\n           Completable.fromAction {\n               action(it)\n           }.subscribeOn(scheduler)\n       }\n       Completable.merge(completables).blockingAwait()\n   }\n}\n```\n\n## Kotlin 코루틴\n\n이제 코루틴을 살펴보죠. Dispatchers.Default라는 것을 가지고 있어요. 해당 문서에는:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본적으로 \"병렬성\"의 최대 수준은 CPU 코어 수와 동일합니다. 우리가 필요한 것이 바로 그겁니다.\n\n코드는 싱글 코어 버전과 유사합니다. 이제 액션들은 Dispatchers.Default 내부에서 withContext를 사용하여 실행됩니다.\n\n```js\n@Test\nfun coroutineCPU() {\n   val list = createTestList()\n   val dispatcher = Dispatchers.Default\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           list.map {\n               async {\n                   withContext(dispatcher) {\n                       action(it)\n                   }\n               }\n           }.forEach { it.await() }\n       }\n   }\n}\n```\n\n하지만 중요한 세부 사항이 있습니다... Dispatchers.Default를 좀 더 자세히 살펴보면이 생성자를 찾을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n내부 객체 DefaultScheduler는 SchedulerCoroutineDispatcher를 상속합니다(\n   CORE_POOL_SIZE, MAX_POOL_SIZE,\n   IDLE_WORKER_KEEP_ALIVE_NS, DEFAULT_SCHEDULER_NAME\n)\n```\n\nCPU 스레드 수인 CORE_POOL_SIZE와 MAX_POOL_SIZE(이 경우 200만이라고합니다) 두 개의 상수를 전달하는 것이 의심스럽습니다.\n\n더 자세히 조사해보니 이러한 변수들은 CoroutineScheduler를 만들기 위해 사용된다는 것을 알 수 있습니다.\n\n```kotlin\nprivate fun createScheduler() = CoroutineScheduler(\n   corePoolSize, maxPoolSize, idleWorkerKeepAliveNs, schedulerName\n)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그리고 문서에는 다음과 같이 나와 있습니다:\n\n그래서 Dispatchers.Default는 CPU 스레드 수에 제한 받지 않습니다.\n\nDispatchers.Default와 Scheduler.Computation을 직접 비교하는 것은 잘못된 접근입니다. 경우에 따라 Dispatchers.Default는 추가적인 스레드를 사용할 수 있습니다. 다행히 문서는 비교를 더 공정하게 하기 위한 정보도 제공합니다. 단순히 LimitingDispatcher를 사용하면 됩니다. 이를 위해 Dispatchers.Default의 limitedParallelism 메서드를 CPU 스레드 수와 함께 호출하면 됩니다.\n\n```js\n@Test\nfun coroutineCPULimit() {\n   val list = createTestList()\n   val threadCount = Runtime.getRuntime().availableProcessors()\n   val dispatcher = Dispatchers.Default.limitedParallelism(threadCount)\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           list.map {\n               async {\n                   withContext(dispatcher) {\n                       action(it)\n                   }\n               }\n           }.forEach { it.await() }\n       }\n   }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 코틀린 Flow\n\nflow에 대해 동일한 작업을 합시다. Dispatchers.Default를 사용하세요.\n\n```js\n@Test\nfun flowCPU() {\n   val list = createTestList()\n   val dispatcher = Dispatchers.Default\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           val flows = list.map {\n               flow {\n                   val result = action(it)\n                   emit(result)\n               }.flowOn(dispatcher)\n           }\n           flows.merge().collect()\n       }\n   }\n}\n```\n\n그리고 제한을 두고 Dispatchers.Default를 사용하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n@Test\nfun flowCPULimit() {\n   val list = createTestList()\n   val threadCount = Runtime.getRuntime().availableProcessors()\n   val dispatcher = Dispatchers.Default.limitedParallelism(threadCount)\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           val flows = list.map {\n               flow {\n                   val result = action(it)\n                   emit(result)\n               }.flowOn(dispatcher)\n           }\n           flows.merge().collect()\n       }\n   }\n}\n```\n\n## Java Executor\n\n코루틴의 모든 복잡성을 탐구해야 했기 때문에, 이러한 복잡성을 사용해볼까요? 따라서 Executor를 사용해보려고 합니다.\n\n먼저, Executors.newFixedThreadPool을 사용하여 Executor를 생성해 보겠습니다. 이렇게 함으로써, 단순히 쓰레드 수로 제한된 Executor가 생성되며, 우리의 경우에는 CPU 코어의 수입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nmeasureRepeated 메소드 이전에 Executor를 생성하니 Executor를 만드는 것은 쉬운 작업이 아닙니다. 그런 다음, 작업을 수행하는 Executor에서 submit을 호출합니다. 완료를 기다리기 위해 get 메소드를 사용해 보겠습니다.\n\n```js\n@Test\nfun executorFixedCPU() {\n   val list = createTestList()\n   val threadCount = Runtime.getRuntime().availableProcessors()\n   val executorService = Executors.newFixedThreadPool(threadCount)\n   benchmarkRule.measureRepeated {\n       val futures = list.map { executorService.submit { action(it) } }\n       futures.forEach { it.get() }\n   }\n}\n```\n\nExecutors.newWorkStealingPool 메소드를 사용하여 관심 있는 두 번째 유형의 Executor를 생성할 것입니다. 실제로, 이 또한 제한된 수의 스레드로 Executor를 생성합니다. 그러나 메소드 이름에 \"Stealing\"이 포함된 것은 우연이 아닙니다. 이 Executor의 스레드는 현재 스레드가 비어 있어 다른 스레드에게 큐에 대기 중인 작업이 있는 경우 현재 스레드가 idle 상태가 되었을 때 다른 스레드로부터 작업을 훔칠 수 있습니다. 이는 최종적으로 공통 큐를 비울 수 있도록 도와줄 수 있습니다.\n\n코드적으로는 이전과 동일합니다. 단, Executor를 만드는 방법이 다를 뿐입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Test\nfun executorStealCPU() {\n   val list = createTestList()\n   val threadCount = Runtime.getRuntime().availableProcessors()\n   val executorService = Executors.newWorkStealingPool(threadCount)\n   benchmarkRule.measureRepeated {\n       val futures = list.map { executorService.submit { action(it) } }\n       futures.forEach { it.get() }\n   }\n}\n```\n\n# 각 작업에 대한 스레드\n\n이제 거의 무제한(실제로는 많은 수, 많다고 할 정도)으로 스레드를 할당하는 가능성을 탐색해 보겠습니다. 100개의 작업만 있기 때문에 100개의 스레드를 할당할 수 있습니다. 더 이상 필요하지 않습니다.\n\n## RxJava\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nRx를 시작합니다. Scheduler.io는 이러한 역할을 맡습니다. Scheduler.io에는 스레드 캐시가 있습니다. 사용 가능한 빈 스레드가 있다면 캐시에서 하나를 가져옵니다. 그렇지 않으면 새로운 스레드를 생성합니다. 코드는 Scheduler.computation과 동일하지만 다른 스케줄러를 사용합니다.\n\n```js\n@Test\nfun rxIo() {\n   val list = createTestList()\n   val scheduler = Schedulers.io()\n   benchmarkRule.measureRepeated {\n       val completables = list.map {\n           Completable.fromAction {\n               action(it)\n           }.subscribeOn(scheduler)\n       }\n       Completable.merge(completables).blockingAwait()\n   }\n}\n```\n\n## Kotlin 코루틴\n\n코루틴에서 유사한 작업은 Dispatchers.IO의 책임이므로 익숙한 코드에 삽입하기만 하면 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Test\nfun coroutineIo() {\n   val list = createTestList()\n   val dispatcher = Dispatchers.IO\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           list.map {\n               async {\n                   withContext(dispatcher) {\n                       action(it)\n                   }\n               }\n           }.forEach { it.await() }\n       }\n   }\n}\n```\n\n## Kotlin Flow\n\nRepeat the same for Flow.\n\n```kotlin\n@Test\nfun flowIo() {\n   val list = createTestList()\n   val dispatcher = Dispatchers.IO\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           val flows = list.map {\n               flow {\n                   val result = action(it)\n                   emit(result)\n               }.flowOn(dispatcher)\n           }\n           flows.merge().collect()\n       }\n   }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 자바 Executor\n\n안타깝게도 Executor는 그다지 좋은 API가 없어요. 따라서 우리는 그에게 100개의 스레드를 할당할 거예요. 100개의 작업만 있으면 충분하니까 더 많이 필요하지 않을 거에요.\n\n```kotlin\n@Test\nfun executorFixedIo() {\n   val list = createTestList()\n   val executorService = Executors.newFixedThreadPool(100)\n   benchmarkRule.measureRepeated {\n       val futures = list.map { executorService.submit { action(it) } }\n       futures.forEach { it.get() }\n   }\n}\n```\n\nnewWorkStealingPool도 같은 방식으로 할 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Test\nfun executorStealIo() {\n   val list = createTestList()\n   val executorService = Executors.newWorkStealingPool(100)\n   benchmarkRule.measureRepeated {\n       val futures = list.map { executorService.submit { action(it) } }\n       futures.forEach { it.get() }\n   }\n}\n```\n\n이것은 모든 테스트 케이스를 프레임워크별로 나열한 표입니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_1.png\" /\u003e\n\n그리고 마지막으로, 테스트를 실행합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 테스트\n\n하하, 조금 속았죠. 먼저, 행동의 카테고리를 고려해 봅시다.\n\n이 중에 단 5가지가 있습니다:\n\n- 산술 — 간단한 산술 연산;\n- listsManipulation — 객체 조작;\n- 저장 — 저장소와의 작업 시뮬레이션;\n- 네트워크 — 네트워크와의 작업 시뮬레이션;\n- 혼합 — 이전 스크립트 모두의 조합, 원본 작업에서 행동의 복잡성을 알 수 없기 때문에.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단한 것부터 시작해 봅시다.\n\n# 산술\n\n제가 여러분에게 상기시키고 싶은 점은 0부터 99까지의 각 항목에 대해 작업을 수행할 것이라는 것입니다. 이 경우 연산을 조금 더 복잡하게 만들기 위해 숫자를 Float로 변환하고 해당 숫자를 그 자신의 값의 제곱으로 올립니다. 0의 제곱부터 99의 제곱까지입니다. 물론 어느 시점에서는 Float의 한계에 도달하겠지만, 괜찮습니다.\n\n```js\nprivate fun arithmetic(seed: Int): Int {\n   return seed.toFloat().pow(seed.toFloat()).toInt()\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적으로, 이 범주로 분류할 수 있는 작업에는 생성자를 사용하여 객체를 생성하거나 속성에 액세스하는 것이 포함됩니다. 이러한 작업은 완료하는 데 오랜 시간이 걸리지 않습니다.\n\n결과는 무엇인가요?\n\n![그림](/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_2.png)\n\n예상대로, directInvoke가 최고의 결과를 보였습니다. 가장 가까운 경쟁 상대보다 70배 빨랐습니다. 이는 이러한 작업이 매우 간단하며 멀티스레딩 프레임워크를 사용하는 데 추가적인 오버헤드가 작업 자체 비용의 10배 더 높을 수 있다는 이치를 따랐기 때문입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 뜻밖의 충격은 두 번째와 세 번째 자리에서 일어났습니다. 두 자리 다 Executors로 고정된 스레드 수를 가진 것들이었어요. 처음에는 directInvoke가 제일일 것으로 예상했는데, 그 다음에는 단일 스레드의 테스트 케이스, 그리고 CPU, 그리고 마지막으로 IO가 실행될 것으로 기대했어요. 그런데 고정된 스레드 수를 가진 Executors가 이러한 로직을 완전히 무너뜨리는 모습을 볼 수 있었어요. 한편으로는 Executors.newWorkStealingPool을 이용하여 만든 Executor는 \"무한\" 스레드 수를 가질 때 성능이 더 좋아 보입니다.\n\nDispatchers.Default를 한정하고 한정하지 않았을 때의 시간이 다른 것을 볼 수 있습니다. 그래서 한정을 한 이유가 있습니다.\n\n하나의 동작을 처리하는 데 가장 많은 오버헤드를 가진 것은 Flow입니다. 모든 경쟁자들보다 느립니다. 그리고 코루틴은 한 스레드에서 Rx보다 나은 경우가 있지만, 스레드 수가 증가할수록 Rx가 선두 주자로 우뚝 서는 것을 볼 수 있습니다.\n\n요약하면, 이 카테고리의 동작에서 directInvoke가 가장 효과적임을 알 수 있습니다. 따라서 이러한 작업에는 멀티스레딩 프레임워크를 사용하지 않는 것이 더 나은 방법입니다. 대신에 하나의 스레드나 적은 수의 스레드를 가진 풀을 사용하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 리스트 조작\n\n자, 이제 더 복잡한 내용을 살펴보겠습니다 — 객체 조작입니다. 객체를 리스트에 추가하면 객체를 다루기가 더 쉬워집니다. 이 카테고리의 작업에는 예를 들어 POJO 매핑이 포함될 수 있습니다.\n\n작업 내에서 우리는 매개변수로 받은 숫자와 같은 크기를 갖는 새로운 리스트를 만들기만 하면 됩니다. 다음으로 몇 가지 작업을 수행하고, 리스트를 맵으로 변환한 다음 다시 몇 가지 작업을 수행한 후 이 컬렉션을 필터링합니다... 일반적으로 리스트를 조작합니다.\n\n이곳에서의 복잡성 기본은 실제 작업 그 자체가 아닙니다. 이것은 정규 불변 리스트이며, 시퀀스가 아닙니다. 이것은 각 작업 후 새로운 리스트가 생성된다는 것을 의미합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nprivate fun listsManipulation(seed: Int): Int {\n    List(seed) { it }\n        .map { it.toFloat() }\n        .map { it + 0.3f }\n        .associateBy { it.toString() }\n        .mapValues { it.value * it.value }\n        .filter { it.value \u003e 5f }\n    return seed\n}\n```\n\n어땠어요?\n\n![image](/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_3.png)\n\ndirectInvoke는 빠르게 선두에서 물러났어요. 객체 조작 같은 기본 작업조차 어려움이 있군요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nExecutor를 생성하여 리드가 됩니다. Executors.newWorkStealingPool을 사용하면 더 효율적입니다. 간단한 대안인 Executors.newFixedThreadPool보다 더욱 효율적입니다.\n\nRx는 조금 앞으로 나아갑니다. 앞에는 Scheduler.computation이 있습니다. 원칙적으로 이 작업에 대한 우선 선택지입니다. 왜냐하면 더 적은 자원을 사용하기 때문입니다.\n\n단일 스레드 테스트 케이스는 목록의 끝에 있지만, directInvoke는 여전히 중간에 남아 있습니다.\n\nflowCPU와 coroutineCPU는 목록의 맨 아래에 있습니다. 이러한 테스트 케이스들은 CPU 코어의 수와 같은 수의 스레드를 가지고 있으며 제한이 없습니다. 테스트를 다시 실행했지만 결과는 동일했습니다. 버그가 있을 수 있다고 생각하여 코루틴을 업데이트했지만 변한 점은 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n총론적으로, 이 복잡성 수준에서 CPU 테스트 케이스가 실행 시간 측면에서 IO보다 빠릅니다.\n\n# 저장공간\n\n데이터베이스나 작은 파일에 액세스하는 것은 블로킹 작업이기 때문에 단순히 스레드를 휴면 상태로 두기만 하면 됩니다. 휴면 시간은 500에서 1,490 마이크로초 또는 0.5에서 1.5 밀리초 사이입니다. 그러나 흔한 Thread.sleep 메서드는 \"바쁜 대기(busy waiting)\"로 인해 정확하지 않은 결과를 나타냅니다. 그래서 LockSupport.parkNanos를 사용하여 스레드를 휴면 상태로 만들겠습니다.\n\n```js\nprivate fun storage(seed: Int): Int {\n   val timeInMicroseconds = 500 + 10 * seed.toLong()\n   LockSupport.parkNanos(TimeUnit.MICROSECONDS.toNanos(timeInMicroseconds))\n   return seed\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마침내 결과가 나왔어요.\n\n![image](/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_4.png)\n\nIO 테스트 케이스를 먼저 실행한 후 CPU를 실행하고 마지막으로 싱글 스레드를 실행했어요. 텍스트북에서 직접 나온 것처럼 들리죠? \"IO 스레드 풀이 IO 작업에 가장 좋아요.\"\n\nrxIO 테스트 케이스가 flowsIO 및 coroutinesIO보다 더 빠르다는군요. 아마 쓰레드를 생성하는 데 필요한 자원이 가장 적게 사용되는 것 같아요만... 그런 작업에서는 그렇게 중요한 점은 아니에요. 차이는 딱 한 밀리초뿐이에요. 프레임워크 간의 구별은 거의 사라진 것 같아요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 네트워크\n\n음, 네트워크 케이스를 테스트하지 않을 수가 없어요. 모든 것은 이전 테스트랑 똑같죠. 이번에는 쓰레드가 잠시 동안 0에서 99밀리초 사이에 쉬도록 만들었어요. 이 테스트에서는 \"바쁜 대기\"에 의한 지연이 더 이상 중요한 역할을 하지 않아요. 그래서 우리는 Thread.sleep을 사용할 거예요.\n\n```js\nprivate fun network(seed: Int): Int {\n   TimeUnit.MILLISECONDS.sleep(seed.toLong())\n   return seed\n}\n```\n\n다음 결과에 주의하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 테이블 태그를 Markdown 형식으로 변경하십시오.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nprivate fun mixed(seed: Int): Int {\n   return when {\n       seed % 5 == 0 -\u003e network(seed)\n       seed % 3 == 0 -\u003e storage(seed)\n       seed % 2 == 0 -\u003e listsManipulation(seed)\n       else -\u003e arithmetic(seed)\n   }\n}\n```\n\n가장 오랜 시간이 걸리는 작업은 코드에서 확인할 수 있듯이 90밀리초입니다.\n\n그래서 여기에 결과가 있습니다.\n\n![Image](/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적으로, 세 개의 블록으로 분할하는 패턴이 동일하게 나타납니다: IO, CPU, One.\n\n차이점은 Executors.newWorkStealingPool로 생성된 Executor가 작은 작업들을 추가하여 선두를 선점한다는 것입니다. 이는 작업을 \"도둑질\"하기 때문으로 보입니다.\n\n# 결론\n\n파일 시스템과 네트워크 작업을 처리할 때는 멀티스레딩의 역할이 거의 사라진 것을 알 수 있습니다. 대부분의 멀티스레딩 사용은 IO 작업을 위한 것입니다. 따라서 성능을 기반으로한 멀티스레딩 프레임워크 선택은 이상합니다. 편의성 및 중요한 요소 등의 기준을 바탕으로 선택하는 것이 더 나을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 0.5밀리초 동안 스레드를 차단하는 것보다 더 간단한 작업을 수행한다면 작은 스레드 풀을 사용하는 것이 좋습니다. 예를 들어 CPU 코어 수를 풀의 크기로 사용할 수 있습니다.\n\nExecutors와 Rx는 이러한 작업에 가장 적합합니다.\n\n예외는 산술, 객체 생성 등과 같이 매우 간단한 작업에 해당합니다. 이러한 경우에는 모든 작업을 완료하는 데 필요한 시간보다 프레임워크에 의한 스레드 생성에 필요한 시간이 더 많이 걸리므로 멀티스레딩을 사용하지 않는 것이 좋습니다.\n\n문제를 해결하기 위해 제가 따랐던 단계는 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 모든 간단한 작업을 별도의 작업 풀에 분리하여 directInvoke를 사용하여 실행했습니다.\n- 다른 모든 작업은 Dispatchers.IO를 사용하여 코루틴에서 실행되었는데, 이는 동기 및 비동기 코드를 동시에 작성하기 쉽게 해줬습니다.\n\n그리고 어떻게 생각하세요? 현재 어떤 프레임워크를 사용하고 있나요?\n","ogImage":{"url":"/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_0.png"},"coverImage":"/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_0.png","tag":["Tech"],"readingTime":30},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e저는 가끔 다중 스레딩 프레임워크 중 어떤 것이 제일 빠른지 궁금했던 적이 있었어요. 어느 날 운명이 저를 이 질문을 조사하도록 이끌었죠. 만약 여러분도 궁금하시다면, 전 테스트를 해보고 비교한 결과를 여러분과 공유해 보았습니다.\u003c/p\u003e\n\u003ch1\u003e문제\u003c/h1\u003e\n\u003cp\u003e우선, 왜 이를 해보게 되었는지부터 알아봅시다. 제게는 간단한 작업이 있었어요: 수백 개의 콜백을 호출하는 시스템이 있었죠. 모든 콜백은 가능한 빨리 완료되어야 했죠.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e각 콜백에 소요되는 복잡성이나 시간을 알지 못했어요. 콜백은 객체를 생성하거나 서버나 데이터베이스에 긴 요청을 할 수도 있어요. 이 경우에는 데이터베이스나 서버에 요청하기 때문에 멀티스레딩을 사용해야 하죠.\u003c/p\u003e\n\u003cp\u003e이 문제를 해결하려고 할 때, 어떤 상황에서 어떤 멀티스레딩 프레임워크가 더 빠른지 정확히 모르는 것을 깨달았어요.\u003c/p\u003e\n\u003ch1\u003e동기부여\u003c/h1\u003e\n\u003cp\u003e하지만 당장 떠오르는 질문이 있죠: \"아직 아무도 테스트해보지 않은 건가요?\" 의외로 제 요구사항을 충족시키는 테스트를 찾을 수 없었어요.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e일부 테스트는 Rx 대 Coroutines와 같이 두 기술 간의 간단한 비교였습니다. 다른 일부는 내 의견으로는 너무 구체적한 테스트 케이스를 가졌는데, 예를 들어 산술 연산이나 데이터베이스 요청만을 테스트하는 것 등이 그러했습니다.\u003c/p\u003e\n\u003cp\u003e어쨌든, 이에 대해 매우 만족스럽지 않았고 나만의 테스트를 하기로 결정했습니다.\u003c/p\u003e\n\u003cp\u003e멀티스레드 프레임워크의 모든 사용 사례를 커버할 수는 없다는 것은 합리적입니다. 내 작업과 관련이 있는 것들만 테스트할 것입니다... 그래서 이게 완벽한 테스트가 아니지만 꽤 철저할 것입니다.\u003c/p\u003e\n\u003ch1\u003e도구\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e측정 도구로 시작해 봅시다. 안드로이드 개발자이기 때문에 안드로이드 도구를 사용하겠습니다. 이론적으로는 컴퓨터에서 JVM에서 멀티스레딩 테스트를 실행하는 것이 안드로이드 장치에서 실행하는 것과 다를 수 있지만, 실제로는 큰 차이가 없으며 전체 테스트 결과에 영향을 미치지 않습니다.\u003c/p\u003e\n\u003cp\u003e그리고 안드로이드 장치에서 코드 성능을 테스트하기 위해 사용할 수 있는 Jetpack Microbenchmark 도구가 있습니다.\u003c/p\u003e\n\u003cp\u003eMicrobenchmark 측정 테스트는 보통의 인스트루먼테이션 테스트와 유사하지만, 차이점은 BenchmarkRule이라는 특정 Rule을 사용한다는 것뿐입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-attr\"\u003eget\u003c/span\u003e:\u003cspan class=\"hljs-title class_\"\u003eRule\u003c/span\u003e\nval benchmarkRule = \u003cspan class=\"hljs-title class_\"\u003eBenchmarkRule\u003c/span\u003e()\n\n@\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e\nfun \u003cspan class=\"hljs-title function_\"\u003esampleTest\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n   benchmarkRule.\u003cspan class=\"hljs-property\"\u003emeasureRepeated\u003c/span\u003e {\n       \u003cspan class=\"hljs-comment\"\u003e// 여기에서 측정할 것입니다\u003c/span\u003e\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e결과적으로 실행에 대한 정보가 포함된 JSON을 얻게 됩니다: 최소 및 최대 시간, 그리고 가장 중요한 중앙값 시간.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    \u003cspan class=\"hljs-string\"\u003e\"benchmarks\"\u003c/span\u003e: [\n        {\n            \u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"sampleTest\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"params\"\u003c/span\u003e: {},\n            \u003cspan class=\"hljs-string\"\u003e\"className\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"com.test.benchmark.ExampleBenchmark\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"totalRunTimeNs\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e85207217833\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"metrics\"\u003c/span\u003e: {\n                \u003cspan class=\"hljs-string\"\u003e\"timeNs\"\u003c/span\u003e: {\n                    \u003cspan class=\"hljs-string\"\u003e\"minimum\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e9.82149833E8\u003c/span\u003e,\n                    \u003cspan class=\"hljs-string\"\u003e\"maximum\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1.019338584E9\u003c/span\u003e,\n                    \u003cspan class=\"hljs-string\"\u003e\"median\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1.004151917E9\u003c/span\u003e,\n                    \u003cspan class=\"hljs-string\"\u003e\"runs\"\u003c/span\u003e: [...]\n                },\n                \u003cspan class=\"hljs-string\"\u003e\"allocationCount\"\u003c/span\u003e: {\n                    \u003cspan class=\"hljs-string\"\u003e\"minimum\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e324.0\u003c/span\u003e,\n                    \u003cspan class=\"hljs-string\"\u003e\"maximum\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e324.0\u003c/span\u003e,\n                    \u003cspan class=\"hljs-string\"\u003e\"median\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e324.0\u003c/span\u003e,\n                    \u003cspan class=\"hljs-string\"\u003e\"runs\"\u003c/span\u003e: [...]\n                }\n            },\n            \u003cspan class=\"hljs-string\"\u003e\"sampledMetrics\"\u003c/span\u003e: {},\n            \u003cspan class=\"hljs-string\"\u003e\"warmupIterations\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3200\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"repeatIterations\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"thermalThrottleSleepSeconds\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n        }\n    ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 JSON은 반복 횟수, 객체 할당 횟수 등을 포함한 기타 정보를 담고 있습니다. 현재는 이것이 우선 순위가 아닙니다.\u003c/p\u003e\n\u003ch1\u003e벤치마크 테스트 케이스\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e프레임워크 간 주요 차이점은:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e단일 스레드 생성에 소요되는 시간\u003c/li\u003e\n\u003cli\u003e프레임워크가 작업을 효율적이고 빠르게 스레드 간에 분배할 수 있는 능력\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e우리는 이러한 프레임워크 간 차이를 평가하기 위해 테스트 케이스 결과를 탐색할 것입니다.\u003c/p\u003e\n\u003cp\u003e이제 우리는 무엇을 테스트하고 싶은지 결정해야 합니다. 테스트 데이터부터 시작해봅시다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003e테스트 데이터\u003c/h1\u003e\n\u003cp\u003e별거 아닌 거에요. 0부터 99까지 범위의 100개 항목을 포함하는 ArrayList를 만들어봤어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecreateTestList\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e: List\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003eInt\u003c/span\u003e\u003e {\n   \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e List(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e) { it }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 각 항목에 대해 몇 가지 작업을 수행할 거예요.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e이제 테스트 케이스를 살펴보겠습니다.\u003c/p\u003e\n\u003ch1\u003e단일 스레드\u003c/h1\u003e\n\u003cp\u003e단일 스레드 테스트 케이스부터 시작해 보죠. 이러한 테스트 케이스의 결과를 비교할 때는 프레임워크가 단일 스레드를 생성하는 데 걸리는 시간을 주의 깊게 살펴볼 것입니다. 하나의 스레드만 있는 경우, 프레임워크가 스레드를 초기화하고 생성하는 데 걸리는 시간을 확인할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e직접 호출\u003c/h2\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e첫 번째 테스트 케이스는 간단히 메서드를 직접 호출하는 것입니다. 어떤 프레임워크도 사용하지 않습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Test\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003edirectInvoke\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n   \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e list = createTestList()\n   benchmarkRule.measureRepeated {\n       list.forEach { action(it) }\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eRxJava\u003c/h2\u003e\n\u003cp\u003e두 번째 테스트 케이스는 Rx입니다. Completable 내에서 작업을 수행할 것입니다. 각 작업에 대해 별도의 Completable이 생성될 것입니다. Scheduler는 모든 작업이 단일 스레드에서 실행되도록 보장하는 Scheduler.single이 될 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e그리고 작업 완료를 기다려야 하기 때문에 결과 Completable에서 blockingAwait를 호출합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Test\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erxOne\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n   \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e list = createTestList()\n   \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e scheduler = Schedulers.single()\n   benchmarkRule.measureRepeated {\n       \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e completables = list.map {\n           Completable.fromAction {\n               action(it)\n           }.subscribeOn(scheduler)\n       }\n       Completable.merge(completables).blockingAwait()\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e코틀린 코루틴\u003c/h2\u003e\n\u003cp\u003e어딜 가나 젊고 유망한 코틀린 코루틴 프레임워크가 없었던 우리들이 어디에 있겠어요? 코루틴이 실행될 때까지 기다리려면 async를 통해 작업을 실행하고 완료를 기다리기 위해 await을 사용합니다. 따라서 각 작업을 위한 별도의 코루틴이 있을 것입니다. 모든 것을 단일 스레드에서 실행하도록 하려면 단순히 runBlocking을 사용하면 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kt\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Test\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecoroutineOne\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n   \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e list = createTestList()\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           list.map {\n               async {\n                   action(it)\n               }\n           }.forEach { it.await() }\n       }\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eKotlin Flow\u003c/h2\u003e\n\u003cp\u003eFlow에서 비교해보겠습니다. 코루틴과 Rx를 직접적으로 비교하는 것은 좋은 방법이 아닐 수 있습니다. 둘 다 다른 방식으로 사용되고 다른 개념을 적용하기 때문에 멀티쓰레딩과 관련이 있다고 해도 다릅니다.\u003c/p\u003e\n\u003cp\u003e각 액션에 대한 Flow를 생성하고 모두 결합한 다음 간단히 수집합니다. 각 액션에 대해 별도의 Flow가 있을 것입니다. 한편, 디스패처를 어디에도 지정하지 않았기 때문에 모든 작업이 동일한 스레드에서 수행됩니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Test\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eflowOne\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n   \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e list = createTestList()\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e flows = list.map {\n               flow {\n                   \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e result = action(it)\n                   emit(result)\n               }\n           }\n           flows.merge().collect()\n       }\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e스레드 수는 CPU 스레드 수와 같음\u003c/h1\u003e\n\u003cp\u003e물론, 한 스레드만 사용하는 것은 최선의 선택처럼 보이지 않습니다. 왜냐하면 멀티스레딩을 위한 프레임워크가 있기 때문이죠.\u003c/p\u003e\n\u003cp\u003e스레드 풀에 있는 스레드 수가 CPU 스레드 수와 같은 상황을 고려해 봅시다. 이상적으로는 이러한 테스트 케이스의 결과를 비교하여 두 번째 차이(프레임워크가 작업을 효율적으로 빠르게 스레드 간에 분배하는 능력)를 볼 수 있습니다. 각 작업에 대해 충분한 스레드가 없기 때문에 프레임워크가 그런 작업들을 어쨌든 분배해야 하게 될 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e프로세서 코어 간 작업의 균등한 분배를 기대해서는 안 됩니다. 운영 체제와 CPU가 결정하는 것은:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e무엇이 실행되는지,\u003c/li\u003e\n\u003cli\u003e언제 실행되는지,\u003c/li\u003e\n\u003cli\u003e누가 실행하는지입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e현대의 \"큰\" CPU는 SMT/HyperThreading을 사용하여 각 CPU 코어마다 여러 논리 스레드를 생성할 수 있습니다. CPU 코어는 독립적으로 명령을 실행할 수 있는 물리적 단위입니다. 반면 스레드는 한 코어에서 실행할 수 있는 논리적 소프트웨어 단위입니다. 또한 이동형 CPU와 최신 인텔 CPU는 다양한 유형의 CPU 코어를 사용합니다. 대형 코어는 복잡한 작업에 적합하며, 중형 및 절전 코어는 성능에서 상당히 차이가 있습니다.\u003c/p\u003e\n\u003cp\u003e그래서, 우리는 이 풀을 적은 수의 스레드를 갖는 풀로 간주할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eCPU 쓰레드 수를 결정하는 훌륭한 방법이 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eRuntime\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetRuntime\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003eavailableProcessors\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e제 테스트 기기에서는 이 값이 여덟이에요.\u003c/p\u003e\n\u003ch2\u003eRxJava\u003c/h2\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eRx를 시작해보겠습니다. Rx에는 원하는 동작을 구현하는 Scheduler.Computation이 있어요. 사실 코드는 단일 스레드를 사용할 때와 똑같이 유지됩니다. 유일한 차이점은 각 개별 Completable에 대해 Scheduler.computation()을 사용하여 subscribeOn을 만든다는 것이에요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Test\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003erxCPU\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n   \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e list = createTestList()\n   \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e scheduler = Schedulers.computation()\n   benchmarkRule.measureRepeated {\n       \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e completables = list.map {\n           Completable.fromAction {\n               action(it)\n           }.subscribeOn(scheduler)\n       }\n       Completable.merge(completables).blockingAwait()\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eKotlin 코루틴\u003c/h2\u003e\n\u003cp\u003e이제 코루틴을 살펴보죠. Dispatchers.Default라는 것을 가지고 있어요. 해당 문서에는:\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e기본적으로 \"병렬성\"의 최대 수준은 CPU 코어 수와 동일합니다. 우리가 필요한 것이 바로 그겁니다.\u003c/p\u003e\n\u003cp\u003e코드는 싱글 코어 버전과 유사합니다. 이제 액션들은 Dispatchers.Default 내부에서 withContext를 사용하여 실행됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e\nfun \u003cspan class=\"hljs-title function_\"\u003ecoroutineCPU\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n   val list = \u003cspan class=\"hljs-title function_\"\u003ecreateTestList\u003c/span\u003e()\n   val dispatcher = \u003cspan class=\"hljs-title class_\"\u003eDispatchers\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eDefault\u003c/span\u003e\n   benchmarkRule.\u003cspan class=\"hljs-property\"\u003emeasureRepeated\u003c/span\u003e {\n       runBlocking {\n           list.\u003cspan class=\"hljs-property\"\u003emap\u003c/span\u003e {\n               \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n                   \u003cspan class=\"hljs-title function_\"\u003ewithContext\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edispatcher\u003c/span\u003e) {\n                       \u003cspan class=\"hljs-title function_\"\u003eaction\u003c/span\u003e(it)\n                   }\n               }\n           }.\u003cspan class=\"hljs-property\"\u003eforEach\u003c/span\u003e { it.\u003cspan class=\"hljs-title function_\"\u003eawait\u003c/span\u003e() }\n       }\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e하지만 중요한 세부 사항이 있습니다... Dispatchers.Default를 좀 더 자세히 살펴보면이 생성자를 찾을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e내부 객체 DefaultScheduler는 SchedulerCoroutineDispatcher를 상속합니다(\n   CORE_POOL_SIZE, MAX_POOL_SIZE,\n   IDLE_WORKER_KEEP_ALIVE_NS, DEFAULT_SCHEDULER_NAME\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCPU 스레드 수인 CORE_POOL_SIZE와 MAX_POOL_SIZE(이 경우 200만이라고합니다) 두 개의 상수를 전달하는 것이 의심스럽습니다.\u003c/p\u003e\n\u003cp\u003e더 자세히 조사해보니 이러한 변수들은 CoroutineScheduler를 만들기 위해 사용된다는 것을 알 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecreateScheduler\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e = CoroutineScheduler(\n   corePoolSize, maxPoolSize, idleWorkerKeepAliveNs, schedulerName\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e그리고 문서에는 다음과 같이 나와 있습니다:\u003c/p\u003e\n\u003cp\u003e그래서 Dispatchers.Default는 CPU 스레드 수에 제한 받지 않습니다.\u003c/p\u003e\n\u003cp\u003eDispatchers.Default와 Scheduler.Computation을 직접 비교하는 것은 잘못된 접근입니다. 경우에 따라 Dispatchers.Default는 추가적인 스레드를 사용할 수 있습니다. 다행히 문서는 비교를 더 공정하게 하기 위한 정보도 제공합니다. 단순히 LimitingDispatcher를 사용하면 됩니다. 이를 위해 Dispatchers.Default의 limitedParallelism 메서드를 CPU 스레드 수와 함께 호출하면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e\nfun \u003cspan class=\"hljs-title function_\"\u003ecoroutineCPULimit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n   val list = \u003cspan class=\"hljs-title function_\"\u003ecreateTestList\u003c/span\u003e()\n   val threadCount = \u003cspan class=\"hljs-title class_\"\u003eRuntime\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetRuntime\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003eavailableProcessors\u003c/span\u003e()\n   val dispatcher = \u003cspan class=\"hljs-title class_\"\u003eDispatchers\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eDefault\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elimitedParallelism\u003c/span\u003e(threadCount)\n   benchmarkRule.\u003cspan class=\"hljs-property\"\u003emeasureRepeated\u003c/span\u003e {\n       runBlocking {\n           list.\u003cspan class=\"hljs-property\"\u003emap\u003c/span\u003e {\n               \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n                   \u003cspan class=\"hljs-title function_\"\u003ewithContext\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edispatcher\u003c/span\u003e) {\n                       \u003cspan class=\"hljs-title function_\"\u003eaction\u003c/span\u003e(it)\n                   }\n               }\n           }.\u003cspan class=\"hljs-property\"\u003eforEach\u003c/span\u003e { it.\u003cspan class=\"hljs-title function_\"\u003eawait\u003c/span\u003e() }\n       }\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e코틀린 Flow\u003c/h2\u003e\n\u003cp\u003eflow에 대해 동일한 작업을 합시다. Dispatchers.Default를 사용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e\nfun \u003cspan class=\"hljs-title function_\"\u003eflowCPU\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n   val list = \u003cspan class=\"hljs-title function_\"\u003ecreateTestList\u003c/span\u003e()\n   val dispatcher = \u003cspan class=\"hljs-title class_\"\u003eDispatchers\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eDefault\u003c/span\u003e\n   benchmarkRule.\u003cspan class=\"hljs-property\"\u003emeasureRepeated\u003c/span\u003e {\n       runBlocking {\n           val flows = list.\u003cspan class=\"hljs-property\"\u003emap\u003c/span\u003e {\n               flow {\n                   val result = \u003cspan class=\"hljs-title function_\"\u003eaction\u003c/span\u003e(it)\n                   \u003cspan class=\"hljs-title function_\"\u003eemit\u003c/span\u003e(result)\n               }.\u003cspan class=\"hljs-title function_\"\u003eflowOn\u003c/span\u003e(dispatcher)\n           }\n           flows.\u003cspan class=\"hljs-title function_\"\u003emerge\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ecollect\u003c/span\u003e()\n       }\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 제한을 두고 Dispatchers.Default를 사용하세요.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e\nfun \u003cspan class=\"hljs-title function_\"\u003eflowCPULimit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n   val list = \u003cspan class=\"hljs-title function_\"\u003ecreateTestList\u003c/span\u003e()\n   val threadCount = \u003cspan class=\"hljs-title class_\"\u003eRuntime\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetRuntime\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003eavailableProcessors\u003c/span\u003e()\n   val dispatcher = \u003cspan class=\"hljs-title class_\"\u003eDispatchers\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eDefault\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elimitedParallelism\u003c/span\u003e(threadCount)\n   benchmarkRule.\u003cspan class=\"hljs-property\"\u003emeasureRepeated\u003c/span\u003e {\n       runBlocking {\n           val flows = list.\u003cspan class=\"hljs-property\"\u003emap\u003c/span\u003e {\n               flow {\n                   val result = \u003cspan class=\"hljs-title function_\"\u003eaction\u003c/span\u003e(it)\n                   \u003cspan class=\"hljs-title function_\"\u003eemit\u003c/span\u003e(result)\n               }.\u003cspan class=\"hljs-title function_\"\u003eflowOn\u003c/span\u003e(dispatcher)\n           }\n           flows.\u003cspan class=\"hljs-title function_\"\u003emerge\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ecollect\u003c/span\u003e()\n       }\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eJava Executor\u003c/h2\u003e\n\u003cp\u003e코루틴의 모든 복잡성을 탐구해야 했기 때문에, 이러한 복잡성을 사용해볼까요? 따라서 Executor를 사용해보려고 합니다.\u003c/p\u003e\n\u003cp\u003e먼저, Executors.newFixedThreadPool을 사용하여 Executor를 생성해 보겠습니다. 이렇게 함으로써, 단순히 쓰레드 수로 제한된 Executor가 생성되며, 우리의 경우에는 CPU 코어의 수입니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003emeasureRepeated 메소드 이전에 Executor를 생성하니 Executor를 만드는 것은 쉬운 작업이 아닙니다. 그런 다음, 작업을 수행하는 Executor에서 submit을 호출합니다. 완료를 기다리기 위해 get 메소드를 사용해 보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e\nfun \u003cspan class=\"hljs-title function_\"\u003eexecutorFixedCPU\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n   val list = \u003cspan class=\"hljs-title function_\"\u003ecreateTestList\u003c/span\u003e()\n   val threadCount = \u003cspan class=\"hljs-title class_\"\u003eRuntime\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetRuntime\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003eavailableProcessors\u003c/span\u003e()\n   val executorService = \u003cspan class=\"hljs-title class_\"\u003eExecutors\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enewFixedThreadPool\u003c/span\u003e(threadCount)\n   benchmarkRule.\u003cspan class=\"hljs-property\"\u003emeasureRepeated\u003c/span\u003e {\n       val futures = list.\u003cspan class=\"hljs-property\"\u003emap\u003c/span\u003e { executorService.\u003cspan class=\"hljs-property\"\u003esubmit\u003c/span\u003e { \u003cspan class=\"hljs-title function_\"\u003eaction\u003c/span\u003e(it) } }\n       futures.\u003cspan class=\"hljs-property\"\u003eforEach\u003c/span\u003e { it.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e() }\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eExecutors.newWorkStealingPool 메소드를 사용하여 관심 있는 두 번째 유형의 Executor를 생성할 것입니다. 실제로, 이 또한 제한된 수의 스레드로 Executor를 생성합니다. 그러나 메소드 이름에 \"Stealing\"이 포함된 것은 우연이 아닙니다. 이 Executor의 스레드는 현재 스레드가 비어 있어 다른 스레드에게 큐에 대기 중인 작업이 있는 경우 현재 스레드가 idle 상태가 되었을 때 다른 스레드로부터 작업을 훔칠 수 있습니다. 이는 최종적으로 공통 큐를 비울 수 있도록 도와줄 수 있습니다.\u003c/p\u003e\n\u003cp\u003e코드적으로는 이전과 동일합니다. 단, Executor를 만드는 방법이 다를 뿐입니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Test\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eexecutorStealCPU\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n   \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e list = createTestList()\n   \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e threadCount = Runtime.getRuntime().availableProcessors()\n   \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e executorService = Executors.newWorkStealingPool(threadCount)\n   benchmarkRule.measureRepeated {\n       \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e futures = list.map { executorService.submit { action(it) } }\n       futures.forEach { it.\u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e() }\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e각 작업에 대한 스레드\u003c/h1\u003e\n\u003cp\u003e이제 거의 무제한(실제로는 많은 수, 많다고 할 정도)으로 스레드를 할당하는 가능성을 탐색해 보겠습니다. 100개의 작업만 있기 때문에 100개의 스레드를 할당할 수 있습니다. 더 이상 필요하지 않습니다.\u003c/p\u003e\n\u003ch2\u003eRxJava\u003c/h2\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eRx를 시작합니다. Scheduler.io는 이러한 역할을 맡습니다. Scheduler.io에는 스레드 캐시가 있습니다. 사용 가능한 빈 스레드가 있다면 캐시에서 하나를 가져옵니다. 그렇지 않으면 새로운 스레드를 생성합니다. 코드는 Scheduler.computation과 동일하지만 다른 스케줄러를 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e\nfun \u003cspan class=\"hljs-title function_\"\u003erxIo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n   val list = \u003cspan class=\"hljs-title function_\"\u003ecreateTestList\u003c/span\u003e()\n   val scheduler = \u003cspan class=\"hljs-title class_\"\u003eSchedulers\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eio\u003c/span\u003e()\n   benchmarkRule.\u003cspan class=\"hljs-property\"\u003emeasureRepeated\u003c/span\u003e {\n       val completables = list.\u003cspan class=\"hljs-property\"\u003emap\u003c/span\u003e {\n           \u003cspan class=\"hljs-title class_\"\u003eCompletable\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003efromAction\u003c/span\u003e {\n               \u003cspan class=\"hljs-title function_\"\u003eaction\u003c/span\u003e(it)\n           }.\u003cspan class=\"hljs-title function_\"\u003esubscribeOn\u003c/span\u003e(scheduler)\n       }\n       \u003cspan class=\"hljs-title class_\"\u003eCompletable\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emerge\u003c/span\u003e(completables).\u003cspan class=\"hljs-title function_\"\u003eblockingAwait\u003c/span\u003e()\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eKotlin 코루틴\u003c/h2\u003e\n\u003cp\u003e코루틴에서 유사한 작업은 Dispatchers.IO의 책임이므로 익숙한 코드에 삽입하기만 하면 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Test\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecoroutineIo\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n   \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e list = createTestList()\n   \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e dispatcher = Dispatchers.IO\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           list.map {\n               async {\n                   withContext(dispatcher) {\n                       action(it)\n                   }\n               }\n           }.forEach { it.await() }\n       }\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eKotlin Flow\u003c/h2\u003e\n\u003cp\u003eRepeat the same for Flow.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Test\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eflowIo\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n   \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e list = createTestList()\n   \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e dispatcher = Dispatchers.IO\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e flows = list.map {\n               flow {\n                   \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e result = action(it)\n                   emit(result)\n               }.flowOn(dispatcher)\n           }\n           flows.merge().collect()\n       }\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e자바 Executor\u003c/h2\u003e\n\u003cp\u003e안타깝게도 Executor는 그다지 좋은 API가 없어요. 따라서 우리는 그에게 100개의 스레드를 할당할 거예요. 100개의 작업만 있으면 충분하니까 더 많이 필요하지 않을 거에요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Test\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eexecutorFixedIo\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n   \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e list = createTestList()\n   \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e executorService = Executors.newFixedThreadPool(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e)\n   benchmarkRule.measureRepeated {\n       \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e futures = list.map { executorService.submit { action(it) } }\n       futures.forEach { it.\u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e() }\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003enewWorkStealingPool도 같은 방식으로 할 거에요.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Test\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eexecutorStealIo\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n   \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e list = createTestList()\n   \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e executorService = Executors.newWorkStealingPool(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e)\n   benchmarkRule.measureRepeated {\n       \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e futures = list.map { executorService.submit { action(it) } }\n       futures.forEach { it.\u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e() }\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 모든 테스트 케이스를 프레임워크별로 나열한 표입니다.\u003c/p\u003e\n\u003cp\u003e그리고 마지막으로, 테스트를 실행합니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003e테스트\u003c/h1\u003e\n\u003cp\u003e하하, 조금 속았죠. 먼저, 행동의 카테고리를 고려해 봅시다.\u003c/p\u003e\n\u003cp\u003e이 중에 단 5가지가 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e산술 — 간단한 산술 연산;\u003c/li\u003e\n\u003cli\u003elistsManipulation — 객체 조작;\u003c/li\u003e\n\u003cli\u003e저장 — 저장소와의 작업 시뮬레이션;\u003c/li\u003e\n\u003cli\u003e네트워크 — 네트워크와의 작업 시뮬레이션;\u003c/li\u003e\n\u003cli\u003e혼합 — 이전 스크립트 모두의 조합, 원본 작업에서 행동의 복잡성을 알 수 없기 때문에.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e간단한 것부터 시작해 봅시다.\u003c/p\u003e\n\u003ch1\u003e산술\u003c/h1\u003e\n\u003cp\u003e제가 여러분에게 상기시키고 싶은 점은 0부터 99까지의 각 항목에 대해 작업을 수행할 것이라는 것입니다. 이 경우 연산을 조금 더 복잡하게 만들기 위해 숫자를 Float로 변환하고 해당 숫자를 그 자신의 값의 제곱으로 올립니다. 0의 제곱부터 99의 제곱까지입니다. 물론 어느 시점에서는 Float의 한계에 도달하겠지만, 괜찮습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eprivate fun \u003cspan class=\"hljs-title function_\"\u003earithmetic\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eseed\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eInt\u003c/span\u003e): \u003cspan class=\"hljs-title class_\"\u003eInt\u003c/span\u003e {\n   \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e seed.\u003cspan class=\"hljs-title function_\"\u003etoFloat\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003epow\u003c/span\u003e(seed.\u003cspan class=\"hljs-title function_\"\u003etoFloat\u003c/span\u003e()).\u003cspan class=\"hljs-title function_\"\u003etoInt\u003c/span\u003e()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e일반적으로, 이 범주로 분류할 수 있는 작업에는 생성자를 사용하여 객체를 생성하거나 속성에 액세스하는 것이 포함됩니다. 이러한 작업은 완료하는 데 오랜 시간이 걸리지 않습니다.\u003c/p\u003e\n\u003cp\u003e결과는 무엇인가요?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_2.png\" alt=\"그림\"\u003e\u003c/p\u003e\n\u003cp\u003e예상대로, directInvoke가 최고의 결과를 보였습니다. 가장 가까운 경쟁 상대보다 70배 빨랐습니다. 이는 이러한 작업이 매우 간단하며 멀티스레딩 프레임워크를 사용하는 데 추가적인 오버헤드가 작업 자체 비용의 10배 더 높을 수 있다는 이치를 따랐기 때문입니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e그러나 뜻밖의 충격은 두 번째와 세 번째 자리에서 일어났습니다. 두 자리 다 Executors로 고정된 스레드 수를 가진 것들이었어요. 처음에는 directInvoke가 제일일 것으로 예상했는데, 그 다음에는 단일 스레드의 테스트 케이스, 그리고 CPU, 그리고 마지막으로 IO가 실행될 것으로 기대했어요. 그런데 고정된 스레드 수를 가진 Executors가 이러한 로직을 완전히 무너뜨리는 모습을 볼 수 있었어요. 한편으로는 Executors.newWorkStealingPool을 이용하여 만든 Executor는 \"무한\" 스레드 수를 가질 때 성능이 더 좋아 보입니다.\u003c/p\u003e\n\u003cp\u003eDispatchers.Default를 한정하고 한정하지 않았을 때의 시간이 다른 것을 볼 수 있습니다. 그래서 한정을 한 이유가 있습니다.\u003c/p\u003e\n\u003cp\u003e하나의 동작을 처리하는 데 가장 많은 오버헤드를 가진 것은 Flow입니다. 모든 경쟁자들보다 느립니다. 그리고 코루틴은 한 스레드에서 Rx보다 나은 경우가 있지만, 스레드 수가 증가할수록 Rx가 선두 주자로 우뚝 서는 것을 볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e요약하면, 이 카테고리의 동작에서 directInvoke가 가장 효과적임을 알 수 있습니다. 따라서 이러한 작업에는 멀티스레딩 프레임워크를 사용하지 않는 것이 더 나은 방법입니다. 대신에 하나의 스레드나 적은 수의 스레드를 가진 풀을 사용하세요.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003e리스트 조작\u003c/h1\u003e\n\u003cp\u003e자, 이제 더 복잡한 내용을 살펴보겠습니다 — 객체 조작입니다. 객체를 리스트에 추가하면 객체를 다루기가 더 쉬워집니다. 이 카테고리의 작업에는 예를 들어 POJO 매핑이 포함될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e작업 내에서 우리는 매개변수로 받은 숫자와 같은 크기를 갖는 새로운 리스트를 만들기만 하면 됩니다. 다음으로 몇 가지 작업을 수행하고, 리스트를 맵으로 변환한 다음 다시 몇 가지 작업을 수행한 후 이 컬렉션을 필터링합니다... 일반적으로 리스트를 조작합니다.\u003c/p\u003e\n\u003cp\u003e이곳에서의 복잡성 기본은 실제 작업 그 자체가 아닙니다. 이것은 정규 불변 리스트이며, 시퀀스가 아닙니다. 이것은 각 작업 후 새로운 리스트가 생성된다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003elistsManipulation\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(seed: \u003cspan class=\"hljs-type\"\u003eInt\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eInt\u003c/span\u003e {\n    List(seed) { it }\n        .map { it.toFloat() }\n        .map { it + \u003cspan class=\"hljs-number\"\u003e0.3f\u003c/span\u003e }\n        .associateBy { it.toString() }\n        .mapValues { it.value * it.value }\n        .filter { it.value \u003e \u003cspan class=\"hljs-number\"\u003e5f\u003c/span\u003e }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e seed\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e어땠어요?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_3.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003edirectInvoke는 빠르게 선두에서 물러났어요. 객체 조작 같은 기본 작업조차 어려움이 있군요.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eExecutor를 생성하여 리드가 됩니다. Executors.newWorkStealingPool을 사용하면 더 효율적입니다. 간단한 대안인 Executors.newFixedThreadPool보다 더욱 효율적입니다.\u003c/p\u003e\n\u003cp\u003eRx는 조금 앞으로 나아갑니다. 앞에는 Scheduler.computation이 있습니다. 원칙적으로 이 작업에 대한 우선 선택지입니다. 왜냐하면 더 적은 자원을 사용하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e단일 스레드 테스트 케이스는 목록의 끝에 있지만, directInvoke는 여전히 중간에 남아 있습니다.\u003c/p\u003e\n\u003cp\u003eflowCPU와 coroutineCPU는 목록의 맨 아래에 있습니다. 이러한 테스트 케이스들은 CPU 코어의 수와 같은 수의 스레드를 가지고 있으며 제한이 없습니다. 테스트를 다시 실행했지만 결과는 동일했습니다. 버그가 있을 수 있다고 생각하여 코루틴을 업데이트했지만 변한 점은 없습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e총론적으로, 이 복잡성 수준에서 CPU 테스트 케이스가 실행 시간 측면에서 IO보다 빠릅니다.\u003c/p\u003e\n\u003ch1\u003e저장공간\u003c/h1\u003e\n\u003cp\u003e데이터베이스나 작은 파일에 액세스하는 것은 블로킹 작업이기 때문에 단순히 스레드를 휴면 상태로 두기만 하면 됩니다. 휴면 시간은 500에서 1,490 마이크로초 또는 0.5에서 1.5 밀리초 사이입니다. 그러나 흔한 Thread.sleep 메서드는 \"바쁜 대기(busy waiting)\"로 인해 정확하지 않은 결과를 나타냅니다. 그래서 LockSupport.parkNanos를 사용하여 스레드를 휴면 상태로 만들겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eprivate fun \u003cspan class=\"hljs-title function_\"\u003estorage\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eseed\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eInt\u003c/span\u003e): \u003cspan class=\"hljs-title class_\"\u003eInt\u003c/span\u003e {\n   val timeInMicroseconds = \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e * seed.\u003cspan class=\"hljs-title function_\"\u003etoLong\u003c/span\u003e()\n   \u003cspan class=\"hljs-title class_\"\u003eLockSupport\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eparkNanos\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eTimeUnit\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eMICROSECONDS\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etoNanos\u003c/span\u003e(timeInMicroseconds))\n   \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e seed\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e마침내 결과가 나왔어요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_4.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eIO 테스트 케이스를 먼저 실행한 후 CPU를 실행하고 마지막으로 싱글 스레드를 실행했어요. 텍스트북에서 직접 나온 것처럼 들리죠? \"IO 스레드 풀이 IO 작업에 가장 좋아요.\"\u003c/p\u003e\n\u003cp\u003erxIO 테스트 케이스가 flowsIO 및 coroutinesIO보다 더 빠르다는군요. 아마 쓰레드를 생성하는 데 필요한 자원이 가장 적게 사용되는 것 같아요만... 그런 작업에서는 그렇게 중요한 점은 아니에요. 차이는 딱 한 밀리초뿐이에요. 프레임워크 간의 구별은 거의 사라진 것 같아요.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003e네트워크\u003c/h1\u003e\n\u003cp\u003e음, 네트워크 케이스를 테스트하지 않을 수가 없어요. 모든 것은 이전 테스트랑 똑같죠. 이번에는 쓰레드가 잠시 동안 0에서 99밀리초 사이에 쉬도록 만들었어요. 이 테스트에서는 \"바쁜 대기\"에 의한 지연이 더 이상 중요한 역할을 하지 않아요. 그래서 우리는 Thread.sleep을 사용할 거예요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eprivate fun \u003cspan class=\"hljs-title function_\"\u003enetwork\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eseed\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eInt\u003c/span\u003e): \u003cspan class=\"hljs-title class_\"\u003eInt\u003c/span\u003e {\n   \u003cspan class=\"hljs-title class_\"\u003eTimeUnit\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eMILLISECONDS\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esleep\u003c/span\u003e(seed.\u003cspan class=\"hljs-title function_\"\u003etoLong\u003c/span\u003e())\n   \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e seed\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음 결과에 주의하세요.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e아래는 테이블 태그를 Markdown 형식으로 변경하십시오.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emixed\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(seed: \u003cspan class=\"hljs-type\"\u003eInt\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eInt\u003c/span\u003e {\n   \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ewhen\u003c/span\u003e {\n       seed % \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e -\u003e network(seed)\n       seed % \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e -\u003e storage(seed)\n       seed % \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e -\u003e listsManipulation(seed)\n       \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e -\u003e arithmetic(seed)\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e가장 오랜 시간이 걸리는 작업은 코드에서 확인할 수 있듯이 90밀리초입니다.\u003c/p\u003e\n\u003cp\u003e그래서 여기에 결과가 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_6.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e일반적으로, 세 개의 블록으로 분할하는 패턴이 동일하게 나타납니다: IO, CPU, One.\u003c/p\u003e\n\u003cp\u003e차이점은 Executors.newWorkStealingPool로 생성된 Executor가 작은 작업들을 추가하여 선두를 선점한다는 것입니다. 이는 작업을 \"도둑질\"하기 때문으로 보입니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e파일 시스템과 네트워크 작업을 처리할 때는 멀티스레딩의 역할이 거의 사라진 것을 알 수 있습니다. 대부분의 멀티스레딩 사용은 IO 작업을 위한 것입니다. 따라서 성능을 기반으로한 멀티스레딩 프레임워크 선택은 이상합니다. 편의성 및 중요한 요소 등의 기준을 바탕으로 선택하는 것이 더 나을 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e그러나 0.5밀리초 동안 스레드를 차단하는 것보다 더 간단한 작업을 수행한다면 작은 스레드 풀을 사용하는 것이 좋습니다. 예를 들어 CPU 코어 수를 풀의 크기로 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eExecutors와 Rx는 이러한 작업에 가장 적합합니다.\u003c/p\u003e\n\u003cp\u003e예외는 산술, 객체 생성 등과 같이 매우 간단한 작업에 해당합니다. 이러한 경우에는 모든 작업을 완료하는 데 필요한 시간보다 프레임워크에 의한 스레드 생성에 필요한 시간이 더 많이 걸리므로 멀티스레딩을 사용하지 않는 것이 좋습니다.\u003c/p\u003e\n\u003cp\u003e문제를 해결하기 위해 제가 따랐던 단계는 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e모든 간단한 작업을 별도의 작업 풀에 분리하여 directInvoke를 사용하여 실행했습니다.\u003c/li\u003e\n\u003cli\u003e다른 모든 작업은 Dispatchers.IO를 사용하여 코루틴에서 실행되었는데, 이는 동기 및 비동기 코드를 동시에 작성하기 쉽게 해줬습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그리고 어떻게 생각하세요? 현재 어떤 프레임워크를 사용하고 있나요?\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor"},"buildId":"bb_yO9GbCvdfc_n71SfUf","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>