<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Swift 동시성 메모리 관리에서 Task Cancellation과 Weak Self의 비교 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Swift 동시성 메모리 관리에서 Task Cancellation과 Weak Self의 비교 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Swift 동시성 메모리 관리에서 Task Cancellation과 Weak Self의 비교 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement" data-gatsby-head="true"/><meta name="twitter:title" content="Swift 동시성 메모리 관리에서 Task Cancellation과 Weak Self의 비교 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 21:25" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_buildManifest.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Swift 동시성 메모리 관리에서 Task Cancellation과 Weak Self의 비교</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Swift 동시성 메모리 관리에서 Task Cancellation과 Weak Self의 비교" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement_0.png" alt="Image"></p>
<p>Swift 개발에 관련해서, 메모리 관리를 이해하는 것은 복잡한 퍼즐을 해결하는 것과 같습니다. 이러한 퍼즐의 핵심에는 클로저와 비동기 작업을 처리하는 동안 메모리 누수에 빠지지 않는 것이라는 도전이 있습니다. 많은 개발자들이 리테인 싸이클을 피하는 데 사용해온 약한 참조(weak self) 개념은 클로저에서 탁월한 해결책이었습니다. 하지만 Swift의 동시성 모델, 특히 Task에서 이 실천이 원활하게 이어지는지 궁금할 것입니다. 실용적인 코드 예제와 통찰을 통해, 효율적인 Swift 프로그래밍을 위한 길을 밝혀보겠습니다.</p>
<h1>다루는 주제</h1>
<ul>
<li>클로저에서 왜 weak self가 필요하며, 사용하지 않으면 어떻게 되는지?</li>
<li>Task 블록에서도 실제로 weak self가 필요한가?</li>
<li>Swift 동시성을 사용할 때 리테인 싸이클을 피하기 위해 어떤 조치를 취할 수 있는가?</li>
</ul>
<p></p>
<h1>주요 포인트</h1>
<ul>
<li>클로저에서의 순환 참조와 약한 self 사용의 중요성을 이해하세요.</li>
<li>비동기 작업이 self를 강하게 캡처하면 작업 블록도 순환 참조를 생성할 수 있습니다.</li>
<li>컴파일러는 클로저와 달리 작업 블록에서 명시적 self 사용을 요구하지 않습니다.</li>
<li>약한 self에만 의존하지 않고 메모리를 효율적으로 관리할 대안으로 작업 취소를 사용할 수 있습니다.</li>
<li>비동기 작업을 다룰 때 ViewModel에서 순환 참조를 방지하기 위해 작업 취소를 구현하세요.</li>
</ul>
<h1>클로저에서의 'Weak Self' 딜레마</h1>
<p>약한 self의 필요성을 이해하려면 먼저 Swift에서 클로저의 세계로 들어가 보겠습니다. 클로저는 참조 타입이며 강하게 인스턴스(예: self)를 캡처하고 유지할 수 있습니다. 이로 인해 잠재적인 순환 참조가 발생할 수 있습니다. 이는 객체가 self를 참조하는 클로저를 소유하고, 그 클로저가 객체 자체에 의해 소유되는 경우 발생하여 서로 해제될 수 없는 루프를 만듭니다.</p>
<p></p>
<p>전통적인 시나리오:</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Repository</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">remoteAPICallWithClosure</span>(<span class="hljs-params">onComplete</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">String</span>) -> <span class="hljs-type">Void</span>) {
        <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="hljs-operator">+</span> <span class="hljs-number">4</span>) {
            onComplete(<span class="hljs-string">"완료"</span>)
        }
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeBigViewModel</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> repository <span class="hljs-operator">=</span> <span class="hljs-type">Repository</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> result <span class="hljs-operator">=</span> <span class="hljs-string">""</span>

    <span class="hljs-keyword">func</span> <span class="hljs-title function_">doSomethingWithClosure</span>() {
        repository.remoteAPICallWithClosure { apiResult <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">self</span>.result <span class="hljs-operator">=</span> apiResult
        }
    }
}
</code></pre>
<p>이제 SomeBigViewModel의 인스턴스를 생성하고 doSomethingWithClosure을 호출한 후에 해당 인스턴스를 해제하려고 시도합니다:</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">var</span> vm: <span class="hljs-type">SomeBigViewModel</span>? <span class="hljs-operator">=</span> <span class="hljs-type">SomeBigViewModel</span>()
vm<span class="hljs-operator">?</span>.doSomethingWithClosure()
vm <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>
</code></pre>
<p></p>
<p>작업이 시작됩니다. 그러나 deint print 문은 즉시 나타나지 않을 것입니다. 이는 유지 주기(순환 참조)를 나타냅니다:</p>
<pre><code class="hljs language-js">작업이 시작됨
</code></pre>
<h2>주기(순환 참조) 파괴하기</h2>
<p>우리의 클로저에서 [weak self]를 사용하여 유지 주기를 피하고 SomeBigViewModel이 해제되도록 할 수 있습니다:</p>
<p></p>
<pre><code class="hljs language-js">func <span class="hljs-title function_">doSomethingWithClosure</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">print</span>(<span class="hljs-string">"작업이 시작되었습니다."</span>)
    repository.<span class="hljs-property">remoteAPICallWithClosure</span> { [weak self] apiResult <span class="hljs-keyword">in</span>
        guard <span class="hljs-keyword">let</span> self = self <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
        self.<span class="hljs-property">result</span> = apiResult
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"API 결과를 받았습니다."</span>)
    }
}
</code></pre>
<p>코드를 수정하고 다시 실행한 후, 출력 결과는 예상대로 <code>deinit</code>이 호출되어 순환 참조가 해제된다는 것을 확인합니다:</p>
<pre><code class="hljs language-js">작업이 시작되었습니다.
<span class="hljs-title class_">SomeBigViewModel</span>이 해제되고 있습니다.
</code></pre>
<h1>Swift의 병행성 모델: Task와의 사례</h1>
<p></p>
<p>Swift의 동시성 모델 소개로 Task에 대한 유사한 질문이 제기됩니다: 여전히 순환 참조를 방지하기 위해 weak self를 사용해야 할까요?</p>
<p>다음 비동기 작업을 고려해보세요.</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">doSomething</span>() {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"비동기 작업 시작됨"</span>)
    <span class="hljs-type">Task</span> {
        <span class="hljs-keyword">do</span> {
            <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> repository.remoteAPICall()
        } <span class="hljs-keyword">catch</span> {
            <span class="hljs-built_in">print</span>(error)
        }
    }
}
</code></pre>
<p>여기서 weak self를 사용하지 않으면, <code>Task</code>이 <code>self</code>을 강하게 캡처하면서 인스턴스가 작업이 완료되기 전에 해제되어야 하는 순환 참조가 발생합니다. 클로저와는 달리, 컴파일러는 여기서 명시적인 <code>self</code> 사용을 요구하지 않기 때문에 weak self이 모든 비동기 작업에서 필수적인지에 대한 의문이 생깁니다. 놀랍게도, 대안 전략으로 작업 취소라는 것이 있기 때문에 weak self가 모든 비동기 작업에서 꼭 필요하지는 않습니다.</p>
<p></p>
<h1>작업 취소: 전략적 접근</h1>
<p>모든 비동기 작업에 일반적으로 <code>weak self</code>를 적용하는 대신 개발자들은 작업 취소를 더 적절한 전략으로 생각할 수 있습니다. 작업이 더 이상 필요하지 않을 때 해당 작업을 취소함으로써 <code>self</code>를 직접 관리하지 않고도 잠재적인 유지 사이클을 방지할 수 있습니다.</p>
<h2>작업 취소 단순화:</h2>
<pre><code class="hljs language-swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">extension</span> <span class="hljs-title class_">Task</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">store</span>(<span class="hljs-params">in</span> <span class="hljs-params">set</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Set</span>&#x3C;<span class="hljs-type">AnyCancellable</span>>) {
        <span class="hljs-keyword">set</span>.insert(<span class="hljs-type">AnyCancellable</span>(cancel))
    }
}
</code></pre>
<p></p>
<p>이 확장 프로그램은 작업 수명주기 관리를 간소화하여 집단 작업 취소를 용이하게 합니다.</p>
<h2>ViewModel에서 작업 취소 활용:</h2>
<pre><code class="hljs language-js">@<span class="hljs-title class_">MainActor</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeBigViewModel</span> {
    private <span class="hljs-keyword">let</span> repository = <span class="hljs-title class_">Repository</span>()
    private <span class="hljs-keyword">var</span> cancellableBag = <span class="hljs-title class_">Set</span>&#x3C;<span class="hljs-title class_">AnyCancellable</span>>()

    deinit {
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"deinit called"</span>)
    }

    func <span class="hljs-title function_">send</span>(<span class="hljs-params">_ action: Action</span>) {
        <span class="hljs-keyword">switch</span> action {
            <span class="hljs-keyword">case</span> .<span class="hljs-property">viewWillDisappear</span>:
                cancellableBag.<span class="hljs-title function_">removeAll</span>()
        }
    }

    private func <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) {
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"async operation started"</span>)
        <span class="hljs-title class_">Task</span> {
            <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> repository.<span class="hljs-title function_">remoteAPICall</span>()
            } <span class="hljs-keyword">catch</span> {
                <span class="hljs-title function_">print</span>(error)
            }
        }
        .<span class="hljs-title function_">store</span>(<span class="hljs-attr">in</span>: &#x26;cancellableBag)
    }
}
</code></pre>
<p>작업 취소를 사용하면 ViewModel이 해제될 때 작업도 취소되어 명시적으로 <code>weak self</code>를 사용하지 않아도 보존 사이클을 방지합니다.</p>
<p></p>
<pre><code class="hljs language-js">비동기 작업이 시작되었습니다
<span class="hljs-title class_">SomeBigViewModel</span>이 해제 중입니다
</code></pre>
<p>더 섬세한 작업 취소 제어를 원하는 개발자를 위해 다음 패턴을 적용할 수 있습니다:</p>
<p>이 접근 방식을 사용하면 비동기 작업의 ViewModel 관리가 보다 구조적이고 효율적으로 되며, 기본적으로 약한 self에 의존하는 것보다 전략적인 작업 취소로서 보류 중인 사이클을 피할 수 있습니다.</p>
<p>이 기사를 즐겼다면, Medium에 Clap으로 사랑을 보여주시고 의견을 자유롭게 공유해주세요. 이와 유사한 통찰력을 얻고 싶다면, Medium에서 저를 팔로우하고 LinkedIn 및 Twitter에서 저와 연락하십시오. 함께 더 많은 기술 토론에 참여해 봅시다!</p>
<p></p>
<p>Medium | LinkedIn | Twitter</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Swift 동시성 메모리 관리에서 Task Cancellation과 Weak Self의 비교","description":"","date":"2024-06-23 21:25","slug":"2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement","content":"\n![Image](/assets/img/2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement_0.png)\n\nSwift 개발에 관련해서, 메모리 관리를 이해하는 것은 복잡한 퍼즐을 해결하는 것과 같습니다. 이러한 퍼즐의 핵심에는 클로저와 비동기 작업을 처리하는 동안 메모리 누수에 빠지지 않는 것이라는 도전이 있습니다. 많은 개발자들이 리테인 싸이클을 피하는 데 사용해온 약한 참조(weak self) 개념은 클로저에서 탁월한 해결책이었습니다. 하지만 Swift의 동시성 모델, 특히 Task에서 이 실천이 원활하게 이어지는지 궁금할 것입니다. 실용적인 코드 예제와 통찰을 통해, 효율적인 Swift 프로그래밍을 위한 길을 밝혀보겠습니다.\n\n# 다루는 주제\n\n- 클로저에서 왜 weak self가 필요하며, 사용하지 않으면 어떻게 되는지?\n- Task 블록에서도 실제로 weak self가 필요한가?\n- Swift 동시성을 사용할 때 리테인 싸이클을 피하기 위해 어떤 조치를 취할 수 있는가?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 주요 포인트\n\n- 클로저에서의 순환 참조와 약한 self 사용의 중요성을 이해하세요.\n- 비동기 작업이 self를 강하게 캡처하면 작업 블록도 순환 참조를 생성할 수 있습니다.\n- 컴파일러는 클로저와 달리 작업 블록에서 명시적 self 사용을 요구하지 않습니다.\n- 약한 self에만 의존하지 않고 메모리를 효율적으로 관리할 대안으로 작업 취소를 사용할 수 있습니다.\n- 비동기 작업을 다룰 때 ViewModel에서 순환 참조를 방지하기 위해 작업 취소를 구현하세요.\n\n# 클로저에서의 'Weak Self' 딜레마\n\n약한 self의 필요성을 이해하려면 먼저 Swift에서 클로저의 세계로 들어가 보겠습니다. 클로저는 참조 타입이며 강하게 인스턴스(예: self)를 캡처하고 유지할 수 있습니다. 이로 인해 잠재적인 순환 참조가 발생할 수 있습니다. 이는 객체가 self를 참조하는 클로저를 소유하고, 그 클로저가 객체 자체에 의해 소유되는 경우 발생하여 서로 해제될 수 없는 루프를 만듭니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n전통적인 시나리오:\n\n```swift\nclass Repository {\n    func remoteAPICallWithClosure(onComplete: @escaping (String) -\u003e Void) {\n        DispatchQueue.main.asyncAfter(deadline: .now() + 4) {\n            onComplete(\"완료\")\n        }\n    }\n}\n\nclass SomeBigViewModel {\n    private let repository = Repository()\n    private var result = \"\"\n\n    func doSomethingWithClosure() {\n        repository.remoteAPICallWithClosure { apiResult in\n            self.result = apiResult\n        }\n    }\n}\n```\n\n이제 SomeBigViewModel의 인스턴스를 생성하고 doSomethingWithClosure을 호출한 후에 해당 인스턴스를 해제하려고 시도합니다:\n\n```swift\nvar vm: SomeBigViewModel? = SomeBigViewModel()\nvm?.doSomethingWithClosure()\nvm = nil\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n작업이 시작됩니다. 그러나 deint print 문은 즉시 나타나지 않을 것입니다. 이는 유지 주기(순환 참조)를 나타냅니다:\n\n```js\n작업이 시작됨\n```\n\n## 주기(순환 참조) 파괴하기\n\n우리의 클로저에서 [weak self]를 사용하여 유지 주기를 피하고 SomeBigViewModel이 해제되도록 할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfunc doSomethingWithClosure() {\n    print(\"작업이 시작되었습니다.\")\n    repository.remoteAPICallWithClosure { [weak self] apiResult in\n        guard let self = self else { return }\n        self.result = apiResult\n        print(\"API 결과를 받았습니다.\")\n    }\n}\n```\n\n코드를 수정하고 다시 실행한 후, 출력 결과는 예상대로 `deinit`이 호출되어 순환 참조가 해제된다는 것을 확인합니다:\n\n```js\n작업이 시작되었습니다.\nSomeBigViewModel이 해제되고 있습니다.\n```\n\n# Swift의 병행성 모델: Task와의 사례\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSwift의 동시성 모델 소개로 Task에 대한 유사한 질문이 제기됩니다: 여전히 순환 참조를 방지하기 위해 weak self를 사용해야 할까요?\n\n다음 비동기 작업을 고려해보세요.\n\n```swift\nfunc doSomething() {\n    print(\"비동기 작업 시작됨\")\n    Task {\n        do {\n            let result = try await repository.remoteAPICall()\n        } catch {\n            print(error)\n        }\n    }\n}\n```\n\n여기서 weak self를 사용하지 않으면, `Task`이 `self`을 강하게 캡처하면서 인스턴스가 작업이 완료되기 전에 해제되어야 하는 순환 참조가 발생합니다. 클로저와는 달리, 컴파일러는 여기서 명시적인 `self` 사용을 요구하지 않기 때문에 weak self이 모든 비동기 작업에서 필수적인지에 대한 의문이 생깁니다. 놀랍게도, 대안 전략으로 작업 취소라는 것이 있기 때문에 weak self가 모든 비동기 작업에서 꼭 필요하지는 않습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 작업 취소: 전략적 접근\n\n모든 비동기 작업에 일반적으로 `weak self`를 적용하는 대신 개발자들은 작업 취소를 더 적절한 전략으로 생각할 수 있습니다. 작업이 더 이상 필요하지 않을 때 해당 작업을 취소함으로써 `self`를 직접 관리하지 않고도 잠재적인 유지 사이클을 방지할 수 있습니다.\n\n## 작업 취소 단순화:\n\n```swift\npublic extension Task {\n    func store(in set: inout Set\u003cAnyCancellable\u003e) {\n        set.insert(AnyCancellable(cancel))\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 확장 프로그램은 작업 수명주기 관리를 간소화하여 집단 작업 취소를 용이하게 합니다.\n\n## ViewModel에서 작업 취소 활용:\n\n```js\n@MainActor\nclass SomeBigViewModel {\n    private let repository = Repository()\n    private var cancellableBag = Set\u003cAnyCancellable\u003e()\n\n    deinit {\n        print(\"deinit called\")\n    }\n\n    func send(_ action: Action) {\n        switch action {\n            case .viewWillDisappear:\n                cancellableBag.removeAll()\n        }\n    }\n\n    private func doSomething() {\n        print(\"async operation started\")\n        Task {\n            do {\n                let result = try await repository.remoteAPICall()\n            } catch {\n                print(error)\n            }\n        }\n        .store(in: \u0026cancellableBag)\n    }\n}\n```\n\n작업 취소를 사용하면 ViewModel이 해제될 때 작업도 취소되어 명시적으로 `weak self`를 사용하지 않아도 보존 사이클을 방지합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n비동기 작업이 시작되었습니다\nSomeBigViewModel이 해제 중입니다\n```\n\n더 섬세한 작업 취소 제어를 원하는 개발자를 위해 다음 패턴을 적용할 수 있습니다:\n\n이 접근 방식을 사용하면 비동기 작업의 ViewModel 관리가 보다 구조적이고 효율적으로 되며, 기본적으로 약한 self에 의존하는 것보다 전략적인 작업 취소로서 보류 중인 사이클을 피할 수 있습니다.\n\n이 기사를 즐겼다면, Medium에 Clap으로 사랑을 보여주시고 의견을 자유롭게 공유해주세요. 이와 유사한 통찰력을 얻고 싶다면, Medium에서 저를 팔로우하고 LinkedIn 및 Twitter에서 저와 연락하십시오. 함께 더 많은 기술 토론에 참여해 봅시다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMedium | LinkedIn | Twitter\n","ogImage":{"url":"/assets/img/2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement_0.png"},"coverImage":"/assets/img/2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement_0.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003eSwift 개발에 관련해서, 메모리 관리를 이해하는 것은 복잡한 퍼즐을 해결하는 것과 같습니다. 이러한 퍼즐의 핵심에는 클로저와 비동기 작업을 처리하는 동안 메모리 누수에 빠지지 않는 것이라는 도전이 있습니다. 많은 개발자들이 리테인 싸이클을 피하는 데 사용해온 약한 참조(weak self) 개념은 클로저에서 탁월한 해결책이었습니다. 하지만 Swift의 동시성 모델, 특히 Task에서 이 실천이 원활하게 이어지는지 궁금할 것입니다. 실용적인 코드 예제와 통찰을 통해, 효율적인 Swift 프로그래밍을 위한 길을 밝혀보겠습니다.\u003c/p\u003e\n\u003ch1\u003e다루는 주제\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e클로저에서 왜 weak self가 필요하며, 사용하지 않으면 어떻게 되는지?\u003c/li\u003e\n\u003cli\u003eTask 블록에서도 실제로 weak self가 필요한가?\u003c/li\u003e\n\u003cli\u003eSwift 동시성을 사용할 때 리테인 싸이클을 피하기 위해 어떤 조치를 취할 수 있는가?\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003e주요 포인트\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e클로저에서의 순환 참조와 약한 self 사용의 중요성을 이해하세요.\u003c/li\u003e\n\u003cli\u003e비동기 작업이 self를 강하게 캡처하면 작업 블록도 순환 참조를 생성할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e컴파일러는 클로저와 달리 작업 블록에서 명시적 self 사용을 요구하지 않습니다.\u003c/li\u003e\n\u003cli\u003e약한 self에만 의존하지 않고 메모리를 효율적으로 관리할 대안으로 작업 취소를 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e비동기 작업을 다룰 때 ViewModel에서 순환 참조를 방지하기 위해 작업 취소를 구현하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e클로저에서의 'Weak Self' 딜레마\u003c/h1\u003e\n\u003cp\u003e약한 self의 필요성을 이해하려면 먼저 Swift에서 클로저의 세계로 들어가 보겠습니다. 클로저는 참조 타입이며 강하게 인스턴스(예: self)를 캡처하고 유지할 수 있습니다. 이로 인해 잠재적인 순환 참조가 발생할 수 있습니다. 이는 객체가 self를 참조하는 클로저를 소유하고, 그 클로저가 객체 자체에 의해 소유되는 경우 발생하여 서로 해제될 수 없는 루프를 만듭니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e전통적인 시나리오:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRepository\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eremoteAPICallWithClosure\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eonComplete\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003e@escaping\u003c/span\u003e (\u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-type\"\u003eVoid\u003c/span\u003e) {\n        \u003cspan class=\"hljs-type\"\u003eDispatchQueue\u003c/span\u003e.main.asyncAfter(deadline: .now() \u003cspan class=\"hljs-operator\"\u003e+\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e) {\n            onComplete(\u003cspan class=\"hljs-string\"\u003e\"완료\"\u003c/span\u003e)\n        }\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSomeBigViewModel\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e repository \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eRepository\u003c/span\u003e()\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e result \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edoSomethingWithClosure\u003c/span\u003e() {\n        repository.remoteAPICallWithClosure { apiResult \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.result \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e apiResult\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 SomeBigViewModel의 인스턴스를 생성하고 doSomethingWithClosure을 호출한 후에 해당 인스턴스를 해제하려고 시도합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e vm: \u003cspan class=\"hljs-type\"\u003eSomeBigViewModel\u003c/span\u003e? \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eSomeBigViewModel\u003c/span\u003e()\nvm\u003cspan class=\"hljs-operator\"\u003e?\u003c/span\u003e.doSomethingWithClosure()\nvm \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e작업이 시작됩니다. 그러나 deint print 문은 즉시 나타나지 않을 것입니다. 이는 유지 주기(순환 참조)를 나타냅니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e작업이 시작됨\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e주기(순환 참조) 파괴하기\u003c/h2\u003e\n\u003cp\u003e우리의 클로저에서 [weak self]를 사용하여 유지 주기를 피하고 SomeBigViewModel이 해제되도록 할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efunc \u003cspan class=\"hljs-title function_\"\u003edoSomethingWithClosure\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"작업이 시작되었습니다.\"\u003c/span\u003e)\n    repository.\u003cspan class=\"hljs-property\"\u003eremoteAPICallWithClosure\u003c/span\u003e { [weak self] apiResult \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n        guard \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e self = self \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e }\n        self.\u003cspan class=\"hljs-property\"\u003eresult\u003c/span\u003e = apiResult\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"API 결과를 받았습니다.\"\u003c/span\u003e)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e코드를 수정하고 다시 실행한 후, 출력 결과는 예상대로 \u003ccode\u003edeinit\u003c/code\u003e이 호출되어 순환 참조가 해제된다는 것을 확인합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e작업이 시작되었습니다.\n\u003cspan class=\"hljs-title class_\"\u003eSomeBigViewModel\u003c/span\u003e이 해제되고 있습니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eSwift의 병행성 모델: Task와의 사례\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eSwift의 동시성 모델 소개로 Task에 대한 유사한 질문이 제기됩니다: 여전히 순환 참조를 방지하기 위해 weak self를 사용해야 할까요?\u003c/p\u003e\n\u003cp\u003e다음 비동기 작업을 고려해보세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edoSomething\u003c/span\u003e() {\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"비동기 작업 시작됨\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-type\"\u003eTask\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003edo\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e result \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e repository.remoteAPICall()\n        } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e {\n            \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(error)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 weak self를 사용하지 않으면, \u003ccode\u003eTask\u003c/code\u003e이 \u003ccode\u003eself\u003c/code\u003e을 강하게 캡처하면서 인스턴스가 작업이 완료되기 전에 해제되어야 하는 순환 참조가 발생합니다. 클로저와는 달리, 컴파일러는 여기서 명시적인 \u003ccode\u003eself\u003c/code\u003e 사용을 요구하지 않기 때문에 weak self이 모든 비동기 작업에서 필수적인지에 대한 의문이 생깁니다. 놀랍게도, 대안 전략으로 작업 취소라는 것이 있기 때문에 weak self가 모든 비동기 작업에서 꼭 필요하지는 않습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003e작업 취소: 전략적 접근\u003c/h1\u003e\n\u003cp\u003e모든 비동기 작업에 일반적으로 \u003ccode\u003eweak self\u003c/code\u003e를 적용하는 대신 개발자들은 작업 취소를 더 적절한 전략으로 생각할 수 있습니다. 작업이 더 이상 필요하지 않을 때 해당 작업을 취소함으로써 \u003ccode\u003eself\u003c/code\u003e를 직접 관리하지 않고도 잠재적인 유지 사이클을 방지할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e작업 취소 단순화:\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextension\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTask\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003estore\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003eset\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003einout\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eSet\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-type\"\u003eAnyCancellable\u003c/span\u003e\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003eset\u003c/span\u003e.insert(\u003cspan class=\"hljs-type\"\u003eAnyCancellable\u003c/span\u003e(cancel))\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e이 확장 프로그램은 작업 수명주기 관리를 간소화하여 집단 작업 취소를 용이하게 합니다.\u003c/p\u003e\n\u003ch2\u003eViewModel에서 작업 취소 활용:\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eMainActor\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSomeBigViewModel\u003c/span\u003e {\n    private \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e repository = \u003cspan class=\"hljs-title class_\"\u003eRepository\u003c/span\u003e()\n    private \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e cancellableBag = \u003cspan class=\"hljs-title class_\"\u003eSet\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eAnyCancellable\u003c/span\u003e\u003e()\n\n    deinit {\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"deinit called\"\u003c/span\u003e)\n    }\n\n    func \u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e_ action: Action\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e action {\n            \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003eviewWillDisappear\u003c/span\u003e:\n                cancellableBag.\u003cspan class=\"hljs-title function_\"\u003eremoveAll\u003c/span\u003e()\n        }\n    }\n\n    private func \u003cspan class=\"hljs-title function_\"\u003edoSomething\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"async operation started\"\u003c/span\u003e)\n        \u003cspan class=\"hljs-title class_\"\u003eTask\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003edo\u003c/span\u003e {\n                \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e result = \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e repository.\u003cspan class=\"hljs-title function_\"\u003eremoteAPICall\u003c/span\u003e()\n            } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e {\n                \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(error)\n            }\n        }\n        .\u003cspan class=\"hljs-title function_\"\u003estore\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ein\u003c/span\u003e: \u0026#x26;cancellableBag)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e작업 취소를 사용하면 ViewModel이 해제될 때 작업도 취소되어 명시적으로 \u003ccode\u003eweak self\u003c/code\u003e를 사용하지 않아도 보존 사이클을 방지합니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e비동기 작업이 시작되었습니다\n\u003cspan class=\"hljs-title class_\"\u003eSomeBigViewModel\u003c/span\u003e이 해제 중입니다\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e더 섬세한 작업 취소 제어를 원하는 개발자를 위해 다음 패턴을 적용할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e이 접근 방식을 사용하면 비동기 작업의 ViewModel 관리가 보다 구조적이고 효율적으로 되며, 기본적으로 약한 self에 의존하는 것보다 전략적인 작업 취소로서 보류 중인 사이클을 피할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 기사를 즐겼다면, Medium에 Clap으로 사랑을 보여주시고 의견을 자유롭게 공유해주세요. 이와 유사한 통찰력을 얻고 싶다면, Medium에서 저를 팔로우하고 LinkedIn 및 Twitter에서 저와 연락하십시오. 함께 더 많은 기술 토론에 참여해 봅시다!\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eMedium | LinkedIn | Twitter\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement"},"buildId":"bb_yO9GbCvdfc_n71SfUf","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>