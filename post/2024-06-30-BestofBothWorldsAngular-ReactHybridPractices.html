<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Angular-React 하이브리드 기법 두 기술의 장점 모음 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-30-BestofBothWorldsAngular-ReactHybridPractices" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Angular-React 하이브리드 기법 두 기술의 장점 모음 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Angular-React 하이브리드 기법 두 기술의 장점 모음 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-30-BestofBothWorldsAngular-ReactHybridPractices_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-30-BestofBothWorldsAngular-ReactHybridPractices" data-gatsby-head="true"/><meta name="twitter:title" content="Angular-React 하이브리드 기법 두 기술의 장점 모음 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-30-BestofBothWorldsAngular-ReactHybridPractices_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-30 22:27" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_buildManifest.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Angular-React 하이브리드 기법 두 기술의 장점 모음</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Angular-React 하이브리드 기법 두 기술의 장점 모음" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 30, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-30-BestofBothWorldsAngular-ReactHybridPractices&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-30-BestofBothWorldsAngular-ReactHybridPractices_0.png" alt="이미지"></p>
<p>지금까지 프론트엔드 개발자들 사이에서 Angular가 React보다 더 나은지 아니면 그 반대인지에 대한 논쟁이 있었습니다. React 개발자로서 몇 년 동안 내가 옳은 쪽에 있다고 확신하고 있던 중에, 상황이 나를 Angular를 배우도록 강요했죠. 처음에는 정말 어색했고 그 개념들을 비판하기 시작했지만, 몇 주간의 학습 후에 드디어 그것에 익숙해졌습니다. 시간이 지나고 더 많은 지식을 쌓으면서 확신 있는 Angular 개발자가 되었고, 이제 "어떤 프레임워크가 더 나은가"라는 질문에 답할 수 있을 것 같지만, 더 깊이 배우면 배울수록 이 두 독특한 도구를 비교하는 것이 더 어려워집니다. 그러나 이 글의 목적은 이들을 비교하는 것이 아니라 한 프레임워크에서 채택한 실천법을 다른 프레임워크로 재사용하는 경험을 공유하는 것입니다.</p>
<h1>HTML 템플릿</h1>
<p>React의 컴포넌트는 JSX와 함께 논리가 섞여있어서 매우 엉망이 될 수 있다는 일반적인 불만이 있습니다. 컴포넌트가 커지면, 코드를 읽으려는 누군가에게 덜 이해하기 쉬워집니다. 이것은 Angular 지지자들이 논쟁에서 사용하는 주장 중 하나입니다. 정확한가요? 음, 부분적으로 맞습니다. React는 Angular와 달리 특정한 범위와 규칙을 부과하지 않고 원하는 대로 코드를 작성할 수 있게 해줍니다. 때로는 React의 이 자유가 엉망으로 이어질 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>구글 프레임워크를 몇 년 동안 사용한 후에 그 방식에 적응되었고 심지어 그 방식에 대한 동정심까지 키웠어요. 그래서 생각했죠: ‘왜 리액트에서도 똑같은 작업을 할 수 없을까?’ 답은 간단해요: ‘할 수 있어요.’ 이를 실현하기 위해선 우리의 리액트 컴포넌트를 두 개의 파일로 분리하는 규칙을 따르면 돼요. 템플릿과 로직을 각각의 파일에 위치시켜야 해요. 아래의 예시처럼 말이죠.”</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// MyComponent.jsx</span>

<span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MyComponentTemplate</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./my.component.template"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">MyComponent</span> = (<span class="hljs-params"></span>) => {
    <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

    <span class="hljs-keyword">const</span> <span class="hljs-title function_">decrement</span> = (<span class="hljs-params"></span>) => {
        <span class="hljs-title function_">setCount</span>(count - <span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) => {
        <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">MyComponentTemplate</span> <span class="hljs-attr">increment</span>=<span class="hljs-string">{increment}</span> <span class="hljs-attr">decrement</span>=<span class="hljs-string">{decrement}</span> <span class="hljs-attr">count</span>=<span class="hljs-string">{count}</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">MyComponentTemplate</span>></span></span>
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// MyComponent.template.jsx</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">MyComponentTemplate</span> = (<span class="hljs-params">{amount, increment, decrement}</span>) => {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>
            {amount}
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{increment}</span>></span> + <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{decrement}</span>></span> - <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/></span></span>
}
</code></pre>
<p>그리고 여기까지입니다. 어떻게 생각하시나요? :)</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>의존성 주입</h1>
<p>의존성 주입은 Angular에서 채택된 주요 디자인 패턴 중 하나입니다. 느슨한 결합 및 관심사 분리를 촉진하여 모듈화, 유지 관리성, 테스트 용이성을 향상시킵니다. 서비스는 비즈니스 로직과 UI 구성 요소를 분리하는 훌륭한 방법을 제공합니다. 데이터 가져오기, 상태 관리 또는 기타 작업과 관련된 기능을 캡슐화함으로써 서비스는 구성 요소를 깔끔하고 집중시킵니다. 서비스는 다른 프레임워크에서 잘 작동하지만 React에서는 자연스럽지 않을 수 있습니다. React의 컴포넌트 중심 접근 방식은 종종 개발자가 로직을 직접 처리하도록 유도합니다. 과제는 컴포넌트 간의 간단함과 로직 분리 사이의 적절한 균형을 찾는 데 있습니다. React의 Context API가 해결책을 제공합니다. Context를 생성함으로써 종속성을 명시적으로 props를 통해 전달하지 않고 컴포넌트 트리 전체에서 공유할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// ContextProvider.jsx</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MyService</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">'@services/myService'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyServiceInstance</span> = <span class="hljs-title function_">createContext</span>({});

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">MyServiceProvider</span>= (<span class="hljs-params">{ children }</span>) => {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">MyServiceInstance.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{new</span> <span class="hljs-attr">MyService</span>()}></span>{children}
         <span class="hljs-tag">&#x3C;/<span class="hljs-name">MyServiceInstance.Provider</span>></span></span>;
};
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// App.jsx</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">return</span> (   
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">MyServiceProvider</span>></span>
      // ...내 앱 콘텐츠
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">MyServiceProvider</span>></span></span> 
  );
}
  
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-comment">// MyComponent.jsx</span>

<span class="hljs-keyword">const</span> <span class="hljs-title function_">MyComponent</span>= (<span class="hljs-params"></span>) => { 
  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> myService = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">MyServiceInstance</span>);
  
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">if</span>(myService) <span class="hljs-title function_">getData</span>();
  }, [myService])

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">getData</span> = (<span class="hljs-params"></span>) => {
    myService.<span class="hljs-title function_">getData</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =></span> <span class="hljs-title function_">setData</span>(res));
  }

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">MyComponentTemplate</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{data}</span> /></span></span>
}
</code></pre>
<h1>타입스크립트</h1>
<p>이게 꽤 명백한 것 같아요. 그러나 저는 종종 타입스크립트를 사용하지 않는 React 프로젝트를 만납니다. 그렇게 되면 Angular 개발자들이 React 앱이 엉망이라고 불평하는 이유가 하나 더 생기게 되는데, 저는 완전히 동의해요. 타입스크립트는 코드를 더 안전하고 이해하기 쉬운 방법을 제공합니다.</p>
<h1>프로미스 또는 옵저버블?</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그 질문을 여러 번 받아봤어요. Angular는 React가 프로미스를 사용하는 용도로 사용하는 것과 같은 목적을 위해 옵저버블을 사용하지만, 저는 이 두 도구를 비교하는 대신 둘 다 사용할 수 있다고 생각해요. 둘 다 장단점이 있지만, 각 도구가 만들어진 목적에 맞게 사용하면 개발 시간과 경험을 향상시킬 수 있을 거예요.</p>
<p>React는 프로미스 기반이라는 사실은 알려진 사실이에요. Angular는 옵저버블 기반이죠. 두 도구를 함께 사용할 때 마주치는 문제 중 하나는 때로는 프로미스를 반드시 사용해야 할 때에도 Angular가 옵저버블을 사용하도록 강요하고, 한 번 호출할 메소드에 불필요한 구독을 생성해야 한다는 것이었어요. 그 말인 즉슨 구독을 해제해야 한다는 것이죠. 이것은 너무 많은 보일러플레이트 코드라고 제 생각에는요. 반면에 React 코드에서는 옵저버블을 자주 사용하지 않는데, 대신에 해결책을 만들어내고, 여러 "useEffect" 훅을 사용하다 보면 엉망이 될 수도 있어요. "useEffect"는 아주 유용한 도구이지만 때로는 옵저버블이 필요할 수도 있어요. RxJs는 Angular 애플리케이션에서 일반적으로 사용되는 강력한 라이브러리이며, React와도 잘 어울린다고 해요.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// MyService.ts 조각</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> {
  isReady = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BehaviorSubject</span>&#x3C;boolean>(<span class="hljs-literal">false</span>);
    
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">connectToSocket</span>();
  }

  private connectToSocket = <span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">socket</span>.<span class="hljs-title function_">connect</span>().<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">message</span>) =></span> {
      <span class="hljs-keyword">if</span>(message.<span class="hljs-property">status</span> === <span class="hljs-string">'READY'</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">isReady</span>.<span class="hljs-title function_">next</span>(<span class="hljs-literal">true</span>);
      }
    })
  }
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// MyComponent.tsx 조각</span>

<span class="hljs-keyword">const</span> myService= <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">MyServiceInstance</span>);  

<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
  <span class="hljs-keyword">const</span> subscription = myService.<span class="hljs-property">isReady</span>.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">isReady: boolean</span>) =></span> {
    <span class="hljs-keyword">if</span> (isReady) {
      <span class="hljs-comment">// ...할 일</span>
    }
  });

  <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> subscription.<span class="hljs-title function_">unsubscribe</span>();
}, [myService]);
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>결론</h1>
<p>소프트웨어 개발은 문제를 다양한 방법으로 해결할 수 있는 풍부한 세계입니다. 어떤 방법을 선택할지는 당신의 몫입니다. 이 글에서는 내게 잘 작용한 방법을 공유했고, 누군가에게 유용할 수도 있다고 생각했습니다. React와 Angular를 비교하는 것은 그리 의미가 없습니다. 둘 다 놀라울 정도로 좋으니까요. 다음에 누군가가 어떤 것이 더 나은지 물어보면, '둘 다!' 라고 대답할 거예요. 여러분은 어떠세요?</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Angular-React 하이브리드 기법 두 기술의 장점 모음","description":"","date":"2024-06-30 22:27","slug":"2024-06-30-BestofBothWorldsAngular-ReactHybridPractices","content":"\n\n![이미지](/assets/img/2024-06-30-BestofBothWorldsAngular-ReactHybridPractices_0.png) \n\n지금까지 프론트엔드 개발자들 사이에서 Angular가 React보다 더 나은지 아니면 그 반대인지에 대한 논쟁이 있었습니다. React 개발자로서 몇 년 동안 내가 옳은 쪽에 있다고 확신하고 있던 중에, 상황이 나를 Angular를 배우도록 강요했죠. 처음에는 정말 어색했고 그 개념들을 비판하기 시작했지만, 몇 주간의 학습 후에 드디어 그것에 익숙해졌습니다. 시간이 지나고 더 많은 지식을 쌓으면서 확신 있는 Angular 개발자가 되었고, 이제 \"어떤 프레임워크가 더 나은가\"라는 질문에 답할 수 있을 것 같지만, 더 깊이 배우면 배울수록 이 두 독특한 도구를 비교하는 것이 더 어려워집니다. 그러나 이 글의 목적은 이들을 비교하는 것이 아니라 한 프레임워크에서 채택한 실천법을 다른 프레임워크로 재사용하는 경험을 공유하는 것입니다.\n\n# HTML 템플릿\n\nReact의 컴포넌트는 JSX와 함께 논리가 섞여있어서 매우 엉망이 될 수 있다는 일반적인 불만이 있습니다. 컴포넌트가 커지면, 코드를 읽으려는 누군가에게 덜 이해하기 쉬워집니다. 이것은 Angular 지지자들이 논쟁에서 사용하는 주장 중 하나입니다. 정확한가요? 음, 부분적으로 맞습니다. React는 Angular와 달리 특정한 범위와 규칙을 부과하지 않고 원하는 대로 코드를 작성할 수 있게 해줍니다. 때로는 React의 이 자유가 엉망으로 이어질 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n구글 프레임워크를 몇 년 동안 사용한 후에 그 방식에 적응되었고 심지어 그 방식에 대한 동정심까지 키웠어요. 그래서 생각했죠: ‘왜 리액트에서도 똑같은 작업을 할 수 없을까?’ 답은 간단해요: ‘할 수 있어요.’ 이를 실현하기 위해선 우리의 리액트 컴포넌트를 두 개의 파일로 분리하는 규칙을 따르면 돼요. 템플릿과 로직을 각각의 파일에 위치시켜야 해요. 아래의 예시처럼 말이죠.”\n\n```js\n// MyComponent.jsx\n\nimport { useState } from \"react\"\nimport { MyComponentTemplate } from \"./my.component.template\";\n\nexport const MyComponent = () =\u003e {\n    const [count, setCount] = useState(0);\n\n    const decrement = () =\u003e {\n        setCount(count - 1);\n    }\n\n    const increment = () =\u003e {\n        setCount(count + 1);\n    }\n\n    return \u003cMyComponentTemplate increment={increment} decrement={decrement} count={count}\u003e\u003c/MyComponentTemplate\u003e\n}\n```\n\n```js\n// MyComponent.template.jsx\n\nexport const MyComponentTemplate = ({amount, increment, decrement}) =\u003e {\n    return \u003c\u003e\n        \u003ch1\u003e\n            {amount}\n        \u003c/h1\u003e\n        \u003cbutton onClick={increment}\u003e + \u003c/button\u003e\n        \u003cbutton onClick={decrement}\u003e - \u003c/button\u003e\n    \u003c/\u003e\n}\n```\n\n그리고 여기까지입니다. 어떻게 생각하시나요? :)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 의존성 주입\n\n의존성 주입은 Angular에서 채택된 주요 디자인 패턴 중 하나입니다. 느슨한 결합 및 관심사 분리를 촉진하여 모듈화, 유지 관리성, 테스트 용이성을 향상시킵니다. 서비스는 비즈니스 로직과 UI 구성 요소를 분리하는 훌륭한 방법을 제공합니다. 데이터 가져오기, 상태 관리 또는 기타 작업과 관련된 기능을 캡슐화함으로써 서비스는 구성 요소를 깔끔하고 집중시킵니다. 서비스는 다른 프레임워크에서 잘 작동하지만 React에서는 자연스럽지 않을 수 있습니다. React의 컴포넌트 중심 접근 방식은 종종 개발자가 로직을 직접 처리하도록 유도합니다. 과제는 컴포넌트 간의 간단함과 로직 분리 사이의 적절한 균형을 찾는 데 있습니다. React의 Context API가 해결책을 제공합니다. Context를 생성함으로써 종속성을 명시적으로 props를 통해 전달하지 않고 컴포넌트 트리 전체에서 공유할 수 있습니다.\n\n```js\n// ContextProvider.jsx\nimport { MyService} from '@services/myService';\n\nexport const MyServiceInstance = createContext({});\n\nexport const MyServiceProvider= ({ children }) =\u003e {\n  return \u003cMyServiceInstance.Provider value={new MyService()}\u003e{children}\n         \u003c/MyServiceInstance.Provider\u003e;\n};\n```\n\n```js\n// App.jsx\n\nexport const App = () =\u003e {\n  return (   \n    \u003cMyServiceProvider\u003e\n      // ...내 앱 콘텐츠\n    \u003c/MyServiceProvider\u003e \n  );\n}\n  \n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// MyComponent.jsx\n\nconst MyComponent= () =\u003e { \n  const [data, setData] = useState(null);\n  const myService = useContext(MyServiceInstance);\n  \n  useEffect(() =\u003e {\n    if(myService) getData();\n  }, [myService])\n\n  const getData = () =\u003e {\n    myService.getData().then(res =\u003e setData(res));\n  }\n\n  return \u003cMyComponentTemplate data={data} /\u003e\n}\n```\n\n# 타입스크립트\n\n이게 꽤 명백한 것 같아요. 그러나 저는 종종 타입스크립트를 사용하지 않는 React 프로젝트를 만납니다. 그렇게 되면 Angular 개발자들이 React 앱이 엉망이라고 불평하는 이유가 하나 더 생기게 되는데, 저는 완전히 동의해요. 타입스크립트는 코드를 더 안전하고 이해하기 쉬운 방법을 제공합니다.\n\n# 프로미스 또는 옵저버블?\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 질문을 여러 번 받아봤어요. Angular는 React가 프로미스를 사용하는 용도로 사용하는 것과 같은 목적을 위해 옵저버블을 사용하지만, 저는 이 두 도구를 비교하는 대신 둘 다 사용할 수 있다고 생각해요. 둘 다 장단점이 있지만, 각 도구가 만들어진 목적에 맞게 사용하면 개발 시간과 경험을 향상시킬 수 있을 거예요.\n\nReact는 프로미스 기반이라는 사실은 알려진 사실이에요. Angular는 옵저버블 기반이죠. 두 도구를 함께 사용할 때 마주치는 문제 중 하나는 때로는 프로미스를 반드시 사용해야 할 때에도 Angular가 옵저버블을 사용하도록 강요하고, 한 번 호출할 메소드에 불필요한 구독을 생성해야 한다는 것이었어요. 그 말인 즉슨 구독을 해제해야 한다는 것이죠. 이것은 너무 많은 보일러플레이트 코드라고 제 생각에는요. 반면에 React 코드에서는 옵저버블을 자주 사용하지 않는데, 대신에 해결책을 만들어내고, 여러 \"useEffect\" 훅을 사용하다 보면 엉망이 될 수도 있어요. \"useEffect\"는 아주 유용한 도구이지만 때로는 옵저버블이 필요할 수도 있어요. RxJs는 Angular 애플리케이션에서 일반적으로 사용되는 강력한 라이브러리이며, React와도 잘 어울린다고 해요.\n\n```js\n// MyService.ts 조각\nexport class MyService {\n  isReady = new BehaviorSubject\u003cboolean\u003e(false);\n    \n  constructor() {\n    this.connectToSocket();\n  }\n\n  private connectToSocket = () =\u003e {\n    this.socket.connect().subscribe((message) =\u003e {\n      if(message.status === 'READY') {\n        this.isReady.next(true);\n      }\n    })\n  }\n}\n```\n\n```js\n// MyComponent.tsx 조각\n\nconst myService= useContext(MyServiceInstance);  \n\nuseEffect(() =\u003e {\n  const subscription = myService.isReady.subscribe((isReady: boolean) =\u003e {\n    if (isReady) {\n      // ...할 일\n    }\n  });\n\n  return () =\u003e subscription.unsubscribe();\n}, [myService]);\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n소프트웨어 개발은 문제를 다양한 방법으로 해결할 수 있는 풍부한 세계입니다. 어떤 방법을 선택할지는 당신의 몫입니다. 이 글에서는 내게 잘 작용한 방법을 공유했고, 누군가에게 유용할 수도 있다고 생각했습니다. React와 Angular를 비교하는 것은 그리 의미가 없습니다. 둘 다 놀라울 정도로 좋으니까요. 다음에 누군가가 어떤 것이 더 나은지 물어보면, '둘 다!' 라고 대답할 거예요. 여러분은 어떠세요?","ogImage":{"url":"/assets/img/2024-06-30-BestofBothWorldsAngular-ReactHybridPractices_0.png"},"coverImage":"/assets/img/2024-06-30-BestofBothWorldsAngular-ReactHybridPractices_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-BestofBothWorldsAngular-ReactHybridPractices_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e지금까지 프론트엔드 개발자들 사이에서 Angular가 React보다 더 나은지 아니면 그 반대인지에 대한 논쟁이 있었습니다. React 개발자로서 몇 년 동안 내가 옳은 쪽에 있다고 확신하고 있던 중에, 상황이 나를 Angular를 배우도록 강요했죠. 처음에는 정말 어색했고 그 개념들을 비판하기 시작했지만, 몇 주간의 학습 후에 드디어 그것에 익숙해졌습니다. 시간이 지나고 더 많은 지식을 쌓으면서 확신 있는 Angular 개발자가 되었고, 이제 \"어떤 프레임워크가 더 나은가\"라는 질문에 답할 수 있을 것 같지만, 더 깊이 배우면 배울수록 이 두 독특한 도구를 비교하는 것이 더 어려워집니다. 그러나 이 글의 목적은 이들을 비교하는 것이 아니라 한 프레임워크에서 채택한 실천법을 다른 프레임워크로 재사용하는 경험을 공유하는 것입니다.\u003c/p\u003e\n\u003ch1\u003eHTML 템플릿\u003c/h1\u003e\n\u003cp\u003eReact의 컴포넌트는 JSX와 함께 논리가 섞여있어서 매우 엉망이 될 수 있다는 일반적인 불만이 있습니다. 컴포넌트가 커지면, 코드를 읽으려는 누군가에게 덜 이해하기 쉬워집니다. 이것은 Angular 지지자들이 논쟁에서 사용하는 주장 중 하나입니다. 정확한가요? 음, 부분적으로 맞습니다. React는 Angular와 달리 특정한 범위와 규칙을 부과하지 않고 원하는 대로 코드를 작성할 수 있게 해줍니다. 때로는 React의 이 자유가 엉망으로 이어질 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e구글 프레임워크를 몇 년 동안 사용한 후에 그 방식에 적응되었고 심지어 그 방식에 대한 동정심까지 키웠어요. 그래서 생각했죠: ‘왜 리액트에서도 똑같은 작업을 할 수 없을까?’ 답은 간단해요: ‘할 수 있어요.’ 이를 실현하기 위해선 우리의 리액트 컴포넌트를 두 개의 파일로 분리하는 규칙을 따르면 돼요. 템플릿과 로직을 각각의 파일에 위치시켜야 해요. 아래의 예시처럼 말이죠.”\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// MyComponent.jsx\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eMyComponentTemplate\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"./my.component.template\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMyComponent\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [count, setCount] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edecrement\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n        \u003cspan class=\"hljs-title function_\"\u003esetCount\u003c/span\u003e(count - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eincrement\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n        \u003cspan class=\"hljs-title function_\"\u003esetCount\u003c/span\u003e(count + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eMyComponentTemplate\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eincrement\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{increment}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edecrement\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{decrement}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecount\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{count}\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eMyComponentTemplate\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// MyComponent.template.jsx\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMyComponentTemplate\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{amount, increment, decrement}\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n            {amount}\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{increment}\u003c/span\u003e\u003e\u003c/span\u003e + \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{decrement}\u003c/span\u003e\u003e\u003c/span\u003e - \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 여기까지입니다. 어떻게 생각하시나요? :)\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e의존성 주입\u003c/h1\u003e\n\u003cp\u003e의존성 주입은 Angular에서 채택된 주요 디자인 패턴 중 하나입니다. 느슨한 결합 및 관심사 분리를 촉진하여 모듈화, 유지 관리성, 테스트 용이성을 향상시킵니다. 서비스는 비즈니스 로직과 UI 구성 요소를 분리하는 훌륭한 방법을 제공합니다. 데이터 가져오기, 상태 관리 또는 기타 작업과 관련된 기능을 캡슐화함으로써 서비스는 구성 요소를 깔끔하고 집중시킵니다. 서비스는 다른 프레임워크에서 잘 작동하지만 React에서는 자연스럽지 않을 수 있습니다. React의 컴포넌트 중심 접근 방식은 종종 개발자가 로직을 직접 처리하도록 유도합니다. 과제는 컴포넌트 간의 간단함과 로직 분리 사이의 적절한 균형을 찾는 데 있습니다. React의 Context API가 해결책을 제공합니다. Context를 생성함으로써 종속성을 명시적으로 props를 통해 전달하지 않고 컴포넌트 트리 전체에서 공유할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ContextProvider.jsx\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eMyService\u003c/span\u003e} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@services/myService'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyServiceInstance\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003ecreateContext\u003c/span\u003e({});\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMyServiceProvider\u003c/span\u003e= (\u003cspan class=\"hljs-params\"\u003e{ children }\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eMyServiceInstance.Provider\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{new\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eMyService\u003c/span\u003e()}\u003e\u003c/span\u003e{children}\n         \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eMyServiceInstance.Provider\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// App.jsx\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (   \n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eMyServiceProvider\u003c/span\u003e\u003e\u003c/span\u003e\n      // ...내 앱 콘텐츠\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eMyServiceProvider\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e \n  );\n}\n  \n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// MyComponent.jsx\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMyComponent\u003c/span\u003e= (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e { \n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [data, setData] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e myService = \u003cspan class=\"hljs-title function_\"\u003euseContext\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMyServiceInstance\u003c/span\u003e);\n  \n  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(myService) \u003cspan class=\"hljs-title function_\"\u003egetData\u003c/span\u003e();\n  }, [myService])\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetData\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n    myService.\u003cspan class=\"hljs-title function_\"\u003egetData\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetData\u003c/span\u003e(res));\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eMyComponentTemplate\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{data}\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e타입스크립트\u003c/h1\u003e\n\u003cp\u003e이게 꽤 명백한 것 같아요. 그러나 저는 종종 타입스크립트를 사용하지 않는 React 프로젝트를 만납니다. 그렇게 되면 Angular 개발자들이 React 앱이 엉망이라고 불평하는 이유가 하나 더 생기게 되는데, 저는 완전히 동의해요. 타입스크립트는 코드를 더 안전하고 이해하기 쉬운 방법을 제공합니다.\u003c/p\u003e\n\u003ch1\u003e프로미스 또는 옵저버블?\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그 질문을 여러 번 받아봤어요. Angular는 React가 프로미스를 사용하는 용도로 사용하는 것과 같은 목적을 위해 옵저버블을 사용하지만, 저는 이 두 도구를 비교하는 대신 둘 다 사용할 수 있다고 생각해요. 둘 다 장단점이 있지만, 각 도구가 만들어진 목적에 맞게 사용하면 개발 시간과 경험을 향상시킬 수 있을 거예요.\u003c/p\u003e\n\u003cp\u003eReact는 프로미스 기반이라는 사실은 알려진 사실이에요. Angular는 옵저버블 기반이죠. 두 도구를 함께 사용할 때 마주치는 문제 중 하나는 때로는 프로미스를 반드시 사용해야 할 때에도 Angular가 옵저버블을 사용하도록 강요하고, 한 번 호출할 메소드에 불필요한 구독을 생성해야 한다는 것이었어요. 그 말인 즉슨 구독을 해제해야 한다는 것이죠. 이것은 너무 많은 보일러플레이트 코드라고 제 생각에는요. 반면에 React 코드에서는 옵저버블을 자주 사용하지 않는데, 대신에 해결책을 만들어내고, 여러 \"useEffect\" 훅을 사용하다 보면 엉망이 될 수도 있어요. \"useEffect\"는 아주 유용한 도구이지만 때로는 옵저버블이 필요할 수도 있어요. RxJs는 Angular 애플리케이션에서 일반적으로 사용되는 강력한 라이브러리이며, React와도 잘 어울린다고 해요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// MyService.ts 조각\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyService\u003c/span\u003e {\n  isReady = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBehaviorSubject\u003c/span\u003e\u0026#x3C;boolean\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n    \n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003econnectToSocket\u003c/span\u003e();\n  }\n\n  private connectToSocket = \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esocket\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003econnect\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003emessage\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(message.\u003cspan class=\"hljs-property\"\u003estatus\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e'READY'\u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eisReady\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n      }\n    })\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// MyComponent.tsx 조각\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e myService= \u003cspan class=\"hljs-title function_\"\u003euseContext\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMyServiceInstance\u003c/span\u003e);  \n\n\u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e subscription = myService.\u003cspan class=\"hljs-property\"\u003eisReady\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eisReady: boolean\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isReady) {\n      \u003cspan class=\"hljs-comment\"\u003e// ...할 일\u003c/span\u003e\n    }\n  });\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e subscription.\u003cspan class=\"hljs-title function_\"\u003eunsubscribe\u003c/span\u003e();\n}, [myService]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e소프트웨어 개발은 문제를 다양한 방법으로 해결할 수 있는 풍부한 세계입니다. 어떤 방법을 선택할지는 당신의 몫입니다. 이 글에서는 내게 잘 작용한 방법을 공유했고, 누군가에게 유용할 수도 있다고 생각했습니다. React와 Angular를 비교하는 것은 그리 의미가 없습니다. 둘 다 놀라울 정도로 좋으니까요. 다음에 누군가가 어떤 것이 더 나은지 물어보면, '둘 다!' 라고 대답할 거예요. 여러분은 어떠세요?\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-30-BestofBothWorldsAngular-ReactHybridPractices"},"buildId":"wfHLuDA3kTGBYfaM5IGXk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>