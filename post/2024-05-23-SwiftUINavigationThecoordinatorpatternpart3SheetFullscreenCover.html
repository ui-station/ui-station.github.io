<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>SwiftUI 네비게이션 - 코디네이터 패턴 - 파트 3 시트, FullscreenCover | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="SwiftUI 네비게이션 - 코디네이터 패턴 - 파트 3 시트, FullscreenCover | ui-station" data-gatsby-head="true"/><meta property="og:title" content="SwiftUI 네비게이션 - 코디네이터 패턴 - 파트 3 시트, FullscreenCover | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover" data-gatsby-head="true"/><meta name="twitter:title" content="SwiftUI 네비게이션 - 코디네이터 패턴 - 파트 3 시트, FullscreenCover | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-23 13:10" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_buildManifest.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">SwiftUI 네비게이션 - 코디네이터 패턴 - 파트 3 시트, FullscreenCover</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="SwiftUI 네비게이션 - 코디네이터 패턴 - 파트 3 시트, FullscreenCover" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 23, 2024</span><span class="posts_reading_time__f7YPP">16<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover_0.png" alt="이미지"></p>
<p>이 글은 이전 글들을 이어서 작성되었으며, 그 위에 쌓아 올릴 것입니다.
SwiftUI 네비게이션 파트 1 — 푸시 네비게이션
SwiftUI 네비게이션 파트 2 — 알림</p>
<p>이 글에서는 Sheets 및 FullscreenCovers을 동시에 다룰 것이며, 이들은 동일한 방식으로 구현됩니다.</p>
<p>시작해 봅시다! 이전 글들에서는 결정적 목적지로 조정하기 위해 Routes를 사용했습니다. 그러나 SwiftUI는 어떻게 이루어지는 걸까요?
뷰 계층 구조의 루트에 있는 NavigationStack에 대한 네비게이션 경로에 대한 바인딩이 있습니다. Apple의 문서 예제를 살펴보겠습니다:</p>
<p></p>
<pre><code class="hljs language-js"><span class="hljs-title class_">NavigationStack</span>(<span class="hljs-attr">path</span>: $presentedParks) {
    <span class="hljs-title class_">List</span>(parks) { park <span class="hljs-keyword">in</span>
        <span class="hljs-title class_">NavigationLink</span>(park.<span class="hljs-property">name</span>, <span class="hljs-attr">value</span>: park)
    }
    .<span class="hljs-title function_">navigationDestination</span>(<span class="hljs-params"><span class="hljs-keyword">for</span>: Park.self</span>) { park <span class="hljs-keyword">in</span>
        <span class="hljs-title class_">ParkDetails</span>(<span class="hljs-attr">park</span>: park)
    }
}
</code></pre>
<p>우리는 NavigationStack 라는 뷰가 있습니다. 이 뷰를 통해 일부 데이터 유형의 바인딩을 통해 .navigationDestination이라는 뷰 수정자에서 제공된 뷰로 이동할 수 있습니다 🤔 어떻게 보면 흥미로운 것 같네요.</p>
<p>그럼 이 뷰 수정자가 무엇인지 궁금하죠? 프레임워크 문서에서 더 자세히 살펴봐 봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/// 스택에 한 개 이상의 네비게이션 대상 수정자를 추가할 수 있습니다.</span>
<span class="hljs-comment">/// 여러 데이터 유형을 표시해야 하는 경우 스택에 네비게이션 대상 수정자를 여러 개 추가할 수 있습니다.</span>
<span class="hljs-comment">///</span>
<span class="hljs-comment">/// "List" 또는 "LazyVStack"과 같은 "lazy" 컨테이너 내부에 네비게이션 대상 수정자를 넣지 마세요.</span>
<span class="hljs-comment">/// 이러한 컨테이너는 화면에 렌더링할 때 필요한 경우에만 자식 뷰를 생성합니다.</span>
<span class="hljs-comment">/// 항상 네비게이션 대상 수정자를 이러한 컨테이너 외부에 추가하여 네비게이션 스택이 대상을 항상 볼 수 있도록 하세요.</span>
<span class="hljs-comment">///</span>
<span class="hljs-comment">/// - Parameters:</span>
<span class="hljs-comment">///   - data: 이 대상이 일치하는 데이터의 유형입니다.</span>
<span class="hljs-comment">///   - destination: 스택의 네비게이션 상태에 유형 'data'의 값을 포함하고 있을 때 표시할 뷰를 정의하는 뷰 빌더입니다.</span>
<span class="hljs-comment">///     클로저는 데이터 값을 나타내는 하나의 인수를 사용합니다.</span>
public func navigationDestination&#x3C;D, C>(<span class="hljs-keyword">for</span> <span class="hljs-attr">data</span>: D.<span class="hljs-property">Type</span>, @<span class="hljs-title class_">ViewBuilder</span> <span class="hljs-attr">destination</span>: @escaping (D) -> C) -> some <span class="hljs-title class_">View</span> where D : <span class="hljs-title class_">Hashable</span>, C : <span class="hljs-title class_">View</span>
</code></pre>
<p></p>
<p>뭐 이건 Data.Type을 받아들이는 ViewModifier인데, 그런 다음에 destination이라고 불리는 클로저가 주입되는데, 이 클로저는 hashable해야 할 that Data.Type의 인스턴스를 주입하고 구체적인 View를 반환해야 해요...... 그렇죠. 😵</p>
<p>또 다른 것은 .navigationDestination(_:)이 NavigationStack 내부의 View에 적용되어야 하며, NavigationStack의 범위 외부에 적용할 수 없다는 것을 주의해야 해요. 🤔</p>
<p>뷰 계층 구조를 통해 데이터를 상위 뷰로 전파하는 유사한 시그니처를 가진 다른 것이 있어요. 이것이 바로 데이터를 뷰의 부모에게 전달하는 데 사용되는 PreferenceKeys입니다!</p>
<p>PreferenceKeys를 사용하여 .navigationDestination(_:)이 NavigationStack에 하는 것처럼 내비게이션 목적지를 전달할 수 있을까요?
우리는 곧 알게 될 거예요!</p>
<p></p>
<p>시트 및 풀스크린 커버의 ViewModifier를 검사해 봅시다.</p>
<pre><code class="hljs language-js">    public func sheet&#x3C;<span class="hljs-title class_">Item</span>, <span class="hljs-title class_">Content</span>>(<span class="hljs-attr">item</span>: <span class="hljs-title class_">Binding</span>&#x3C;<span class="hljs-title class_">Item</span>?>, <span class="hljs-attr">onDismiss</span>: (() -> <span class="hljs-title class_">Void</span>)? = nil, @<span class="hljs-title class_">ViewBuilder</span> <span class="hljs-attr">content</span>: @escaping (<span class="hljs-title class_">Item</span>) -> <span class="hljs-title class_">Content</span>) -> some <span class="hljs-title class_">View</span> where <span class="hljs-title class_">Item</span> : <span class="hljs-title class_">Identifiable</span>, <span class="hljs-title class_">Content</span> : <span class="hljs-title class_">View</span>

    public func fullScreenCover&#x3C;<span class="hljs-title class_">Item</span>, <span class="hljs-title class_">Content</span>>(<span class="hljs-attr">item</span>: <span class="hljs-title class_">Binding</span>&#x3C;<span class="hljs-title class_">Item</span>?>, <span class="hljs-attr">onDismiss</span>: (() -> <span class="hljs-title class_">Void</span>)? = nil, @<span class="hljs-title class_">ViewBuilder</span> <span class="hljs-attr">content</span>: @escaping (<span class="hljs-title class_">Item</span>) -> <span class="hljs-title class_">Content</span>) -> some <span class="hljs-title class_">View</span> where <span class="hljs-title class_">Item</span> : <span class="hljs-title class_">Identifiable</span>, <span class="hljs-title class_">Content</span> : <span class="hljs-title class_">View</span>
</code></pre>
<p>이들은 서로 거의 동일하며 navigationDestination(_:)과도 매우 유사합니다. 주요 차이점은 나타낼 아이템에 대한 바인딩이 Hashable 대신 Identifiable을 준수해야 하며 전달할 수 있는 선택적인 onDismiss 클로저가 있는 것입니다.</p>
<p>Routes도 Identifiable을 준수하도록 만들어 보겠습니다.</p>
<p></p>
<pre><code class="hljs language-js">enum <span class="hljs-title class_">FirstTabCoordinatorRoute</span>: <span class="hljs-title class_">Codable</span>, <span class="hljs-title class_">Hashable</span>, <span class="hljs-title class_">Identifiable</span> { <span class="hljs-comment">// &#x3C;-- Identifiable</span>
    <span class="hljs-keyword">var</span> <span class="hljs-attr">id</span>: <span class="hljs-title class_">String</span> { <span class="hljs-title class_">String</span>(<span class="hljs-attr">describing</span>: self) }

    <span class="hljs-keyword">case</span> detailView
    <span class="hljs-keyword">case</span> <span class="hljs-title function_">secondDetailView</span>(<span class="hljs-title class_">String</span>)
}
</code></pre>
<p>이제 루트를 처리하는 ViewModifier를 만들어야 합니다. navigationDestination(<em>:)가 어떻게 작동하는지 더 잘 이해하려고 했고, navigationDestination(</em>:)와 동일하게 목적지를 뷰 계층 구조로 전달할 수 있는 방법을 재현해 볼 수 있을지 생각했습니다.</p>
<p>내가 알기로는 뷰 계층 구조로 데이터를 전송하는 유일한 방법은 PreferenceKeys이니까 그것부터 시작하겠습니다.
그러나 몇 가지 기준이 있습니다. 어떤 경로에 대해서도 작동하고 다른 경로에 대한 모든 목적지를 해결할 수 있어야합니다. 이 기준으로 인해 타입 지워를 사용해야 합니다. 다음과 같이 PreferenceKeys를 생성해 봅시다.</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">SheetFactoryKey</span>: <span class="hljs-title class_">PreferenceKey</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">defaultValue</span>: [<span class="hljs-title class_">String</span>: <span class="hljs-title class_">NavigationViewFactory</span>] = [:]
    <span class="hljs-keyword">static</span> func <span class="hljs-title function_">reduce</span>(<span class="hljs-params">value: inout [<span class="hljs-built_in">String</span>: NavigationViewFactory], nextValue: () -> [<span class="hljs-built_in">String</span>: NavigationViewFactory]</span>) { value.<span class="hljs-title function_">merge</span>(<span class="hljs-params">nextValue()</span>) { $1 } } <span class="hljs-comment">// reduce all into one value (dictionary)</span>
}

struct <span class="hljs-title class_">CoverFactoryKey</span>: <span class="hljs-title class_">PreferenceKey</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">defaultValue</span>: [<span class="hljs-title class_">String</span>: <span class="hljs-title class_">NavigationViewFactory</span>] = [:]
    <span class="hljs-keyword">static</span> func <span class="hljs-title function_">reduce</span>(<span class="hljs-params">value: inout [<span class="hljs-built_in">String</span>: NavigationViewFactory], nextValue: () -> [<span class="hljs-built_in">String</span>: NavigationViewFactory]</span>) { value.<span class="hljs-title function_">merge</span>(<span class="hljs-params">nextValue()</span>) { $1 } }
}

extension <span class="hljs-title class_">View</span> {
    public func sheetDestination&#x3C;D,C>(<span class="hljs-keyword">for</span> <span class="hljs-attr">data</span>: D.<span class="hljs-property">Type</span>, @<span class="hljs-title class_">ViewBuilder</span> <span class="hljs-attr">sheet</span>: @escaping (D) -> C) -> some <span class="hljs-title class_">View</span> where <span class="hljs-attr">D</span>: <span class="hljs-title class_">Identifiable</span> &#x26; <span class="hljs-title class_">Hashable</span>, C : <span class="hljs-title class_">View</span>  {
        <span class="hljs-title function_">preference</span>(<span class="hljs-attr">key</span>: <span class="hljs-title class_">SheetFactoryKey</span>.<span class="hljs-property">self</span>, <span class="hljs-attr">value</span>: [<span class="hljs-title class_">String</span>(<span class="hljs-attr">describing</span>: data): <span class="hljs-title class_">NavigationViewFactory</span>(data, sheet)]) <span class="hljs-comment">// &#x3C;- Here we set the key to the data type's description! and pass our view factory</span>
    }

    public func coverDestination&#x3C;D,C>(<span class="hljs-keyword">for</span> <span class="hljs-attr">data</span>: D.<span class="hljs-property">Type</span>, @<span class="hljs-title class_">ViewBuilder</span> <span class="hljs-attr">cover</span>: @escaping (D) -> C) -> some <span class="hljs-title class_">View</span> where <span class="hljs-attr">D</span>: <span class="hljs-title class_">Identifiable</span> &#x26; <span class="hljs-title class_">Hashable</span>, C : <span class="hljs-title class_">View</span>  {
        <span class="hljs-title function_">preference</span>(<span class="hljs-attr">key</span>: <span class="hljs-title class_">CoverFactoryKey</span>.<span class="hljs-property">self</span>, <span class="hljs-attr">value</span>: [<span class="hljs-title class_">String</span>(<span class="hljs-attr">describing</span>: data): <span class="hljs-title class_">NavigationViewFactory</span>(data, cover)])
    }
}
</code></pre>
<p></p>
<p>네비게이션 목적지()가 sheetDestination()와 coverDestination() 선호 키 모두 호출자의 모든 값을 하나의 [String: NavigationViewFactory] 사전으로 줄입니다.</p>
<p>기본적으로 여러 Coordinator가 있는 경우 각각이 자체 경로 유형을 위해 sheetDestination() 선호 키를 사용합니다. 이것은 PreferenceKeys에서 보내진 모든 값들을 하나의 사전으로 병합/줄이고, 문자열 키를 사용하여 작업하는 데이터 유형에 대한 식별자로 사용할 수 있습니다. 따라서 뷰 계층 구조를 통해 전달된 대응하는 예상 값에 접근할 수 있습니다. 이 값은 해당 목적지를 반환하는 데 도움이 됩니다.</p>
<p>여기에는 데이터 유형을 설명하는 ID와 AnyView를 반환하는 타입 지워진 NavigationViewFactory가 있습니다.
AnyView는 SwiftUI에서 제공되는 타입 지워진 뷰 래퍼로 성능에 부담이 있으므로 절약해서 사용해야 합니다. 그러나 한 번에 하나의 시트나 커버만 표시할 수 있기 때문에 수용할만한 것으로 보입니다.</p>
<p></p>
<p>NavigationController로 다시 가서 코드를 추가해 봅시다.</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Observable</span> final <span class="hljs-keyword">class</span> <span class="hljs-title class_">NavigationController</span> {
    <span class="hljs-keyword">var</span> navigationPath = <span class="hljs-title class_">NavigationPath</span>()
    <span class="hljs-keyword">var</span> alertPath = <span class="hljs-title class_">AlertPath</span>()
    <span class="hljs-keyword">var</span> <span class="hljs-attr">sheetPath</span>: <span class="hljs-title class_">SheetPath</span> = .<span class="hljs-title function_">init</span>() <span class="hljs-comment">// &#x3C;- SheetPath를 생성해 봅시다</span>
    <span class="hljs-keyword">var</span> <span class="hljs-attr">coverPath</span>: <span class="hljs-title class_">CoverPath</span> = .<span class="hljs-title function_">init</span>() <span class="hljs-comment">// &#x3C;- CoverPath를 생성해 봅시다</span>

    func presentSheet&#x3C;T>(_ <span class="hljs-attr">route</span>: T, <span class="hljs-attr">onDismiss</span>: (() -> <span class="hljs-title class_">Void</span>)? = nil)  where <span class="hljs-attr">T</span>: <span class="hljs-title class_">Codable</span> &#x26; <span class="hljs-title class_">Identifiable</span> &#x26; <span class="hljs-title class_">Hashable</span>  {
        sheetPath.<span class="hljs-title function_">setSheet</span>(route, <span class="hljs-attr">onDismiss</span>: onDismiss)
    }

    func presentCover&#x3C;T>(_ <span class="hljs-attr">route</span>: T, <span class="hljs-attr">onDismiss</span>: (() -> <span class="hljs-title class_">Void</span>)? = nil)  where <span class="hljs-attr">T</span>: <span class="hljs-title class_">Codable</span> &#x26; <span class="hljs-title class_">Identifiable</span> &#x26; <span class="hljs-title class_">Hashable</span>  {
        coverPath.<span class="hljs-title function_">setCover</span>(route, <span class="hljs-attr">onDismiss</span>: onDismiss)
    }
}

<span class="hljs-comment">// Sheet</span>
struct <span class="hljs-title class_">SheetPath</span>: <span class="hljs-title class_">Identifiable</span> {
    <span class="hljs-keyword">var</span> <span class="hljs-attr">id</span>: <span class="hljs-title class_">String</span> { sheet?.<span class="hljs-property">id</span> ?? <span class="hljs-title function_">UUID</span>().<span class="hljs-property">uuidString</span> } <span class="hljs-comment">// &#x3C;- 현재 sheet의 id를 사용합니다.</span>
    <span class="hljs-keyword">var</span> <span class="hljs-attr">sheet</span>: <span class="hljs-title class_">SheetContainer</span>?

    mutating func setSheet&#x3C;T>(_ <span class="hljs-attr">sheet</span>: T, <span class="hljs-attr">onDismiss</span>: (() -> <span class="hljs-title class_">Void</span>)? = nil) where <span class="hljs-attr">T</span>: <span class="hljs-title class_">Codable</span> &#x26; <span class="hljs-title class_">Identifiable</span> &#x26; <span class="hljs-title class_">Hashable</span>  {
        self.<span class="hljs-property">sheet</span> = <span class="hljs-title class_">SheetContainer</span>(sheet, <span class="hljs-attr">onDismiss</span>: onDismiss)
    }
}

struct <span class="hljs-title class_">SheetContainer</span>: <span class="hljs-title class_">Identifiable</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-attr">id</span>: <span class="hljs-title class_">String</span>
    <span class="hljs-keyword">let</span> <span class="hljs-attr">sheet</span>: <span class="hljs-title class_">Any</span>
    <span class="hljs-keyword">let</span> <span class="hljs-attr">onDismiss</span>: (() -> <span class="hljs-title class_">Void</span>)?

    init&#x3C;T>(_ <span class="hljs-attr">sheet</span>: T, <span class="hljs-attr">onDismiss</span>: (() -> <span class="hljs-title class_">Void</span>)? = nil) where <span class="hljs-attr">T</span>: <span class="hljs-title class_">Codable</span> &#x26; <span class="hljs-title class_">Identifiable</span> &#x26; <span class="hljs-title class_">Hashable</span>  {
        self.<span class="hljs-property">id</span> = <span class="hljs-title class_">String</span>(<span class="hljs-attr">describing</span>: T.<span class="hljs-property">self</span>)
        self.<span class="hljs-property">sheet</span> = sheet
        self.<span class="hljs-property">onDismiss</span> = onDismiss
    }
}

<span class="hljs-comment">// Fullscreen Cover</span>
struct <span class="hljs-title class_">CoverPath</span>: <span class="hljs-title class_">Identifiable</span> {
    <span class="hljs-keyword">var</span> <span class="hljs-attr">id</span>: <span class="hljs-title class_">String</span> { cover?.<span class="hljs-property">id</span> ?? <span class="hljs-title function_">UUID</span>().<span class="hljs-property">uuidString</span> }
    <span class="hljs-keyword">var</span> <span class="hljs-attr">cover</span>: <span class="hljs-title class_">CoverContainer</span>?

    mutating func setCover&#x3C;T>(_ <span class="hljs-attr">cover</span>: T, <span class="hljs-attr">onDismiss</span>: (() -> <span class="hljs-title class_">Void</span>)? = nil) where <span class="hljs-attr">T</span>: <span class="hljs-title class_">Codable</span> &#x26; <span class="hljs-title class_">Identifiable</span> &#x26; <span class="hljs-title class_">Hashable</span>  {
        self.<span class="hljs-property">cover</span> = <span class="hljs-title class_">CoverContainer</span>(cover, <span class="hljs-attr">onDismiss</span>: onDismiss)
    }
}

struct <span class="hljs-title class_">CoverContainer</span>: <span class="hljs-title class_">Identifiable</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-attr">id</span>: <span class="hljs-title class_">String</span>
    <span class="hljs-keyword">let</span> <span class="hljs-attr">cover</span>: <span class="hljs-title class_">Any</span>
    <span class="hljs-keyword">let</span> <span class="hljs-attr">onDismiss</span>: (() -> <span class="hljs-title class_">Void</span>)?

    init&#x3C;T>(_ <span class="hljs-attr">cover</span>: T, <span class="hljs-attr">onDismiss</span>: (() -> <span class="hljs-title class_">Void</span>)? = nil) where <span class="hljs-attr">T</span>: <span class="hljs-title class_">Codable</span> &#x26; <span class="hljs-title class_">Identifiable</span> &#x26; <span class="hljs-title class_">Hashable</span>  {
        self.<span class="hljs-property">id</span> = <span class="hljs-title class_">String</span>(<span class="hljs-attr">describing</span>: T.<span class="hljs-property">self</span>)
        self.<span class="hljs-property">cover</span> = cover
        self.<span class="hljs-property">onDismiss</span> = onDismiss
    }
}
</code></pre>
<p>이 두 가지 구현 사항은 기본적으로 동일하며 같은 컨테이너, 경로, 함수 뷰 수정자 등을 사용하고 열거형 PresentationMode를 추가하여 sheet와 cover를 구분할 수 있는 case를 추가할 수 있습니다. 그러나 일관성을 유지하기 위해 이 예제에서는 이들을 분리해 두었습니다. 또한 SwiftUI가 이후에 여러 개의 sheet/cover를 지원한다면 별도로 처리하고자 할 수도 있습니다. 선택은 당신에게 맡깁니다. 지금까지 어떤 것들을 얻었나요?</p>
<ul>
<li>NavigationController에는 이제 sheet 및 fullScreenCover에 대한 경로가 있습니다.</li>
<li>우리는 데이터 작업의 구체적인 유형을 지우기 위해 타입 이레이저를 사용하지만, 우리가 수용할 수 있는 유형으로만 컨테이너를 초기화할 수 있도록 하여, 지워진 타입 값은 일종의 Identifiable, Hashable 및 Codable 유형이 되도록 보장합니다.</li>
<li>또한, 해당 데이터 유형의 설명을 Identifiable 준수를위한 식별자로 저장하여 우리의 뷰 팩토리 콜백 딕셔너리에서 구분할 수 있도록 합니다.</li>
</ul>
<p></p>
<p>여전히 함께 계신다니 너무 기쁘네요! 이제 모든 것을 함께 연결해보려 합니다.</p>
<p>이제 시트를 표시하는 ViewModifier를 만들어야 합니다.</p>
<pre><code class="hljs language-js">extension <span class="hljs-title class_">View</span> {
    func <span class="hljs-title function_">sheet</span>(<span class="hljs-keyword">for</span> <span class="hljs-attr">sheetPath</span>: <span class="hljs-title class_">Binding</span>&#x3C;<span class="hljs-title class_">SheetPath</span>>) -> some <span class="hljs-title class_">View</span> {
        <span class="hljs-title function_">modifier</span>(<span class="hljs-title class_">SheetModifier</span>(<span class="hljs-attr">sheetPath</span>: sheetPath))
    }

    func <span class="hljs-title function_">cover</span>(<span class="hljs-keyword">for</span> <span class="hljs-attr">data</span>: <span class="hljs-title class_">Binding</span>&#x3C;<span class="hljs-title class_">CoverPath</span>>, <span class="hljs-attr">onDismiss</span>: (() -> <span class="hljs-title class_">Void</span>)? = nil) -> some <span class="hljs-title class_">View</span> {
        <span class="hljs-title function_">modifier</span>(<span class="hljs-title class_">CoverModifier</span>(<span class="hljs-attr">data</span>: data))
    }
}

struct <span class="hljs-title class_">SheetModifier</span>: <span class="hljs-title class_">ViewModifier</span> {
    @<span class="hljs-title class_">Binding</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">sheetPath</span>: <span class="hljs-title class_">SheetPath</span>
    @<span class="hljs-title class_">State</span> private <span class="hljs-keyword">var</span> <span class="hljs-attr">factories</span>: [<span class="hljs-title class_">String</span>: <span class="hljs-title class_">NavigationViewFactory</span>] = [:]
    private <span class="hljs-keyword">let</span> <span class="hljs-attr">onDismiss</span>: (() -> <span class="hljs-title class_">Void</span>)?

    <span class="hljs-title function_">init</span>(<span class="hljs-params">sheetPath: Binding&#x3C;SheetPath></span>) {
        self.<span class="hljs-property">_sheetPath</span> = sheetPath
        self.<span class="hljs-property">onDismiss</span> = sheetPath.<span class="hljs-property">wrappedValue</span>.<span class="hljs-property">sheet</span>?.<span class="hljs-property">onDismiss</span>
    }

    func <span class="hljs-title function_">body</span>(<span class="hljs-attr">content</span>: <span class="hljs-title class_">Content</span>) -> some <span class="hljs-title class_">View</span> {
        content
            .<span class="hljs-title function_">onPreferenceChange</span>(<span class="hljs-params">SheetFactoryKey.self</span>) { factories = $0 }
            .<span class="hljs-title function_">sheet</span>(<span class="hljs-attr">item</span>: _sheetPath.<span class="hljs-property">sheet</span>, <span class="hljs-attr">onDismiss</span>: sheetPath.<span class="hljs-property">sheet</span>?.<span class="hljs-property">onDismiss</span>, <span class="hljs-attr">content</span>: { factories[sheetPath.<span class="hljs-property">id</span>]?.<span class="hljs-title function_">factory</span>($0.<span class="hljs-property">sheet</span>) })
    }
}

struct <span class="hljs-title class_">CoverModifier</span>: <span class="hljs-title class_">ViewModifier</span> {
    @<span class="hljs-title class_">Binding</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">data</span>: <span class="hljs-title class_">CoverPath</span>
    @<span class="hljs-title class_">State</span> private <span class="hljs-keyword">var</span> <span class="hljs-attr">factories</span>: [<span class="hljs-title class_">String</span>: <span class="hljs-title class_">NavigationViewFactory</span>] = [:]
    private <span class="hljs-keyword">let</span> <span class="hljs-attr">onDismiss</span>: (() -> <span class="hljs-title class_">Void</span>)?

    <span class="hljs-title function_">init</span>(<span class="hljs-params">data: Binding&#x3C;CoverPath></span>) {
        self.<span class="hljs-property">_data</span> = data
        self.<span class="hljs-property">onDismiss</span> = data.<span class="hljs-property">wrappedValue</span>.<span class="hljs-property">cover</span>?.<span class="hljs-property">onDismiss</span>
    }

    func <span class="hljs-title function_">body</span>(<span class="hljs-attr">content</span>: <span class="hljs-title class_">Content</span>) -> some <span class="hljs-title class_">View</span> {
        content
            .<span class="hljs-title function_">onPreferenceChange</span>(<span class="hljs-params">CoverFactoryKey.self</span>) { factories = $0 }
            .<span class="hljs-title function_">fullScreenCover</span>(<span class="hljs-attr">item</span>: _data.<span class="hljs-property">cover</span>, <span class="hljs-attr">onDismiss</span>: data.<span class="hljs-property">cover</span>?.<span class="hljs-property">onDismiss</span>, <span class="hljs-attr">content</span>: { factories[data.<span class="hljs-property">id</span>]?.<span class="hljs-title function_">factory</span>($0.<span class="hljs-property">cover</span>) })
    }
}
</code></pre>
<p>이게 뭐하는 거야? 모든 .sheetDestination()를 사용하는 코디네이터는 경로에 해당하는 코디네이션 함수를 뷰 계층 구조에 전달합니다. 그리고 sheetPath에 값을 설정하면 동일한 데이터 유형에 대한 viewFactory를 추출하고 데이터 인스턴스를 주입하여 메서드를 호출하여 대상을 반환할 것입니다. 모두 어떻게 함께 작동하는지 예제를 살펴봅시다.</p>
<pre><code class="hljs language-js">enum <span class="hljs-title class_">FirstTabCoordinatorRoute</span>: <span class="hljs-title class_">Codable</span>, <span class="hljs-title class_">Hashable</span>, <span class="hljs-title class_">Identifiable</span> {
    <span class="hljs-keyword">var</span> <span class="hljs-attr">id</span>: <span class="hljs-title class_">String</span> { <span class="hljs-title class_">String</span>(<span class="hljs-attr">describing</span>: self) }
    ... 이전 경로들

    <span class="hljs-keyword">case</span> sheet <span class="hljs-comment">// 선택 사항으로 연결된 값 전달 가능</span>
    <span class="hljs-keyword">case</span> cover
}

@<span class="hljs-title class_">Observable</span> final <span class="hljs-keyword">class</span> <span class="hljs-title class_">FirstTabCoordinator</span>: <span class="hljs-title class_">Coordinator</span> {
    ... 이전 코드

    @<span class="hljs-title class_">ViewBuilder</span> @<span class="hljs-title class_">MainActor</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">rootView</span>: some <span class="hljs-title class_">View</span> {
        <span class="hljs-keyword">let</span> viewModel = <span class="hljs-title class_">FirstViewModel</span>(self)
        <span class="hljs-title class_">FirstView</span>(viewModel)
            .<span class="hljs-title function_">navigationDestination</span>(<span class="hljs-attr">for</span>: <span class="hljs-title class_">Route</span>.<span class="hljs-property">self</span>, <span class="hljs-attr">destination</span>: <span class="hljs-title function_">coordinate</span>(<span class="hljs-attr">_</span>:))
            .<span class="hljs-title function_">sheetDestination</span>(<span class="hljs-attr">for</span>: <span class="hljs-title class_">Route</span>.<span class="hljs-property">self</span>, <span class="hljs-attr">sheet</span>: <span class="hljs-title function_">coordinate</span>(<span class="hljs-attr">_</span>:))
            .<span class="hljs-title function_">coverDestination</span>(<span class="hljs-attr">for</span>: <span class="hljs-title class_">Route</span>.<span class="hljs-property">self</span>, <span class="hljs-attr">cover</span>: <span class="hljs-title function_">coordinate</span>(<span class="hljs-attr">_</span>:))
    }

    func <span class="hljs-title function_">presentSheet</span>(<span class="hljs-params">onDismiss: (() -> Void)? = nil</span>) {
        navigationController.<span class="hljs-title function_">presentSheet</span>(<span class="hljs-title class_">Route</span>.<span class="hljs-property">sheet</span>, <span class="hljs-attr">onDismiss</span>: onDismiss)
    }

    func <span class="hljs-title function_">presentCover</span>(<span class="hljs-params">onDismiss: (() -> Void)? = nil</span>) {
        navigationController.<span class="hljs-title function_">presentCover</span>(<span class="hljs-title class_">Route</span>.<span class="hljs-property">cover</span>, <span class="hljs-attr">onDismiss</span>: onDismiss)
    }

    @<span class="hljs-title class_">ViewBuilder</span> @<span class="hljs-title class_">MainActor</span> func <span class="hljs-title function_">coordinate</span>(_ <span class="hljs-attr">route</span>: <span class="hljs-title class_">Route</span>) -> some <span class="hljs-title class_">View</span> {
        <span class="hljs-keyword">switch</span> route {
            ... 이전 경로들

            <span class="hljs-keyword">case</span> .<span class="hljs-property">sheet</span>: <span class="hljs-title class_">SomeBranchedView</span>()
            <span class="hljs-keyword">case</span> .<span class="hljs-property">cover</span>: <span class="hljs-title class_">SomeCoverView</span>()
        }
    }
}
</code></pre>
<p></p>
<p>와, 정말 깔끔하네요!
rootView 계산 속성 내에서 PreferenceKeys를 설정하여 모든 정보가 코디네이터의 Route.Types를 해결하는 데 필요한 정보를 코디네이트(coordinates) 함수로 보냅니다. 이 함수는 특정 코디네이터가 좌표를 맡은 모든 뷰를 생성합니다. 🤔 꽤 괜찮죠.</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">CoordinatedView</span>&#x3C;<span class="hljs-attr">C</span>: <span class="hljs-title class_">Coordinator</span>>: <span class="hljs-title class_">View</span> {
    private <span class="hljs-keyword">let</span> <span class="hljs-attr">coordinator</span>: C

    <span class="hljs-title function_">init</span>(<span class="hljs-params">_ coordinator: C</span>) {
        self.<span class="hljs-property">coordinator</span> = coordinator
    }

    <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span> {
        @<span class="hljs-title class_">Bindable</span> <span class="hljs-keyword">var</span> navigationController = coordinator.<span class="hljs-property">navigationController</span>
        <span class="hljs-title class_">NavigationStack</span>(<span class="hljs-attr">path</span>: $navigationController.<span class="hljs-property">navigationPath</span>) {
            coordinator.<span class="hljs-property">rootView</span>
        }
        .<span class="hljs-title function_">sheet</span>(<span class="hljs-attr">for</span>: $navigationController.<span class="hljs-property">sheetPath</span>)
        .<span class="hljs-title function_">cover</span>(<span class="hljs-attr">for</span>: $navigationController.<span class="hljs-property">coverPath</span>)
        .<span class="hljs-title function_">alert</span>(<span class="hljs-attr">for</span>: $navigationController.<span class="hljs-property">alertPath</span>)
    }
}
</code></pre>
<p>마지막으로 루트 CoordinatedView에 sheet 또는 cover를 적용하는 방법에 대해 다음과 같이 살펴보겠습니다. 이것도 꽤 깔끔하네요 😉</p>
<p>그러니까 이 경우를 위해 우리의 view와 viewModel을 검사해봅시다.</p>
<p></p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FirstView</span>: <span class="hljs-title class_">View</span> {
    <span class="hljs-keyword">let</span> viewModel: <span class="hljs-type">FirstViewModel</span>

    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span> {
            <span class="hljs-type">Text</span>(<span class="hljs-string">"First View"</span>)
            <span class="hljs-type">Button</span>(<span class="hljs-string">"상세 화면으로 이동"</span>) {
                viewModel.didTapButton()
            }
        }
    }
}

<span class="hljs-meta">@Observable</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FirstViewModel</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> coordinator: <span class="hljs-type">FirstTabCoordinator</span>

    <span class="hljs-keyword">init</span>(<span class="hljs-params">coordinator</span>: <span class="hljs-type">FirstTabCoordinator</span>) {
        <span class="hljs-keyword">self</span>.coordinator <span class="hljs-operator">=</span> coordinator
    }

    <span class="hljs-keyword">func</span> <span class="hljs-title function_">didTapButton</span>() {
        coordinator.presentSheet {
          <span class="hljs-comment">// closure called onDismiss</span>
        }
    }
}
</code></pre>
<p>우리의 뷰는 didTapButton 이외에 무슨 일이 벌어지고 있는지 알 수 없습니다.</p>
<p>ℹ️ 또한 다른 필요한 수식어(modifier)들이 coordinate() 함수에서 반환되기 전에 뷰에 적용될 수 있습니다.</p>
<p>예를 들어, 시트에 presentationDetents를 적용하려면. 그리고 뷰 내부에서 심지어 그것에 대해 알 필요조차 없을 수 있습니다.</p>
<p></p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Observable</span> final <span class="hljs-keyword">class</span> <span class="hljs-title class_">FirstTabCoordinator</span>: <span class="hljs-title class_">Coordinator</span> {
    ... 이전 코드

    @<span class="hljs-title class_">ViewBuilder</span> @<span class="hljs-title class_">MainActor</span> func <span class="hljs-title function_">coordinate</span>(_ <span class="hljs-attr">route</span>: <span class="hljs-title class_">Route</span>) -> some <span class="hljs-title class_">View</span> {
        <span class="hljs-keyword">switch</span> route {
         ... 이전 루트

        <span class="hljs-keyword">case</span> .<span class="hljs-property">sheet</span>: <span class="hljs-title class_">SomeBranchedView</span>().<span class="hljs-title function_">presentationDetents</span>([.<span class="hljs-property">medium</span>, .<span class="hljs-property">large</span>]) <span class="hljs-comment">// 시트를 반으로 크기 조정하고 드래그 액션 등을 허용합니다.</span>
        <span class="hljs-keyword">case</span> .<span class="hljs-property">cover</span>: <span class="hljs-title class_">SomeCoverView</span>()
        }
    }
}
</code></pre>
<p>지금은 여기까지입니다.</p>
<p>이 글에서 어떤 통찰을 얻으셨다면 좋겠네요. 피드백이나 개선 제안이 있다면 알려주세요. 이 글이 가치 있다고 느끼신다면 공유해주세요!</p>
<p>즐거운 코딩하세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"SwiftUI 네비게이션 - 코디네이터 패턴 - 파트 3 시트, FullscreenCover","description":"","date":"2024-05-23 13:10","slug":"2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover","content":"\n![이미지](/assets/img/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover_0.png)\n\n이 글은 이전 글들을 이어서 작성되었으며, 그 위에 쌓아 올릴 것입니다.\nSwiftUI 네비게이션 파트 1 — 푸시 네비게이션\nSwiftUI 네비게이션 파트 2 — 알림\n\n이 글에서는 Sheets 및 FullscreenCovers을 동시에 다룰 것이며, 이들은 동일한 방식으로 구현됩니다.\n\n시작해 봅시다! 이전 글들에서는 결정적 목적지로 조정하기 위해 Routes를 사용했습니다. 그러나 SwiftUI는 어떻게 이루어지는 걸까요?\n뷰 계층 구조의 루트에 있는 NavigationStack에 대한 네비게이션 경로에 대한 바인딩이 있습니다. Apple의 문서 예제를 살펴보겠습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nNavigationStack(path: $presentedParks) {\n    List(parks) { park in\n        NavigationLink(park.name, value: park)\n    }\n    .navigationDestination(for: Park.self) { park in\n        ParkDetails(park: park)\n    }\n}\n```\n\n우리는 NavigationStack 라는 뷰가 있습니다. 이 뷰를 통해 일부 데이터 유형의 바인딩을 통해 .navigationDestination이라는 뷰 수정자에서 제공된 뷰로 이동할 수 있습니다 🤔 어떻게 보면 흥미로운 것 같네요.\n\n그럼 이 뷰 수정자가 무엇인지 궁금하죠? 프레임워크 문서에서 더 자세히 살펴봐 봅시다.\n\n```js\n/// 스택에 한 개 이상의 네비게이션 대상 수정자를 추가할 수 있습니다.\n/// 여러 데이터 유형을 표시해야 하는 경우 스택에 네비게이션 대상 수정자를 여러 개 추가할 수 있습니다.\n///\n/// \"List\" 또는 \"LazyVStack\"과 같은 \"lazy\" 컨테이너 내부에 네비게이션 대상 수정자를 넣지 마세요.\n/// 이러한 컨테이너는 화면에 렌더링할 때 필요한 경우에만 자식 뷰를 생성합니다.\n/// 항상 네비게이션 대상 수정자를 이러한 컨테이너 외부에 추가하여 네비게이션 스택이 대상을 항상 볼 수 있도록 하세요.\n///\n/// - Parameters:\n///   - data: 이 대상이 일치하는 데이터의 유형입니다.\n///   - destination: 스택의 네비게이션 상태에 유형 'data'의 값을 포함하고 있을 때 표시할 뷰를 정의하는 뷰 빌더입니다.\n///     클로저는 데이터 값을 나타내는 하나의 인수를 사용합니다.\npublic func navigationDestination\u003cD, C\u003e(for data: D.Type, @ViewBuilder destination: @escaping (D) -\u003e C) -\u003e some View where D : Hashable, C : View\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n뭐 이건 Data.Type을 받아들이는 ViewModifier인데, 그런 다음에 destination이라고 불리는 클로저가 주입되는데, 이 클로저는 hashable해야 할 that Data.Type의 인스턴스를 주입하고 구체적인 View를 반환해야 해요...... 그렇죠. 😵\n\n또 다른 것은 .navigationDestination(\\_:)이 NavigationStack 내부의 View에 적용되어야 하며, NavigationStack의 범위 외부에 적용할 수 없다는 것을 주의해야 해요. 🤔\n\n뷰 계층 구조를 통해 데이터를 상위 뷰로 전파하는 유사한 시그니처를 가진 다른 것이 있어요. 이것이 바로 데이터를 뷰의 부모에게 전달하는 데 사용되는 PreferenceKeys입니다!\n\nPreferenceKeys를 사용하여 .navigationDestination(\\_:)이 NavigationStack에 하는 것처럼 내비게이션 목적지를 전달할 수 있을까요?\n우리는 곧 알게 될 거예요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n시트 및 풀스크린 커버의 ViewModifier를 검사해 봅시다.\n\n```js\n    public func sheet\u003cItem, Content\u003e(item: Binding\u003cItem?\u003e, onDismiss: (() -\u003e Void)? = nil, @ViewBuilder content: @escaping (Item) -\u003e Content) -\u003e some View where Item : Identifiable, Content : View\n\n    public func fullScreenCover\u003cItem, Content\u003e(item: Binding\u003cItem?\u003e, onDismiss: (() -\u003e Void)? = nil, @ViewBuilder content: @escaping (Item) -\u003e Content) -\u003e some View where Item : Identifiable, Content : View\n```\n\n이들은 서로 거의 동일하며 navigationDestination(\\_:)과도 매우 유사합니다. 주요 차이점은 나타낼 아이템에 대한 바인딩이 Hashable 대신 Identifiable을 준수해야 하며 전달할 수 있는 선택적인 onDismiss 클로저가 있는 것입니다.\n\nRoutes도 Identifiable을 준수하도록 만들어 보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nenum FirstTabCoordinatorRoute: Codable, Hashable, Identifiable { // \u003c-- Identifiable\n    var id: String { String(describing: self) }\n\n    case detailView\n    case secondDetailView(String)\n}\n```\n\n이제 루트를 처리하는 ViewModifier를 만들어야 합니다. navigationDestination(_:)가 어떻게 작동하는지 더 잘 이해하려고 했고, navigationDestination(_:)와 동일하게 목적지를 뷰 계층 구조로 전달할 수 있는 방법을 재현해 볼 수 있을지 생각했습니다.\n\n내가 알기로는 뷰 계층 구조로 데이터를 전송하는 유일한 방법은 PreferenceKeys이니까 그것부터 시작하겠습니다.\n그러나 몇 가지 기준이 있습니다. 어떤 경로에 대해서도 작동하고 다른 경로에 대한 모든 목적지를 해결할 수 있어야합니다. 이 기준으로 인해 타입 지워를 사용해야 합니다. 다음과 같이 PreferenceKeys를 생성해 봅시다.\n\n```js\nstruct SheetFactoryKey: PreferenceKey {\n    static var defaultValue: [String: NavigationViewFactory] = [:]\n    static func reduce(value: inout [String: NavigationViewFactory], nextValue: () -\u003e [String: NavigationViewFactory]) { value.merge(nextValue()) { $1 } } // reduce all into one value (dictionary)\n}\n\nstruct CoverFactoryKey: PreferenceKey {\n    static var defaultValue: [String: NavigationViewFactory] = [:]\n    static func reduce(value: inout [String: NavigationViewFactory], nextValue: () -\u003e [String: NavigationViewFactory]) { value.merge(nextValue()) { $1 } }\n}\n\nextension View {\n    public func sheetDestination\u003cD,C\u003e(for data: D.Type, @ViewBuilder sheet: @escaping (D) -\u003e C) -\u003e some View where D: Identifiable \u0026 Hashable, C : View  {\n        preference(key: SheetFactoryKey.self, value: [String(describing: data): NavigationViewFactory(data, sheet)]) // \u003c- Here we set the key to the data type's description! and pass our view factory\n    }\n\n    public func coverDestination\u003cD,C\u003e(for data: D.Type, @ViewBuilder cover: @escaping (D) -\u003e C) -\u003e some View where D: Identifiable \u0026 Hashable, C : View  {\n        preference(key: CoverFactoryKey.self, value: [String(describing: data): NavigationViewFactory(data, cover)])\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n네비게이션 목적지()가 sheetDestination()와 coverDestination() 선호 키 모두 호출자의 모든 값을 하나의 [String: NavigationViewFactory] 사전으로 줄입니다.\n\n기본적으로 여러 Coordinator가 있는 경우 각각이 자체 경로 유형을 위해 sheetDestination() 선호 키를 사용합니다. 이것은 PreferenceKeys에서 보내진 모든 값들을 하나의 사전으로 병합/줄이고, 문자열 키를 사용하여 작업하는 데이터 유형에 대한 식별자로 사용할 수 있습니다. 따라서 뷰 계층 구조를 통해 전달된 대응하는 예상 값에 접근할 수 있습니다. 이 값은 해당 목적지를 반환하는 데 도움이 됩니다.\n\n여기에는 데이터 유형을 설명하는 ID와 AnyView를 반환하는 타입 지워진 NavigationViewFactory가 있습니다.\nAnyView는 SwiftUI에서 제공되는 타입 지워진 뷰 래퍼로 성능에 부담이 있으므로 절약해서 사용해야 합니다. 그러나 한 번에 하나의 시트나 커버만 표시할 수 있기 때문에 수용할만한 것으로 보입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNavigationController로 다시 가서 코드를 추가해 봅시다.\n\n```js\n@Observable final class NavigationController {\n    var navigationPath = NavigationPath()\n    var alertPath = AlertPath()\n    var sheetPath: SheetPath = .init() // \u003c- SheetPath를 생성해 봅시다\n    var coverPath: CoverPath = .init() // \u003c- CoverPath를 생성해 봅시다\n\n    func presentSheet\u003cT\u003e(_ route: T, onDismiss: (() -\u003e Void)? = nil)  where T: Codable \u0026 Identifiable \u0026 Hashable  {\n        sheetPath.setSheet(route, onDismiss: onDismiss)\n    }\n\n    func presentCover\u003cT\u003e(_ route: T, onDismiss: (() -\u003e Void)? = nil)  where T: Codable \u0026 Identifiable \u0026 Hashable  {\n        coverPath.setCover(route, onDismiss: onDismiss)\n    }\n}\n\n// Sheet\nstruct SheetPath: Identifiable {\n    var id: String { sheet?.id ?? UUID().uuidString } // \u003c- 현재 sheet의 id를 사용합니다.\n    var sheet: SheetContainer?\n\n    mutating func setSheet\u003cT\u003e(_ sheet: T, onDismiss: (() -\u003e Void)? = nil) where T: Codable \u0026 Identifiable \u0026 Hashable  {\n        self.sheet = SheetContainer(sheet, onDismiss: onDismiss)\n    }\n}\n\nstruct SheetContainer: Identifiable {\n    let id: String\n    let sheet: Any\n    let onDismiss: (() -\u003e Void)?\n\n    init\u003cT\u003e(_ sheet: T, onDismiss: (() -\u003e Void)? = nil) where T: Codable \u0026 Identifiable \u0026 Hashable  {\n        self.id = String(describing: T.self)\n        self.sheet = sheet\n        self.onDismiss = onDismiss\n    }\n}\n\n// Fullscreen Cover\nstruct CoverPath: Identifiable {\n    var id: String { cover?.id ?? UUID().uuidString }\n    var cover: CoverContainer?\n\n    mutating func setCover\u003cT\u003e(_ cover: T, onDismiss: (() -\u003e Void)? = nil) where T: Codable \u0026 Identifiable \u0026 Hashable  {\n        self.cover = CoverContainer(cover, onDismiss: onDismiss)\n    }\n}\n\nstruct CoverContainer: Identifiable {\n    let id: String\n    let cover: Any\n    let onDismiss: (() -\u003e Void)?\n\n    init\u003cT\u003e(_ cover: T, onDismiss: (() -\u003e Void)? = nil) where T: Codable \u0026 Identifiable \u0026 Hashable  {\n        self.id = String(describing: T.self)\n        self.cover = cover\n        self.onDismiss = onDismiss\n    }\n}\n```\n\n이 두 가지 구현 사항은 기본적으로 동일하며 같은 컨테이너, 경로, 함수 뷰 수정자 등을 사용하고 열거형 PresentationMode를 추가하여 sheet와 cover를 구분할 수 있는 case를 추가할 수 있습니다. 그러나 일관성을 유지하기 위해 이 예제에서는 이들을 분리해 두었습니다. 또한 SwiftUI가 이후에 여러 개의 sheet/cover를 지원한다면 별도로 처리하고자 할 수도 있습니다. 선택은 당신에게 맡깁니다. 지금까지 어떤 것들을 얻었나요?\n\n- NavigationController에는 이제 sheet 및 fullScreenCover에 대한 경로가 있습니다.\n- 우리는 데이터 작업의 구체적인 유형을 지우기 위해 타입 이레이저를 사용하지만, 우리가 수용할 수 있는 유형으로만 컨테이너를 초기화할 수 있도록 하여, 지워진 타입 값은 일종의 Identifiable, Hashable 및 Codable 유형이 되도록 보장합니다.\n- 또한, 해당 데이터 유형의 설명을 Identifiable 준수를위한 식별자로 저장하여 우리의 뷰 팩토리 콜백 딕셔너리에서 구분할 수 있도록 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여전히 함께 계신다니 너무 기쁘네요! 이제 모든 것을 함께 연결해보려 합니다.\n\n이제 시트를 표시하는 ViewModifier를 만들어야 합니다.\n\n```js\nextension View {\n    func sheet(for sheetPath: Binding\u003cSheetPath\u003e) -\u003e some View {\n        modifier(SheetModifier(sheetPath: sheetPath))\n    }\n\n    func cover(for data: Binding\u003cCoverPath\u003e, onDismiss: (() -\u003e Void)? = nil) -\u003e some View {\n        modifier(CoverModifier(data: data))\n    }\n}\n\nstruct SheetModifier: ViewModifier {\n    @Binding var sheetPath: SheetPath\n    @State private var factories: [String: NavigationViewFactory] = [:]\n    private let onDismiss: (() -\u003e Void)?\n\n    init(sheetPath: Binding\u003cSheetPath\u003e) {\n        self._sheetPath = sheetPath\n        self.onDismiss = sheetPath.wrappedValue.sheet?.onDismiss\n    }\n\n    func body(content: Content) -\u003e some View {\n        content\n            .onPreferenceChange(SheetFactoryKey.self) { factories = $0 }\n            .sheet(item: _sheetPath.sheet, onDismiss: sheetPath.sheet?.onDismiss, content: { factories[sheetPath.id]?.factory($0.sheet) })\n    }\n}\n\nstruct CoverModifier: ViewModifier {\n    @Binding var data: CoverPath\n    @State private var factories: [String: NavigationViewFactory] = [:]\n    private let onDismiss: (() -\u003e Void)?\n\n    init(data: Binding\u003cCoverPath\u003e) {\n        self._data = data\n        self.onDismiss = data.wrappedValue.cover?.onDismiss\n    }\n\n    func body(content: Content) -\u003e some View {\n        content\n            .onPreferenceChange(CoverFactoryKey.self) { factories = $0 }\n            .fullScreenCover(item: _data.cover, onDismiss: data.cover?.onDismiss, content: { factories[data.id]?.factory($0.cover) })\n    }\n}\n```\n\n이게 뭐하는 거야? 모든 .sheetDestination()를 사용하는 코디네이터는 경로에 해당하는 코디네이션 함수를 뷰 계층 구조에 전달합니다. 그리고 sheetPath에 값을 설정하면 동일한 데이터 유형에 대한 viewFactory를 추출하고 데이터 인스턴스를 주입하여 메서드를 호출하여 대상을 반환할 것입니다. 모두 어떻게 함께 작동하는지 예제를 살펴봅시다.\n\n```js\nenum FirstTabCoordinatorRoute: Codable, Hashable, Identifiable {\n    var id: String { String(describing: self) }\n    ... 이전 경로들\n\n    case sheet // 선택 사항으로 연결된 값 전달 가능\n    case cover\n}\n\n@Observable final class FirstTabCoordinator: Coordinator {\n    ... 이전 코드\n\n    @ViewBuilder @MainActor var rootView: some View {\n        let viewModel = FirstViewModel(self)\n        FirstView(viewModel)\n            .navigationDestination(for: Route.self, destination: coordinate(_:))\n            .sheetDestination(for: Route.self, sheet: coordinate(_:))\n            .coverDestination(for: Route.self, cover: coordinate(_:))\n    }\n\n    func presentSheet(onDismiss: (() -\u003e Void)? = nil) {\n        navigationController.presentSheet(Route.sheet, onDismiss: onDismiss)\n    }\n\n    func presentCover(onDismiss: (() -\u003e Void)? = nil) {\n        navigationController.presentCover(Route.cover, onDismiss: onDismiss)\n    }\n\n    @ViewBuilder @MainActor func coordinate(_ route: Route) -\u003e some View {\n        switch route {\n            ... 이전 경로들\n\n            case .sheet: SomeBranchedView()\n            case .cover: SomeCoverView()\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n와, 정말 깔끔하네요!\nrootView 계산 속성 내에서 PreferenceKeys를 설정하여 모든 정보가 코디네이터의 Route.Types를 해결하는 데 필요한 정보를 코디네이트(coordinates) 함수로 보냅니다. 이 함수는 특정 코디네이터가 좌표를 맡은 모든 뷰를 생성합니다. 🤔 꽤 괜찮죠.\n\n```js\nstruct CoordinatedView\u003cC: Coordinator\u003e: View {\n    private let coordinator: C\n\n    init(_ coordinator: C) {\n        self.coordinator = coordinator\n    }\n\n    var body: some View {\n        @Bindable var navigationController = coordinator.navigationController\n        NavigationStack(path: $navigationController.navigationPath) {\n            coordinator.rootView\n        }\n        .sheet(for: $navigationController.sheetPath)\n        .cover(for: $navigationController.coverPath)\n        .alert(for: $navigationController.alertPath)\n    }\n}\n```\n\n마지막으로 루트 CoordinatedView에 sheet 또는 cover를 적용하는 방법에 대해 다음과 같이 살펴보겠습니다. 이것도 꽤 깔끔하네요 😉\n\n그러니까 이 경우를 위해 우리의 view와 viewModel을 검사해봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nstruct FirstView: View {\n    let viewModel: FirstViewModel\n\n    var body: some View {\n        VStack {\n            Text(\"First View\")\n            Button(\"상세 화면으로 이동\") {\n                viewModel.didTapButton()\n            }\n        }\n    }\n}\n\n@Observable class FirstViewModel {\n\n    private let coordinator: FirstTabCoordinator\n\n    init(coordinator: FirstTabCoordinator) {\n        self.coordinator = coordinator\n    }\n\n    func didTapButton() {\n        coordinator.presentSheet {\n          // closure called onDismiss\n        }\n    }\n}\n```\n\n우리의 뷰는 didTapButton 이외에 무슨 일이 벌어지고 있는지 알 수 없습니다.\n\nℹ️ 또한 다른 필요한 수식어(modifier)들이 coordinate() 함수에서 반환되기 전에 뷰에 적용될 수 있습니다.\n\n예를 들어, 시트에 presentationDetents를 적용하려면. 그리고 뷰 내부에서 심지어 그것에 대해 알 필요조차 없을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n@Observable final class FirstTabCoordinator: Coordinator {\n    ... 이전 코드\n\n    @ViewBuilder @MainActor func coordinate(_ route: Route) -\u003e some View {\n        switch route {\n         ... 이전 루트\n\n        case .sheet: SomeBranchedView().presentationDetents([.medium, .large]) // 시트를 반으로 크기 조정하고 드래그 액션 등을 허용합니다.\n        case .cover: SomeCoverView()\n        }\n    }\n}\n```\n\n지금은 여기까지입니다.\n\n이 글에서 어떤 통찰을 얻으셨다면 좋겠네요. 피드백이나 개선 제안이 있다면 알려주세요. 이 글이 가치 있다고 느끼신다면 공유해주세요!\n\n즐거운 코딩하세요!\n","ogImage":{"url":"/assets/img/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover_0.png"},"coverImage":"/assets/img/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover_0.png","tag":["Tech"],"readingTime":16},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이 글은 이전 글들을 이어서 작성되었으며, 그 위에 쌓아 올릴 것입니다.\nSwiftUI 네비게이션 파트 1 — 푸시 네비게이션\nSwiftUI 네비게이션 파트 2 — 알림\u003c/p\u003e\n\u003cp\u003e이 글에서는 Sheets 및 FullscreenCovers을 동시에 다룰 것이며, 이들은 동일한 방식으로 구현됩니다.\u003c/p\u003e\n\u003cp\u003e시작해 봅시다! 이전 글들에서는 결정적 목적지로 조정하기 위해 Routes를 사용했습니다. 그러나 SwiftUI는 어떻게 이루어지는 걸까요?\n뷰 계층 구조의 루트에 있는 NavigationStack에 대한 네비게이션 경로에 대한 바인딩이 있습니다. Apple의 문서 예제를 살펴보겠습니다:\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eNavigationStack\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: $presentedParks) {\n    \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e(parks) { park \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eNavigationLink\u003c/span\u003e(park.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: park)\n    }\n    .\u003cspan class=\"hljs-title function_\"\u003enavigationDestination\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e: Park.self\u003c/span\u003e) { park \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eParkDetails\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003epark\u003c/span\u003e: park)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 NavigationStack 라는 뷰가 있습니다. 이 뷰를 통해 일부 데이터 유형의 바인딩을 통해 .navigationDestination이라는 뷰 수정자에서 제공된 뷰로 이동할 수 있습니다 🤔 어떻게 보면 흥미로운 것 같네요.\u003c/p\u003e\n\u003cp\u003e그럼 이 뷰 수정자가 무엇인지 궁금하죠? 프레임워크 문서에서 더 자세히 살펴봐 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/// 스택에 한 개 이상의 네비게이션 대상 수정자를 추가할 수 있습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e/// 여러 데이터 유형을 표시해야 하는 경우 스택에 네비게이션 대상 수정자를 여러 개 추가할 수 있습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e///\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e/// \"List\" 또는 \"LazyVStack\"과 같은 \"lazy\" 컨테이너 내부에 네비게이션 대상 수정자를 넣지 마세요.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e/// 이러한 컨테이너는 화면에 렌더링할 때 필요한 경우에만 자식 뷰를 생성합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e/// 항상 네비게이션 대상 수정자를 이러한 컨테이너 외부에 추가하여 네비게이션 스택이 대상을 항상 볼 수 있도록 하세요.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e///\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e/// - Parameters:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e///   - data: 이 대상이 일치하는 데이터의 유형입니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e///   - destination: 스택의 네비게이션 상태에 유형 'data'의 값을 포함하고 있을 때 표시할 뷰를 정의하는 뷰 빌더입니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e///     클로저는 데이터 값을 나타내는 하나의 인수를 사용합니다.\u003c/span\u003e\npublic func navigationDestination\u0026#x3C;D, C\u003e(\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: D.\u003cspan class=\"hljs-property\"\u003eType\u003c/span\u003e, @\u003cspan class=\"hljs-title class_\"\u003eViewBuilder\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: @escaping (D) -\u003e C) -\u003e some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e where D : \u003cspan class=\"hljs-title class_\"\u003eHashable\u003c/span\u003e, C : \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e뭐 이건 Data.Type을 받아들이는 ViewModifier인데, 그런 다음에 destination이라고 불리는 클로저가 주입되는데, 이 클로저는 hashable해야 할 that Data.Type의 인스턴스를 주입하고 구체적인 View를 반환해야 해요...... 그렇죠. 😵\u003c/p\u003e\n\u003cp\u003e또 다른 것은 .navigationDestination(_:)이 NavigationStack 내부의 View에 적용되어야 하며, NavigationStack의 범위 외부에 적용할 수 없다는 것을 주의해야 해요. 🤔\u003c/p\u003e\n\u003cp\u003e뷰 계층 구조를 통해 데이터를 상위 뷰로 전파하는 유사한 시그니처를 가진 다른 것이 있어요. 이것이 바로 데이터를 뷰의 부모에게 전달하는 데 사용되는 PreferenceKeys입니다!\u003c/p\u003e\n\u003cp\u003ePreferenceKeys를 사용하여 .navigationDestination(_:)이 NavigationStack에 하는 것처럼 내비게이션 목적지를 전달할 수 있을까요?\n우리는 곧 알게 될 거예요!\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e시트 및 풀스크린 커버의 ViewModifier를 검사해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    public func sheet\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eItem\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eContent\u003c/span\u003e\u003e(\u003cspan class=\"hljs-attr\"\u003eitem\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBinding\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eItem\u003c/span\u003e?\u003e, \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e: (() -\u003e \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e)? = nil, @\u003cspan class=\"hljs-title class_\"\u003eViewBuilder\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: @escaping (\u003cspan class=\"hljs-title class_\"\u003eItem\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-title class_\"\u003eContent\u003c/span\u003e) -\u003e some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e where \u003cspan class=\"hljs-title class_\"\u003eItem\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eIdentifiable\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eContent\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e\n\n    public func fullScreenCover\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eItem\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eContent\u003c/span\u003e\u003e(\u003cspan class=\"hljs-attr\"\u003eitem\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBinding\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eItem\u003c/span\u003e?\u003e, \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e: (() -\u003e \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e)? = nil, @\u003cspan class=\"hljs-title class_\"\u003eViewBuilder\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: @escaping (\u003cspan class=\"hljs-title class_\"\u003eItem\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-title class_\"\u003eContent\u003c/span\u003e) -\u003e some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e where \u003cspan class=\"hljs-title class_\"\u003eItem\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eIdentifiable\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eContent\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이들은 서로 거의 동일하며 navigationDestination(_:)과도 매우 유사합니다. 주요 차이점은 나타낼 아이템에 대한 바인딩이 Hashable 대신 Identifiable을 준수해야 하며 전달할 수 있는 선택적인 onDismiss 클로저가 있는 것입니다.\u003c/p\u003e\n\u003cp\u003eRoutes도 Identifiable을 준수하도록 만들어 보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eenum \u003cspan class=\"hljs-title class_\"\u003eFirstTabCoordinatorRoute\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCodable\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eHashable\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eIdentifiable\u003c/span\u003e { \u003cspan class=\"hljs-comment\"\u003e// \u0026#x3C;-- Identifiable\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003edescribing\u003c/span\u003e: self) }\n\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e detailView\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esecondDetailView\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 루트를 처리하는 ViewModifier를 만들어야 합니다. navigationDestination(\u003cem\u003e:)가 어떻게 작동하는지 더 잘 이해하려고 했고, navigationDestination(\u003c/em\u003e:)와 동일하게 목적지를 뷰 계층 구조로 전달할 수 있는 방법을 재현해 볼 수 있을지 생각했습니다.\u003c/p\u003e\n\u003cp\u003e내가 알기로는 뷰 계층 구조로 데이터를 전송하는 유일한 방법은 PreferenceKeys이니까 그것부터 시작하겠습니다.\n그러나 몇 가지 기준이 있습니다. 어떤 경로에 대해서도 작동하고 다른 경로에 대한 모든 목적지를 해결할 수 있어야합니다. 이 기준으로 인해 타입 지워를 사용해야 합니다. 다음과 같이 PreferenceKeys를 생성해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eSheetFactoryKey\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003ePreferenceKey\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edefaultValue\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eNavigationViewFactory\u003c/span\u003e] = [:]\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e func \u003cspan class=\"hljs-title function_\"\u003ereduce\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003evalue: inout [\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e: NavigationViewFactory], nextValue: () -\u003e [\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e: NavigationViewFactory]\u003c/span\u003e) { value.\u003cspan class=\"hljs-title function_\"\u003emerge\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enextValue()\u003c/span\u003e) { $1 } } \u003cspan class=\"hljs-comment\"\u003e// reduce all into one value (dictionary)\u003c/span\u003e\n}\n\nstruct \u003cspan class=\"hljs-title class_\"\u003eCoverFactoryKey\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003ePreferenceKey\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edefaultValue\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eNavigationViewFactory\u003c/span\u003e] = [:]\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e func \u003cspan class=\"hljs-title function_\"\u003ereduce\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003evalue: inout [\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e: NavigationViewFactory], nextValue: () -\u003e [\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e: NavigationViewFactory]\u003c/span\u003e) { value.\u003cspan class=\"hljs-title function_\"\u003emerge\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enextValue()\u003c/span\u003e) { $1 } }\n}\n\nextension \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    public func sheetDestination\u0026#x3C;D,C\u003e(\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: D.\u003cspan class=\"hljs-property\"\u003eType\u003c/span\u003e, @\u003cspan class=\"hljs-title class_\"\u003eViewBuilder\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esheet\u003c/span\u003e: @escaping (D) -\u003e C) -\u003e some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e where \u003cspan class=\"hljs-attr\"\u003eD\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eIdentifiable\u003c/span\u003e \u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eHashable\u003c/span\u003e, C : \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e  {\n        \u003cspan class=\"hljs-title function_\"\u003epreference\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSheetFactoryKey\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eself\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003edescribing\u003c/span\u003e: data): \u003cspan class=\"hljs-title class_\"\u003eNavigationViewFactory\u003c/span\u003e(data, sheet)]) \u003cspan class=\"hljs-comment\"\u003e// \u0026#x3C;- Here we set the key to the data type's description! and pass our view factory\u003c/span\u003e\n    }\n\n    public func coverDestination\u0026#x3C;D,C\u003e(\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: D.\u003cspan class=\"hljs-property\"\u003eType\u003c/span\u003e, @\u003cspan class=\"hljs-title class_\"\u003eViewBuilder\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecover\u003c/span\u003e: @escaping (D) -\u003e C) -\u003e some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e where \u003cspan class=\"hljs-attr\"\u003eD\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eIdentifiable\u003c/span\u003e \u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eHashable\u003c/span\u003e, C : \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e  {\n        \u003cspan class=\"hljs-title function_\"\u003epreference\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCoverFactoryKey\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eself\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003edescribing\u003c/span\u003e: data): \u003cspan class=\"hljs-title class_\"\u003eNavigationViewFactory\u003c/span\u003e(data, cover)])\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e네비게이션 목적지()가 sheetDestination()와 coverDestination() 선호 키 모두 호출자의 모든 값을 하나의 [String: NavigationViewFactory] 사전으로 줄입니다.\u003c/p\u003e\n\u003cp\u003e기본적으로 여러 Coordinator가 있는 경우 각각이 자체 경로 유형을 위해 sheetDestination() 선호 키를 사용합니다. 이것은 PreferenceKeys에서 보내진 모든 값들을 하나의 사전으로 병합/줄이고, 문자열 키를 사용하여 작업하는 데이터 유형에 대한 식별자로 사용할 수 있습니다. 따라서 뷰 계층 구조를 통해 전달된 대응하는 예상 값에 접근할 수 있습니다. 이 값은 해당 목적지를 반환하는 데 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e여기에는 데이터 유형을 설명하는 ID와 AnyView를 반환하는 타입 지워진 NavigationViewFactory가 있습니다.\nAnyView는 SwiftUI에서 제공되는 타입 지워진 뷰 래퍼로 성능에 부담이 있으므로 절약해서 사용해야 합니다. 그러나 한 번에 하나의 시트나 커버만 표시할 수 있기 때문에 수용할만한 것으로 보입니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eNavigationController로 다시 가서 코드를 추가해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e final \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNavigationController\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e navigationPath = \u003cspan class=\"hljs-title class_\"\u003eNavigationPath\u003c/span\u003e()\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e alertPath = \u003cspan class=\"hljs-title class_\"\u003eAlertPath\u003c/span\u003e()\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esheetPath\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSheetPath\u003c/span\u003e = .\u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e() \u003cspan class=\"hljs-comment\"\u003e// \u0026#x3C;- SheetPath를 생성해 봅시다\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecoverPath\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCoverPath\u003c/span\u003e = .\u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e() \u003cspan class=\"hljs-comment\"\u003e// \u0026#x3C;- CoverPath를 생성해 봅시다\u003c/span\u003e\n\n    func presentSheet\u0026#x3C;T\u003e(_ \u003cspan class=\"hljs-attr\"\u003eroute\u003c/span\u003e: T, \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e: (() -\u003e \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e)? = nil)  where \u003cspan class=\"hljs-attr\"\u003eT\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCodable\u003c/span\u003e \u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eIdentifiable\u003c/span\u003e \u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eHashable\u003c/span\u003e  {\n        sheetPath.\u003cspan class=\"hljs-title function_\"\u003esetSheet\u003c/span\u003e(route, \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e: onDismiss)\n    }\n\n    func presentCover\u0026#x3C;T\u003e(_ \u003cspan class=\"hljs-attr\"\u003eroute\u003c/span\u003e: T, \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e: (() -\u003e \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e)? = nil)  where \u003cspan class=\"hljs-attr\"\u003eT\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCodable\u003c/span\u003e \u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eIdentifiable\u003c/span\u003e \u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eHashable\u003c/span\u003e  {\n        coverPath.\u003cspan class=\"hljs-title function_\"\u003esetCover\u003c/span\u003e(route, \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e: onDismiss)\n    }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// Sheet\u003c/span\u003e\nstruct \u003cspan class=\"hljs-title class_\"\u003eSheetPath\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eIdentifiable\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e { sheet?.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e ?? \u003cspan class=\"hljs-title function_\"\u003eUUID\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003euuidString\u003c/span\u003e } \u003cspan class=\"hljs-comment\"\u003e// \u0026#x3C;- 현재 sheet의 id를 사용합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esheet\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSheetContainer\u003c/span\u003e?\n\n    mutating func setSheet\u0026#x3C;T\u003e(_ \u003cspan class=\"hljs-attr\"\u003esheet\u003c/span\u003e: T, \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e: (() -\u003e \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e)? = nil) where \u003cspan class=\"hljs-attr\"\u003eT\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCodable\u003c/span\u003e \u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eIdentifiable\u003c/span\u003e \u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eHashable\u003c/span\u003e  {\n        self.\u003cspan class=\"hljs-property\"\u003esheet\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eSheetContainer\u003c/span\u003e(sheet, \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e: onDismiss)\n    }\n}\n\nstruct \u003cspan class=\"hljs-title class_\"\u003eSheetContainer\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eIdentifiable\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esheet\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAny\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e: (() -\u003e \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e)?\n\n    init\u0026#x3C;T\u003e(_ \u003cspan class=\"hljs-attr\"\u003esheet\u003c/span\u003e: T, \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e: (() -\u003e \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e)? = nil) where \u003cspan class=\"hljs-attr\"\u003eT\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCodable\u003c/span\u003e \u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eIdentifiable\u003c/span\u003e \u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eHashable\u003c/span\u003e  {\n        self.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003edescribing\u003c/span\u003e: T.\u003cspan class=\"hljs-property\"\u003eself\u003c/span\u003e)\n        self.\u003cspan class=\"hljs-property\"\u003esheet\u003c/span\u003e = sheet\n        self.\u003cspan class=\"hljs-property\"\u003eonDismiss\u003c/span\u003e = onDismiss\n    }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// Fullscreen Cover\u003c/span\u003e\nstruct \u003cspan class=\"hljs-title class_\"\u003eCoverPath\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eIdentifiable\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e { cover?.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e ?? \u003cspan class=\"hljs-title function_\"\u003eUUID\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003euuidString\u003c/span\u003e }\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecover\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCoverContainer\u003c/span\u003e?\n\n    mutating func setCover\u0026#x3C;T\u003e(_ \u003cspan class=\"hljs-attr\"\u003ecover\u003c/span\u003e: T, \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e: (() -\u003e \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e)? = nil) where \u003cspan class=\"hljs-attr\"\u003eT\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCodable\u003c/span\u003e \u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eIdentifiable\u003c/span\u003e \u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eHashable\u003c/span\u003e  {\n        self.\u003cspan class=\"hljs-property\"\u003ecover\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eCoverContainer\u003c/span\u003e(cover, \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e: onDismiss)\n    }\n}\n\nstruct \u003cspan class=\"hljs-title class_\"\u003eCoverContainer\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eIdentifiable\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecover\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAny\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e: (() -\u003e \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e)?\n\n    init\u0026#x3C;T\u003e(_ \u003cspan class=\"hljs-attr\"\u003ecover\u003c/span\u003e: T, \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e: (() -\u003e \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e)? = nil) where \u003cspan class=\"hljs-attr\"\u003eT\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCodable\u003c/span\u003e \u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eIdentifiable\u003c/span\u003e \u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eHashable\u003c/span\u003e  {\n        self.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003edescribing\u003c/span\u003e: T.\u003cspan class=\"hljs-property\"\u003eself\u003c/span\u003e)\n        self.\u003cspan class=\"hljs-property\"\u003ecover\u003c/span\u003e = cover\n        self.\u003cspan class=\"hljs-property\"\u003eonDismiss\u003c/span\u003e = onDismiss\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 두 가지 구현 사항은 기본적으로 동일하며 같은 컨테이너, 경로, 함수 뷰 수정자 등을 사용하고 열거형 PresentationMode를 추가하여 sheet와 cover를 구분할 수 있는 case를 추가할 수 있습니다. 그러나 일관성을 유지하기 위해 이 예제에서는 이들을 분리해 두었습니다. 또한 SwiftUI가 이후에 여러 개의 sheet/cover를 지원한다면 별도로 처리하고자 할 수도 있습니다. 선택은 당신에게 맡깁니다. 지금까지 어떤 것들을 얻었나요?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNavigationController에는 이제 sheet 및 fullScreenCover에 대한 경로가 있습니다.\u003c/li\u003e\n\u003cli\u003e우리는 데이터 작업의 구체적인 유형을 지우기 위해 타입 이레이저를 사용하지만, 우리가 수용할 수 있는 유형으로만 컨테이너를 초기화할 수 있도록 하여, 지워진 타입 값은 일종의 Identifiable, Hashable 및 Codable 유형이 되도록 보장합니다.\u003c/li\u003e\n\u003cli\u003e또한, 해당 데이터 유형의 설명을 Identifiable 준수를위한 식별자로 저장하여 우리의 뷰 팩토리 콜백 딕셔너리에서 구분할 수 있도록 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e여전히 함께 계신다니 너무 기쁘네요! 이제 모든 것을 함께 연결해보려 합니다.\u003c/p\u003e\n\u003cp\u003e이제 시트를 표시하는 ViewModifier를 만들어야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eextension \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    func \u003cspan class=\"hljs-title function_\"\u003esheet\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esheetPath\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBinding\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eSheetPath\u003c/span\u003e\u003e) -\u003e some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-title function_\"\u003emodifier\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eSheetModifier\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003esheetPath\u003c/span\u003e: sheetPath))\n    }\n\n    func \u003cspan class=\"hljs-title function_\"\u003ecover\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBinding\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eCoverPath\u003c/span\u003e\u003e, \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e: (() -\u003e \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e)? = nil) -\u003e some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-title function_\"\u003emodifier\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eCoverModifier\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: data))\n    }\n}\n\nstruct \u003cspan class=\"hljs-title class_\"\u003eSheetModifier\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eViewModifier\u003c/span\u003e {\n    @\u003cspan class=\"hljs-title class_\"\u003eBinding\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esheetPath\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSheetPath\u003c/span\u003e\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e private \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efactories\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eNavigationViewFactory\u003c/span\u003e] = [:]\n    private \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e: (() -\u003e \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e)?\n\n    \u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003esheetPath: Binding\u0026#x3C;SheetPath\u003e\u003c/span\u003e) {\n        self.\u003cspan class=\"hljs-property\"\u003e_sheetPath\u003c/span\u003e = sheetPath\n        self.\u003cspan class=\"hljs-property\"\u003eonDismiss\u003c/span\u003e = sheetPath.\u003cspan class=\"hljs-property\"\u003ewrappedValue\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esheet\u003c/span\u003e?.\u003cspan class=\"hljs-property\"\u003eonDismiss\u003c/span\u003e\n    }\n\n    func \u003cspan class=\"hljs-title function_\"\u003ebody\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eContent\u003c/span\u003e) -\u003e some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        content\n            .\u003cspan class=\"hljs-title function_\"\u003eonPreferenceChange\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eSheetFactoryKey.self\u003c/span\u003e) { factories = $0 }\n            .\u003cspan class=\"hljs-title function_\"\u003esheet\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eitem\u003c/span\u003e: _sheetPath.\u003cspan class=\"hljs-property\"\u003esheet\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e: sheetPath.\u003cspan class=\"hljs-property\"\u003esheet\u003c/span\u003e?.\u003cspan class=\"hljs-property\"\u003eonDismiss\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: { factories[sheetPath.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e]?.\u003cspan class=\"hljs-title function_\"\u003efactory\u003c/span\u003e($0.\u003cspan class=\"hljs-property\"\u003esheet\u003c/span\u003e) })\n    }\n}\n\nstruct \u003cspan class=\"hljs-title class_\"\u003eCoverModifier\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eViewModifier\u003c/span\u003e {\n    @\u003cspan class=\"hljs-title class_\"\u003eBinding\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCoverPath\u003c/span\u003e\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e private \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efactories\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eNavigationViewFactory\u003c/span\u003e] = [:]\n    private \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e: (() -\u003e \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e)?\n\n    \u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edata: Binding\u0026#x3C;CoverPath\u003e\u003c/span\u003e) {\n        self.\u003cspan class=\"hljs-property\"\u003e_data\u003c/span\u003e = data\n        self.\u003cspan class=\"hljs-property\"\u003eonDismiss\u003c/span\u003e = data.\u003cspan class=\"hljs-property\"\u003ewrappedValue\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecover\u003c/span\u003e?.\u003cspan class=\"hljs-property\"\u003eonDismiss\u003c/span\u003e\n    }\n\n    func \u003cspan class=\"hljs-title function_\"\u003ebody\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eContent\u003c/span\u003e) -\u003e some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        content\n            .\u003cspan class=\"hljs-title function_\"\u003eonPreferenceChange\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eCoverFactoryKey.self\u003c/span\u003e) { factories = $0 }\n            .\u003cspan class=\"hljs-title function_\"\u003efullScreenCover\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eitem\u003c/span\u003e: _data.\u003cspan class=\"hljs-property\"\u003ecover\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e: data.\u003cspan class=\"hljs-property\"\u003ecover\u003c/span\u003e?.\u003cspan class=\"hljs-property\"\u003eonDismiss\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: { factories[data.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e]?.\u003cspan class=\"hljs-title function_\"\u003efactory\u003c/span\u003e($0.\u003cspan class=\"hljs-property\"\u003ecover\u003c/span\u003e) })\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이게 뭐하는 거야? 모든 .sheetDestination()를 사용하는 코디네이터는 경로에 해당하는 코디네이션 함수를 뷰 계층 구조에 전달합니다. 그리고 sheetPath에 값을 설정하면 동일한 데이터 유형에 대한 viewFactory를 추출하고 데이터 인스턴스를 주입하여 메서드를 호출하여 대상을 반환할 것입니다. 모두 어떻게 함께 작동하는지 예제를 살펴봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eenum \u003cspan class=\"hljs-title class_\"\u003eFirstTabCoordinatorRoute\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCodable\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eHashable\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eIdentifiable\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003edescribing\u003c/span\u003e: self) }\n    ... 이전 경로들\n\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e sheet \u003cspan class=\"hljs-comment\"\u003e// 선택 사항으로 연결된 값 전달 가능\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e cover\n}\n\n@\u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e final \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFirstTabCoordinator\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCoordinator\u003c/span\u003e {\n    ... 이전 코드\n\n    @\u003cspan class=\"hljs-title class_\"\u003eViewBuilder\u003c/span\u003e @\u003cspan class=\"hljs-title class_\"\u003eMainActor\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erootView\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e viewModel = \u003cspan class=\"hljs-title class_\"\u003eFirstViewModel\u003c/span\u003e(self)\n        \u003cspan class=\"hljs-title class_\"\u003eFirstView\u003c/span\u003e(viewModel)\n            .\u003cspan class=\"hljs-title function_\"\u003enavigationDestination\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003efor\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eRoute\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eself\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003ecoordinate\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003e_\u003c/span\u003e:))\n            .\u003cspan class=\"hljs-title function_\"\u003esheetDestination\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003efor\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eRoute\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eself\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003esheet\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003ecoordinate\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003e_\u003c/span\u003e:))\n            .\u003cspan class=\"hljs-title function_\"\u003ecoverDestination\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003efor\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eRoute\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eself\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ecover\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003ecoordinate\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003e_\u003c/span\u003e:))\n    }\n\n    func \u003cspan class=\"hljs-title function_\"\u003epresentSheet\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eonDismiss: (() -\u003e Void)? = nil\u003c/span\u003e) {\n        navigationController.\u003cspan class=\"hljs-title function_\"\u003epresentSheet\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eRoute\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esheet\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e: onDismiss)\n    }\n\n    func \u003cspan class=\"hljs-title function_\"\u003epresentCover\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eonDismiss: (() -\u003e Void)? = nil\u003c/span\u003e) {\n        navigationController.\u003cspan class=\"hljs-title function_\"\u003epresentCover\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eRoute\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecover\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e: onDismiss)\n    }\n\n    @\u003cspan class=\"hljs-title class_\"\u003eViewBuilder\u003c/span\u003e @\u003cspan class=\"hljs-title class_\"\u003eMainActor\u003c/span\u003e func \u003cspan class=\"hljs-title function_\"\u003ecoordinate\u003c/span\u003e(_ \u003cspan class=\"hljs-attr\"\u003eroute\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eRoute\u003c/span\u003e) -\u003e some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e route {\n            ... 이전 경로들\n\n            \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003esheet\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSomeBranchedView\u003c/span\u003e()\n            \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003ecover\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSomeCoverView\u003c/span\u003e()\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e와, 정말 깔끔하네요!\nrootView 계산 속성 내에서 PreferenceKeys를 설정하여 모든 정보가 코디네이터의 Route.Types를 해결하는 데 필요한 정보를 코디네이트(coordinates) 함수로 보냅니다. 이 함수는 특정 코디네이터가 좌표를 맡은 모든 뷰를 생성합니다. 🤔 꽤 괜찮죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eCoordinatedView\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-attr\"\u003eC\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCoordinator\u003c/span\u003e\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    private \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecoordinator\u003c/span\u003e: C\n\n    \u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e_ coordinator: C\u003c/span\u003e) {\n        self.\u003cspan class=\"hljs-property\"\u003ecoordinator\u003c/span\u003e = coordinator\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        @\u003cspan class=\"hljs-title class_\"\u003eBindable\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e navigationController = coordinator.\u003cspan class=\"hljs-property\"\u003enavigationController\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eNavigationStack\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: $navigationController.\u003cspan class=\"hljs-property\"\u003enavigationPath\u003c/span\u003e) {\n            coordinator.\u003cspan class=\"hljs-property\"\u003erootView\u003c/span\u003e\n        }\n        .\u003cspan class=\"hljs-title function_\"\u003esheet\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003efor\u003c/span\u003e: $navigationController.\u003cspan class=\"hljs-property\"\u003esheetPath\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003ecover\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003efor\u003c/span\u003e: $navigationController.\u003cspan class=\"hljs-property\"\u003ecoverPath\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003ealert\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003efor\u003c/span\u003e: $navigationController.\u003cspan class=\"hljs-property\"\u003ealertPath\u003c/span\u003e)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막으로 루트 CoordinatedView에 sheet 또는 cover를 적용하는 방법에 대해 다음과 같이 살펴보겠습니다. 이것도 꽤 깔끔하네요 😉\u003c/p\u003e\n\u003cp\u003e그러니까 이 경우를 위해 우리의 view와 viewModel을 검사해봅시다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFirstView\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e viewModel: \u003cspan class=\"hljs-type\"\u003eFirstViewModel\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e body: \u003cspan class=\"hljs-keyword\"\u003esome\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-type\"\u003eVStack\u003c/span\u003e {\n            \u003cspan class=\"hljs-type\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"First View\"\u003c/span\u003e)\n            \u003cspan class=\"hljs-type\"\u003eButton\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"상세 화면으로 이동\"\u003c/span\u003e) {\n                viewModel.didTapButton()\n            }\n        }\n    }\n}\n\n\u003cspan class=\"hljs-meta\"\u003e@Observable\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFirstViewModel\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e coordinator: \u003cspan class=\"hljs-type\"\u003eFirstTabCoordinator\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003einit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecoordinator\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eFirstTabCoordinator\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.coordinator \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e coordinator\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edidTapButton\u003c/span\u003e() {\n        coordinator.presentSheet {\n          \u003cspan class=\"hljs-comment\"\u003e// closure called onDismiss\u003c/span\u003e\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리의 뷰는 didTapButton 이외에 무슨 일이 벌어지고 있는지 알 수 없습니다.\u003c/p\u003e\n\u003cp\u003eℹ️ 또한 다른 필요한 수식어(modifier)들이 coordinate() 함수에서 반환되기 전에 뷰에 적용될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 시트에 presentationDetents를 적용하려면. 그리고 뷰 내부에서 심지어 그것에 대해 알 필요조차 없을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e final \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFirstTabCoordinator\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCoordinator\u003c/span\u003e {\n    ... 이전 코드\n\n    @\u003cspan class=\"hljs-title class_\"\u003eViewBuilder\u003c/span\u003e @\u003cspan class=\"hljs-title class_\"\u003eMainActor\u003c/span\u003e func \u003cspan class=\"hljs-title function_\"\u003ecoordinate\u003c/span\u003e(_ \u003cspan class=\"hljs-attr\"\u003eroute\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eRoute\u003c/span\u003e) -\u003e some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e route {\n         ... 이전 루트\n\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003esheet\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSomeBranchedView\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003epresentationDetents\u003c/span\u003e([.\u003cspan class=\"hljs-property\"\u003emedium\u003c/span\u003e, .\u003cspan class=\"hljs-property\"\u003elarge\u003c/span\u003e]) \u003cspan class=\"hljs-comment\"\u003e// 시트를 반으로 크기 조정하고 드래그 액션 등을 허용합니다.\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003ecover\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSomeCoverView\u003c/span\u003e()\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e지금은 여기까지입니다.\u003c/p\u003e\n\u003cp\u003e이 글에서 어떤 통찰을 얻으셨다면 좋겠네요. 피드백이나 개선 제안이 있다면 알려주세요. 이 글이 가치 있다고 느끼신다면 공유해주세요!\u003c/p\u003e\n\u003cp\u003e즐거운 코딩하세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover"},"buildId":"bb_yO9GbCvdfc_n71SfUf","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>