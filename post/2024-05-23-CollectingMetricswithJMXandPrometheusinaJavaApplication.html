<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>자바 애플리케이션에서 JMX와 프로메테우스로 메트릭 수집하기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="자바 애플리케이션에서 JMX와 프로메테우스로 메트릭 수집하기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="자바 애플리케이션에서 JMX와 프로메테우스로 메트릭 수집하기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication" data-gatsby-head="true"/><meta name="twitter:title" content="자바 애플리케이션에서 JMX와 프로메테우스로 메트릭 수집하기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-23 12:38" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_buildManifest.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">자바 애플리케이션에서 JMX와 프로메테우스로 메트릭 수집하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="자바 애플리케이션에서 JMX와 프로메테우스로 메트릭 수집하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 23, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>저희 응용 프로그램의 내부 작업, 성능 특성 및 비즈니스 지표를 이해하는 것은 사용자 경험과 비즈니스 상태를 구분짓고, 비즈니스가 어떻게 진행되고 있는지를 나타낼 수 있습니다. 높은 CPU 또는 메모리 사용량, 느린 응답 시간 또는 높은 지연과 같은 성능 문제는 비효율성이나 자원 경합을 지적할 수 있습니다.</p>
<p>하지만 이러한 수치가 사용자에게 영향을 주기 전에 어떻게 감지, 추적 및 관찰할 수 있을까요?</p>
<h1>소개</h1>
<p>우리는 지표를 수집하고 분석함으로써 응용 프로그램의 상태, 동작 및 건강 상태에 대한 통찰력을 얻을 수 있습니다. JMX 및 프로메테우스와 같은 도구를 활용하여 간단한 방식으로 자바 응용 프로그램 지표에 대한 심도있는 가시성을 제공하는 강력한 모니터링 인프라를 구축할 수 있습니다.</p>
<p></p>
<p>이 글에서는 다음을 배울 것입니다:</p>
<ul>
<li>MBeans를 사용한 JMX 계측의 기본 사항.</li>
<li>jconsole을 사용하여 JMX에 노출된 메트릭을 시각화하는 방법.</li>
<li>Prometheus가 무엇이며 JMX와 통합하여 대시보드에 메트릭을 노출하는 방법.</li>
<li>Java Prometheus 에이전트를 구성하고 Prometheus 서버를 실행하는 방법.</li>
<li>Prometheus를 사용하여 시계열 데이터를 시각화하는 방법.</li>
</ul>
<p><img src="/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_0.png" alt="이미지"></p>
<h1>JMX란 무엇인가요?</h1>
<p></p>
<p>JMX (Java Management Extensions)은 애플리케이션, 시스템 객체, 장치 및 서비스 중심 네트워크를 관리하고 모니터링하는 도구를 제공하는 네이티브 Java 기술입니다. 이러한 자원들은 MBeans(또는 관리되는 빈)이라고 불리는 객체로 나타낼 수 있습니다.</p>
<p>작동 방식은 다음과 같습니다: 하나 이상의 MBeans가 리소스에 의해 계측(instrumented)되며, MBeans는 표준(관리 인터페이스가 메서드 이름으로 설명됨) 또는 동적(런타임에 관리 인터페이스를 노출하여 최대 유연성을 제공) 중 하나일 수 있습니다. 그런 다음 MBeans는 MBean 서버로 알려진 코어-관리되는 객체 서버에 등록되어 레지스트리 역할을 하는데, 각 MBean은 ObjectName에 의해 식별된 MBeanServer 내에서 고유한 식별자를 갖습니다.</p>
<p>이것들은 JMX의 기본 사항이지만 이 기사를 따라갈 정도로 충분합니다. 자세히 살펴보고 싶다면, 오라클의 "Getting Started with Java Management Extensions (JMX): Developing Management and Monitoring Solutions"라는 오래되었지만 상당히 유용한 기술 포스트를 읽어보시기를 권장합니다.</p>
<h2>Mbeans 구현하기</h2>
<p></p>
<p>JMX에 메트릭을 노출하는 MBean 규칙은 다음과 같습니다:</p>
<ul>
<li>MBean 접미사를 가진 인터페이스를 정의합니다.</li>
<li>이 인터페이스를 클래스에서 구현합니다.</li>
<li>구현을 Platform MBean 서버에 ObjectName을 사용하여 등록합니다.</li>
</ul>
<p>세 가지 작업(step 1)이 있는 간단한 DemoJmxMBean 인터페이스를 정의해봅시다:</p>
<pre><code class="hljs language-js">public interface <span class="hljs-title class_">DemoJmxMBean</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">increaseVolume</span>();
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">decreaseVolume</span>();
    int <span class="hljs-title function_">getVolume</span>();
}
</code></pre>
<p></p>
<p>다음으로 이 인터페이스를 구현해야 합니다 (단계 2). 다음과 같이 DemoJmx 클래스에서 작업해 봅시다:</p>
<pre><code class="hljs language-js">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoJmx</span> implements <span class="hljs-title class_">DemoJmxMBean</span> {
    private int volume = <span class="hljs-number">0</span>;
    @<span class="hljs-title class_">Override</span>
    public <span class="hljs-keyword">void</span> <span class="hljs-title function_">increaseVolume</span>(<span class="hljs-params"></span>) {
        volume++;
    }
    @<span class="hljs-title class_">Override</span>
    public <span class="hljs-keyword">void</span> <span class="hljs-title function_">decreaseVolume</span>(<span class="hljs-params"></span>) {
        volume--;
    }
    @<span class="hljs-title class_">Override</span>
    public int <span class="hljs-title function_">getVolume</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> volume;
    }
...
</code></pre>
<p>이후, MBean 서버를 초기화하고 사용자 정의 MBean (DemoJmx)의 인스턴스를 생성한 다음, main 메소드 내에서 고유한 ObjectName을 사용하여 MBean 서버에 등록해야 합니다 (단계 3). 이 설정을 통해 JMX를 통해 DemoJmx 인스턴스를 관리하고 모니터링할 수 있게 됩니다. 이 경우, 볼륨을 관리하고 수집할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 모든 MBean을 위한 레지스트리인 플랫폼 MBeanServer를 검색합니다</span>
<span class="hljs-title class_">MBeanServer</span> mbs = <span class="hljs-title class_">ManagementFactory</span>.<span class="hljs-title function_">getPlatformMBeanServer</span>();
<span class="hljs-comment">// MBean 구현의 인스턴스를 생성합니다</span>
<span class="hljs-title class_">DemoJmx</span> demoService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DemoJmx</span>();
<span class="hljs-title class_">ObjectName</span> name;
<span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 특정 네이밍 패턴을 사용하여 새 ObjectName 인스턴스를 생성합니다</span>
    name = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectName</span>(<span class="hljs-string">"com.example.DemoJmx:type=DemoJmxMBean,name=DemoJmxMetrics"</span>);
    <span class="hljs-comment">// ObjectName을 사용하여 MBean 인스턴스 (demoService)를 MBeanServer에 등록합니다</span>
    <span class="hljs-comment">// 이렇게 하면 JMX를 통해 MBean을 관리하고 모니터링할 수 있습니다</span>
    mbs.<span class="hljs-title function_">registerMBean</span>(demoService, name);
</code></pre>
<p></p>
<p>시간을 절약하기 위해 전체 코드는 제 Github에서 확인할 수 있어요. 원하는 IDE를 선택하고 이 기사를 따라해보세요.</p>
<h2>노출된 MBean 시각화</h2>
<p>한 번 MBean이 등록되면, 우리는 JMX 클라이언트(예: JConsole)를 사용하여 메트릭에 액세스할 수 있어요. 이 클라이언트는 JVM에 연결되어 등록된 MBeans를 탐색하고 상호 작용할 수 있게 해줍니다 (그림 1).</p>
<p></p>
<p>만약 나처럼 JConsole을 사용 중이라면 MBeans 탭으로 이동하면 DemoJmxMetrics라는 우리의 MBeans가 있을 것입니다 (그림 2).</p>
<p><img src="/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_2.png" alt="DemoJmxMetrics"></p>
<p>JConsole UI에 노출된 volume 속성을 확인할 수 있습니다. 그러나 이는 해당 속성의 현재 상태입니다. 만약 우리가 이 속성의 볼륨을 시계열 그래프를 통해 보고 싶다면 어떻게 할까요? 이 임무를 위해 우리는 다른 도구 — Prometheus가 필요합니다. 다음에 소개됩니다.</p>
<h1>Prometheus란 무엇인가요?</h1>
<p></p>
<p>프로메테우스는 신뢰성과 확장성을 위해 설계된 오픈 소스 시스템 모니터링 및 경고 도구입니다. 특히 동적 클라우드 환경, 컨테이너화된 응용프로그램 및 마이크로서비스 아키텍처의 모니터링에 적합합니다. 프로메테우스는 Cloud Native Computing Foundation (CNCF)의 일부입니다. 이 어떻게 우리를 도울까요?</p>
<p>프로메테우스는 JMX 메트릭을 수집하고 http 엔드포인트를 통해 노출시킵니다. 이 작업을 위해 일반적으로 프로메테우스 JMX 내보내기 도구를 사용합니다. 이 도구는 JMX 메트릭과 프로메테우스 사이의 다리 역할을 하며, 프로메테우스가 다른 메트릭 엔드포인트와 마찬가지로 JMX 메트릭을 수집할 수 있도록 합니다.</p>
<p>이제 프로메테우스가 무엇이며 JMX 속성(또는 메트릭)을 내보내기하는 데 사용할 수 있는 것을 알았으니, 다시 손을 더럽히기 시작해봅시다.</p>
<h2>프로메테우스 JMX 내보내기로 JMX 메트릭 노출하기</h2>
<p></p>
<p>단순해요. 먼저 GitHub 릴리스 페이지에서 최신 jmx_prometheus_javaagent-<code>버전</code>.jar 파일을 다운로드하세요.</p>
<p>그런 다음 config.yaml(다른 이름일 수도 있음)이라는 설정 파일을 생성하여 JMX Exporter를 구성하세요. 이 파일은 수집할 JMX 메트릭과 Prometheus 메트릭으로의 매핑을 정의할 것입니다.</p>
<p>다음은 promiscuous(넓은 범위) 설정 파일 예시입니다 (수집하려는 항목만 남기도록 필터링할 수 있습니다):</p>
<pre><code class="hljs language-js"><span class="hljs-attr">rules</span>:
- <span class="hljs-attr">pattern</span>: <span class="hljs-string">".*"</span>
</code></pre>
<p></p>
<p>프로메테우스에 메트릭 유형을 지정하려면 config.yaml에서해야 합니다. 이것은 JMX 익스포터 설명서에 설명되어 있습니다.</p>
<p>다음으로, IntelliJ를 사용 중이라면 Figure 3처럼 Java 애플리케이션의 시작 매개변수로 JMX 익스포터를 Java 에이전트로 추가해야 합니다.</p>
<p><img src="/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_3.png" alt="Figure 3"></p>
<p>위와 동일합니다.</p>
<p></p>
<pre><code class="hljs language-bash">java -javaagent:./../jmx_prometheus_javaagent-0.20.0.jar=8080:./../config.yaml -classpath mbeans-example/target/classes com.example.DemoJmx
</code></pre>
<p>이전에 다운로드한 파일의 경로(jmx_prometheus_javaagent-<code>버전</code>.jar 및 config.yaml)를 사용함을 기억해주세요.</p>
<p>이제 우리는 프로메테우스 에이전트가 게시한 메트릭에 /metrics 엔드포인트(<a href="http://localhost:8080/metrics)%EB%A5%BC" rel="nofollow" target="_blank">http://localhost:8080/metrics)를</a> 통해 액세스할 수 있어야 합니다. 도표 4에서 볼 수 있듯이, 자세히 살펴보면 DemoJmxMetrics 객체와 속성 volume을 확인할 수 있습니다.</p>
<p><img src="/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_4.png" alt="이미지"></p>
<p></p>
<p>이제 데이터가 캡처되는 것을 확인했지만, 이는 확실히 시각화하기에 최적의 방법은 아닙니다. 다음에는 이에 대해 처리해 봅시다.</p>
<h2>그래프를 통한 데이터 시각화</h2>
<p>먼저, JMX 익스포터에서 메트릭을 수집하기 위해 프로메테우스 설정 파일 (prometheus.yml)을 가져옵니다. 그림 5는 이 시점까지의 디렉토리 구조를 보여줌으로써 우리가 길을 잃지 않도록 도와줍니다.</p>
<p><img src="/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_5.png" alt="Figure 5"></p>
<p></p>
<p>그럼, 새로운 작업을 추가하여 prometheus.yml 구성 파일을 업데이트합니다:</p>
<pre><code class="hljs language-js">- <span class="hljs-attr">job_name</span>: <span class="hljs-string">'jmx-exporter'</span>
  <span class="hljs-attr">static_configs</span>:
    - <span class="hljs-attr">targets</span>: [<span class="hljs-string">'&#x3C;당신의 IP 주소>:8080'</span>]
</code></pre>
<p><code>your IP address</code>는 우리의 Java 어플리케이션이 실행 중인 네트워크 인터페이스의 IP로 대체되어야 합니다.</p>
<p>마지막으로, prometheus.yml 파일을 위한 볼륨을 만들어 컨테이너 이미지를 사용하여 Prometheus 서버를 실행합니다:</p>
<p></p>
<pre><code class="hljs language-js">docker run \
    -p <span class="hljs-number">9090</span>:<span class="hljs-number">9090</span> \
    -v ./prometheus.<span class="hljs-property">yml</span>:<span class="hljs-regexp">/etc/</span>prometheus/prometheus.<span class="hljs-property">yml</span> \
    prom/prometheus
</code></pre>
<p>모든 것이 잘 되면 콘솔에 다음 메시지가 표시될 것입니다: "서버는 웹 요청을 받을 준비가 되었습니다."</p>
<p>그런 다음, Prometheus 서버 UI 엔드포인트인 <a href="http://localhost:9090" rel="nofollow" target="_blank">http://localhost:9090</a> 으로 이동합니다 (그림 6). 우리의 애플리케이션에서 메트릭이 스크랩되고 있는지 확인하기 위해 상태 메뉴로 이동한 다음 타겟을 선택합니다.</p>
<p><img src="/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_6.png" alt="이미지"></p>
<p></p>
<p>볼륨 측정치의 변화를 시각화하기 위해 JConsole 인터페이스를 사용하여 볼륨을 증가하거나 감소시킬 수 있습니다 (그림 7).</p>
<p><img src="/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_7.png" alt="Figure 7"></p>
<p>increaseVolume() 또는 decreaseVolume()을 클릭한 후에는 볼륨 속성이 그에 맞게 변경되며 이러한 값은 Prometheus에 업데이트될 것입니다.</p>
<p>그래프를 시각화하기 위해 Graph 메뉴로 이동하여 원하는 메트릭을 검색할 수 있습니다. 그림 8에서는 볼륨이라는 데모용으로 생성한 메트릭을 찾고 있습니다.</p>
<p></p>
<p>마지막이에요! 프로메테우스 서버가 응용 프로그램을 스크래핑하는 시간 주기를 구성할 수 있고, 다른 여러 옵션들을 파라미터화할 수도 있지만 이 부분은 당신의 요구에 따라 결정됩니다. 학습 목적으로는 충분할 것입니다.</p>
<h1>최종 고려 사항</h1>
<p>이 기사에서는 MBean 규약을 따르는 방법을 배웠습니다. 또한, 시계열 방식으로 이러한 메트릭을 시각화하기 위해 프로메테우스 서버를 설정했습니다. 프로메테우스가 노출하는 데이터를 시각화하기 위해 Grafana와 같은 다른 도구를 사용할 수 있음에 유의하십시오. Grafana는 대시보드를 생성, 탐색 및 공유하는 데 풍부한 기능 세트를 제공하는 도구입니다.</p>
<p></p>
<p>기타 유의할 점은 Kafka, RabbitMQ, ActiveMQ 등을 포함한 많은 인기있는 Java 기반 라이브러리들이 기본적으로 JMX(metrics)를 제공한다는 것입니다. 이러한 메트릭들은 여기에서 배운 방법과 마찬가지로 노출될 수 있습니다. 따라서 이러한 MBeans를 활용하여 사용 가능한 메트릭을 찾고 응용 프로그램에서 간편하게 모니터링할 수 있습니다.</p>
<p>마지막으로, 응용 프로그램 내에서 비즈니스 메트릭을 생성하고 수집하는 데도 이 같은 패턴을 적용할 수 있다는 점을 강조해야 합니다. 이 접근 방식은 제품 팀과 다른 이해관계자들을 위한 매우 관련성 높은 대시보드를 만들어주어 가치 있는 통찰력을 제공하고 정보에 근거한 의사 결정을 도울 수 있습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"자바 애플리케이션에서 JMX와 프로메테우스로 메트릭 수집하기","description":"","date":"2024-05-23 12:38","slug":"2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication","content":"\n저희 응용 프로그램의 내부 작업, 성능 특성 및 비즈니스 지표를 이해하는 것은 사용자 경험과 비즈니스 상태를 구분짓고, 비즈니스가 어떻게 진행되고 있는지를 나타낼 수 있습니다. 높은 CPU 또는 메모리 사용량, 느린 응답 시간 또는 높은 지연과 같은 성능 문제는 비효율성이나 자원 경합을 지적할 수 있습니다.\n\n하지만 이러한 수치가 사용자에게 영향을 주기 전에 어떻게 감지, 추적 및 관찰할 수 있을까요?\n\n# 소개\n\n우리는 지표를 수집하고 분석함으로써 응용 프로그램의 상태, 동작 및 건강 상태에 대한 통찰력을 얻을 수 있습니다. JMX 및 프로메테우스와 같은 도구를 활용하여 간단한 방식으로 자바 응용 프로그램 지표에 대한 심도있는 가시성을 제공하는 강력한 모니터링 인프라를 구축할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 글에서는 다음을 배울 것입니다:\n\n- MBeans를 사용한 JMX 계측의 기본 사항.\n- jconsole을 사용하여 JMX에 노출된 메트릭을 시각화하는 방법.\n- Prometheus가 무엇이며 JMX와 통합하여 대시보드에 메트릭을 노출하는 방법.\n- Java Prometheus 에이전트를 구성하고 Prometheus 서버를 실행하는 방법.\n- Prometheus를 사용하여 시계열 데이터를 시각화하는 방법.\n\n![이미지](/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_0.png)\n\n# JMX란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJMX (Java Management Extensions)은 애플리케이션, 시스템 객체, 장치 및 서비스 중심 네트워크를 관리하고 모니터링하는 도구를 제공하는 네이티브 Java 기술입니다. 이러한 자원들은 MBeans(또는 관리되는 빈)이라고 불리는 객체로 나타낼 수 있습니다.\n\n작동 방식은 다음과 같습니다: 하나 이상의 MBeans가 리소스에 의해 계측(instrumented)되며, MBeans는 표준(관리 인터페이스가 메서드 이름으로 설명됨) 또는 동적(런타임에 관리 인터페이스를 노출하여 최대 유연성을 제공) 중 하나일 수 있습니다. 그런 다음 MBeans는 MBean 서버로 알려진 코어-관리되는 객체 서버에 등록되어 레지스트리 역할을 하는데, 각 MBean은 ObjectName에 의해 식별된 MBeanServer 내에서 고유한 식별자를 갖습니다.\n\n이것들은 JMX의 기본 사항이지만 이 기사를 따라갈 정도로 충분합니다. 자세히 살펴보고 싶다면, 오라클의 \"Getting Started with Java Management Extensions (JMX): Developing Management and Monitoring Solutions\"라는 오래되었지만 상당히 유용한 기술 포스트를 읽어보시기를 권장합니다.\n\n## Mbeans 구현하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJMX에 메트릭을 노출하는 MBean 규칙은 다음과 같습니다:\n\n- MBean 접미사를 가진 인터페이스를 정의합니다.\n- 이 인터페이스를 클래스에서 구현합니다.\n- 구현을 Platform MBean 서버에 ObjectName을 사용하여 등록합니다.\n\n세 가지 작업(step 1)이 있는 간단한 DemoJmxMBean 인터페이스를 정의해봅시다:\n\n```js\npublic interface DemoJmxMBean {\n    void increaseVolume();\n    void decreaseVolume();\n    int getVolume();\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음으로 이 인터페이스를 구현해야 합니다 (단계 2). 다음과 같이 DemoJmx 클래스에서 작업해 봅시다:\n\n```js\npublic class DemoJmx implements DemoJmxMBean {\n    private int volume = 0;\n    @Override\n    public void increaseVolume() {\n        volume++;\n    }\n    @Override\n    public void decreaseVolume() {\n        volume--;\n    }\n    @Override\n    public int getVolume() {\n        return volume;\n    }\n...\n```\n\n이후, MBean 서버를 초기화하고 사용자 정의 MBean (DemoJmx)의 인스턴스를 생성한 다음, main 메소드 내에서 고유한 ObjectName을 사용하여 MBean 서버에 등록해야 합니다 (단계 3). 이 설정을 통해 JMX를 통해 DemoJmx 인스턴스를 관리하고 모니터링할 수 있게 됩니다. 이 경우, 볼륨을 관리하고 수집할 수 있습니다.\n\n```js\n// 모든 MBean을 위한 레지스트리인 플랫폼 MBeanServer를 검색합니다\nMBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n// MBean 구현의 인스턴스를 생성합니다\nDemoJmx demoService = new DemoJmx();\nObjectName name;\ntry {\n    // 특정 네이밍 패턴을 사용하여 새 ObjectName 인스턴스를 생성합니다\n    name = new ObjectName(\"com.example.DemoJmx:type=DemoJmxMBean,name=DemoJmxMetrics\");\n    // ObjectName을 사용하여 MBean 인스턴스 (demoService)를 MBeanServer에 등록합니다\n    // 이렇게 하면 JMX를 통해 MBean을 관리하고 모니터링할 수 있습니다\n    mbs.registerMBean(demoService, name);\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n시간을 절약하기 위해 전체 코드는 제 Github에서 확인할 수 있어요. 원하는 IDE를 선택하고 이 기사를 따라해보세요.\n\n## 노출된 MBean 시각화\n\n한 번 MBean이 등록되면, 우리는 JMX 클라이언트(예: JConsole)를 사용하여 메트릭에 액세스할 수 있어요. 이 클라이언트는 JVM에 연결되어 등록된 MBeans를 탐색하고 상호 작용할 수 있게 해줍니다 (그림 1).\n\n\u003cimg src=\"/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_1.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 나처럼 JConsole을 사용 중이라면 MBeans 탭으로 이동하면 DemoJmxMetrics라는 우리의 MBeans가 있을 것입니다 (그림 2).\n\n![DemoJmxMetrics](/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_2.png)\n\nJConsole UI에 노출된 volume 속성을 확인할 수 있습니다. 그러나 이는 해당 속성의 현재 상태입니다. 만약 우리가 이 속성의 볼륨을 시계열 그래프를 통해 보고 싶다면 어떻게 할까요? 이 임무를 위해 우리는 다른 도구 — Prometheus가 필요합니다. 다음에 소개됩니다.\n\n# Prometheus란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로메테우스는 신뢰성과 확장성을 위해 설계된 오픈 소스 시스템 모니터링 및 경고 도구입니다. 특히 동적 클라우드 환경, 컨테이너화된 응용프로그램 및 마이크로서비스 아키텍처의 모니터링에 적합합니다. 프로메테우스는 Cloud Native Computing Foundation (CNCF)의 일부입니다. 이 어떻게 우리를 도울까요?\n\n프로메테우스는 JMX 메트릭을 수집하고 http 엔드포인트를 통해 노출시킵니다. 이 작업을 위해 일반적으로 프로메테우스 JMX 내보내기 도구를 사용합니다. 이 도구는 JMX 메트릭과 프로메테우스 사이의 다리 역할을 하며, 프로메테우스가 다른 메트릭 엔드포인트와 마찬가지로 JMX 메트릭을 수집할 수 있도록 합니다.\n\n이제 프로메테우스가 무엇이며 JMX 속성(또는 메트릭)을 내보내기하는 데 사용할 수 있는 것을 알았으니, 다시 손을 더럽히기 시작해봅시다.\n\n## 프로메테우스 JMX 내보내기로 JMX 메트릭 노출하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단순해요. 먼저 GitHub 릴리스 페이지에서 최신 jmx_prometheus_javaagent-`버전`.jar 파일을 다운로드하세요.\n\n그런 다음 config.yaml(다른 이름일 수도 있음)이라는 설정 파일을 생성하여 JMX Exporter를 구성하세요. 이 파일은 수집할 JMX 메트릭과 Prometheus 메트릭으로의 매핑을 정의할 것입니다.\n\n다음은 promiscuous(넓은 범위) 설정 파일 예시입니다 (수집하려는 항목만 남기도록 필터링할 수 있습니다):\n\n```js\nrules:\n- pattern: \".*\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로메테우스에 메트릭 유형을 지정하려면 config.yaml에서해야 합니다. 이것은 JMX 익스포터 설명서에 설명되어 있습니다.\n\n다음으로, IntelliJ를 사용 중이라면 Figure 3처럼 Java 애플리케이션의 시작 매개변수로 JMX 익스포터를 Java 에이전트로 추가해야 합니다.\n\n![Figure 3](/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_3.png)\n\n위와 동일합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```bash\njava -javaagent:./../jmx_prometheus_javaagent-0.20.0.jar=8080:./../config.yaml -classpath mbeans-example/target/classes com.example.DemoJmx\n```\n\n이전에 다운로드한 파일의 경로(jmx_prometheus_javaagent-`버전`.jar 및 config.yaml)를 사용함을 기억해주세요.\n\n이제 우리는 프로메테우스 에이전트가 게시한 메트릭에 /metrics 엔드포인트(http://localhost:8080/metrics)를 통해 액세스할 수 있어야 합니다. 도표 4에서 볼 수 있듯이, 자세히 살펴보면 DemoJmxMetrics 객체와 속성 volume을 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 데이터가 캡처되는 것을 확인했지만, 이는 확실히 시각화하기에 최적의 방법은 아닙니다. 다음에는 이에 대해 처리해 봅시다.\n\n## 그래프를 통한 데이터 시각화\n\n먼저, JMX 익스포터에서 메트릭을 수집하기 위해 프로메테우스 설정 파일 (prometheus.yml)을 가져옵니다. 그림 5는 이 시점까지의 디렉토리 구조를 보여줌으로써 우리가 길을 잃지 않도록 도와줍니다.\n\n![Figure 5](/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼, 새로운 작업을 추가하여 prometheus.yml 구성 파일을 업데이트합니다:\n\n```js\n- job_name: 'jmx-exporter'\n  static_configs:\n    - targets: ['\u003c당신의 IP 주소\u003e:8080']\n```\n\n`your IP address`는 우리의 Java 어플리케이션이 실행 중인 네트워크 인터페이스의 IP로 대체되어야 합니다.\n\n마지막으로, prometheus.yml 파일을 위한 볼륨을 만들어 컨테이너 이미지를 사용하여 Prometheus 서버를 실행합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndocker run \\\n    -p 9090:9090 \\\n    -v ./prometheus.yml:/etc/prometheus/prometheus.yml \\\n    prom/prometheus\n```\n\n모든 것이 잘 되면 콘솔에 다음 메시지가 표시될 것입니다: \"서버는 웹 요청을 받을 준비가 되었습니다.\"\n\n그런 다음, Prometheus 서버 UI 엔드포인트인 http://localhost:9090 으로 이동합니다 (그림 6). 우리의 애플리케이션에서 메트릭이 스크랩되고 있는지 확인하기 위해 상태 메뉴로 이동한 다음 타겟을 선택합니다.\n\n![이미지](/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n볼륨 측정치의 변화를 시각화하기 위해 JConsole 인터페이스를 사용하여 볼륨을 증가하거나 감소시킬 수 있습니다 (그림 7).\n\n![Figure 7](/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_7.png)\n\nincreaseVolume() 또는 decreaseVolume()을 클릭한 후에는 볼륨 속성이 그에 맞게 변경되며 이러한 값은 Prometheus에 업데이트될 것입니다.\n\n그래프를 시각화하기 위해 Graph 메뉴로 이동하여 원하는 메트릭을 검색할 수 있습니다. 그림 8에서는 볼륨이라는 데모용으로 생성한 메트릭을 찾고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_8.png\" /\u003e\n\n마지막이에요! 프로메테우스 서버가 응용 프로그램을 스크래핑하는 시간 주기를 구성할 수 있고, 다른 여러 옵션들을 파라미터화할 수도 있지만 이 부분은 당신의 요구에 따라 결정됩니다. 학습 목적으로는 충분할 것입니다.\n\n# 최종 고려 사항\n\n이 기사에서는 MBean 규약을 따르는 방법을 배웠습니다. 또한, 시계열 방식으로 이러한 메트릭을 시각화하기 위해 프로메테우스 서버를 설정했습니다. 프로메테우스가 노출하는 데이터를 시각화하기 위해 Grafana와 같은 다른 도구를 사용할 수 있음에 유의하십시오. Grafana는 대시보드를 생성, 탐색 및 공유하는 데 풍부한 기능 세트를 제공하는 도구입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기타 유의할 점은 Kafka, RabbitMQ, ActiveMQ 등을 포함한 많은 인기있는 Java 기반 라이브러리들이 기본적으로 JMX(metrics)를 제공한다는 것입니다. 이러한 메트릭들은 여기에서 배운 방법과 마찬가지로 노출될 수 있습니다. 따라서 이러한 MBeans를 활용하여 사용 가능한 메트릭을 찾고 응용 프로그램에서 간편하게 모니터링할 수 있습니다.\n\n마지막으로, 응용 프로그램 내에서 비즈니스 메트릭을 생성하고 수집하는 데도 이 같은 패턴을 적용할 수 있다는 점을 강조해야 합니다. 이 접근 방식은 제품 팀과 다른 이해관계자들을 위한 매우 관련성 높은 대시보드를 만들어주어 가치 있는 통찰력을 제공하고 정보에 근거한 의사 결정을 도울 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_0.png"},"coverImage":"/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_0.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e저희 응용 프로그램의 내부 작업, 성능 특성 및 비즈니스 지표를 이해하는 것은 사용자 경험과 비즈니스 상태를 구분짓고, 비즈니스가 어떻게 진행되고 있는지를 나타낼 수 있습니다. 높은 CPU 또는 메모리 사용량, 느린 응답 시간 또는 높은 지연과 같은 성능 문제는 비효율성이나 자원 경합을 지적할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e하지만 이러한 수치가 사용자에게 영향을 주기 전에 어떻게 감지, 추적 및 관찰할 수 있을까요?\u003c/p\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003e우리는 지표를 수집하고 분석함으로써 응용 프로그램의 상태, 동작 및 건강 상태에 대한 통찰력을 얻을 수 있습니다. JMX 및 프로메테우스와 같은 도구를 활용하여 간단한 방식으로 자바 응용 프로그램 지표에 대한 심도있는 가시성을 제공하는 강력한 모니터링 인프라를 구축할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e이 글에서는 다음을 배울 것입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMBeans를 사용한 JMX 계측의 기본 사항.\u003c/li\u003e\n\u003cli\u003ejconsole을 사용하여 JMX에 노출된 메트릭을 시각화하는 방법.\u003c/li\u003e\n\u003cli\u003ePrometheus가 무엇이며 JMX와 통합하여 대시보드에 메트릭을 노출하는 방법.\u003c/li\u003e\n\u003cli\u003eJava Prometheus 에이전트를 구성하고 Prometheus 서버를 실행하는 방법.\u003c/li\u003e\n\u003cli\u003ePrometheus를 사용하여 시계열 데이터를 시각화하는 방법.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003eJMX란 무엇인가요?\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eJMX (Java Management Extensions)은 애플리케이션, 시스템 객체, 장치 및 서비스 중심 네트워크를 관리하고 모니터링하는 도구를 제공하는 네이티브 Java 기술입니다. 이러한 자원들은 MBeans(또는 관리되는 빈)이라고 불리는 객체로 나타낼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e작동 방식은 다음과 같습니다: 하나 이상의 MBeans가 리소스에 의해 계측(instrumented)되며, MBeans는 표준(관리 인터페이스가 메서드 이름으로 설명됨) 또는 동적(런타임에 관리 인터페이스를 노출하여 최대 유연성을 제공) 중 하나일 수 있습니다. 그런 다음 MBeans는 MBean 서버로 알려진 코어-관리되는 객체 서버에 등록되어 레지스트리 역할을 하는데, 각 MBean은 ObjectName에 의해 식별된 MBeanServer 내에서 고유한 식별자를 갖습니다.\u003c/p\u003e\n\u003cp\u003e이것들은 JMX의 기본 사항이지만 이 기사를 따라갈 정도로 충분합니다. 자세히 살펴보고 싶다면, 오라클의 \"Getting Started with Java Management Extensions (JMX): Developing Management and Monitoring Solutions\"라는 오래되었지만 상당히 유용한 기술 포스트를 읽어보시기를 권장합니다.\u003c/p\u003e\n\u003ch2\u003eMbeans 구현하기\u003c/h2\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eJMX에 메트릭을 노출하는 MBean 규칙은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMBean 접미사를 가진 인터페이스를 정의합니다.\u003c/li\u003e\n\u003cli\u003e이 인터페이스를 클래스에서 구현합니다.\u003c/li\u003e\n\u003cli\u003e구현을 Platform MBean 서버에 ObjectName을 사용하여 등록합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e세 가지 작업(step 1)이 있는 간단한 DemoJmxMBean 인터페이스를 정의해봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epublic interface \u003cspan class=\"hljs-title class_\"\u003eDemoJmxMBean\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eincreaseVolume\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edecreaseVolume\u003c/span\u003e();\n    int \u003cspan class=\"hljs-title function_\"\u003egetVolume\u003c/span\u003e();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e다음으로 이 인터페이스를 구현해야 합니다 (단계 2). 다음과 같이 DemoJmx 클래스에서 작업해 봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epublic \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDemoJmx\u003c/span\u003e implements \u003cspan class=\"hljs-title class_\"\u003eDemoJmxMBean\u003c/span\u003e {\n    private int volume = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n    @\u003cspan class=\"hljs-title class_\"\u003eOverride\u003c/span\u003e\n    public \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eincreaseVolume\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        volume++;\n    }\n    @\u003cspan class=\"hljs-title class_\"\u003eOverride\u003c/span\u003e\n    public \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edecreaseVolume\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        volume--;\n    }\n    @\u003cspan class=\"hljs-title class_\"\u003eOverride\u003c/span\u003e\n    public int \u003cspan class=\"hljs-title function_\"\u003egetVolume\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e volume;\n    }\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이후, MBean 서버를 초기화하고 사용자 정의 MBean (DemoJmx)의 인스턴스를 생성한 다음, main 메소드 내에서 고유한 ObjectName을 사용하여 MBean 서버에 등록해야 합니다 (단계 3). 이 설정을 통해 JMX를 통해 DemoJmx 인스턴스를 관리하고 모니터링할 수 있게 됩니다. 이 경우, 볼륨을 관리하고 수집할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 모든 MBean을 위한 레지스트리인 플랫폼 MBeanServer를 검색합니다\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eMBeanServer\u003c/span\u003e mbs = \u003cspan class=\"hljs-title class_\"\u003eManagementFactory\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetPlatformMBeanServer\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// MBean 구현의 인스턴스를 생성합니다\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eDemoJmx\u003c/span\u003e demoService = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDemoJmx\u003c/span\u003e();\n\u003cspan class=\"hljs-title class_\"\u003eObjectName\u003c/span\u003e name;\n\u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 특정 네이밍 패턴을 사용하여 새 ObjectName 인스턴스를 생성합니다\u003c/span\u003e\n    name = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObjectName\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"com.example.DemoJmx:type=DemoJmxMBean,name=DemoJmxMetrics\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-comment\"\u003e// ObjectName을 사용하여 MBean 인스턴스 (demoService)를 MBeanServer에 등록합니다\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// 이렇게 하면 JMX를 통해 MBean을 관리하고 모니터링할 수 있습니다\u003c/span\u003e\n    mbs.\u003cspan class=\"hljs-title function_\"\u003eregisterMBean\u003c/span\u003e(demoService, name);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e시간을 절약하기 위해 전체 코드는 제 Github에서 확인할 수 있어요. 원하는 IDE를 선택하고 이 기사를 따라해보세요.\u003c/p\u003e\n\u003ch2\u003e노출된 MBean 시각화\u003c/h2\u003e\n\u003cp\u003e한 번 MBean이 등록되면, 우리는 JMX 클라이언트(예: JConsole)를 사용하여 메트릭에 액세스할 수 있어요. 이 클라이언트는 JVM에 연결되어 등록된 MBeans를 탐색하고 상호 작용할 수 있게 해줍니다 (그림 1).\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e만약 나처럼 JConsole을 사용 중이라면 MBeans 탭으로 이동하면 DemoJmxMetrics라는 우리의 MBeans가 있을 것입니다 (그림 2).\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_2.png\" alt=\"DemoJmxMetrics\"\u003e\u003c/p\u003e\n\u003cp\u003eJConsole UI에 노출된 volume 속성을 확인할 수 있습니다. 그러나 이는 해당 속성의 현재 상태입니다. 만약 우리가 이 속성의 볼륨을 시계열 그래프를 통해 보고 싶다면 어떻게 할까요? 이 임무를 위해 우리는 다른 도구 — Prometheus가 필요합니다. 다음에 소개됩니다.\u003c/p\u003e\n\u003ch1\u003ePrometheus란 무엇인가요?\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e프로메테우스는 신뢰성과 확장성을 위해 설계된 오픈 소스 시스템 모니터링 및 경고 도구입니다. 특히 동적 클라우드 환경, 컨테이너화된 응용프로그램 및 마이크로서비스 아키텍처의 모니터링에 적합합니다. 프로메테우스는 Cloud Native Computing Foundation (CNCF)의 일부입니다. 이 어떻게 우리를 도울까요?\u003c/p\u003e\n\u003cp\u003e프로메테우스는 JMX 메트릭을 수집하고 http 엔드포인트를 통해 노출시킵니다. 이 작업을 위해 일반적으로 프로메테우스 JMX 내보내기 도구를 사용합니다. 이 도구는 JMX 메트릭과 프로메테우스 사이의 다리 역할을 하며, 프로메테우스가 다른 메트릭 엔드포인트와 마찬가지로 JMX 메트릭을 수집할 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e이제 프로메테우스가 무엇이며 JMX 속성(또는 메트릭)을 내보내기하는 데 사용할 수 있는 것을 알았으니, 다시 손을 더럽히기 시작해봅시다.\u003c/p\u003e\n\u003ch2\u003e프로메테우스 JMX 내보내기로 JMX 메트릭 노출하기\u003c/h2\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e단순해요. 먼저 GitHub 릴리스 페이지에서 최신 jmx_prometheus_javaagent-\u003ccode\u003e버전\u003c/code\u003e.jar 파일을 다운로드하세요.\u003c/p\u003e\n\u003cp\u003e그런 다음 config.yaml(다른 이름일 수도 있음)이라는 설정 파일을 생성하여 JMX Exporter를 구성하세요. 이 파일은 수집할 JMX 메트릭과 Prometheus 메트릭으로의 매핑을 정의할 것입니다.\u003c/p\u003e\n\u003cp\u003e다음은 promiscuous(넓은 범위) 설정 파일 예시입니다 (수집하려는 항목만 남기도록 필터링할 수 있습니다):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003erules\u003c/span\u003e:\n- \u003cspan class=\"hljs-attr\"\u003epattern\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\".*\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e프로메테우스에 메트릭 유형을 지정하려면 config.yaml에서해야 합니다. 이것은 JMX 익스포터 설명서에 설명되어 있습니다.\u003c/p\u003e\n\u003cp\u003e다음으로, IntelliJ를 사용 중이라면 Figure 3처럼 Java 애플리케이션의 시작 매개변수로 JMX 익스포터를 Java 에이전트로 추가해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_3.png\" alt=\"Figure 3\"\u003e\u003c/p\u003e\n\u003cp\u003e위와 동일합니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003ejava -javaagent:./../jmx_prometheus_javaagent-0.20.0.jar=8080:./../config.yaml -classpath mbeans-example/target/classes com.example.DemoJmx\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이전에 다운로드한 파일의 경로(jmx_prometheus_javaagent-\u003ccode\u003e버전\u003c/code\u003e.jar 및 config.yaml)를 사용함을 기억해주세요.\u003c/p\u003e\n\u003cp\u003e이제 우리는 프로메테우스 에이전트가 게시한 메트릭에 /metrics 엔드포인트(\u003ca href=\"http://localhost:8080/metrics)%EB%A5%BC\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://localhost:8080/metrics)를\u003c/a\u003e 통해 액세스할 수 있어야 합니다. 도표 4에서 볼 수 있듯이, 자세히 살펴보면 DemoJmxMetrics 객체와 속성 volume을 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e이제 데이터가 캡처되는 것을 확인했지만, 이는 확실히 시각화하기에 최적의 방법은 아닙니다. 다음에는 이에 대해 처리해 봅시다.\u003c/p\u003e\n\u003ch2\u003e그래프를 통한 데이터 시각화\u003c/h2\u003e\n\u003cp\u003e먼저, JMX 익스포터에서 메트릭을 수집하기 위해 프로메테우스 설정 파일 (prometheus.yml)을 가져옵니다. 그림 5는 이 시점까지의 디렉토리 구조를 보여줌으로써 우리가 길을 잃지 않도록 도와줍니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_5.png\" alt=\"Figure 5\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e그럼, 새로운 작업을 추가하여 prometheus.yml 구성 파일을 업데이트합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e- \u003cspan class=\"hljs-attr\"\u003ejob_name\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'jmx-exporter'\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003estatic_configs\u003c/span\u003e:\n    - \u003cspan class=\"hljs-attr\"\u003etargets\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'\u0026#x3C;당신의 IP 주소\u003e:8080'\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eyour IP address\u003c/code\u003e는 우리의 Java 어플리케이션이 실행 중인 네트워크 인터페이스의 IP로 대체되어야 합니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, prometheus.yml 파일을 위한 볼륨을 만들어 컨테이너 이미지를 사용하여 Prometheus 서버를 실행합니다:\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker run \\\n    -p \u003cspan class=\"hljs-number\"\u003e9090\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e9090\u003c/span\u003e \\\n    -v ./prometheus.\u003cspan class=\"hljs-property\"\u003eyml\u003c/span\u003e:\u003cspan class=\"hljs-regexp\"\u003e/etc/\u003c/span\u003eprometheus/prometheus.\u003cspan class=\"hljs-property\"\u003eyml\u003c/span\u003e \\\n    prom/prometheus\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e모든 것이 잘 되면 콘솔에 다음 메시지가 표시될 것입니다: \"서버는 웹 요청을 받을 준비가 되었습니다.\"\u003c/p\u003e\n\u003cp\u003e그런 다음, Prometheus 서버 UI 엔드포인트인 \u003ca href=\"http://localhost:9090\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://localhost:9090\u003c/a\u003e 으로 이동합니다 (그림 6). 우리의 애플리케이션에서 메트릭이 스크랩되고 있는지 확인하기 위해 상태 메뉴로 이동한 다음 타겟을 선택합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e볼륨 측정치의 변화를 시각화하기 위해 JConsole 인터페이스를 사용하여 볼륨을 증가하거나 감소시킬 수 있습니다 (그림 7).\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_7.png\" alt=\"Figure 7\"\u003e\u003c/p\u003e\n\u003cp\u003eincreaseVolume() 또는 decreaseVolume()을 클릭한 후에는 볼륨 속성이 그에 맞게 변경되며 이러한 값은 Prometheus에 업데이트될 것입니다.\u003c/p\u003e\n\u003cp\u003e그래프를 시각화하기 위해 Graph 메뉴로 이동하여 원하는 메트릭을 검색할 수 있습니다. 그림 8에서는 볼륨이라는 데모용으로 생성한 메트릭을 찾고 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e마지막이에요! 프로메테우스 서버가 응용 프로그램을 스크래핑하는 시간 주기를 구성할 수 있고, 다른 여러 옵션들을 파라미터화할 수도 있지만 이 부분은 당신의 요구에 따라 결정됩니다. 학습 목적으로는 충분할 것입니다.\u003c/p\u003e\n\u003ch1\u003e최종 고려 사항\u003c/h1\u003e\n\u003cp\u003e이 기사에서는 MBean 규약을 따르는 방법을 배웠습니다. 또한, 시계열 방식으로 이러한 메트릭을 시각화하기 위해 프로메테우스 서버를 설정했습니다. 프로메테우스가 노출하는 데이터를 시각화하기 위해 Grafana와 같은 다른 도구를 사용할 수 있음에 유의하십시오. Grafana는 대시보드를 생성, 탐색 및 공유하는 데 풍부한 기능 세트를 제공하는 도구입니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e기타 유의할 점은 Kafka, RabbitMQ, ActiveMQ 등을 포함한 많은 인기있는 Java 기반 라이브러리들이 기본적으로 JMX(metrics)를 제공한다는 것입니다. 이러한 메트릭들은 여기에서 배운 방법과 마찬가지로 노출될 수 있습니다. 따라서 이러한 MBeans를 활용하여 사용 가능한 메트릭을 찾고 응용 프로그램에서 간편하게 모니터링할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, 응용 프로그램 내에서 비즈니스 메트릭을 생성하고 수집하는 데도 이 같은 패턴을 적용할 수 있다는 점을 강조해야 합니다. 이 접근 방식은 제품 팀과 다른 이해관계자들을 위한 매우 관련성 높은 대시보드를 만들어주어 가치 있는 통찰력을 제공하고 정보에 근거한 의사 결정을 도울 수 있습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication"},"buildId":"bb_yO9GbCvdfc_n71SfUf","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>