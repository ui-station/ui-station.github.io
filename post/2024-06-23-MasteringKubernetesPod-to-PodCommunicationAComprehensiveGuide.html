<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>쿠버네티스 Pod 간 통신 완벽 가이드 마스터하기 위한 모든 것 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="쿠버네티스 Pod 간 통신 완벽 가이드 마스터하기 위한 모든 것 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="쿠버네티스 Pod 간 통신 완벽 가이드 마스터하기 위한 모든 것 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide" data-gatsby-head="true"/><meta name="twitter:title" content="쿠버네티스 Pod 간 통신 완벽 가이드 마스터하기 위한 모든 것 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 22:50" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_buildManifest.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">쿠버네티스 Pod 간 통신 완벽 가이드 마스터하기 위한 모든 것</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="쿠버네티스 Pod 간 통신 완벽 가이드 마스터하기 위한 모든 것" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide_0.png">
<h1>소개</h1>
<p>Kubernetes는 컨테이너 오케스트레이션을 혁신하여 기업이 규모에 맞게 응용 프로그램을 배포하고 관리할 수 있게 하였습니다. Kubernetes의 주요 구성요소 중 하나인 pod는 하나 이상의 강하게 결합된 컨테이너들의 논리적 그룹입니다. pod가 서로 통신하는 방식을 이해하는 것은 Kubernetes 클러스터에서 탄력적이고 확장 가능한 응용 프로그램을 구축하는 데 중요합니다. 이 블로그 게시물에서는 Kubernetes pod 간 통신에 대해 깊이 알아보고 다양한 통신 패턴과 기술을 탐구할 것입니다.</p>
<h1>Pod 네트워킹 이해하기</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>쿠버네티스에서 Pods는 클러스터 내에서 고유한 IP 주소가 할당되어 직접 통신할 수 있습니다. 기본적으로 각 Pod는 격리되어 고유한 IP 주소를 가지며, 안전한 통신을 가능하게 하고 포트 충돌을 피할 수 있습니다. 이러한 IP 주소는 외부 액세스를 위해 특정 구성이 없는 한 쿠버네티스 클러스터 네트워크 내에서만 접근 가능합니다.</p>
<h1>쿠버네티스 네트워킹 모델</h1>
<ul>
<li>동일 노드 내 Pod 간 통신: 동일한 노드에 여러 개의 Pod가 예약되면 localhost 또는 루프백 인터페이스를 사용하여 직접 통신할 수 있습니다. 이 통신은 주로 가상 이더넷(veth) 쌍 형태로 클러스터 내에 할당된 Pod의 IP 주소를 통해 이루어집니다. 이 통신은 네트워크 계층에서 발생하여 동일 노드의 Pod 간 높은 성능과 낮은 지연 시간 상호작용을 가능하게 합니다.</li>
<li>노드 간 Pod 간 통신: 클러스터 내 서로 다른 노드 간에 통신이 필요한 경우, 쿠버네티스는 다양한 네트워킹 솔루션인 Container Network Interfaces (CNIs) 및 소프트웨어 정의 네트워킹(SDN) 기술을 활용합니다. 이러한 솔루션은 전체 클러스터를 가로지르는 가상 네트워크 오버레이를 생성하여 노드 간 Pod 간 통신을 가능하게 합니다. Calico, Flannel, Weave, Cilium 등이 인기 있는 CNIs 중 일부이며, 이러한 네트워킹 솔루션은 Pod의 IP 주소가 Reachable하도록 보장하며, 클러스터 내에서 Pod의 위치에 관계없이 투명한 네트워크 연결성을 제공합니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>기본적으로 쿠버네티스 클러스터 내의 파드는 내부 IP 주소를 사용하여 서로 통신할 수 있습니다. 이 통신은 백그라운드의 컨테이너 런타임이나 네트워크 플러그인에서 제공하는 가상 네트워크 오버레이를 통해 이루어집니다. 내부 IP 주소는 쿠버네티스 클러스터 네트워킹 솔루션에 의해 할당되며 클러스터 내에서만 라우터링됩니다.</p>
<h1>DNS 기반 서비스 검색</h1>
<p>쿠버네티스는 클러스터 내에서 서비스 검색을 위한 내장 DNS 서비스를 제공합니다. 서비스들은 기본 파드를 추상화한 안정적인 엔드포인트 역할을 합니다. 각 서비스는 DNS 이름이 할당되며, 해당 서비스를 지원하는 파드의 IP 주소로 해석됩니다. 이 DNS 기반 접근 방식을 통해 파드는 개별 파드 IP 주소를 직접 참조하는 대신 서비스 이름을 사용하여 서로 통신할 수 있습니다.</p>
<h1>서비스 로드 밸런싱</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>여러 개의 팟이 동일한 애플리케이션을 제공할 때, Kubernetes는 이러한 팟들 간의 트래픽을 분산하는 데 사용하는 내장된 로드 밸런싱 기능을 제공합니다. 서비스 객체를 생성하고 이를 일련의 팟과 연결함으로써, Kubernetes는 사용 가능한 팟들 사이에 들어오는 요청을 자동으로 로드 밸런싱합니다. 이 로드 밸런싱 메커니즘은 애플리케이션의 고가용성과 확장성을 보장합니다.</p>
<h1>네트워크 정책</h1>
<p>Kubernetes는 팟 간의 트래픽 흐름을 제어하기 위한 수단으로 네트워크 정책을 제공합니다. 네트워크 정책은 IP 주소, 포트 및 프로토콜과 같은 다양한 매개변수를 기반으로 어떤 팟이 서로 통신할 수 있는지를 지정하는 규칙을 정의합니다. 네트워크 정책을 시행함으로써, 애플리케이션의 네트워크 트래픽을 세분화하고 추가적인 보안 층을 추가할 수 있습니다.</p>
<h1>외부 통신</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Kubernetes 클러스터 바깥의 리소스와 통신해야 하는 팟이 자주 있습니다. 외부 서비스나 데이터베이스와 통신하는 방법을 용이하게 해주는 여러 메커니즘이 Kubernetes에서 제공됩니다. 한 가지 접근법은 서비스 유형이 "LoadBalancer" 또는 "NodePort"인 서비스를 사용하여 팟 또는 팟 세트를 노출하는 것으로, 외부 클라이언트가 팟에 액세스할 수 있게 합니다. 또 다른 옵션은 Ingress 컨트롤러를 사용하는 것인데, 이를 통해 외부 클러스터로부터 들어오는 트래픽을 정의된 규칙에 따라 적절한 팟으로 라우팅할 수 있습니다.</p>
<h1>서비스 메쉬</h1>
<p>고급 네트워킹 시나리오를 위해, 서비스 메쉬를 사용하여 팟 간 통신을 강화할 수 있습니다. Istio나 Linkerd와 같은 서비스 메쉬는 Kubernetes 클러스터 상단에 있는 레이어로써 트래픽 관리, 관찰가능성, 보안과 같은 기능을 제공합니다. 서비스 메쉬를 사용하면 고급 라우팅 규칙, 회로 차단, 분산 추적을 통해 팟 간 통신을 제어하고 모니터링할 수 있습니다.</p>
<h1>예시</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Kubernetes에서 pod 간 통신을 구성하는 방법을 보여드리기 위해 예제 사양을 살펴보겠습니다. 이 예제에서는 서비스를 사용하여 두 개의 파드를 생성하고 그들 간의 통신을 수립할 것입니다.</p>
<ul>
<li>Pod A 생성: 먼저 간단한 웹 애플리케이션을 실행하는 Pod A를 생성해 보겠습니다. pod-a.yaml이라는 파일을 만들고 아래 내용을 추가하세요:</li>
</ul>
<pre><code class="hljs language-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-a</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">web-app</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">your-web-app-image</span>
      <span class="hljs-attr">ports:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span>
</code></pre>
<p>"your-web-app-image"를 사용 중인 웹 애플리케이션의 적절한 이미지로 교체해 주세요. 이 사양은 지정된 포트 8080이 노출된 상태로 "pod-a"라는 이름의 파드를 생성합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ol start="2">
<li>Pod B를 생성하세요: 이제 Pod A와 통신하는 클라이언트 Pod인 Pod B를 생성해 봅시다. pod-b.yaml이라는 파일을 만들고 다음 내용을 추가해 주세요:</li>
</ol>
<pre><code class="hljs language-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-b</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">client-app</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">your-client-app-image</span>
      <span class="hljs-attr">command:</span> [<span class="hljs-string">"sleep"</span>, <span class="hljs-string">"infinity"</span>]
</code></pre>
<p>your-client-app-image를 사용하고 있는 클라이언트 어플리케이션에 해당하는 이미지로 변경해 주세요. 이 명세는 "pod-b"라는 이름의 pod를 생성하고, 해당 컨테이너를 실행하여 pod를 계속 실행 상태로 유지할 수 있는 무한 sleep 명령을 실행합니다.</p>
<ol start="3">
<li>서비스 생성하기: Pod A와 Pod B 간의 통신을 가능하게 하기 위해 안전한 엔드포인트로 작동하는 서비스를 생성할 것입니다. service.yaml이라는 파일을 만들고 다음 내용을 추가하세요:</li>
</ol>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-service</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">web-app</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span>
</code></pre>
<p>이 구성은 "pod-service"라는 서비스를 생성하며, 이 서비스는 app: web-app 라벨을 가진 파드를 대상으로합니다 (우리가 Pod A에 추가 할 것입니다). 이 서비스는 포트 80을 노출하고 선택한 파드의 포트 8080으로 트래픽을 전달합니다.</p>
<ol start="4">
<li>설정 적용: 다음 명령을 사용하여 생성된 구성을 적용하십시오:</li>
</ol>
<pre><code class="hljs language-yaml"><span class="hljs-string">kubectl</span> <span class="hljs-string">apply</span> <span class="hljs-string">-f</span> <span class="hljs-string">pod-a.yaml</span>
<span class="hljs-string">kubectl</span> <span class="hljs-string">apply</span> <span class="hljs-string">-f</span> <span class="hljs-string">pod-b.yaml</span>
<span class="hljs-string">kubectl</span> <span class="hljs-string">apply</span> <span class="hljs-string">-f</span> <span class="hljs-string">service.yaml</span>
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 쿠버네티스 클러스터에 Pod A, Pod B 및 서비스가 생성됩니다.</p>
<ol start="5">
<li>통신 테스트: 통신을 테스트하려면 Pod B에 접속하여 서비스의 DNS 이름을 사용하여 Pod A에 요청을 보낼 수 있습니다. 다음 명령어를 실행하세요:</li>
</ol>
<pre><code class="hljs language-sh">kubectl <span class="hljs-built_in">exec</span> -it pod-b -- sh
</code></pre>
<p>Pod B 쉘에 들어간 후에 curl과 같은 도구를 사용하여 Pod A에 요청을 보낼 수 있습니다. 서비스 명세서에서 다른 이름을 사용했다면 실제 서비스 이름으로 pod-service를 대체하세요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">curl pod-service
</code></pre>
<p>이 명령은 서비스로 요청을 보내어 트래픽을 로드 밸런싱하고 Pod A로 전달합니다.</p>
<p>여기까지입니다! 이제 쿠버네티스에서 서비스를 사용하여 pod 간 통신을 설정했습니다. 다양한 통신 패턴을 탐색하거나 네트워크 정책을 적용하거나 특정 요구 사항을 충족시키기 위해 추가적인 쿠버네티스 기능을 활용하여 이 예시를 확장할 수 있습니다.</p>
<h1>결론</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>마크다운 형식으로 테이블 태그를 변경하세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"쿠버네티스 Pod 간 통신 완벽 가이드 마스터하기 위한 모든 것","description":"","date":"2024-06-23 22:50","slug":"2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide","content":"\n\u003cimg src=\"/assets/img/2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide_0.png\" /\u003e\n\n# 소개\n\nKubernetes는 컨테이너 오케스트레이션을 혁신하여 기업이 규모에 맞게 응용 프로그램을 배포하고 관리할 수 있게 하였습니다. Kubernetes의 주요 구성요소 중 하나인 pod는 하나 이상의 강하게 결합된 컨테이너들의 논리적 그룹입니다. pod가 서로 통신하는 방식을 이해하는 것은 Kubernetes 클러스터에서 탄력적이고 확장 가능한 응용 프로그램을 구축하는 데 중요합니다. 이 블로그 게시물에서는 Kubernetes pod 간 통신에 대해 깊이 알아보고 다양한 통신 패턴과 기술을 탐구할 것입니다.\n\n# Pod 네트워킹 이해하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n쿠버네티스에서 Pods는 클러스터 내에서 고유한 IP 주소가 할당되어 직접 통신할 수 있습니다. 기본적으로 각 Pod는 격리되어 고유한 IP 주소를 가지며, 안전한 통신을 가능하게 하고 포트 충돌을 피할 수 있습니다. 이러한 IP 주소는 외부 액세스를 위해 특정 구성이 없는 한 쿠버네티스 클러스터 네트워크 내에서만 접근 가능합니다.\n\n# 쿠버네티스 네트워킹 모델\n\n- 동일 노드 내 Pod 간 통신: 동일한 노드에 여러 개의 Pod가 예약되면 localhost 또는 루프백 인터페이스를 사용하여 직접 통신할 수 있습니다. 이 통신은 주로 가상 이더넷(veth) 쌍 형태로 클러스터 내에 할당된 Pod의 IP 주소를 통해 이루어집니다. 이 통신은 네트워크 계층에서 발생하여 동일 노드의 Pod 간 높은 성능과 낮은 지연 시간 상호작용을 가능하게 합니다.\n- 노드 간 Pod 간 통신: 클러스터 내 서로 다른 노드 간에 통신이 필요한 경우, 쿠버네티스는 다양한 네트워킹 솔루션인 Container Network Interfaces (CNIs) 및 소프트웨어 정의 네트워킹(SDN) 기술을 활용합니다. 이러한 솔루션은 전체 클러스터를 가로지르는 가상 네트워크 오버레이를 생성하여 노드 간 Pod 간 통신을 가능하게 합니다. Calico, Flannel, Weave, Cilium 등이 인기 있는 CNIs 중 일부이며, 이러한 네트워킹 솔루션은 Pod의 IP 주소가 Reachable하도록 보장하며, 클러스터 내에서 Pod의 위치에 관계없이 투명한 네트워크 연결성을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본적으로 쿠버네티스 클러스터 내의 파드는 내부 IP 주소를 사용하여 서로 통신할 수 있습니다. 이 통신은 백그라운드의 컨테이너 런타임이나 네트워크 플러그인에서 제공하는 가상 네트워크 오버레이를 통해 이루어집니다. 내부 IP 주소는 쿠버네티스 클러스터 네트워킹 솔루션에 의해 할당되며 클러스터 내에서만 라우터링됩니다.\n\n# DNS 기반 서비스 검색\n\n쿠버네티스는 클러스터 내에서 서비스 검색을 위한 내장 DNS 서비스를 제공합니다. 서비스들은 기본 파드를 추상화한 안정적인 엔드포인트 역할을 합니다. 각 서비스는 DNS 이름이 할당되며, 해당 서비스를 지원하는 파드의 IP 주소로 해석됩니다. 이 DNS 기반 접근 방식을 통해 파드는 개별 파드 IP 주소를 직접 참조하는 대신 서비스 이름을 사용하여 서로 통신할 수 있습니다.\n\n# 서비스 로드 밸런싱\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러 개의 팟이 동일한 애플리케이션을 제공할 때, Kubernetes는 이러한 팟들 간의 트래픽을 분산하는 데 사용하는 내장된 로드 밸런싱 기능을 제공합니다. 서비스 객체를 생성하고 이를 일련의 팟과 연결함으로써, Kubernetes는 사용 가능한 팟들 사이에 들어오는 요청을 자동으로 로드 밸런싱합니다. 이 로드 밸런싱 메커니즘은 애플리케이션의 고가용성과 확장성을 보장합니다.\n\n# 네트워크 정책\n\nKubernetes는 팟 간의 트래픽 흐름을 제어하기 위한 수단으로 네트워크 정책을 제공합니다. 네트워크 정책은 IP 주소, 포트 및 프로토콜과 같은 다양한 매개변수를 기반으로 어떤 팟이 서로 통신할 수 있는지를 지정하는 규칙을 정의합니다. 네트워크 정책을 시행함으로써, 애플리케이션의 네트워크 트래픽을 세분화하고 추가적인 보안 층을 추가할 수 있습니다.\n\n# 외부 통신\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKubernetes 클러스터 바깥의 리소스와 통신해야 하는 팟이 자주 있습니다. 외부 서비스나 데이터베이스와 통신하는 방법을 용이하게 해주는 여러 메커니즘이 Kubernetes에서 제공됩니다. 한 가지 접근법은 서비스 유형이 \"LoadBalancer\" 또는 \"NodePort\"인 서비스를 사용하여 팟 또는 팟 세트를 노출하는 것으로, 외부 클라이언트가 팟에 액세스할 수 있게 합니다. 또 다른 옵션은 Ingress 컨트롤러를 사용하는 것인데, 이를 통해 외부 클러스터로부터 들어오는 트래픽을 정의된 규칙에 따라 적절한 팟으로 라우팅할 수 있습니다.\n\n# 서비스 메쉬\n\n고급 네트워킹 시나리오를 위해, 서비스 메쉬를 사용하여 팟 간 통신을 강화할 수 있습니다. Istio나 Linkerd와 같은 서비스 메쉬는 Kubernetes 클러스터 상단에 있는 레이어로써 트래픽 관리, 관찰가능성, 보안과 같은 기능을 제공합니다. 서비스 메쉬를 사용하면 고급 라우팅 규칙, 회로 차단, 분산 추적을 통해 팟 간 통신을 제어하고 모니터링할 수 있습니다.\n\n# 예시\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKubernetes에서 pod 간 통신을 구성하는 방법을 보여드리기 위해 예제 사양을 살펴보겠습니다. 이 예제에서는 서비스를 사용하여 두 개의 파드를 생성하고 그들 간의 통신을 수립할 것입니다.\n\n- Pod A 생성: 먼저 간단한 웹 애플리케이션을 실행하는 Pod A를 생성해 보겠습니다. pod-a.yaml이라는 파일을 만들고 아래 내용을 추가하세요:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-a\nspec:\n  containers:\n    - name: web-app\n      image: your-web-app-image\n      ports:\n        - containerPort: 8080\n```\n\n\"your-web-app-image\"를 사용 중인 웹 애플리케이션의 적절한 이미지로 교체해 주세요. 이 사양은 지정된 포트 8080이 노출된 상태로 \"pod-a\"라는 이름의 파드를 생성합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. Pod B를 생성하세요: 이제 Pod A와 통신하는 클라이언트 Pod인 Pod B를 생성해 봅시다. pod-b.yaml이라는 파일을 만들고 다음 내용을 추가해 주세요:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-b\nspec:\n  containers:\n    - name: client-app\n      image: your-client-app-image\n      command: [\"sleep\", \"infinity\"]\n```\n\nyour-client-app-image를 사용하고 있는 클라이언트 어플리케이션에 해당하는 이미지로 변경해 주세요. 이 명세는 \"pod-b\"라는 이름의 pod를 생성하고, 해당 컨테이너를 실행하여 pod를 계속 실행 상태로 유지할 수 있는 무한 sleep 명령을 실행합니다.\n\n3. 서비스 생성하기: Pod A와 Pod B 간의 통신을 가능하게 하기 위해 안전한 엔드포인트로 작동하는 서비스를 생성할 것입니다. service.yaml이라는 파일을 만들고 다음 내용을 추가하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: pod-service\nspec:\n  selector:\n    app: web-app\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n```\n\n이 구성은 \"pod-service\"라는 서비스를 생성하며, 이 서비스는 app: web-app 라벨을 가진 파드를 대상으로합니다 (우리가 Pod A에 추가 할 것입니다). 이 서비스는 포트 80을 노출하고 선택한 파드의 포트 8080으로 트래픽을 전달합니다.\n\n4. 설정 적용: 다음 명령을 사용하여 생성된 구성을 적용하십시오:\n\n```yaml\nkubectl apply -f pod-a.yaml\nkubectl apply -f pod-b.yaml\nkubectl apply -f service.yaml\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 쿠버네티스 클러스터에 Pod A, Pod B 및 서비스가 생성됩니다.\n\n5. 통신 테스트: 통신을 테스트하려면 Pod B에 접속하여 서비스의 DNS 이름을 사용하여 Pod A에 요청을 보낼 수 있습니다. 다음 명령어를 실행하세요:\n\n```sh\nkubectl exec -it pod-b -- sh\n```\n\nPod B 쉘에 들어간 후에 curl과 같은 도구를 사용하여 Pod A에 요청을 보낼 수 있습니다. 서비스 명세서에서 다른 이름을 사용했다면 실제 서비스 이름으로 pod-service를 대체하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ncurl pod-service\n```\n\n이 명령은 서비스로 요청을 보내어 트래픽을 로드 밸런싱하고 Pod A로 전달합니다.\n\n여기까지입니다! 이제 쿠버네티스에서 서비스를 사용하여 pod 간 통신을 설정했습니다. 다양한 통신 패턴을 탐색하거나 네트워크 정책을 적용하거나 특정 요구 사항을 충족시키기 위해 추가적인 쿠버네티스 기능을 활용하여 이 예시를 확장할 수 있습니다.\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마크다운 형식으로 테이블 태그를 변경하세요.\n","ogImage":{"url":"/assets/img/2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide_0.png\"\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003eKubernetes는 컨테이너 오케스트레이션을 혁신하여 기업이 규모에 맞게 응용 프로그램을 배포하고 관리할 수 있게 하였습니다. Kubernetes의 주요 구성요소 중 하나인 pod는 하나 이상의 강하게 결합된 컨테이너들의 논리적 그룹입니다. pod가 서로 통신하는 방식을 이해하는 것은 Kubernetes 클러스터에서 탄력적이고 확장 가능한 응용 프로그램을 구축하는 데 중요합니다. 이 블로그 게시물에서는 Kubernetes pod 간 통신에 대해 깊이 알아보고 다양한 통신 패턴과 기술을 탐구할 것입니다.\u003c/p\u003e\n\u003ch1\u003ePod 네트워킹 이해하기\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e쿠버네티스에서 Pods는 클러스터 내에서 고유한 IP 주소가 할당되어 직접 통신할 수 있습니다. 기본적으로 각 Pod는 격리되어 고유한 IP 주소를 가지며, 안전한 통신을 가능하게 하고 포트 충돌을 피할 수 있습니다. 이러한 IP 주소는 외부 액세스를 위해 특정 구성이 없는 한 쿠버네티스 클러스터 네트워크 내에서만 접근 가능합니다.\u003c/p\u003e\n\u003ch1\u003e쿠버네티스 네트워킹 모델\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e동일 노드 내 Pod 간 통신: 동일한 노드에 여러 개의 Pod가 예약되면 localhost 또는 루프백 인터페이스를 사용하여 직접 통신할 수 있습니다. 이 통신은 주로 가상 이더넷(veth) 쌍 형태로 클러스터 내에 할당된 Pod의 IP 주소를 통해 이루어집니다. 이 통신은 네트워크 계층에서 발생하여 동일 노드의 Pod 간 높은 성능과 낮은 지연 시간 상호작용을 가능하게 합니다.\u003c/li\u003e\n\u003cli\u003e노드 간 Pod 간 통신: 클러스터 내 서로 다른 노드 간에 통신이 필요한 경우, 쿠버네티스는 다양한 네트워킹 솔루션인 Container Network Interfaces (CNIs) 및 소프트웨어 정의 네트워킹(SDN) 기술을 활용합니다. 이러한 솔루션은 전체 클러스터를 가로지르는 가상 네트워크 오버레이를 생성하여 노드 간 Pod 간 통신을 가능하게 합니다. Calico, Flannel, Weave, Cilium 등이 인기 있는 CNIs 중 일부이며, 이러한 네트워킹 솔루션은 Pod의 IP 주소가 Reachable하도록 보장하며, 클러스터 내에서 Pod의 위치에 관계없이 투명한 네트워크 연결성을 제공합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e기본적으로 쿠버네티스 클러스터 내의 파드는 내부 IP 주소를 사용하여 서로 통신할 수 있습니다. 이 통신은 백그라운드의 컨테이너 런타임이나 네트워크 플러그인에서 제공하는 가상 네트워크 오버레이를 통해 이루어집니다. 내부 IP 주소는 쿠버네티스 클러스터 네트워킹 솔루션에 의해 할당되며 클러스터 내에서만 라우터링됩니다.\u003c/p\u003e\n\u003ch1\u003eDNS 기반 서비스 검색\u003c/h1\u003e\n\u003cp\u003e쿠버네티스는 클러스터 내에서 서비스 검색을 위한 내장 DNS 서비스를 제공합니다. 서비스들은 기본 파드를 추상화한 안정적인 엔드포인트 역할을 합니다. 각 서비스는 DNS 이름이 할당되며, 해당 서비스를 지원하는 파드의 IP 주소로 해석됩니다. 이 DNS 기반 접근 방식을 통해 파드는 개별 파드 IP 주소를 직접 참조하는 대신 서비스 이름을 사용하여 서로 통신할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e서비스 로드 밸런싱\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e여러 개의 팟이 동일한 애플리케이션을 제공할 때, Kubernetes는 이러한 팟들 간의 트래픽을 분산하는 데 사용하는 내장된 로드 밸런싱 기능을 제공합니다. 서비스 객체를 생성하고 이를 일련의 팟과 연결함으로써, Kubernetes는 사용 가능한 팟들 사이에 들어오는 요청을 자동으로 로드 밸런싱합니다. 이 로드 밸런싱 메커니즘은 애플리케이션의 고가용성과 확장성을 보장합니다.\u003c/p\u003e\n\u003ch1\u003e네트워크 정책\u003c/h1\u003e\n\u003cp\u003eKubernetes는 팟 간의 트래픽 흐름을 제어하기 위한 수단으로 네트워크 정책을 제공합니다. 네트워크 정책은 IP 주소, 포트 및 프로토콜과 같은 다양한 매개변수를 기반으로 어떤 팟이 서로 통신할 수 있는지를 지정하는 규칙을 정의합니다. 네트워크 정책을 시행함으로써, 애플리케이션의 네트워크 트래픽을 세분화하고 추가적인 보안 층을 추가할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e외부 통신\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eKubernetes 클러스터 바깥의 리소스와 통신해야 하는 팟이 자주 있습니다. 외부 서비스나 데이터베이스와 통신하는 방법을 용이하게 해주는 여러 메커니즘이 Kubernetes에서 제공됩니다. 한 가지 접근법은 서비스 유형이 \"LoadBalancer\" 또는 \"NodePort\"인 서비스를 사용하여 팟 또는 팟 세트를 노출하는 것으로, 외부 클라이언트가 팟에 액세스할 수 있게 합니다. 또 다른 옵션은 Ingress 컨트롤러를 사용하는 것인데, 이를 통해 외부 클러스터로부터 들어오는 트래픽을 정의된 규칙에 따라 적절한 팟으로 라우팅할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e서비스 메쉬\u003c/h1\u003e\n\u003cp\u003e고급 네트워킹 시나리오를 위해, 서비스 메쉬를 사용하여 팟 간 통신을 강화할 수 있습니다. Istio나 Linkerd와 같은 서비스 메쉬는 Kubernetes 클러스터 상단에 있는 레이어로써 트래픽 관리, 관찰가능성, 보안과 같은 기능을 제공합니다. 서비스 메쉬를 사용하면 고급 라우팅 규칙, 회로 차단, 분산 추적을 통해 팟 간 통신을 제어하고 모니터링할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e예시\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eKubernetes에서 pod 간 통신을 구성하는 방법을 보여드리기 위해 예제 사양을 살펴보겠습니다. 이 예제에서는 서비스를 사용하여 두 개의 파드를 생성하고 그들 간의 통신을 수립할 것입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePod A 생성: 먼저 간단한 웹 애플리케이션을 실행하는 Pod A를 생성해 보겠습니다. pod-a.yaml이라는 파일을 만들고 아래 내용을 추가하세요:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-attr\"\u003eapiVersion:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ev1\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003ekind:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ePod\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003emetadata:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003epod-a\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003espec:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003econtainers:\u003c/span\u003e\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eweb-app\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eimage:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eyour-web-app-image\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eports:\u003c/span\u003e\n        \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003econtainerPort:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\"your-web-app-image\"를 사용 중인 웹 애플리케이션의 적절한 이미지로 교체해 주세요. 이 사양은 지정된 포트 8080이 노출된 상태로 \"pod-a\"라는 이름의 파드를 생성합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003ePod B를 생성하세요: 이제 Pod A와 통신하는 클라이언트 Pod인 Pod B를 생성해 봅시다. pod-b.yaml이라는 파일을 만들고 다음 내용을 추가해 주세요:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-attr\"\u003eapiVersion:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ev1\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003ekind:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ePod\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003emetadata:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003epod-b\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003espec:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003econtainers:\u003c/span\u003e\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eclient-app\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eimage:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eyour-client-app-image\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ecommand:\u003c/span\u003e [\u003cspan class=\"hljs-string\"\u003e\"sleep\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"infinity\"\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eyour-client-app-image를 사용하고 있는 클라이언트 어플리케이션에 해당하는 이미지로 변경해 주세요. 이 명세는 \"pod-b\"라는 이름의 pod를 생성하고, 해당 컨테이너를 실행하여 pod를 계속 실행 상태로 유지할 수 있는 무한 sleep 명령을 실행합니다.\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e서비스 생성하기: Pod A와 Pod B 간의 통신을 가능하게 하기 위해 안전한 엔드포인트로 작동하는 서비스를 생성할 것입니다. service.yaml이라는 파일을 만들고 다음 내용을 추가하세요:\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-attr\"\u003eapiVersion:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ev1\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003ekind:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eService\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003emetadata:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003epod-service\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003espec:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eselector:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eapp:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eweb-app\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eports:\u003c/span\u003e\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eprotocol:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eTCP\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eport:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003etargetPort:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 구성은 \"pod-service\"라는 서비스를 생성하며, 이 서비스는 app: web-app 라벨을 가진 파드를 대상으로합니다 (우리가 Pod A에 추가 할 것입니다). 이 서비스는 포트 80을 노출하고 선택한 파드의 포트 8080으로 트래픽을 전달합니다.\u003c/p\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e설정 적용: 다음 명령을 사용하여 생성된 구성을 적용하십시오:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-string\"\u003ekubectl\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eapply\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e-f\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003epod-a.yaml\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003ekubectl\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eapply\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e-f\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003epod-b.yaml\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003ekubectl\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eapply\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e-f\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eservice.yaml\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 쿠버네티스 클러스터에 Pod A, Pod B 및 서비스가 생성됩니다.\u003c/p\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e통신 테스트: 통신을 테스트하려면 Pod B에 접속하여 서비스의 DNS 이름을 사용하여 Pod A에 요청을 보낼 수 있습니다. 다음 명령어를 실행하세요:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sh\"\u003ekubectl \u003cspan class=\"hljs-built_in\"\u003eexec\u003c/span\u003e -it pod-b -- sh\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePod B 쉘에 들어간 후에 curl과 같은 도구를 사용하여 Pod A에 요청을 보낼 수 있습니다. 서비스 명세서에서 다른 이름을 사용했다면 실제 서비스 이름으로 pod-service를 대체하세요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecurl pod-service\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 명령은 서비스로 요청을 보내어 트래픽을 로드 밸런싱하고 Pod A로 전달합니다.\u003c/p\u003e\n\u003cp\u003e여기까지입니다! 이제 쿠버네티스에서 서비스를 사용하여 pod 간 통신을 설정했습니다. 다양한 통신 패턴을 탐색하거나 네트워크 정책을 적용하거나 특정 요구 사항을 충족시키기 위해 추가적인 쿠버네티스 기능을 활용하여 이 예시를 확장할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e마크다운 형식으로 테이블 태그를 변경하세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide"},"buildId":"wOkGEDZCvEs3S_XaNsdwr","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>