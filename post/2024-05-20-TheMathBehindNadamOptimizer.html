<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>나담 옵티마이저 뒤의 수학 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-20-TheMathBehindNadamOptimizer" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="나담 옵티마이저 뒤의 수학 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="나담 옵티마이저 뒤의 수학 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-20-TheMathBehindNadamOptimizer_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-20-TheMathBehindNadamOptimizer" data-gatsby-head="true"/><meta name="twitter:title" content="나담 옵티마이저 뒤의 수학 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-20-TheMathBehindNadamOptimizer_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-20 20:12" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/RZIEBQ2aNAp_DXFVTV6eL/_buildManifest.js" defer=""></script><script src="/_next/static/RZIEBQ2aNAp_DXFVTV6eL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">나담 옵티마이저 뒤의 수학</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="나담 옵티마이저 뒤의 수학" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 20, 2024</span><span class="posts_reading_time__f7YPP">22<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-20-TheMathBehindNadamOptimizer&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-20-TheMathBehindNadamOptimizer_0.png" alt="이미지"></p>
<p>이전에 우리가 Adam 옵티마이저에 대해 이야기했을 때, Adam이 적응적 학습률을 효과적으로 다루면서 기계 학습에서 최적화 지형을 변화시켰다는 것을 탐구했습니다. 다양한 기계 학습 대회에서 특히 Kaggle과 같은 플랫폼에서의 성공으로 알려진 Adam은 확실히 최적화 기술에 높은 기준을 설정했습니다. 그러나 최적화 알고리즘의 진화는 거기서 멈추지 않았습니다. 여기 나담(Nadam)이 나옵니다 — Nesterov-accelerated Adaptive Moment Estimation의 약자인 Adam의 고급 후속 버전입니다.</p>
<p>이 문서를 이해하기 위해 이전에 Adam에 대한 나의 기사를 읽을 필요는 없지만, 관심이 있다면 다음 링크에서 확인할 수 있습니다:</p>
<p>Nadam은 나스테로프 모멘텀을 통합하여 Adam 옵티마이저를 개선하며, 기울기 업데이트에 선행(lookahead) 능력을 도입합니다. 이 조정은 수렴 과정을 가속화할 뿐만 아니라 손실 함수를 최소화하기 위한 단계의 정확도도 향상시킵니다.</p>
<p>Nadam을 Adam보다 선택해야 하는 이유는 무엇일까요? 이 기사는 Nadam의 메커니즘을 분석하고 Adam과 비교하며 실제 적용에서의 통찰을 제공하여 이 질문에 대답합니다. 우리는 이를 지원하는 수학적 내용을 알아볼 것이며, Python에서 최적화 도구를 처음부터 구축하여 그것이 어떻게 실행되는지 살펴볼 것입니다. 이 기사를 마치면 기계 학습 프로젝트에 Nadam이 좋은 선택일 수 있는 시기와 이유를 명확히 이해하게 되어, 당신이 필요로 하는 최적화 도구에 대해 정보를 잘 얻을 수 있게 해줄 것입니다.</p>
<h2>목차</h2>
<p>1: Nadam: 개념 및 기원
∘ 1.1: Nadam이란 무엇인가?
∘ 1.2: Nadam이 Adam을 기반으로하는 방식</p>
<p>2: Nadam 뒤에 숨은 메커니즘
∘ 2.1: 초기화
∘ 2.2: 각 타임 스텝(𝑡)에 대한 반복적인 업데이트
∘ 2.3: 네스테로프 모멘텀 보정
∘ 2.4: 편향 보정
∘ 2.5: 매개변수 업데이트
∘ 2.6: Adam과의 주요 차이점</p>
<ol start="3">
<li>실무에서 Nadam 구현하기</li>
</ol>
<ul>
<li>3.1: Nadam Optimizer 클래스 정의</li>
<li>3.2: 선형 회귀 모델 클래스</li>
<li>3.3: 모델 트레이너 클래스</li>
<li>3.4: 데이터셋 처리 및 모델 훈련</li>
</ul>
<ol start="4">
<li>장점과 고려사항</li>
</ol>
<ul>
<li>4.1 Nadam의 우수성</li>
<li>4.2 한계와 도전 과제</li>
</ul>
<p>결론</p>
<p>참고문헌</p>
<h1>1: 나담: 개념과 기원</h1>
<h2>1.1: 나담이란?</h2>
<p>나담은 뉴럴 네트워크를 최적화하기 위해 기계 학습에서 널리 사용되는 아담 옵티마이저를 개선한 것입니다. 이는 아담의 적응 학습률 기능과 네스테로프 모멘텀의 예측 능력을 통합하였습니다.</p>
<p>이 개선은 모델이 수렴하는 속도를 높일뿐만 아니라 복잡한 최적화 과제를 효과적으로 해결하는 방법을 제공합니다.</p>
<p>나담(Nadam) 뒤에 있는 아이디어는 1980년대 유리 네스테로프(Yuri Nesterov)의 선도적인 작업으로 거슬러 올라갈 수 있습니다. 그 당시 네스테로프는 네스테로프의 가속 그래디언트(Nesterov’s accelerated gradient, NAG)를 소개했습니다. NAG의 목표는 기울기 중심의 최적화 알고리즘의 수렴을 가속화하여 기울기의 경로를 가장 낮은 점으로 더 잘 지시하는 것이었습니다. 이 전략을 아담(Adam)의 적응형 학습률 조정과 결합하여, 나담은 이러한 기본 개념을 향상시켜 최적화 알고리즘의 능력을 크게 향상시킵니다.</p>
<h2>1.2: 나담(Nadam)이 아담(Adam)을 바탕으로 어떻게 구축되는가</h2>
<p>나담은 아담이 설정한 프레임워크를 바탕으로 업데이트가 어떻게 계산되는지를 조정함으로써 구축됩니다. 아담이 과거 제곱 기울기와 과거 기울기의 지수 이동 평균을 사용하는 반면, 나담은 기울기 업데이트 규칙을 수정합니다. 나담은 누적된 기울기 방향으로 적극적으로 전진하며, 미래 기울기를 예측하는 종류의 "모멘텀"(momentum)을 활용합니다.</p>
<p>이를 더 잘 이해하기 위해 최적화 경로를 보는 것을 상상해보세요. 위의 이미지는 나담과 아담이 최적화 랜드스케이프를 통해 어떻게 이동하는지 개념적으로 보여줍니다.</p>
<p><img src="/assets/img/2024-05-20-TheMathBehindNadamOptimizer_1.png" alt="TheMathBehindNadamOptimizer"></p>
<p>이 그림에서 두 옵티마이저는 동일한 지점에서 시작합니다. "Adam"은 효율적인 수렴과 적응력을 나타내는 평탄하고 잘 포장된 고속도로 위에 있습니다. "Nadam"은 가끔 충격이 있는 약간 더 구불구불한 도로 위에 있으며 종종 최소값 지점을 향해 더 날카로운 회전을 하곤 합니다. 이러한 행동은 예상 업데이트에 의해 주도되며 Adam보다 덜 최적의 경로를 더 효과적으로 피할 모멘텀을 제공합니다. 이 능력은 Nadam이 Adam과 Nesterov 모멘텀의 강점을 결합하여 복잡한 손실 함수 랜드스케이프에 특히 적합한 강력한 옵티마이저를 형성한다는 것을 보여줍니다.</p>
<h2>2: Nadam의 작동 메커니즘</h2>
<p>Nadam은 Adam 옵티마이저의 메커니즘을 Nesterov 모멘텀과 똑똑하게 결합하여 학습을 최적화합니다. 주요 방정식을 살펴보고 Adam과 비교하여 업데이트 규칙의 차이점을 강조해보겠습니다.</p>
<h2>2.1: 초기화</h2>
<p>시작할 때, Nadam은 첫 번째 및 두 번째 모멘트 벡터를 초기화합니다. 이 벡터들은 기울기와 제곱 기울기의 이동 평균을 저장하는 데 중요합니다. 시간이 지남에 따라 매개 변수 업데이트를 부드럽게 합니다.</p>
<p><img src="/assets/img/2024-05-20-TheMathBehindNadamOptimizer_2.png" alt="그림"></p>
<p>동시에 우리는 반복의 시작을 표시하는 초기 타임스텝을 설정합니다.</p>
<h2>2.2: 각 타임 스텝(𝑡)별 반복적 업데이트</h2>
<p>각 반복(𝑡)에 대해, 해당 시점의 매개변수에 대한 손실 함수의 기울기(𝑔_𝑡)를 계산하는 것으로 시작합니다. 이 기울기는 함수의 손실이 가장 빠르게 증가하는 방향을 가리킵니다.</p>
<p>편향된 첫 번째 모멘트 추정값 업데이트</p>
<p><img src="/assets/img/2024-05-20-TheMathBehindNadamOptimizer_4.png" alt="매쓰사인네처날날담옵티마이저 그림 4"></p>
<p>첫 번째 모멘트(𝑚_𝑡)는 과거 그래디언트의 지수적 평균이며, 이는 감쇠율(β1, 일반적으로 0.9 주변)을 사용하여 업데이트됩니다. 이 비율은 과거 그래디언트 정보 대비 새 데이터 유지 비율에 영향을 미치며, 더 높은 β1은 더 부드럽지만 더 반응이 느린 추정치로 이어집니다.</p>
<p>편향된 두 번째 모멘트 추정 업데이트</p>
<p><img src="/assets/img/2024-05-20-TheMathBehindNadamOptimizer_5.png" alt="매쓰사인네처날날담옵티마이저 그림 5"></p>
<p>비슷하게, 두 번째 모멘트 (𝑣_𝑡)은 이전 그래디언트의 제곱의 지수 가중 평균을 추적합니다. 여기서 감쇠율 (β2, 일반적으로 약 0.999)은 매개변수 업데이트의 변동성에 따라 학습률을 조정하여 업데이트를 안정화하는 데 도움을 줍니다.</p>
<h2>2.3: 네스테로프 모멘텀 보정</h2>
<p><img src="/assets/img/2024-05-20-TheMathBehindNadamOptimizer_6.png" alt="이미지"></p>
<p>여기서 Nadam은 일반적인 모멘트 계산을 수정하여 네스테로프 모멘텀을 통합합니다. 이 접근 방식은 그래디언트의 미래 위치를 예상하여 업데이트 방향을 보정합니다. 이러한 선행은 초기에 제로 초기화된 모멘트가 편향된 업데이트를 초래할 수 있는 훈련 초기에 특히 유용합니다.</p>
<h2>2.4: 편향 보정</h2>
<p>첫 번째 및 두 번째 모멘트 추정치의 편향을 보정하세요:</p>
<p><img src="/assets/img/2024-05-20-TheMathBehindNadamOptimizer_7.png" alt="Image"></p>
<p>첫 번째와 두 번째 모멘트는 처음에는 영에서 시작하기 때문에 편향되어 있습니다. 이를 극복하기 위해 편향 보정 용어가 도입되었으며, 더 많은 반복이 완료됨에 따라 모멘트의 추정치를 점진적으로 확대하여, 추정치가 시간이 지남에 따라 보다 정확하고 진짜 기울기 정보를 반영하도록 보장합니다.</p>
<h2>2.5: 매개변수 업데이트</h2>
<p><img src="/assets/img/2024-05-20-TheMathBehindNadamOptimizer_8.png" alt="Image"></p>
<p>최종 매개변수 업데이트는 기울기의 방향에 대해 조정된 적응형 학습률(𝛼)과 작은 상수(𝜖, 10^(-8)과 같은)로 수치적 안정성을 위해 이루어집니다. 수정된 첫 번째 모멘트(𝑚_𝑡)와 수정된 두 번째 모멘트의 제곱근(𝑣_𝑡)은 이러한 업데이트를 적절하게 조정하는 데 사용되며, 기울기의 방향과 크기를 모두 고려합니다.</p>
<h2>2.6: Adam과의 주요 차이점</h2>
<p>Nadam과 Adam 사이의 주요 차이점은 Nadam이 적극적으로 조정을 합니다. Adam은 현재 기울기 추정만을 의존하는 반면, Nadam은 Nesterov 모멘텀을 통해 앞서 보는 단계를 도입합니다. 이로 인해 미래의 기울기 방향을 예측뿐만 아니라 업데이트를 더 정확하게 조정하여 더 효율적인 학습 역학을 이끌어냅니다.</p>
<p>Nadam은 Nesterov 모멘텀의 통합을 통해 최적화에 대해 보다 섬세하고 선심을 기울인 접근 방식을 제공하여 Adam보다 데이터 landscape를 효과적으로 탐색하고 적응하는 능력을 향상시킵니다. 이로써 Nadam은 다양한 머신 러닝 과제에 대한 견고한 선택지가 되며, 실제 결과를 선택할 때 이론적 통찰력과 실용적 결과를 모두 고려하도록 실무자에게 요청합니다.</p>
<h2>3. 실무에서 Nadam 구현</h2>
<p>이 섹션에서는 Nadam 옵티마이저를 처음부터 구축하고 머신 러닝 환경에서 적용할 것입니다. 우리는 선형 회귀 작업에 Nadam 옵티마이저를 구현하고 사용하는 맥락에서 코드를 여러 주요 섹션으로 분할할 것입니다.</p>
<p>아래의 코드를 살펴보고 싶다면, 오늘 다룰 코드와 추가적인 보너스 콘텐츠가 모두 포함된 이 Jupyter 노트북을 살펴보는 것을 고려해보세요:</p>
<h2>3.1: Nadam Optimizer Class Definition</h2>
<p>Nadam 알고리즘을 사용하여 매개변수를 최적화하는 데 중요한 역할을 하는 NadamOptimizer 클래스를 자세히 살펴봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NadamOptimizer</span>:
    def <span class="hljs-title function_">__init__</span>(self, learning_rate=<span class="hljs-number">0.001</span>, beta1=<span class="hljs-number">0.9</span>, beta2=<span class="hljs-number">0.999</span>, epsilon=<span class="hljs-number">1e-8</span>):
        self.<span class="hljs-property">learning_rate</span> = learning_rate
        self.<span class="hljs-property">beta1</span> = beta1
        self.<span class="hljs-property">beta2</span> = beta2
        self.<span class="hljs-property">epsilon</span> = epsilon
        self.<span class="hljs-property">m</span> = <span class="hljs-title class_">None</span>
        self.<span class="hljs-property">v</span> = <span class="hljs-title class_">None</span>
        self.<span class="hljs-property">t</span> = <span class="hljs-number">0</span>

    def <span class="hljs-title function_">initialize_moments</span>(self, params):
        self.<span class="hljs-property">m</span> = {<span class="hljs-attr">k</span>: np.<span class="hljs-title function_">zeros_like</span>(v) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> params.<span class="hljs-title function_">items</span>()}
        self.<span class="hljs-property">v</span> = {<span class="hljs-attr">k</span>: np.<span class="hljs-title function_">zeros_like</span>(v) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> params.<span class="hljs-title function_">items</span>()}

    def <span class="hljs-title function_">update_params</span>(self, params, grads):
        <span class="hljs-keyword">if</span> self.<span class="hljs-property">m</span> is <span class="hljs-title class_">None</span> or self.<span class="hljs-property">v</span> is <span class="hljs-title class_">None</span>:
            self.<span class="hljs-title function_">initialize_moments</span>(params)

        self.<span class="hljs-property">t</span> += <span class="hljs-number">1</span>
        updated_params = {}
        mu_t = self.<span class="hljs-property">beta1</span> * (<span class="hljs-number">1</span> - <span class="hljs-number">0.5</span> * <span class="hljs-number">0.96</span> ** (self.<span class="hljs-property">t</span> * <span class="hljs-number">0.004</span>))
        mu_t1 = self.<span class="hljs-property">beta1</span> * (<span class="hljs-number">1</span> - <span class="hljs-number">0.5</span> * <span class="hljs-number">0.96</span> ** ((self.<span class="hljs-property">t</span> + <span class="hljs-number">1</span>) * <span class="hljs-number">0.004</span>))
        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> params.<span class="hljs-title function_">keys</span>():
            g_tilde = grads[key] / (<span class="hljs-number">1</span> - np.<span class="hljs-title function_">prod</span>([self.<span class="hljs-property">beta1</span>] * self.<span class="hljs-property">t</span>))
            self.<span class="hljs-property">m</span>[key] = self.<span class="hljs-property">beta1</span> * self.<span class="hljs-property">m</span>[key] + (<span class="hljs-number">1</span> - self.<span class="hljs-property">beta1</span>) * grads[key]
            self.<span class="hljs-property">v</span>[key] = self.<span class="hljs-property">beta2</span> * self.<span class="hljs-property">v</span>[key] + (<span class="hljs-number">1</span> - self.<span class="hljs-property">beta2</span>) * np.<span class="hljs-title function_">square</span>(grads[key])

            m_corrected = self.<span class="hljs-property">m</span>[key] / (<span class="hljs-number">1</span> - mu_t1 ** self.<span class="hljs-property">t</span>)
            v_corrected = self.<span class="hljs-property">v</span>[key] / (<span class="hljs-number">1</span> - self.<span class="hljs-property">beta2</span> ** self.<span class="hljs-property">t</span>)

            m_bar = (<span class="hljs-number">1</span> - mu_t) * g_tilde + mu_t1 * m_corrected

            updated_params[key] = params[key] - self.<span class="hljs-property">learning_rate</span> * m_bar / (np.<span class="hljs-title function_">sqrt</span>(v_corrected) + self.<span class="hljs-property">epsilon</span>)

        <span class="hljs-keyword">return</span> updated_params
</code></pre>
<p>NadamOptimizer 클래스는 Nadam 최적화 방법을 관리하고 실행하기 위해 구조화되어 있습니다. 아래는 클래스와 해당 함수들을 설명한 것입니다:</p>
<p><strong>init</strong> 메서드</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NadamOptimizer</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, learning_rate=<span class="hljs-number">0.001</span>, beta1=<span class="hljs-number">0.9</span>, beta2=<span class="hljs-number">0.999</span>, epsilon=<span class="hljs-number">1e-8</span></span>):
        self.learning_rate = learning_rate
        self.beta1 = beta1
        self.beta2 = beta2
        self.epsilon = epsilon
        self.m = <span class="hljs-literal">None</span>
        self.v = <span class="hljs-literal">None</span>
        self.t = <span class="hljs-number">0</span>
</code></pre>
<p>초기화 메서드는 최적화기를 학습률, 베타 값, 그리고 엡실론에 대한 미리 정의된 설정으로 설정합니다. 이러한 매개변수 각각은 중요한 역할을 합니다:</p>
<ul>
<li>학습률: 이는 손실 함수의 최소값으로 이동하는 각 반복에서의 단계 크기를 결정합니다.</li>
<li>beta1 및 beta2: 이러한 매개 변수는 기울기와 해당 제곱값의 이동 평균의 감쇠율을 제어하며 업데이트를 부드럽게 만들고 학습률을 동적으로 관리하는 데 도움이 됩니다.</li>
<li>epsilon: 계산 중에 0으로 나누는 것을 방지하기 위한 매우 작은 수입니다.</li>
<li>self.m 및 self.v: 초기에 None으로 설정되며 나중에는 각각 기울기와 제곱 기울기의 이동 평균을 저장합니다.</li>
<li>self.t: 업데이트 또는 반복 횟수를 추적하는 카운터입니다.</li>
</ul>
<p>이 설정은 Nadam의 기본 측면과 일치하며, 적응형 학습률이 지속적으로 조정되어 수렴을 개선합니다.</p>
<p>initialize_moments 메서드</p>
<pre><code class="hljs language-js">    def <span class="hljs-title function_">initialize_moments</span>(self, params):
        self.<span class="hljs-property">m</span> = {<span class="hljs-attr">k</span>: np.<span class="hljs-title function_">zeros_like</span>(v) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> params.<span class="hljs-title function_">items</span>()}
        self.<span class="hljs-property">v</span> = {<span class="hljs-attr">k</span>: np.<span class="hljs-title function_">zeros_like</span>(v) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> params.<span class="hljs-title function_">items</span>()}
</code></pre>
<p>이 메소드는 이동 평균을 저장하는 딕셔너리 m과 v를 초기화합니다. 각 매개변수의 기울기와 제곱 기울기가 0으로 초기화되는데, 이는 최적화 프로세스의 후속 단계에서 계산을 시작하는 데 중요합니다.</p>
<p>update_params 메소드</p>
<pre><code class="hljs language-js">    def <span class="hljs-title function_">update_params</span>(self, params, grads):
        <span class="hljs-keyword">if</span> self.<span class="hljs-property">m</span> is <span class="hljs-title class_">None</span> or self.<span class="hljs-property">v</span> is <span class="hljs-title class_">None</span>:
            self.<span class="hljs-title function_">initialize_moments</span>(params)

        self.<span class="hljs-property">t</span> += <span class="hljs-number">1</span>
        updated_params = {}
        mu_t = self.<span class="hljs-property">beta1</span> * (<span class="hljs-number">1</span> - <span class="hljs-number">0.5</span> * <span class="hljs-number">0.96</span> ** (self.<span class="hljs-property">t</span> * <span class="hljs-number">0.004</span>))
        mu_t1 = self.<span class="hljs-property">beta1</span> * (<span class="hljs-number">1</span> - <span class="hljs-number">0.5</span> * <span class="hljs-number">0.96</span> ** ((self.<span class="hljs-property">t</span> + <span class="hljs-number">1</span>) * <span class="hljs-number">0.004</span>))
        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> params.<span class="hljs-title function_">keys</span>():
            g_tilde = grads[key] / (<span class="hljs-number">1</span> - np.<span class="hljs-title function_">prod</span>([self.<span class="hljs-property">beta1</span>] * self.<span class="hljs-property">t</span>))
            self.<span class="hljs-property">m</span>[key] = self.<span class="hljs-property">beta1</span> * self.<span class="hljs-property">m</span>[key] + (<span class="hljs-number">1</span> - self.<span class="hljs-property">beta1</span>) * grads[key]
            self.<span class="hljs-property">v</span>[key] = self.<span class="hljs-property">beta2</span> * self.<span class="hljs-property">v</span>[key] + (<span class="hljs-number">1</span> - self.<span class="hljs-property">beta2</span>) * np.<span class="hljs-title function_">square</span>(grads[key])

            m_corrected = self.<span class="hljs-property">m</span>[key] / (<span class="hljs-number">1</span> - mu_t1 ** self.<span class="hljs-property">t</span>)
            v_corrected = self.<span class="hljs-property">v</span>[key] / (<span class="hljs-number">1</span> - self.<span class="hljs-property">beta2</span> ** self.<span class="hljs-property">t</span>)

            m_bar = (<span class="hljs-number">1</span> - mu_t) * g_tilde + mu_t1 * m_corrected

            updated_params[key] = params[key] - self.<span class="hljs-property">learning_rate</span> * m_bar / (np.<span class="hljs-title function_">sqrt</span>(v_corrected) + self.<span class="hljs-property">epsilon</span>)

        <span class="hljs-keyword">return</span> updated_params
</code></pre>
<p>이 함수는 Nadam 옵티마이저의 핵심입니다. 전달된 기울기를 기반으로 매개변수를 업데이트합니다. 포함된 단계는 다음과 같습니다:</p>
<p>순간 초기화 확인</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> self.<span class="hljs-property">m</span>이 <span class="hljs-title class_">None</span>이거나 self.<span class="hljs-property">v</span>가 <span class="hljs-title class_">None</span>이면:
            self.<span class="hljs-title function_">initialize_moments</span>(params)
</code></pre>
<p>만약 m 또는 v가 초기화되지 않았다면 0으로 설정됩니다.</p>
<p>시간 단계 업데이트</p>
<pre><code class="hljs language-js">셀프.티 += <span class="hljs-number">1</span>
</code></pre>
<p>decay factors를 동적으로 조절하는 시간 단계 t를 증가시킵니다.</p>
<p>네스테로프 모멘텀 조정</p>
<pre><code class="hljs language-js">뮤_티 = self.<span class="hljs-property">beta1</span> * (<span class="hljs-number">1</span> - <span class="hljs-number">0.5</span> * <span class="hljs-number">0.96</span> ** (self.티 * <span class="hljs-number">0.004</span>))
뮤_t1 = self.<span class="hljs-property">beta1</span> * (<span class="hljs-number">1</span> - <span class="hljs-number">0.5</span> * <span class="hljs-number">0.96</span> ** ((self.티 + <span class="hljs-number">1</span>) * <span class="hljs-number">0.004</span>))
</code></pre>
<p>mu_t 및 mu_t1은 시간 단계의 진행을 고려하여 Nesterov 모멘텀의 효과를 반영하기 위해 beta1을 조정합니다. 이러한 조정은 모멘텀이 미래의 기울기를 더 효과적으로 반영하도록 합니다.</p>
<p>각 매개변수를 순회하면서:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> params.<span class="hljs-title function_">keys</span>():
      g_tilde = grads[key] / (<span class="hljs-number">1</span> - np.<span class="hljs-title function_">prod</span>([self.<span class="hljs-property">beta1</span>] * self.<span class="hljs-property">t</span>))
      self.<span class="hljs-property">m</span>[key] = self.<span class="hljs-property">beta1</span> * self.<span class="hljs-property">m</span>[key] + (<span class="hljs-number">1</span> - self.<span class="hljs-property">beta1</span>) * grads[key]
      self.<span class="hljs-property">v</span>[key] = self.<span class="hljs-property">beta2</span> * self.<span class="hljs-property">v</span>[key] + (<span class="hljs-number">1</span> - self.<span class="hljs-property">beta2</span>) * np.<span class="hljs-title function_">square</span>(grads[key])

      m_corrected = self.<span class="hljs-property">m</span>[key] / (<span class="hljs-number">1</span> - mu_t1 ** self.<span class="hljs-property">t</span>)
      v_corrected = self.<span class="hljs-property">v</span>[key] / (<span class="hljs-number">1</span> - self.<span class="hljs-property">beta2</span> ** self.<span class="hljs-property">t</span>)

      m_bar = (<span class="hljs-number">1</span> - mu_t) * g_tilde + mu_t1 * m_corrected
</code></pre>
<p>g_tilde은 과거 그래디언트의 감쇠를 현재 시간 단계까지 반영한 조정된 기울기를 계산합니다. 이는 lookahead를 포함하여 그래디언트 계산을 수정하여 Nesterov 모멘텀의 효과를 나타냅니다.</p>
<p>나중에는 새로운 기울기와 조정된 베타 값에 기초하여 각 매개변수에 대해 m과 v를 조정합니다. 이 단계는 과거 기울기의 모멘텀 이점과 새로운 기울기에 대한 적응성을 결합하는 중요한 단계입니다.</p>
<p>m_corrected와 v_corrected는 편향이 수정된 제1 및 제2 모먼트의 추정치를 나타냅니다. 바이어스 보정은 계산된 기울기가 더 적을 때 교육 초기에 중요합니다.</p>
<p>m_bar는 미래의 그래디언트와 모멘텀이 보정된 그래디언트를 결합하여 매개변수 공간에서 취해야 할 단계의 방향과 크기를 효과적으로 결정합니다.</p>
<p>매개변수 업데이트</p>
<p>updated_params[key] = params[key] - self.learning_rate * m_bar / (np.sqrt(v_corrected) + self.epsilon)</p>
<p>모든 매개변수는 m_bar와 조정된 학습률에 의해 업데이트되며, v_corrected에 제곱근을 더한 것으로 스케일링됩니다. 이 단계는 실제 매개변수 업데이트가 발생하는 곳으로, 모델의 학습에 직접적인 영향을 미칩니다.</p>
<h2>3.2: 선형 회귀 모델 클래스</h2>
<p>이제 간단한 회귀 모델을 구축하고, Nadam 옵티마이저를 적용해 보겠습니다.</p>
<pre><code class="hljs language-js"># 선형 회귀 모델
<span class="hljs-keyword">class</span> <span class="hljs-title class_">LinearRegression</span>:
    def <span class="hljs-title function_">__init__</span>(self, n_features):
        self.<span class="hljs-property">weights</span> = np.<span class="hljs-property">random</span>.<span class="hljs-title function_">randn</span>(n_features)
        self.<span class="hljs-property">bias</span> = np.<span class="hljs-property">random</span>.<span class="hljs-title function_">randn</span>()

    def <span class="hljs-title function_">predict</span>(self, X):
        <span class="hljs-keyword">return</span> np.<span class="hljs-title function_">dot</span>(X, self.<span class="hljs-property">weights</span>) + self.<span class="hljs-property">bias</span>
</code></pre>
<p>여기서 <strong>init</strong> 메서드는 features 수에 기반하여 랜덤한 weights와 biases로 모델을 초기화합니다.</p>
<p>그런 다음 predict 메서드는 입력과 weights 및 bias의 내적을 사용하여 예측을 계산합니다.</p>
<p>여기서 선형 회귀는 Nadam이 어떻게 작동하는지 이해하는 간단한 방법을 제공하지만, 실제로는 더 복잡한 딥러닝 모델에서 Nadam을 사용하려고 할 것입니다. 그렇다면, 가장 인기 있는 딥러닝 모델 중 일부를 포괄적으로 이해할 수 있는 다음의 글을 살펴보고 그 코드를 수정하여 Nadam을 구현해보기를 강력히 추천합니다:```</p>
<h2>3.3: Model Trainer Class</h2>
<p>앞으로 나아가봅시다. 이제는 지정된 최적화 도구를 사용하여 머신 러닝 모델을 훈련시키는 전체 과정을 캡슐화하는 클래스가 필요합니다. 이것이 바로 ModelTrainer 클래스가 할 일입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelTrainer</span>:
    def <span class="hljs-title function_">__init__</span>(self, model, optimizer, n_epochs):
        self.<span class="hljs-property">model</span> = model
        self.<span class="hljs-property">optimizer</span> = optimizer
        self.<span class="hljs-property">n_epochs</span> = n_epochs

    def <span class="hljs-title function_">compute_gradients</span>(self, X, y):
        predictions = self.<span class="hljs-property">model</span>.<span class="hljs-title function_">predict</span>(X)
        errors = predictions - y
        dW = <span class="hljs-number">2</span> * np.<span class="hljs-title function_">dot</span>(X.<span class="hljs-property">T</span>, errors) / <span class="hljs-title function_">len</span>(y)
        db = <span class="hljs-number">2</span> * np.<span class="hljs-title function_">mean</span>(errors)
        <span class="hljs-keyword">return</span> {<span class="hljs-string">'weights'</span>: dW, <span class="hljs-string">'bias'</span>: db}

    def <span class="hljs-title function_">train</span>(self, X, y, verbose=<span class="hljs-title class_">False</span>):
        <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(self.<span class="hljs-property">n_epochs</span>):
            grads = self.<span class="hljs-title function_">compute_gradients</span>(X, y)
            params = {<span class="hljs-string">'weights'</span>: self.<span class="hljs-property">model</span>.<span class="hljs-property">weights</span>, <span class="hljs-string">'bias'</span>: self.<span class="hljs-property">model</span>.<span class="hljs-property">bias</span>}
            updated_params = self.<span class="hljs-property">optimizer</span>.<span class="hljs-title function_">update_params</span>(params, grads)

            self.<span class="hljs-property">model</span>.<span class="hljs-property">weights</span> = updated_params[<span class="hljs-string">'weights'</span>]
            self.<span class="hljs-property">model</span>.<span class="hljs-property">bias</span> = updated_params[<span class="hljs-string">'bias'</span>]

            # <span class="hljs-title class_">Optionally</span>, print loss here to observe training
            loss = np.<span class="hljs-title function_">mean</span>((self.<span class="hljs-property">model</span>.<span class="hljs-title function_">predict</span>(X) - y) ** <span class="hljs-number">2</span>)
            <span class="hljs-keyword">if</span> epoch % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span> and <span class="hljs-attr">verbose</span>:
                <span class="hljs-title function_">print</span>(f<span class="hljs-string">"Epoch {epoch}, Loss: {loss}"</span>)
</code></pre>
<p><strong>init</strong> 메서드</p>
<pre><code class="hljs language-python">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, model, optimizer, n_epochs</span>):
        self.model = model
        self.optimizer = optimizer
        self.n_epochs = n_epochs
</code></pre>
<p>이 생성자 메서드는 세 가지 주요 구성 요소로 트레이너를 초기화합니다:</p>
<ul>
<li>model: 훈련될 머신러닝 모델이며, 예측을 수행하는 메서드와 매개변수(가중치 및 편향)에 대한 속성이 있어야 합니다.</li>
<li>optimizer: Nadam과 같은 옵티마이저 클래스의 인스턴스로, 계산된 그래디언트에 기초하여 모델의 매개변수를 업데이트하는 역할을 담당합니다.</li>
<li>n_epochs: 훈련 프로세스가 실행할 훈련 데이터 세트를 전체적으로 순회하는 횟수입니다.</li>
</ul>
<p>이러한 구성 요소는 손실 함수를 최소화하기 위해 모델의 매개변수가 반복적으로 업데이트되는 훈련 프로세스를 설정하는 데 필수적입니다.</p>
<p>compute_gradients 메서드</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_gradients</span>(<span class="hljs-params">self, X, y</span>):
    predictions = self.model.predict(X)
    errors = predictions - y
    dW = <span class="hljs-number">2</span> * np.dot(X.T, errors) / <span class="hljs-built_in">len</span>(y)
    db = <span class="hljs-number">2</span> * np.mean(errors)
    <span class="hljs-keyword">return</span> {<span class="hljs-string">'weights'</span>: dW, <span class="hljs-string">'bias'</span>: db}
</code></pre>
<p>이 메서드는 모델 매개변수에 대한 손실 함수의 그래디언트를 계산합니다:</p>
<pre><code class="hljs language-python">predictions = self.model.predict(X)
</code></pre>
<p>다음은 모델이 현재 매개변수를 사용하여 입력 X를 기반으로 출력을 예측하는 부분입니다.</p>
<pre><code class="hljs language-js">오류 = 예측 - y
</code></pre>
<p>이 코드 라인은 예측된 출력과 실제 출력인 y와의 차이, 즉 오차를 나타냅니다.</p>
<pre><code class="hljs language-js">dW = <span class="hljs-number">2</span> * np.<span class="hljs-title function_">dot</span>(X.<span class="hljs-property">T</span>, 오류) / <span class="hljs-title function_">len</span>(y)
</code></pre>
<p>이것은 가중치의 기울기를 계산합니다. 가중치에 대한 평균 제곱 오차 손실 함수의 도함수는 len(y)의 데이터 포인트에 의해 조정된 표현으로 주어집니다. 이는 모든 특성과 데이터 포인트에 대한 기울기를 효율적으로 계산하는 벡터화된 구현입니다.</p>
<pre><code class="hljs language-js">db = <span class="hljs-number">2</span> * np.<span class="hljs-title function_">mean</span>(errors)
</code></pre>
<p>마찬가지로, 이는 편향의 기울기를 계산하며, 이는 단순히 오차의 평균에 2를 곱한 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">return</span> {<span class="hljs-string">'weights'</span>: dW, <span class="hljs-string">'bias'</span>: db}
</code></pre>
<p>그러면 메서드는 이러한 그래디언트를 딕셔너리로 반환하여 모델의 매개변수를 업데이트하는 데 사용할 수 있도록 합니다. 이 메서드는 옵티마이저가 손실을 최소화하기 위해 매개변수를 조정해야 하는 필수적인 기울기 계산 단계를 캡슐화합니다.</p>
<p>train 메서드</p>
<pre><code class="hljs language-python">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">self, X, y, verbose=<span class="hljs-literal">False</span></span>):
        <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.n_epochs):
            grads = self.compute_gradients(X, y)
            params = {<span class="hljs-string">'weights'</span>: self.model.weights, <span class="hljs-string">'bias'</span>: self.model.bias}
            updated_params = self.optimizer.update_params(params, grads)

            self.model.weights = updated_params[<span class="hljs-string">'weights'</span>]
            self.model.bias = updated_params[<span class="hljs-string">'bias'</span>]

            <span class="hljs-comment"># 선택사항: 여기서 손실을 출력하여 학습을 관찰합니다</span>
            loss = np.mean((self.model.predict(X) - y) ** <span class="hljs-number">2</span>)
            <span class="hljs-keyword">if</span> epoch % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> verbose:
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"Epoch <span class="hljs-subst">{epoch}</span>, Loss: <span class="hljs-subst">{loss}</span>"</span>)
</code></pre>
<p>이 메서드는 각 epoch(데이터를 완전히 통과하는 단계)마다 n_epochs에 이르기까지 반복됩니다. 루프 내에서 현재 매개변수와 데이터 집합에 대해 compute_gradients를 사용하여 그래디언트를 먼저 계산합니다.</p>
<p>그런 다음 이러한 그래디언트를 현재 매개변수와 함께 옵티마이저(self.optimizer.update_params(params, grads))에 전달하고, 옵티마이저는 최적화 알고리즘(예: Nadam)을 기반으로 업데이트된 매개변수를 반환합니다.</p>
<p>모델의 매개변수는 이러한 새 값으로 업데이트되어 손실을 최소화하는 상태로 움직이게 됩니다.</p>
<p>verbose가 True로 설정되어 있는 경우, 메서드는 1000번의 epoch마다 손실을 인쇄하여 교육 진행 상황을 모니터링합니다. 손실은 예측 값과 실제 출력 사이의 평균 제곱 오차로 계산되며, 모델의 성능을 얼마나 잘 평가하고 있는지에 대한 간단한 지표를 제공합니다.</p>
<p>train 메서드는 따라서 전체 교육 과정을 조정하며, 손실 함수의 피드백에 기초하여 옵티마이저를 통해 모델의 매개변수를 반복적으로 조정합니다. 이 메서드는 머신러닝에서 사용되는 반복적 최적화 기법의 실용적 구현이며, 그래디언트 하강과 매개변수 업데이트의 이론적 원리를 직접 적용하여 여러 번의 반복을 통해 미리 정의된 손실 함수를 최소화합니다.</p>
<h2>3.4: 데이터셋 처리 및 모델 훈련</h2>
<p>마지막으로, Nadam 옵티마이저를 사용하여 머신러닝 모델을 설정, 훈련 및 평가해 봅시다. 이 접근 방식은 데이터 조작, Optuna를 사용한 하이퍼파라미터 튜닝, 그리고 모델의 효과를 개선하고 평가하기 위한 반복적인 훈련 및 테스트를 포함합니다.</p>
<h3>3.4.1: 데이터 준비</h3>
<pre><code class="hljs language-python"><span class="hljs-comment"># 입력 피처(X) 및 타겟 값(y) 가져오기</span>
X = diabetes.data
y = diabetes.target
</code></pre>
<p>우선, 당뇨 데이터셋에서 피처 데이터(X)와 타겟값(y)을 불러옵니다. 이 데이터셋은 sci-kit learn에서 가져오며 상업적 이용이 가능합니다. (Scikit-learn: Python의 머신 러닝, Pedregosa et al., JMLR 12, pp. 2825–2830, 2011.)</p>
<pre><code class="hljs language-js"># 데이터셋을 훈련 세트와 테스트 세트로 나눕니다
def <span class="hljs-title function_">split_dataset</span>(X, y, test_ratio=<span class="hljs-number">0.2</span>):
    indices = np.<span class="hljs-property">random</span>.<span class="hljs-title function_">permutation</span>(<span class="hljs-title function_">len</span>(X))
    test_size = <span class="hljs-title function_">int</span>(<span class="hljs-title function_">len</span>(X) * test_ratio)
    test_indices = indices[:test_size]
    train_indices = indices[<span class="hljs-attr">test_size</span>:]
    <span class="hljs-keyword">return</span> X[train_indices], X[test_indices], y[train_indices], y[test_indices]

X_train, X_test, y_train, y_test = <span class="hljs-title function_">split_dataset</span>(X, y)
X_train, X_val, y_train, y_val = <span class="hljs-title function_">split_dataset</span>(X_train, y_train)
</code></pre>
<p>split_dataset 함수는 지정된 비율에 따라 데이터셋을 훈련 세트와 테스트 세트로 무작위로 분할합니다. 데이터셋 인덱스를 섞어 분할을 무작위로 다양하게 만들어 모델 평가를 견고하게 합니다. 훈련 세트는 모델 매개변수를 학습하는 데 사용되고, 테스트 세트는 모델이 보지 못한 데이터에서 얼마나 잘 수행되는지를 평가합니다.</p>
<p>3.4.2: Optuna을 이용한 하이퍼파라미터 튜닝
우리는 Optuna를 사용하여 모델의 하이퍼파라미터를 최적화할 것이며, 이는 훈련 동적과 Nadam 옵티마이저의 효과에 상당한 영향을 미칩니다.</p>
<p>다른 기사에서 우리는 옵투나(optuna)를 광범위하게 다루었습니다. 거기에서는 이를 신경망에 적용하여 성공적으로 세밀하게 조정하는 방법을 보여주었습니다. 만약 Nadam을 더 복잡한 모델에 적용하고 싶다면, 이 기사를 읽어보시면 좋을 것 같아요:</p>
<p>목적 함수 정의</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">objective</span>(<span class="hljs-params">trial</span>):
    n_features = X_train.shape[<span class="hljs-number">1</span>]

    learning_rate = trial.suggest_loguniform(<span class="hljs-string">'learning_rate'</span>, <span class="hljs-number">1e-5</span>, <span class="hljs-number">1e-1</span>)
    beta1 = trial.suggest_uniform(<span class="hljs-string">'beta1'</span>, <span class="hljs-number">0.9</span>, <span class="hljs-number">0.999</span>)
    beta2 = trial.suggest_uniform(<span class="hljs-string">'beta2'</span>, <span class="hljs-number">0.99</span>, <span class="hljs-number">0.9999</span>)
    epsilon = trial.suggest_loguniform(<span class="hljs-string">'epsilon'</span>, <span class="hljs-number">1e-10</span>, <span class="hljs-number">1e-5</span>)

    n_epochs = trial.suggest_int(<span class="hljs-string">'epochs'</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">100000</span>)

    <span class="hljs-comment"># Define the model</span>
    model = LinearRegression(n_features)
    optimizer = NadamOptimizer(learning_rate=learning_rate, beta1=beta1, beta2=beta2, epsilon=epsilon)
    trainer = ModelTrainer(model, optimizer, n_epochs=n_epochs)

    <span class="hljs-comment"># Train the model</span>
    trainer.train(X_train, y_train, verbose=<span class="hljs-literal">False</span>)

    <span class="hljs-comment"># Compute the validation loss</span>
    val_loss = np.mean((model.predict(X_val) - y_val) ** <span class="hljs-number">2</span>)

    <span class="hljs-keyword">return</span> val_loss
</code></pre>
<p>우리의 목적 함수는 옵투나(optuna)의 최적화 과정을 안내하는 중요한 역할을 합니다. 각 시도는 다음 값을 제안합니다:</p>
<ul>
<li>학습률: 매개변수 업데이트의 단계 크기에 영향을 줍니다.</li>
<li>beta1 및 beta2: 그래디언트 및 그들의 제곱값에 대한 평균의 감쇠율을 조절합니다.</li>
<li>epsilon: 업데이트 중에 0으로 나누는 것을 방지하기 위해 작은 값이 추가됩니다.</li>
</ul>
<p>각 시도는 이러한 매개변수를 사용하여 LinearRegression 모델과 NadamOptimizer를 설정하고, ModelTrainer를 사용하여 모델을 훈련합니다. 훈련 후, 검증 세트에서의 검증 손실을 계산하여 하이퍼파라미터의 효과를 Optuna에 제공합니다.</p>
<pre><code class="hljs language-js"># 연구 객체 생성
optuna.<span class="hljs-property">logging</span>.<span class="hljs-title function_">set_verbosity</span>(optuna.<span class="hljs-property">logging</span>.<span class="hljs-property">WARNING</span>)
study = optuna.<span class="hljs-title function_">create_study</span>(direction=<span class="hljs-string">'minimize'</span>, sampler=optuna.<span class="hljs-property">samplers</span>.<span class="hljs-title class_">TPESampler</span>(seed=<span class="hljs-number">42</span>))

# 연구 개선, 더 많은 시행을 사용하여 더 나은 결과를 얻거나, 더 적은 시행을 사용하여 더 비용 효율적일 수 있습니다
study.<span class="hljs-title function_">optimize</span>(objective, n_trials=<span class="hljs-number">10</span>)
</code></pre>
<p>Optuna가 최적의 매개변수를 식별한 후, 최종 모델이 구성되고 훈련됩니다. 이 단계에서는 테스트 세트에서 모델의 일반화 능력을 평가합니다.</p>
<p>훈련 및 평가</p>
<pre><code class="hljs language-js"># 최적 모델 가져오기
n_features = X_train.<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>]
best_model = <span class="hljs-title class_">LinearRegression</span>(n_features)
optimizer = <span class="hljs-title class_">NadamOptimizer</span>(learning_rate=study.<span class="hljs-property">best_params</span>[<span class="hljs-string">'learning_rate'</span>],
                          beta1=study.<span class="hljs-property">best_params</span>[<span class="hljs-string">'beta1'</span>],
                          beta2=study.<span class="hljs-property">best_params</span>[<span class="hljs-string">'beta2'</span>],
                          epsilon=study.<span class="hljs-property">best_params</span>[<span class="hljs-string">'epsilon'</span>])

# 모델 훈련하기
trainer = <span class="hljs-title class_">ModelTrainer</span>(best_model, optimizer, n_epochs=study.<span class="hljs-property">best_params</span>[<span class="hljs-string">'epochs'</span>])
trainer.<span class="hljs-title function_">train</span>(X_train, y_train)
</code></pre>
<p>Optuna의 최적 매개변수를 사용하여 모델은 추가 훈련을 받습니다. 이 추가 훈련을 통해 모델이 데이터에 완전히 적응하도록 보장합니다.</p>
<pre><code class="hljs language-js"># 테스트 손실 계산하기
test_loss = np.<span class="hljs-title function_">mean</span>((best_model.<span class="hljs-title function_">predict</span>(X_test) - y_test) ** <span class="hljs-number">2</span>)**<span class="hljs-number">0.5</span>
<span class="hljs-title function_">print</span>(f<span class="hljs-string">'테스트 손실: {test_loss:.2f}'</span>)
</code></pre>
<p>마침내, 새로운, 보지 못했던 데이터에 대한 모델의 예측 정확도를 평가하기 위해 시험 손실을 계산합니다. 이 측정값은 모델의 실용적 성능을 평가하는 데 중요합니다.</p>
<h1>4. 장점과 고려 사항</h1>
<h2>4.1 Nadam이 뛰어난 점</h2>
<p>Nadam은 Adam을 바탕으로 네스테로프 모멘텀을 통합하여, 그레이디언트가 믿을 수 없거나 에포크 간 크게 다를 수 있는 복잡한 최적화 작업을 처리할 수 있는 능력을 향상시킵니다. 여기에서 Nadam이 빛을 발합니다:</p>
<p>딥 뉴럴 네트워크: Nadam은 수렴 속도가 중요한 딥 뉴럴 네트워크의 학습에서 뛰어납니다. 미래를 예측하는 기능이 수렴 속도를 높이는 데 도움을 주어 모델이 최적이 아닌 해결책에 갇히지 않도록 합니다.</p>
<p>희소한 데이터: 텍스트나 대규모 범주형 데이터와 같은 많은 영 피처를 포함한 데이터셋에 대해서는 Nadam이 매개변수 업데이트를 더 효과적으로 조정하여 희소한 정보를 더 잘 관리합니다.</p>
<p>잡음이 많은 데이터: 실시간 스트림이나 온라인 학습과 같이 잡음이 많은 데이터 환경에서는 Nadam의 변동 데이터 처리 및 적응형 학습률 조정이 특히 유용합니다.</p>
<h2>4.2 한계와 도전과제</h2>
<p>그 강점에도 불구하고, Nadam은 항상 최적의 선택이 되지는 않습니다:</p>
<p>간단한 문제: 오차 함수가 잘 행동하고 국소 최솟값이 적은 간단한 작업의 경우, SGD와 같은 간단한 옵티마이저가 연산 요구가 적어 더 효율적일 수 있습니다.</p>
<p>메모리 집약적 모델: Nadam은 그래디언트와 제곱 그래디언트의 모멘트 추정 값을 저장해야 하므로, 더 간단한 방법과 비교하여 메모리 사용량이 증가합니다. 이는 메모리 제한 환경에서 문제가 될 수 있습니다.</p>
<p>하이퍼파라미터 민감도: Nadam의 성능은 𝛽1, 𝛽2 및 학습률과 같은 하이퍼파라미터의 설정에 민감합니다. 올바른 조정을 위해 포괄적인 테스트 또는 하이퍼파라미터 최적화 도구가 필요할 수 있으며, 최적의 성능을 위해 필수적입니다.</p>
<h1>결론</h1>
<p>Nadam을 탐색하는 것은 Nesterov 운동량과 Adam의 적응형 모멘트 추정을 결합하여 복잡한 머신 러닝 모델을 최적화하는데 중요한 발전을 나타냅니다. Nadam은 Adam에 선행 지식을 추가하여 매개변수 업데이트를 개선하고 수렴 속도를 향상시키며 다양한 어려운 데이터 환경에서 학습 과정을 안정화시킵니다.</p>
<p>Nadam은 최적화 알고리즘 분야에서 상당한 향상을 제공하지만, Adam보다 선택하는 것은 머신 러닝 프로젝트의 특정 요구 사항과 제약 사항을 신중히 고려해야 합니다. 최적화 기술의 지속적인 진화는 능력을 향상시키고 새로운 가능성을 열어주며, 더 많은 연구와 실험을 위한 활기찬 분야로 만들어 냅니다.</p>
<h1>참고문헌</h1>
<ul>
<li>Dozat, T. (2016). “Incorporating Nesterov Momentum into Adam.” ICLR Workshop.</li>
<li>Kingma, D. P., &#x26; Ba, J. (2014). “Adam: A Method for Stochastic Optimization.” arXiv preprint arXiv:1412.6980.</li>
<li>Nesterov, Y. (1983). “A Method for Unconstrained Convex Minimization Problem with the Rate of Convergence 𝑂(1/𝑘2)O(1/k2).” Doklady AN USSR.</li>
<li>Ruder, S. (2016). “An overview of gradient descent optimization algorithms.” arXiv preprint arXiv:1609.04747.</li>
<li>Bottou, L., Curtis, F. E., &#x26; Nocedal, J. (2018). “Optimization Methods for Large-Scale Machine Learning.” SIAM Review, 60(2), 223–311.</li>
<li>Zhang, M. R., Lucas, J., Ba, J., &#x26; Hinton, G. E. (2019). “Lookahead Optimizer: k steps forward, 1 step back.” arXiv preprint arXiv:1907.08610.</li>
</ul>
<p>당신은 끝까지 왔습니다. 축하해요! 이 기사를 즐겼다면 좋아요를 누르고 저를 팔로우해주시면 감사하겠습니다. 저는 주기적으로 비슷한 기사를 게시할 것이기 때문에, 재미있게 보아 주실 것을 희망합니다. 제 목표는 가장 인기 있는 알고리즘을 모두 처음부터 다시 만들어 기계 학습을 모두에게 접근 가능하게 하는 것입니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"나담 옵티마이저 뒤의 수학","description":"","date":"2024-05-20 20:12","slug":"2024-05-20-TheMathBehindNadamOptimizer","content":"\n\n![이미지](/assets/img/2024-05-20-TheMathBehindNadamOptimizer_0.png)\n\n이전에 우리가 Adam 옵티마이저에 대해 이야기했을 때, Adam이 적응적 학습률을 효과적으로 다루면서 기계 학습에서 최적화 지형을 변화시켰다는 것을 탐구했습니다. 다양한 기계 학습 대회에서 특히 Kaggle과 같은 플랫폼에서의 성공으로 알려진 Adam은 확실히 최적화 기술에 높은 기준을 설정했습니다. 그러나 최적화 알고리즘의 진화는 거기서 멈추지 않았습니다. 여기 나담(Nadam)이 나옵니다 — Nesterov-accelerated Adaptive Moment Estimation의 약자인 Adam의 고급 후속 버전입니다.\n\n이 문서를 이해하기 위해 이전에 Adam에 대한 나의 기사를 읽을 필요는 없지만, 관심이 있다면 다음 링크에서 확인할 수 있습니다:\n\nNadam은 나스테로프 모멘텀을 통합하여 Adam 옵티마이저를 개선하며, 기울기 업데이트에 선행(lookahead) 능력을 도입합니다. 이 조정은 수렴 과정을 가속화할 뿐만 아니라 손실 함수를 최소화하기 위한 단계의 정확도도 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNadam을 Adam보다 선택해야 하는 이유는 무엇일까요? 이 기사는 Nadam의 메커니즘을 분석하고 Adam과 비교하며 실제 적용에서의 통찰을 제공하여 이 질문에 대답합니다. 우리는 이를 지원하는 수학적 내용을 알아볼 것이며, Python에서 최적화 도구를 처음부터 구축하여 그것이 어떻게 실행되는지 살펴볼 것입니다. 이 기사를 마치면 기계 학습 프로젝트에 Nadam이 좋은 선택일 수 있는 시기와 이유를 명확히 이해하게 되어, 당신이 필요로 하는 최적화 도구에 대해 정보를 잘 얻을 수 있게 해줄 것입니다.\n\n## 목차\n\n1: Nadam: 개념 및 기원\n∘ 1.1: Nadam이란 무엇인가?\n∘ 1.2: Nadam이 Adam을 기반으로하는 방식\n\n2: Nadam 뒤에 숨은 메커니즘\n∘ 2.1: 초기화\n∘ 2.2: 각 타임 스텝(𝑡)에 대한 반복적인 업데이트\n∘ 2.3: 네스테로프 모멘텀 보정\n∘ 2.4: 편향 보정\n∘ 2.5: 매개변수 업데이트\n∘ 2.6: Adam과의 주요 차이점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 실무에서 Nadam 구현하기\n  - 3.1: Nadam Optimizer 클래스 정의\n  - 3.2: 선형 회귀 모델 클래스\n  - 3.3: 모델 트레이너 클래스\n  - 3.4: 데이터셋 처리 및 모델 훈련\n\n4. 장점과 고려사항\n  - 4.1 Nadam의 우수성\n  - 4.2 한계와 도전 과제\n\n결론\n\n참고문헌\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1: 나담: 개념과 기원\n\n## 1.1: 나담이란?\n\n나담은 뉴럴 네트워크를 최적화하기 위해 기계 학습에서 널리 사용되는 아담 옵티마이저를 개선한 것입니다. 이는 아담의 적응 학습률 기능과 네스테로프 모멘텀의 예측 능력을 통합하였습니다.\n\n이 개선은 모델이 수렴하는 속도를 높일뿐만 아니라 복잡한 최적화 과제를 효과적으로 해결하는 방법을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n나담(Nadam) 뒤에 있는 아이디어는 1980년대 유리 네스테로프(Yuri Nesterov)의 선도적인 작업으로 거슬러 올라갈 수 있습니다. 그 당시 네스테로프는 네스테로프의 가속 그래디언트(Nesterov’s accelerated gradient, NAG)를 소개했습니다. NAG의 목표는 기울기 중심의 최적화 알고리즘의 수렴을 가속화하여 기울기의 경로를 가장 낮은 점으로 더 잘 지시하는 것이었습니다. 이 전략을 아담(Adam)의 적응형 학습률 조정과 결합하여, 나담은 이러한 기본 개념을 향상시켜 최적화 알고리즘의 능력을 크게 향상시킵니다.\n\n## 1.2: 나담(Nadam)이 아담(Adam)을 바탕으로 어떻게 구축되는가\n\n나담은 아담이 설정한 프레임워크를 바탕으로 업데이트가 어떻게 계산되는지를 조정함으로써 구축됩니다. 아담이 과거 제곱 기울기와 과거 기울기의 지수 이동 평균을 사용하는 반면, 나담은 기울기 업데이트 규칙을 수정합니다. 나담은 누적된 기울기 방향으로 적극적으로 전진하며, 미래 기울기를 예측하는 종류의 \"모멘텀\"(momentum)을 활용합니다.\n\n이를 더 잘 이해하기 위해 최적화 경로를 보는 것을 상상해보세요. 위의 이미지는 나담과 아담이 최적화 랜드스케이프를 통해 어떻게 이동하는지 개념적으로 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![TheMathBehindNadamOptimizer](/assets/img/2024-05-20-TheMathBehindNadamOptimizer_1.png)\n\n이 그림에서 두 옵티마이저는 동일한 지점에서 시작합니다. \"Adam\"은 효율적인 수렴과 적응력을 나타내는 평탄하고 잘 포장된 고속도로 위에 있습니다. \"Nadam\"은 가끔 충격이 있는 약간 더 구불구불한 도로 위에 있으며 종종 최소값 지점을 향해 더 날카로운 회전을 하곤 합니다. 이러한 행동은 예상 업데이트에 의해 주도되며 Adam보다 덜 최적의 경로를 더 효과적으로 피할 모멘텀을 제공합니다. 이 능력은 Nadam이 Adam과 Nesterov 모멘텀의 강점을 결합하여 복잡한 손실 함수 랜드스케이프에 특히 적합한 강력한 옵티마이저를 형성한다는 것을 보여줍니다.\n\n## 2: Nadam의 작동 메커니즘\n\nNadam은 Adam 옵티마이저의 메커니즘을 Nesterov 모멘텀과 똑똑하게 결합하여 학습을 최적화합니다. 주요 방정식을 살펴보고 Adam과 비교하여 업데이트 규칙의 차이점을 강조해보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2.1: 초기화\n\n시작할 때, Nadam은 첫 번째 및 두 번째 모멘트 벡터를 초기화합니다. 이 벡터들은 기울기와 제곱 기울기의 이동 평균을 저장하는 데 중요합니다. 시간이 지남에 따라 매개 변수 업데이트를 부드럽게 합니다.\n\n![그림](/assets/img/2024-05-20-TheMathBehindNadamOptimizer_2.png)\n\n동시에 우리는 반복의 시작을 표시하는 초기 타임스텝을 설정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-TheMathBehindNadamOptimizer_3.png\" /\u003e\n\n## 2.2: 각 타임 스텝(𝑡)별 반복적 업데이트\n\n각 반복(𝑡)에 대해, 해당 시점의 매개변수에 대한 손실 함수의 기울기(𝑔_𝑡)를 계산하는 것으로 시작합니다. 이 기울기는 함수의 손실이 가장 빠르게 증가하는 방향을 가리킵니다.\n\n편향된 첫 번째 모멘트 추정값 업데이트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![매쓰사인네처날날담옵티마이저 그림 4](/assets/img/2024-05-20-TheMathBehindNadamOptimizer_4.png)\n\n첫 번째 모멘트(𝑚_𝑡)는 과거 그래디언트의 지수적 평균이며, 이는 감쇠율(β1, 일반적으로 0.9 주변)을 사용하여 업데이트됩니다. 이 비율은 과거 그래디언트 정보 대비 새 데이터 유지 비율에 영향을 미치며, 더 높은 β1은 더 부드럽지만 더 반응이 느린 추정치로 이어집니다.\n\n편향된 두 번째 모멘트 추정 업데이트\n\n![매쓰사인네처날날담옵티마이저 그림 5](/assets/img/2024-05-20-TheMathBehindNadamOptimizer_5.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비슷하게, 두 번째 모멘트 (𝑣_𝑡)은 이전 그래디언트의 제곱의 지수 가중 평균을 추적합니다. 여기서 감쇠율 (β2, 일반적으로 약 0.999)은 매개변수 업데이트의 변동성에 따라 학습률을 조정하여 업데이트를 안정화하는 데 도움을 줍니다.\n\n## 2.3: 네스테로프 모멘텀 보정\n\n![이미지](/assets/img/2024-05-20-TheMathBehindNadamOptimizer_6.png)\n\n여기서 Nadam은 일반적인 모멘트 계산을 수정하여 네스테로프 모멘텀을 통합합니다. 이 접근 방식은 그래디언트의 미래 위치를 예상하여 업데이트 방향을 보정합니다. 이러한 선행은 초기에 제로 초기화된 모멘트가 편향된 업데이트를 초래할 수 있는 훈련 초기에 특히 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2.4: 편향 보정\n\n첫 번째 및 두 번째 모멘트 추정치의 편향을 보정하세요:\n\n![Image](/assets/img/2024-05-20-TheMathBehindNadamOptimizer_7.png)\n\n첫 번째와 두 번째 모멘트는 처음에는 영에서 시작하기 때문에 편향되어 있습니다. 이를 극복하기 위해 편향 보정 용어가 도입되었으며, 더 많은 반복이 완료됨에 따라 모멘트의 추정치를 점진적으로 확대하여, 추정치가 시간이 지남에 따라 보다 정확하고 진짜 기울기 정보를 반영하도록 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2.5: 매개변수 업데이트\n\n![Image](/assets/img/2024-05-20-TheMathBehindNadamOptimizer_8.png)\n\n최종 매개변수 업데이트는 기울기의 방향에 대해 조정된 적응형 학습률(𝛼)과 작은 상수(𝜖, 10^(-8)과 같은)로 수치적 안정성을 위해 이루어집니다. 수정된 첫 번째 모멘트(𝑚_𝑡)와 수정된 두 번째 모멘트의 제곱근(𝑣_𝑡)은 이러한 업데이트를 적절하게 조정하는 데 사용되며, 기울기의 방향과 크기를 모두 고려합니다.\n\n## 2.6: Adam과의 주요 차이점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNadam과 Adam 사이의 주요 차이점은 Nadam이 적극적으로 조정을 합니다. Adam은 현재 기울기 추정만을 의존하는 반면, Nadam은 Nesterov 모멘텀을 통해 앞서 보는 단계를 도입합니다. 이로 인해 미래의 기울기 방향을 예측뿐만 아니라 업데이트를 더 정확하게 조정하여 더 효율적인 학습 역학을 이끌어냅니다.\n\nNadam은 Nesterov 모멘텀의 통합을 통해 최적화에 대해 보다 섬세하고 선심을 기울인 접근 방식을 제공하여 Adam보다 데이터 landscape를 효과적으로 탐색하고 적응하는 능력을 향상시킵니다. 이로써 Nadam은 다양한 머신 러닝 과제에 대한 견고한 선택지가 되며, 실제 결과를 선택할 때 이론적 통찰력과 실용적 결과를 모두 고려하도록 실무자에게 요청합니다.\n\n## 3. 실무에서 Nadam 구현\n\n이 섹션에서는 Nadam 옵티마이저를 처음부터 구축하고 머신 러닝 환경에서 적용할 것입니다. 우리는 선형 회귀 작업에 Nadam 옵티마이저를 구현하고 사용하는 맥락에서 코드를 여러 주요 섹션으로 분할할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래의 코드를 살펴보고 싶다면, 오늘 다룰 코드와 추가적인 보너스 콘텐츠가 모두 포함된 이 Jupyter 노트북을 살펴보는 것을 고려해보세요:\n\n## 3.1: Nadam Optimizer Class Definition\n\nNadam 알고리즘을 사용하여 매개변수를 최적화하는 데 중요한 역할을 하는 NadamOptimizer 클래스를 자세히 살펴봅시다.\n\n```js\nclass NadamOptimizer:\n    def __init__(self, learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-8):\n        self.learning_rate = learning_rate\n        self.beta1 = beta1\n        self.beta2 = beta2\n        self.epsilon = epsilon\n        self.m = None\n        self.v = None\n        self.t = 0\n\n    def initialize_moments(self, params):\n        self.m = {k: np.zeros_like(v) for k, v in params.items()}\n        self.v = {k: np.zeros_like(v) for k, v in params.items()}\n\n    def update_params(self, params, grads):\n        if self.m is None or self.v is None:\n            self.initialize_moments(params)\n\n        self.t += 1\n        updated_params = {}\n        mu_t = self.beta1 * (1 - 0.5 * 0.96 ** (self.t * 0.004))\n        mu_t1 = self.beta1 * (1 - 0.5 * 0.96 ** ((self.t + 1) * 0.004))\n        for key in params.keys():\n            g_tilde = grads[key] / (1 - np.prod([self.beta1] * self.t))\n            self.m[key] = self.beta1 * self.m[key] + (1 - self.beta1) * grads[key]\n            self.v[key] = self.beta2 * self.v[key] + (1 - self.beta2) * np.square(grads[key])\n\n            m_corrected = self.m[key] / (1 - mu_t1 ** self.t)\n            v_corrected = self.v[key] / (1 - self.beta2 ** self.t)\n\n            m_bar = (1 - mu_t) * g_tilde + mu_t1 * m_corrected\n\n            updated_params[key] = params[key] - self.learning_rate * m_bar / (np.sqrt(v_corrected) + self.epsilon)\n\n        return updated_params\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNadamOptimizer 클래스는 Nadam 최적화 방법을 관리하고 실행하기 위해 구조화되어 있습니다. 아래는 클래스와 해당 함수들을 설명한 것입니다:\n\n__init__ 메서드\n\n```python\nclass NadamOptimizer:\n    def __init__(self, learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-8):\n        self.learning_rate = learning_rate\n        self.beta1 = beta1\n        self.beta2 = beta2\n        self.epsilon = epsilon\n        self.m = None\n        self.v = None\n        self.t = 0\n```\n\n초기화 메서드는 최적화기를 학습률, 베타 값, 그리고 엡실론에 대한 미리 정의된 설정으로 설정합니다. 이러한 매개변수 각각은 중요한 역할을 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 학습률: 이는 손실 함수의 최소값으로 이동하는 각 반복에서의 단계 크기를 결정합니다.\n- beta1 및 beta2: 이러한 매개 변수는 기울기와 해당 제곱값의 이동 평균의 감쇠율을 제어하며 업데이트를 부드럽게 만들고 학습률을 동적으로 관리하는 데 도움이 됩니다.\n- epsilon: 계산 중에 0으로 나누는 것을 방지하기 위한 매우 작은 수입니다.\n- self.m 및 self.v: 초기에 None으로 설정되며 나중에는 각각 기울기와 제곱 기울기의 이동 평균을 저장합니다.\n- self.t: 업데이트 또는 반복 횟수를 추적하는 카운터입니다.\n\n이 설정은 Nadam의 기본 측면과 일치하며, 적응형 학습률이 지속적으로 조정되어 수렴을 개선합니다.\n\ninitialize_moments 메서드\n\n```js\n    def initialize_moments(self, params):\n        self.m = {k: np.zeros_like(v) for k, v in params.items()}\n        self.v = {k: np.zeros_like(v) for k, v in params.items()}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 메소드는 이동 평균을 저장하는 딕셔너리 m과 v를 초기화합니다. 각 매개변수의 기울기와 제곱 기울기가 0으로 초기화되는데, 이는 최적화 프로세스의 후속 단계에서 계산을 시작하는 데 중요합니다.\n\nupdate_params 메소드\n\n```js\n    def update_params(self, params, grads):\n        if self.m is None or self.v is None:\n            self.initialize_moments(params)\n\n        self.t += 1\n        updated_params = {}\n        mu_t = self.beta1 * (1 - 0.5 * 0.96 ** (self.t * 0.004))\n        mu_t1 = self.beta1 * (1 - 0.5 * 0.96 ** ((self.t + 1) * 0.004))\n        for key in params.keys():\n            g_tilde = grads[key] / (1 - np.prod([self.beta1] * self.t))\n            self.m[key] = self.beta1 * self.m[key] + (1 - self.beta1) * grads[key]\n            self.v[key] = self.beta2 * self.v[key] + (1 - self.beta2) * np.square(grads[key])\n\n            m_corrected = self.m[key] / (1 - mu_t1 ** self.t)\n            v_corrected = self.v[key] / (1 - self.beta2 ** self.t)\n\n            m_bar = (1 - mu_t) * g_tilde + mu_t1 * m_corrected\n\n            updated_params[key] = params[key] - self.learning_rate * m_bar / (np.sqrt(v_corrected) + self.epsilon)\n\n        return updated_params\n```\n\n이 함수는 Nadam 옵티마이저의 핵심입니다. 전달된 기울기를 기반으로 매개변수를 업데이트합니다. 포함된 단계는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n순간 초기화 확인\n\n```js\nif self.m이 None이거나 self.v가 None이면:\n            self.initialize_moments(params)\n```\n\n만약 m 또는 v가 초기화되지 않았다면 0으로 설정됩니다.\n\n시간 단계 업데이트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n셀프.티 += 1\n```\n\ndecay factors를 동적으로 조절하는 시간 단계 t를 증가시킵니다.\n\n네스테로프 모멘텀 조정\n\n```js\n뮤_티 = self.beta1 * (1 - 0.5 * 0.96 ** (self.티 * 0.004))\n뮤_t1 = self.beta1 * (1 - 0.5 * 0.96 ** ((self.티 + 1) * 0.004))\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nmu_t 및 mu_t1은 시간 단계의 진행을 고려하여 Nesterov 모멘텀의 효과를 반영하기 위해 beta1을 조정합니다. 이러한 조정은 모멘텀이 미래의 기울기를 더 효과적으로 반영하도록 합니다.\n\n각 매개변수를 순회하면서:\n\n```js\nfor key in params.keys():\n      g_tilde = grads[key] / (1 - np.prod([self.beta1] * self.t))\n      self.m[key] = self.beta1 * self.m[key] + (1 - self.beta1) * grads[key]\n      self.v[key] = self.beta2 * self.v[key] + (1 - self.beta2) * np.square(grads[key])\n\n      m_corrected = self.m[key] / (1 - mu_t1 ** self.t)\n      v_corrected = self.v[key] / (1 - self.beta2 ** self.t)\n\n      m_bar = (1 - mu_t) * g_tilde + mu_t1 * m_corrected\n```\n\ng_tilde은 과거 그래디언트의 감쇠를 현재 시간 단계까지 반영한 조정된 기울기를 계산합니다. 이는 lookahead를 포함하여 그래디언트 계산을 수정하여 Nesterov 모멘텀의 효과를 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n나중에는 새로운 기울기와 조정된 베타 값에 기초하여 각 매개변수에 대해 m과 v를 조정합니다. 이 단계는 과거 기울기의 모멘텀 이점과 새로운 기울기에 대한 적응성을 결합하는 중요한 단계입니다.\n\nm_corrected와 v_corrected는 편향이 수정된 제1 및 제2 모먼트의 추정치를 나타냅니다. 바이어스 보정은 계산된 기울기가 더 적을 때 교육 초기에 중요합니다.\n\nm_bar는 미래의 그래디언트와 모멘텀이 보정된 그래디언트를 결합하여 매개변수 공간에서 취해야 할 단계의 방향과 크기를 효과적으로 결정합니다.\n\n매개변수 업데이트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nupdated_params[key] = params[key] - self.learning_rate * m_bar / (np.sqrt(v_corrected) + self.epsilon)\n\n\n모든 매개변수는 m_bar와 조정된 학습률에 의해 업데이트되며, v_corrected에 제곱근을 더한 것으로 스케일링됩니다. 이 단계는 실제 매개변수 업데이트가 발생하는 곳으로, 모델의 학습에 직접적인 영향을 미칩니다.\n\n## 3.2: 선형 회귀 모델 클래스\n\n이제 간단한 회귀 모델을 구축하고, Nadam 옵티마이저를 적용해 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 선형 회귀 모델\nclass LinearRegression:\n    def __init__(self, n_features):\n        self.weights = np.random.randn(n_features)\n        self.bias = np.random.randn()\n\n    def predict(self, X):\n        return np.dot(X, self.weights) + self.bias\n```\n\n여기서 __init__ 메서드는 features 수에 기반하여 랜덤한 weights와 biases로 모델을 초기화합니다.\n\n그런 다음 predict 메서드는 입력과 weights 및 bias의 내적을 사용하여 예측을 계산합니다.\n\n여기서 선형 회귀는 Nadam이 어떻게 작동하는지 이해하는 간단한 방법을 제공하지만, 실제로는 더 복잡한 딥러닝 모델에서 Nadam을 사용하려고 할 것입니다. 그렇다면, 가장 인기 있는 딥러닝 모델 중 일부를 포괄적으로 이해할 수 있는 다음의 글을 살펴보고 그 코드를 수정하여 Nadam을 구현해보기를 강력히 추천합니다:```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 3.3: Model Trainer Class\n\n앞으로 나아가봅시다. 이제는 지정된 최적화 도구를 사용하여 머신 러닝 모델을 훈련시키는 전체 과정을 캡슐화하는 클래스가 필요합니다. 이것이 바로 ModelTrainer 클래스가 할 일입니다.\n\n```js\nclass ModelTrainer:\n    def __init__(self, model, optimizer, n_epochs):\n        self.model = model\n        self.optimizer = optimizer\n        self.n_epochs = n_epochs\n\n    def compute_gradients(self, X, y):\n        predictions = self.model.predict(X)\n        errors = predictions - y\n        dW = 2 * np.dot(X.T, errors) / len(y)\n        db = 2 * np.mean(errors)\n        return {'weights': dW, 'bias': db}\n\n    def train(self, X, y, verbose=False):\n        for epoch in range(self.n_epochs):\n            grads = self.compute_gradients(X, y)\n            params = {'weights': self.model.weights, 'bias': self.model.bias}\n            updated_params = self.optimizer.update_params(params, grads)\n\n            self.model.weights = updated_params['weights']\n            self.model.bias = updated_params['bias']\n\n            # Optionally, print loss here to observe training\n            loss = np.mean((self.model.predict(X) - y) ** 2)\n            if epoch % 1000 == 0 and verbose:\n                print(f\"Epoch {epoch}, Loss: {loss}\")\n```\n\n__init__ 메서드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\n    def __init__(self, model, optimizer, n_epochs):\n        self.model = model\n        self.optimizer = optimizer\n        self.n_epochs = n_epochs\n```\n\n이 생성자 메서드는 세 가지 주요 구성 요소로 트레이너를 초기화합니다:\n\n- model: 훈련될 머신러닝 모델이며, 예측을 수행하는 메서드와 매개변수(가중치 및 편향)에 대한 속성이 있어야 합니다.\n- optimizer: Nadam과 같은 옵티마이저 클래스의 인스턴스로, 계산된 그래디언트에 기초하여 모델의 매개변수를 업데이트하는 역할을 담당합니다.\n- n_epochs: 훈련 프로세스가 실행할 훈련 데이터 세트를 전체적으로 순회하는 횟수입니다.\n\n이러한 구성 요소는 손실 함수를 최소화하기 위해 모델의 매개변수가 반복적으로 업데이트되는 훈련 프로세스를 설정하는 데 필수적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ncompute_gradients 메서드\n\n```python\ndef compute_gradients(self, X, y):\n    predictions = self.model.predict(X)\n    errors = predictions - y\n    dW = 2 * np.dot(X.T, errors) / len(y)\n    db = 2 * np.mean(errors)\n    return {'weights': dW, 'bias': db}\n```\n\n이 메서드는 모델 매개변수에 대한 손실 함수의 그래디언트를 계산합니다:\n\n```python\npredictions = self.model.predict(X)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 모델이 현재 매개변수를 사용하여 입력 X를 기반으로 출력을 예측하는 부분입니다.\n\n```js\n오류 = 예측 - y\n```\n\n이 코드 라인은 예측된 출력과 실제 출력인 y와의 차이, 즉 오차를 나타냅니다.\n\n```js\ndW = 2 * np.dot(X.T, 오류) / len(y)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 가중치의 기울기를 계산합니다. 가중치에 대한 평균 제곱 오차 손실 함수의 도함수는 len(y)의 데이터 포인트에 의해 조정된 표현으로 주어집니다. 이는 모든 특성과 데이터 포인트에 대한 기울기를 효율적으로 계산하는 벡터화된 구현입니다.\n\n```js\ndb = 2 * np.mean(errors)\n```\n\n마찬가지로, 이는 편향의 기울기를 계산하며, 이는 단순히 오차의 평균에 2를 곱한 것입니다.\n\n```js\nreturn {'weights': dW, 'bias': db}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러면 메서드는 이러한 그래디언트를 딕셔너리로 반환하여 모델의 매개변수를 업데이트하는 데 사용할 수 있도록 합니다. 이 메서드는 옵티마이저가 손실을 최소화하기 위해 매개변수를 조정해야 하는 필수적인 기울기 계산 단계를 캡슐화합니다.\n\ntrain 메서드\n\n```python\n    def train(self, X, y, verbose=False):\n        for epoch in range(self.n_epochs):\n            grads = self.compute_gradients(X, y)\n            params = {'weights': self.model.weights, 'bias': self.model.bias}\n            updated_params = self.optimizer.update_params(params, grads)\n\n            self.model.weights = updated_params['weights']\n            self.model.bias = updated_params['bias']\n\n            # 선택사항: 여기서 손실을 출력하여 학습을 관찰합니다\n            loss = np.mean((self.model.predict(X) - y) ** 2)\n            if epoch % 1000 == 0 and verbose:\n                print(f\"Epoch {epoch}, Loss: {loss}\")\n```\n\n이 메서드는 각 epoch(데이터를 완전히 통과하는 단계)마다 n_epochs에 이르기까지 반복됩니다. 루프 내에서 현재 매개변수와 데이터 집합에 대해 compute_gradients를 사용하여 그래디언트를 먼저 계산합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그런 다음 이러한 그래디언트를 현재 매개변수와 함께 옵티마이저(self.optimizer.update_params(params, grads))에 전달하고, 옵티마이저는 최적화 알고리즘(예: Nadam)을 기반으로 업데이트된 매개변수를 반환합니다.\n\n모델의 매개변수는 이러한 새 값으로 업데이트되어 손실을 최소화하는 상태로 움직이게 됩니다.\n\nverbose가 True로 설정되어 있는 경우, 메서드는 1000번의 epoch마다 손실을 인쇄하여 교육 진행 상황을 모니터링합니다. 손실은 예측 값과 실제 출력 사이의 평균 제곱 오차로 계산되며, 모델의 성능을 얼마나 잘 평가하고 있는지에 대한 간단한 지표를 제공합니다.\n\ntrain 메서드는 따라서 전체 교육 과정을 조정하며, 손실 함수의 피드백에 기초하여 옵티마이저를 통해 모델의 매개변수를 반복적으로 조정합니다. 이 메서드는 머신러닝에서 사용되는 반복적 최적화 기법의 실용적 구현이며, 그래디언트 하강과 매개변수 업데이트의 이론적 원리를 직접 적용하여 여러 번의 반복을 통해 미리 정의된 손실 함수를 최소화합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 3.4: 데이터셋 처리 및 모델 훈련\n\n마지막으로, Nadam 옵티마이저를 사용하여 머신러닝 모델을 설정, 훈련 및 평가해 봅시다. 이 접근 방식은 데이터 조작, Optuna를 사용한 하이퍼파라미터 튜닝, 그리고 모델의 효과를 개선하고 평가하기 위한 반복적인 훈련 및 테스트를 포함합니다.\n\n### 3.4.1: 데이터 준비\n\n```python\n# 입력 피처(X) 및 타겟 값(y) 가져오기\nX = diabetes.data\ny = diabetes.target\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우선, 당뇨 데이터셋에서 피처 데이터(X)와 타겟값(y)을 불러옵니다. 이 데이터셋은 sci-kit learn에서 가져오며 상업적 이용이 가능합니다. (Scikit-learn: Python의 머신 러닝, Pedregosa et al., JMLR 12, pp. 2825–2830, 2011.)\n\n```js\n# 데이터셋을 훈련 세트와 테스트 세트로 나눕니다\ndef split_dataset(X, y, test_ratio=0.2):\n    indices = np.random.permutation(len(X))\n    test_size = int(len(X) * test_ratio)\n    test_indices = indices[:test_size]\n    train_indices = indices[test_size:]\n    return X[train_indices], X[test_indices], y[train_indices], y[test_indices]\n\nX_train, X_test, y_train, y_test = split_dataset(X, y)\nX_train, X_val, y_train, y_val = split_dataset(X_train, y_train)\n```\n\nsplit_dataset 함수는 지정된 비율에 따라 데이터셋을 훈련 세트와 테스트 세트로 무작위로 분할합니다. 데이터셋 인덱스를 섞어 분할을 무작위로 다양하게 만들어 모델 평가를 견고하게 합니다. 훈련 세트는 모델 매개변수를 학습하는 데 사용되고, 테스트 세트는 모델이 보지 못한 데이터에서 얼마나 잘 수행되는지를 평가합니다.\n\n3.4.2: Optuna을 이용한 하이퍼파라미터 튜닝\n우리는 Optuna를 사용하여 모델의 하이퍼파라미터를 최적화할 것이며, 이는 훈련 동적과 Nadam 옵티마이저의 효과에 상당한 영향을 미칩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 기사에서 우리는 옵투나(optuna)를 광범위하게 다루었습니다. 거기에서는 이를 신경망에 적용하여 성공적으로 세밀하게 조정하는 방법을 보여주었습니다. 만약 Nadam을 더 복잡한 모델에 적용하고 싶다면, 이 기사를 읽어보시면 좋을 것 같아요:\n\n목적 함수 정의\n\n```python\ndef objective(trial):\n    n_features = X_train.shape[1]\n\n    learning_rate = trial.suggest_loguniform('learning_rate', 1e-5, 1e-1)\n    beta1 = trial.suggest_uniform('beta1', 0.9, 0.999)\n    beta2 = trial.suggest_uniform('beta2', 0.99, 0.9999)\n    epsilon = trial.suggest_loguniform('epsilon', 1e-10, 1e-5)\n\n    n_epochs = trial.suggest_int('epochs', 1000, 100000)\n\n    # Define the model\n    model = LinearRegression(n_features)\n    optimizer = NadamOptimizer(learning_rate=learning_rate, beta1=beta1, beta2=beta2, epsilon=epsilon)\n    trainer = ModelTrainer(model, optimizer, n_epochs=n_epochs)\n\n    # Train the model\n    trainer.train(X_train, y_train, verbose=False)\n\n    # Compute the validation loss\n    val_loss = np.mean((model.predict(X_val) - y_val) ** 2)\n\n    return val_loss\n```\n\n우리의 목적 함수는 옵투나(optuna)의 최적화 과정을 안내하는 중요한 역할을 합니다. 각 시도는 다음 값을 제안합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 학습률: 매개변수 업데이트의 단계 크기에 영향을 줍니다.\n- beta1 및 beta2: 그래디언트 및 그들의 제곱값에 대한 평균의 감쇠율을 조절합니다.\n- epsilon: 업데이트 중에 0으로 나누는 것을 방지하기 위해 작은 값이 추가됩니다.\n\n각 시도는 이러한 매개변수를 사용하여 LinearRegression 모델과 NadamOptimizer를 설정하고, ModelTrainer를 사용하여 모델을 훈련합니다. 훈련 후, 검증 세트에서의 검증 손실을 계산하여 하이퍼파라미터의 효과를 Optuna에 제공합니다.\n\n```js\n# 연구 객체 생성\noptuna.logging.set_verbosity(optuna.logging.WARNING)\nstudy = optuna.create_study(direction='minimize', sampler=optuna.samplers.TPESampler(seed=42))\n\n# 연구 개선, 더 많은 시행을 사용하여 더 나은 결과를 얻거나, 더 적은 시행을 사용하여 더 비용 효율적일 수 있습니다\nstudy.optimize(objective, n_trials=10)\n```\n\nOptuna가 최적의 매개변수를 식별한 후, 최종 모델이 구성되고 훈련됩니다. 이 단계에서는 테스트 세트에서 모델의 일반화 능력을 평가합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n훈련 및 평가\n\n```js\n# 최적 모델 가져오기\nn_features = X_train.shape[1]\nbest_model = LinearRegression(n_features)\noptimizer = NadamOptimizer(learning_rate=study.best_params['learning_rate'],\n                          beta1=study.best_params['beta1'],\n                          beta2=study.best_params['beta2'],\n                          epsilon=study.best_params['epsilon'])\n\n# 모델 훈련하기\ntrainer = ModelTrainer(best_model, optimizer, n_epochs=study.best_params['epochs'])\ntrainer.train(X_train, y_train)\n```\n\nOptuna의 최적 매개변수를 사용하여 모델은 추가 훈련을 받습니다. 이 추가 훈련을 통해 모델이 데이터에 완전히 적응하도록 보장합니다.\n\n```js\n# 테스트 손실 계산하기\ntest_loss = np.mean((best_model.predict(X_test) - y_test) ** 2)**0.5\nprint(f'테스트 손실: {test_loss:.2f}')\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마침내, 새로운, 보지 못했던 데이터에 대한 모델의 예측 정확도를 평가하기 위해 시험 손실을 계산합니다. 이 측정값은 모델의 실용적 성능을 평가하는 데 중요합니다.\n\n# 4. 장점과 고려 사항\n\n## 4.1 Nadam이 뛰어난 점\n\nNadam은 Adam을 바탕으로 네스테로프 모멘텀을 통합하여, 그레이디언트가 믿을 수 없거나 에포크 간 크게 다를 수 있는 복잡한 최적화 작업을 처리할 수 있는 능력을 향상시킵니다. 여기에서 Nadam이 빛을 발합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n딥 뉴럴 네트워크: Nadam은 수렴 속도가 중요한 딥 뉴럴 네트워크의 학습에서 뛰어납니다. 미래를 예측하는 기능이 수렴 속도를 높이는 데 도움을 주어 모델이 최적이 아닌 해결책에 갇히지 않도록 합니다.\n\n희소한 데이터: 텍스트나 대규모 범주형 데이터와 같은 많은 영 피처를 포함한 데이터셋에 대해서는 Nadam이 매개변수 업데이트를 더 효과적으로 조정하여 희소한 정보를 더 잘 관리합니다.\n\n잡음이 많은 데이터: 실시간 스트림이나 온라인 학습과 같이 잡음이 많은 데이터 환경에서는 Nadam의 변동 데이터 처리 및 적응형 학습률 조정이 특히 유용합니다.\n\n## 4.2 한계와 도전과제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 강점에도 불구하고, Nadam은 항상 최적의 선택이 되지는 않습니다:\n\n간단한 문제: 오차 함수가 잘 행동하고 국소 최솟값이 적은 간단한 작업의 경우, SGD와 같은 간단한 옵티마이저가 연산 요구가 적어 더 효율적일 수 있습니다.\n\n메모리 집약적 모델: Nadam은 그래디언트와 제곱 그래디언트의 모멘트 추정 값을 저장해야 하므로, 더 간단한 방법과 비교하여 메모리 사용량이 증가합니다. 이는 메모리 제한 환경에서 문제가 될 수 있습니다.\n\n하이퍼파라미터 민감도: Nadam의 성능은 𝛽1, 𝛽2 및 학습률과 같은 하이퍼파라미터의 설정에 민감합니다. 올바른 조정을 위해 포괄적인 테스트 또는 하이퍼파라미터 최적화 도구가 필요할 수 있으며, 최적의 성능을 위해 필수적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nNadam을 탐색하는 것은 Nesterov 운동량과 Adam의 적응형 모멘트 추정을 결합하여 복잡한 머신 러닝 모델을 최적화하는데 중요한 발전을 나타냅니다. Nadam은 Adam에 선행 지식을 추가하여 매개변수 업데이트를 개선하고 수렴 속도를 향상시키며 다양한 어려운 데이터 환경에서 학습 과정을 안정화시킵니다.\n\nNadam은 최적화 알고리즘 분야에서 상당한 향상을 제공하지만, Adam보다 선택하는 것은 머신 러닝 프로젝트의 특정 요구 사항과 제약 사항을 신중히 고려해야 합니다. 최적화 기술의 지속적인 진화는 능력을 향상시키고 새로운 가능성을 열어주며, 더 많은 연구와 실험을 위한 활기찬 분야로 만들어 냅니다.\n\n# 참고문헌\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Dozat, T. (2016). “Incorporating Nesterov Momentum into Adam.” ICLR Workshop.\n- Kingma, D. P., \u0026 Ba, J. (2014). “Adam: A Method for Stochastic Optimization.” arXiv preprint arXiv:1412.6980.\n- Nesterov, Y. (1983). “A Method for Unconstrained Convex Minimization Problem with the Rate of Convergence 𝑂(1/𝑘2)O(1/k2).” Doklady AN USSR.\n- Ruder, S. (2016). “An overview of gradient descent optimization algorithms.” arXiv preprint arXiv:1609.04747.\n- Bottou, L., Curtis, F. E., \u0026 Nocedal, J. (2018). “Optimization Methods for Large-Scale Machine Learning.” SIAM Review, 60(2), 223–311.\n- Zhang, M. R., Lucas, J., Ba, J., \u0026 Hinton, G. E. (2019). “Lookahead Optimizer: k steps forward, 1 step back.” arXiv preprint arXiv:1907.08610.\n\n당신은 끝까지 왔습니다. 축하해요! 이 기사를 즐겼다면 좋아요를 누르고 저를 팔로우해주시면 감사하겠습니다. 저는 주기적으로 비슷한 기사를 게시할 것이기 때문에, 재미있게 보아 주실 것을 희망합니다. 제 목표는 가장 인기 있는 알고리즘을 모두 처음부터 다시 만들어 기계 학습을 모두에게 접근 가능하게 하는 것입니다.","ogImage":{"url":"/assets/img/2024-05-20-TheMathBehindNadamOptimizer_0.png"},"coverImage":"/assets/img/2024-05-20-TheMathBehindNadamOptimizer_0.png","tag":["Tech"],"readingTime":22},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-TheMathBehindNadamOptimizer_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이전에 우리가 Adam 옵티마이저에 대해 이야기했을 때, Adam이 적응적 학습률을 효과적으로 다루면서 기계 학습에서 최적화 지형을 변화시켰다는 것을 탐구했습니다. 다양한 기계 학습 대회에서 특히 Kaggle과 같은 플랫폼에서의 성공으로 알려진 Adam은 확실히 최적화 기술에 높은 기준을 설정했습니다. 그러나 최적화 알고리즘의 진화는 거기서 멈추지 않았습니다. 여기 나담(Nadam)이 나옵니다 — Nesterov-accelerated Adaptive Moment Estimation의 약자인 Adam의 고급 후속 버전입니다.\u003c/p\u003e\n\u003cp\u003e이 문서를 이해하기 위해 이전에 Adam에 대한 나의 기사를 읽을 필요는 없지만, 관심이 있다면 다음 링크에서 확인할 수 있습니다:\u003c/p\u003e\n\u003cp\u003eNadam은 나스테로프 모멘텀을 통합하여 Adam 옵티마이저를 개선하며, 기울기 업데이트에 선행(lookahead) 능력을 도입합니다. 이 조정은 수렴 과정을 가속화할 뿐만 아니라 손실 함수를 최소화하기 위한 단계의 정확도도 향상시킵니다.\u003c/p\u003e\n\u003cp\u003eNadam을 Adam보다 선택해야 하는 이유는 무엇일까요? 이 기사는 Nadam의 메커니즘을 분석하고 Adam과 비교하며 실제 적용에서의 통찰을 제공하여 이 질문에 대답합니다. 우리는 이를 지원하는 수학적 내용을 알아볼 것이며, Python에서 최적화 도구를 처음부터 구축하여 그것이 어떻게 실행되는지 살펴볼 것입니다. 이 기사를 마치면 기계 학습 프로젝트에 Nadam이 좋은 선택일 수 있는 시기와 이유를 명확히 이해하게 되어, 당신이 필요로 하는 최적화 도구에 대해 정보를 잘 얻을 수 있게 해줄 것입니다.\u003c/p\u003e\n\u003ch2\u003e목차\u003c/h2\u003e\n\u003cp\u003e1: Nadam: 개념 및 기원\n∘ 1.1: Nadam이란 무엇인가?\n∘ 1.2: Nadam이 Adam을 기반으로하는 방식\u003c/p\u003e\n\u003cp\u003e2: Nadam 뒤에 숨은 메커니즘\n∘ 2.1: 초기화\n∘ 2.2: 각 타임 스텝(𝑡)에 대한 반복적인 업데이트\n∘ 2.3: 네스테로프 모멘텀 보정\n∘ 2.4: 편향 보정\n∘ 2.5: 매개변수 업데이트\n∘ 2.6: Adam과의 주요 차이점\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e실무에서 Nadam 구현하기\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e3.1: Nadam Optimizer 클래스 정의\u003c/li\u003e\n\u003cli\u003e3.2: 선형 회귀 모델 클래스\u003c/li\u003e\n\u003cli\u003e3.3: 모델 트레이너 클래스\u003c/li\u003e\n\u003cli\u003e3.4: 데이터셋 처리 및 모델 훈련\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e장점과 고려사항\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e4.1 Nadam의 우수성\u003c/li\u003e\n\u003cli\u003e4.2 한계와 도전 과제\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e결론\u003c/p\u003e\n\u003cp\u003e참고문헌\u003c/p\u003e\n\u003ch1\u003e1: 나담: 개념과 기원\u003c/h1\u003e\n\u003ch2\u003e1.1: 나담이란?\u003c/h2\u003e\n\u003cp\u003e나담은 뉴럴 네트워크를 최적화하기 위해 기계 학습에서 널리 사용되는 아담 옵티마이저를 개선한 것입니다. 이는 아담의 적응 학습률 기능과 네스테로프 모멘텀의 예측 능력을 통합하였습니다.\u003c/p\u003e\n\u003cp\u003e이 개선은 모델이 수렴하는 속도를 높일뿐만 아니라 복잡한 최적화 과제를 효과적으로 해결하는 방법을 제공합니다.\u003c/p\u003e\n\u003cp\u003e나담(Nadam) 뒤에 있는 아이디어는 1980년대 유리 네스테로프(Yuri Nesterov)의 선도적인 작업으로 거슬러 올라갈 수 있습니다. 그 당시 네스테로프는 네스테로프의 가속 그래디언트(Nesterov’s accelerated gradient, NAG)를 소개했습니다. NAG의 목표는 기울기 중심의 최적화 알고리즘의 수렴을 가속화하여 기울기의 경로를 가장 낮은 점으로 더 잘 지시하는 것이었습니다. 이 전략을 아담(Adam)의 적응형 학습률 조정과 결합하여, 나담은 이러한 기본 개념을 향상시켜 최적화 알고리즘의 능력을 크게 향상시킵니다.\u003c/p\u003e\n\u003ch2\u003e1.2: 나담(Nadam)이 아담(Adam)을 바탕으로 어떻게 구축되는가\u003c/h2\u003e\n\u003cp\u003e나담은 아담이 설정한 프레임워크를 바탕으로 업데이트가 어떻게 계산되는지를 조정함으로써 구축됩니다. 아담이 과거 제곱 기울기와 과거 기울기의 지수 이동 평균을 사용하는 반면, 나담은 기울기 업데이트 규칙을 수정합니다. 나담은 누적된 기울기 방향으로 적극적으로 전진하며, 미래 기울기를 예측하는 종류의 \"모멘텀\"(momentum)을 활용합니다.\u003c/p\u003e\n\u003cp\u003e이를 더 잘 이해하기 위해 최적화 경로를 보는 것을 상상해보세요. 위의 이미지는 나담과 아담이 최적화 랜드스케이프를 통해 어떻게 이동하는지 개념적으로 보여줍니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-TheMathBehindNadamOptimizer_1.png\" alt=\"TheMathBehindNadamOptimizer\"\u003e\u003c/p\u003e\n\u003cp\u003e이 그림에서 두 옵티마이저는 동일한 지점에서 시작합니다. \"Adam\"은 효율적인 수렴과 적응력을 나타내는 평탄하고 잘 포장된 고속도로 위에 있습니다. \"Nadam\"은 가끔 충격이 있는 약간 더 구불구불한 도로 위에 있으며 종종 최소값 지점을 향해 더 날카로운 회전을 하곤 합니다. 이러한 행동은 예상 업데이트에 의해 주도되며 Adam보다 덜 최적의 경로를 더 효과적으로 피할 모멘텀을 제공합니다. 이 능력은 Nadam이 Adam과 Nesterov 모멘텀의 강점을 결합하여 복잡한 손실 함수 랜드스케이프에 특히 적합한 강력한 옵티마이저를 형성한다는 것을 보여줍니다.\u003c/p\u003e\n\u003ch2\u003e2: Nadam의 작동 메커니즘\u003c/h2\u003e\n\u003cp\u003eNadam은 Adam 옵티마이저의 메커니즘을 Nesterov 모멘텀과 똑똑하게 결합하여 학습을 최적화합니다. 주요 방정식을 살펴보고 Adam과 비교하여 업데이트 규칙의 차이점을 강조해보겠습니다.\u003c/p\u003e\n\u003ch2\u003e2.1: 초기화\u003c/h2\u003e\n\u003cp\u003e시작할 때, Nadam은 첫 번째 및 두 번째 모멘트 벡터를 초기화합니다. 이 벡터들은 기울기와 제곱 기울기의 이동 평균을 저장하는 데 중요합니다. 시간이 지남에 따라 매개 변수 업데이트를 부드럽게 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-TheMathBehindNadamOptimizer_2.png\" alt=\"그림\"\u003e\u003c/p\u003e\n\u003cp\u003e동시에 우리는 반복의 시작을 표시하는 초기 타임스텝을 설정합니다.\u003c/p\u003e\n\u003ch2\u003e2.2: 각 타임 스텝(𝑡)별 반복적 업데이트\u003c/h2\u003e\n\u003cp\u003e각 반복(𝑡)에 대해, 해당 시점의 매개변수에 대한 손실 함수의 기울기(𝑔_𝑡)를 계산하는 것으로 시작합니다. 이 기울기는 함수의 손실이 가장 빠르게 증가하는 방향을 가리킵니다.\u003c/p\u003e\n\u003cp\u003e편향된 첫 번째 모멘트 추정값 업데이트\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-TheMathBehindNadamOptimizer_4.png\" alt=\"매쓰사인네처날날담옵티마이저 그림 4\"\u003e\u003c/p\u003e\n\u003cp\u003e첫 번째 모멘트(𝑚_𝑡)는 과거 그래디언트의 지수적 평균이며, 이는 감쇠율(β1, 일반적으로 0.9 주변)을 사용하여 업데이트됩니다. 이 비율은 과거 그래디언트 정보 대비 새 데이터 유지 비율에 영향을 미치며, 더 높은 β1은 더 부드럽지만 더 반응이 느린 추정치로 이어집니다.\u003c/p\u003e\n\u003cp\u003e편향된 두 번째 모멘트 추정 업데이트\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-TheMathBehindNadamOptimizer_5.png\" alt=\"매쓰사인네처날날담옵티마이저 그림 5\"\u003e\u003c/p\u003e\n\u003cp\u003e비슷하게, 두 번째 모멘트 (𝑣_𝑡)은 이전 그래디언트의 제곱의 지수 가중 평균을 추적합니다. 여기서 감쇠율 (β2, 일반적으로 약 0.999)은 매개변수 업데이트의 변동성에 따라 학습률을 조정하여 업데이트를 안정화하는 데 도움을 줍니다.\u003c/p\u003e\n\u003ch2\u003e2.3: 네스테로프 모멘텀 보정\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-TheMathBehindNadamOptimizer_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e여기서 Nadam은 일반적인 모멘트 계산을 수정하여 네스테로프 모멘텀을 통합합니다. 이 접근 방식은 그래디언트의 미래 위치를 예상하여 업데이트 방향을 보정합니다. 이러한 선행은 초기에 제로 초기화된 모멘트가 편향된 업데이트를 초래할 수 있는 훈련 초기에 특히 유용합니다.\u003c/p\u003e\n\u003ch2\u003e2.4: 편향 보정\u003c/h2\u003e\n\u003cp\u003e첫 번째 및 두 번째 모멘트 추정치의 편향을 보정하세요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-TheMathBehindNadamOptimizer_7.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e첫 번째와 두 번째 모멘트는 처음에는 영에서 시작하기 때문에 편향되어 있습니다. 이를 극복하기 위해 편향 보정 용어가 도입되었으며, 더 많은 반복이 완료됨에 따라 모멘트의 추정치를 점진적으로 확대하여, 추정치가 시간이 지남에 따라 보다 정확하고 진짜 기울기 정보를 반영하도록 보장합니다.\u003c/p\u003e\n\u003ch2\u003e2.5: 매개변수 업데이트\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-TheMathBehindNadamOptimizer_8.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e최종 매개변수 업데이트는 기울기의 방향에 대해 조정된 적응형 학습률(𝛼)과 작은 상수(𝜖, 10^(-8)과 같은)로 수치적 안정성을 위해 이루어집니다. 수정된 첫 번째 모멘트(𝑚_𝑡)와 수정된 두 번째 모멘트의 제곱근(𝑣_𝑡)은 이러한 업데이트를 적절하게 조정하는 데 사용되며, 기울기의 방향과 크기를 모두 고려합니다.\u003c/p\u003e\n\u003ch2\u003e2.6: Adam과의 주요 차이점\u003c/h2\u003e\n\u003cp\u003eNadam과 Adam 사이의 주요 차이점은 Nadam이 적극적으로 조정을 합니다. Adam은 현재 기울기 추정만을 의존하는 반면, Nadam은 Nesterov 모멘텀을 통해 앞서 보는 단계를 도입합니다. 이로 인해 미래의 기울기 방향을 예측뿐만 아니라 업데이트를 더 정확하게 조정하여 더 효율적인 학습 역학을 이끌어냅니다.\u003c/p\u003e\n\u003cp\u003eNadam은 Nesterov 모멘텀의 통합을 통해 최적화에 대해 보다 섬세하고 선심을 기울인 접근 방식을 제공하여 Adam보다 데이터 landscape를 효과적으로 탐색하고 적응하는 능력을 향상시킵니다. 이로써 Nadam은 다양한 머신 러닝 과제에 대한 견고한 선택지가 되며, 실제 결과를 선택할 때 이론적 통찰력과 실용적 결과를 모두 고려하도록 실무자에게 요청합니다.\u003c/p\u003e\n\u003ch2\u003e3. 실무에서 Nadam 구현\u003c/h2\u003e\n\u003cp\u003e이 섹션에서는 Nadam 옵티마이저를 처음부터 구축하고 머신 러닝 환경에서 적용할 것입니다. 우리는 선형 회귀 작업에 Nadam 옵티마이저를 구현하고 사용하는 맥락에서 코드를 여러 주요 섹션으로 분할할 것입니다.\u003c/p\u003e\n\u003cp\u003e아래의 코드를 살펴보고 싶다면, 오늘 다룰 코드와 추가적인 보너스 콘텐츠가 모두 포함된 이 Jupyter 노트북을 살펴보는 것을 고려해보세요:\u003c/p\u003e\n\u003ch2\u003e3.1: Nadam Optimizer Class Definition\u003c/h2\u003e\n\u003cp\u003eNadam 알고리즘을 사용하여 매개변수를 최적화하는 데 중요한 역할을 하는 NadamOptimizer 클래스를 자세히 살펴봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNadamOptimizer\u003c/span\u003e:\n    def \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(self, learning_rate=\u003cspan class=\"hljs-number\"\u003e0.001\u003c/span\u003e, beta1=\u003cspan class=\"hljs-number\"\u003e0.9\u003c/span\u003e, beta2=\u003cspan class=\"hljs-number\"\u003e0.999\u003c/span\u003e, epsilon=\u003cspan class=\"hljs-number\"\u003e1e-8\u003c/span\u003e):\n        self.\u003cspan class=\"hljs-property\"\u003elearning_rate\u003c/span\u003e = learning_rate\n        self.\u003cspan class=\"hljs-property\"\u003ebeta1\u003c/span\u003e = beta1\n        self.\u003cspan class=\"hljs-property\"\u003ebeta2\u003c/span\u003e = beta2\n        self.\u003cspan class=\"hljs-property\"\u003eepsilon\u003c/span\u003e = epsilon\n        self.\u003cspan class=\"hljs-property\"\u003em\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\n        self.\u003cspan class=\"hljs-property\"\u003ev\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\n        self.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\n    def \u003cspan class=\"hljs-title function_\"\u003einitialize_moments\u003c/span\u003e(self, params):\n        self.\u003cspan class=\"hljs-property\"\u003em\u003c/span\u003e = {\u003cspan class=\"hljs-attr\"\u003ek\u003c/span\u003e: np.\u003cspan class=\"hljs-title function_\"\u003ezeros_like\u003c/span\u003e(v) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e k, v \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e params.\u003cspan class=\"hljs-title function_\"\u003eitems\u003c/span\u003e()}\n        self.\u003cspan class=\"hljs-property\"\u003ev\u003c/span\u003e = {\u003cspan class=\"hljs-attr\"\u003ek\u003c/span\u003e: np.\u003cspan class=\"hljs-title function_\"\u003ezeros_like\u003c/span\u003e(v) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e k, v \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e params.\u003cspan class=\"hljs-title function_\"\u003eitems\u003c/span\u003e()}\n\n    def \u003cspan class=\"hljs-title function_\"\u003eupdate_params\u003c/span\u003e(self, params, grads):\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e self.\u003cspan class=\"hljs-property\"\u003em\u003c/span\u003e is \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e or self.\u003cspan class=\"hljs-property\"\u003ev\u003c/span\u003e is \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n            self.\u003cspan class=\"hljs-title function_\"\u003einitialize_moments\u003c/span\u003e(params)\n\n        self.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n        updated_params = {}\n        mu_t = self.\u003cspan class=\"hljs-property\"\u003ebeta1\u003c/span\u003e * (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e0.96\u003c/span\u003e ** (self.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e0.004\u003c/span\u003e))\n        mu_t1 = self.\u003cspan class=\"hljs-property\"\u003ebeta1\u003c/span\u003e * (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e0.96\u003c/span\u003e ** ((self.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) * \u003cspan class=\"hljs-number\"\u003e0.004\u003c/span\u003e))\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e key \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e params.\u003cspan class=\"hljs-title function_\"\u003ekeys\u003c/span\u003e():\n            g_tilde = grads[key] / (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - np.\u003cspan class=\"hljs-title function_\"\u003eprod\u003c/span\u003e([self.\u003cspan class=\"hljs-property\"\u003ebeta1\u003c/span\u003e] * self.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e))\n            self.\u003cspan class=\"hljs-property\"\u003em\u003c/span\u003e[key] = self.\u003cspan class=\"hljs-property\"\u003ebeta1\u003c/span\u003e * self.\u003cspan class=\"hljs-property\"\u003em\u003c/span\u003e[key] + (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - self.\u003cspan class=\"hljs-property\"\u003ebeta1\u003c/span\u003e) * grads[key]\n            self.\u003cspan class=\"hljs-property\"\u003ev\u003c/span\u003e[key] = self.\u003cspan class=\"hljs-property\"\u003ebeta2\u003c/span\u003e * self.\u003cspan class=\"hljs-property\"\u003ev\u003c/span\u003e[key] + (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - self.\u003cspan class=\"hljs-property\"\u003ebeta2\u003c/span\u003e) * np.\u003cspan class=\"hljs-title function_\"\u003esquare\u003c/span\u003e(grads[key])\n\n            m_corrected = self.\u003cspan class=\"hljs-property\"\u003em\u003c/span\u003e[key] / (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - mu_t1 ** self.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e)\n            v_corrected = self.\u003cspan class=\"hljs-property\"\u003ev\u003c/span\u003e[key] / (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - self.\u003cspan class=\"hljs-property\"\u003ebeta2\u003c/span\u003e ** self.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e)\n\n            m_bar = (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - mu_t) * g_tilde + mu_t1 * m_corrected\n\n            updated_params[key] = params[key] - self.\u003cspan class=\"hljs-property\"\u003elearning_rate\u003c/span\u003e * m_bar / (np.\u003cspan class=\"hljs-title function_\"\u003esqrt\u003c/span\u003e(v_corrected) + self.\u003cspan class=\"hljs-property\"\u003eepsilon\u003c/span\u003e)\n\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e updated_params\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNadamOptimizer 클래스는 Nadam 최적화 방법을 관리하고 실행하기 위해 구조화되어 있습니다. 아래는 클래스와 해당 함수들을 설명한 것입니다:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003einit\u003c/strong\u003e 메서드\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNadamOptimizer\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, learning_rate=\u003cspan class=\"hljs-number\"\u003e0.001\u003c/span\u003e, beta1=\u003cspan class=\"hljs-number\"\u003e0.9\u003c/span\u003e, beta2=\u003cspan class=\"hljs-number\"\u003e0.999\u003c/span\u003e, epsilon=\u003cspan class=\"hljs-number\"\u003e1e-8\u003c/span\u003e\u003c/span\u003e):\n        self.learning_rate = learning_rate\n        self.beta1 = beta1\n        self.beta2 = beta2\n        self.epsilon = epsilon\n        self.m = \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e\n        self.v = \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e\n        self.t = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e초기화 메서드는 최적화기를 학습률, 베타 값, 그리고 엡실론에 대한 미리 정의된 설정으로 설정합니다. 이러한 매개변수 각각은 중요한 역할을 합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e학습률: 이는 손실 함수의 최소값으로 이동하는 각 반복에서의 단계 크기를 결정합니다.\u003c/li\u003e\n\u003cli\u003ebeta1 및 beta2: 이러한 매개 변수는 기울기와 해당 제곱값의 이동 평균의 감쇠율을 제어하며 업데이트를 부드럽게 만들고 학습률을 동적으로 관리하는 데 도움이 됩니다.\u003c/li\u003e\n\u003cli\u003eepsilon: 계산 중에 0으로 나누는 것을 방지하기 위한 매우 작은 수입니다.\u003c/li\u003e\n\u003cli\u003eself.m 및 self.v: 초기에 None으로 설정되며 나중에는 각각 기울기와 제곱 기울기의 이동 평균을 저장합니다.\u003c/li\u003e\n\u003cli\u003eself.t: 업데이트 또는 반복 횟수를 추적하는 카운터입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 설정은 Nadam의 기본 측면과 일치하며, 적응형 학습률이 지속적으로 조정되어 수렴을 개선합니다.\u003c/p\u003e\n\u003cp\u003einitialize_moments 메서드\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    def \u003cspan class=\"hljs-title function_\"\u003einitialize_moments\u003c/span\u003e(self, params):\n        self.\u003cspan class=\"hljs-property\"\u003em\u003c/span\u003e = {\u003cspan class=\"hljs-attr\"\u003ek\u003c/span\u003e: np.\u003cspan class=\"hljs-title function_\"\u003ezeros_like\u003c/span\u003e(v) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e k, v \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e params.\u003cspan class=\"hljs-title function_\"\u003eitems\u003c/span\u003e()}\n        self.\u003cspan class=\"hljs-property\"\u003ev\u003c/span\u003e = {\u003cspan class=\"hljs-attr\"\u003ek\u003c/span\u003e: np.\u003cspan class=\"hljs-title function_\"\u003ezeros_like\u003c/span\u003e(v) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e k, v \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e params.\u003cspan class=\"hljs-title function_\"\u003eitems\u003c/span\u003e()}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 메소드는 이동 평균을 저장하는 딕셔너리 m과 v를 초기화합니다. 각 매개변수의 기울기와 제곱 기울기가 0으로 초기화되는데, 이는 최적화 프로세스의 후속 단계에서 계산을 시작하는 데 중요합니다.\u003c/p\u003e\n\u003cp\u003eupdate_params 메소드\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    def \u003cspan class=\"hljs-title function_\"\u003eupdate_params\u003c/span\u003e(self, params, grads):\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e self.\u003cspan class=\"hljs-property\"\u003em\u003c/span\u003e is \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e or self.\u003cspan class=\"hljs-property\"\u003ev\u003c/span\u003e is \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n            self.\u003cspan class=\"hljs-title function_\"\u003einitialize_moments\u003c/span\u003e(params)\n\n        self.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n        updated_params = {}\n        mu_t = self.\u003cspan class=\"hljs-property\"\u003ebeta1\u003c/span\u003e * (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e0.96\u003c/span\u003e ** (self.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e0.004\u003c/span\u003e))\n        mu_t1 = self.\u003cspan class=\"hljs-property\"\u003ebeta1\u003c/span\u003e * (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e0.96\u003c/span\u003e ** ((self.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) * \u003cspan class=\"hljs-number\"\u003e0.004\u003c/span\u003e))\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e key \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e params.\u003cspan class=\"hljs-title function_\"\u003ekeys\u003c/span\u003e():\n            g_tilde = grads[key] / (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - np.\u003cspan class=\"hljs-title function_\"\u003eprod\u003c/span\u003e([self.\u003cspan class=\"hljs-property\"\u003ebeta1\u003c/span\u003e] * self.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e))\n            self.\u003cspan class=\"hljs-property\"\u003em\u003c/span\u003e[key] = self.\u003cspan class=\"hljs-property\"\u003ebeta1\u003c/span\u003e * self.\u003cspan class=\"hljs-property\"\u003em\u003c/span\u003e[key] + (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - self.\u003cspan class=\"hljs-property\"\u003ebeta1\u003c/span\u003e) * grads[key]\n            self.\u003cspan class=\"hljs-property\"\u003ev\u003c/span\u003e[key] = self.\u003cspan class=\"hljs-property\"\u003ebeta2\u003c/span\u003e * self.\u003cspan class=\"hljs-property\"\u003ev\u003c/span\u003e[key] + (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - self.\u003cspan class=\"hljs-property\"\u003ebeta2\u003c/span\u003e) * np.\u003cspan class=\"hljs-title function_\"\u003esquare\u003c/span\u003e(grads[key])\n\n            m_corrected = self.\u003cspan class=\"hljs-property\"\u003em\u003c/span\u003e[key] / (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - mu_t1 ** self.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e)\n            v_corrected = self.\u003cspan class=\"hljs-property\"\u003ev\u003c/span\u003e[key] / (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - self.\u003cspan class=\"hljs-property\"\u003ebeta2\u003c/span\u003e ** self.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e)\n\n            m_bar = (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - mu_t) * g_tilde + mu_t1 * m_corrected\n\n            updated_params[key] = params[key] - self.\u003cspan class=\"hljs-property\"\u003elearning_rate\u003c/span\u003e * m_bar / (np.\u003cspan class=\"hljs-title function_\"\u003esqrt\u003c/span\u003e(v_corrected) + self.\u003cspan class=\"hljs-property\"\u003eepsilon\u003c/span\u003e)\n\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e updated_params\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 함수는 Nadam 옵티마이저의 핵심입니다. 전달된 기울기를 기반으로 매개변수를 업데이트합니다. 포함된 단계는 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e순간 초기화 확인\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e self.\u003cspan class=\"hljs-property\"\u003em\u003c/span\u003e이 \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e이거나 self.\u003cspan class=\"hljs-property\"\u003ev\u003c/span\u003e가 \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e이면:\n            self.\u003cspan class=\"hljs-title function_\"\u003einitialize_moments\u003c/span\u003e(params)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 m 또는 v가 초기화되지 않았다면 0으로 설정됩니다.\u003c/p\u003e\n\u003cp\u003e시간 단계 업데이트\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e셀프.티 += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edecay factors를 동적으로 조절하는 시간 단계 t를 증가시킵니다.\u003c/p\u003e\n\u003cp\u003e네스테로프 모멘텀 조정\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e뮤_티 = self.\u003cspan class=\"hljs-property\"\u003ebeta1\u003c/span\u003e * (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e0.96\u003c/span\u003e ** (self.티 * \u003cspan class=\"hljs-number\"\u003e0.004\u003c/span\u003e))\n뮤_t1 = self.\u003cspan class=\"hljs-property\"\u003ebeta1\u003c/span\u003e * (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e0.96\u003c/span\u003e ** ((self.티 + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) * \u003cspan class=\"hljs-number\"\u003e0.004\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emu_t 및 mu_t1은 시간 단계의 진행을 고려하여 Nesterov 모멘텀의 효과를 반영하기 위해 beta1을 조정합니다. 이러한 조정은 모멘텀이 미래의 기울기를 더 효과적으로 반영하도록 합니다.\u003c/p\u003e\n\u003cp\u003e각 매개변수를 순회하면서:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e key \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e params.\u003cspan class=\"hljs-title function_\"\u003ekeys\u003c/span\u003e():\n      g_tilde = grads[key] / (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - np.\u003cspan class=\"hljs-title function_\"\u003eprod\u003c/span\u003e([self.\u003cspan class=\"hljs-property\"\u003ebeta1\u003c/span\u003e] * self.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e))\n      self.\u003cspan class=\"hljs-property\"\u003em\u003c/span\u003e[key] = self.\u003cspan class=\"hljs-property\"\u003ebeta1\u003c/span\u003e * self.\u003cspan class=\"hljs-property\"\u003em\u003c/span\u003e[key] + (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - self.\u003cspan class=\"hljs-property\"\u003ebeta1\u003c/span\u003e) * grads[key]\n      self.\u003cspan class=\"hljs-property\"\u003ev\u003c/span\u003e[key] = self.\u003cspan class=\"hljs-property\"\u003ebeta2\u003c/span\u003e * self.\u003cspan class=\"hljs-property\"\u003ev\u003c/span\u003e[key] + (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - self.\u003cspan class=\"hljs-property\"\u003ebeta2\u003c/span\u003e) * np.\u003cspan class=\"hljs-title function_\"\u003esquare\u003c/span\u003e(grads[key])\n\n      m_corrected = self.\u003cspan class=\"hljs-property\"\u003em\u003c/span\u003e[key] / (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - mu_t1 ** self.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e)\n      v_corrected = self.\u003cspan class=\"hljs-property\"\u003ev\u003c/span\u003e[key] / (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - self.\u003cspan class=\"hljs-property\"\u003ebeta2\u003c/span\u003e ** self.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e)\n\n      m_bar = (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - mu_t) * g_tilde + mu_t1 * m_corrected\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eg_tilde은 과거 그래디언트의 감쇠를 현재 시간 단계까지 반영한 조정된 기울기를 계산합니다. 이는 lookahead를 포함하여 그래디언트 계산을 수정하여 Nesterov 모멘텀의 효과를 나타냅니다.\u003c/p\u003e\n\u003cp\u003e나중에는 새로운 기울기와 조정된 베타 값에 기초하여 각 매개변수에 대해 m과 v를 조정합니다. 이 단계는 과거 기울기의 모멘텀 이점과 새로운 기울기에 대한 적응성을 결합하는 중요한 단계입니다.\u003c/p\u003e\n\u003cp\u003em_corrected와 v_corrected는 편향이 수정된 제1 및 제2 모먼트의 추정치를 나타냅니다. 바이어스 보정은 계산된 기울기가 더 적을 때 교육 초기에 중요합니다.\u003c/p\u003e\n\u003cp\u003em_bar는 미래의 그래디언트와 모멘텀이 보정된 그래디언트를 결합하여 매개변수 공간에서 취해야 할 단계의 방향과 크기를 효과적으로 결정합니다.\u003c/p\u003e\n\u003cp\u003e매개변수 업데이트\u003c/p\u003e\n\u003cp\u003eupdated_params[key] = params[key] - self.learning_rate * m_bar / (np.sqrt(v_corrected) + self.epsilon)\u003c/p\u003e\n\u003cp\u003e모든 매개변수는 m_bar와 조정된 학습률에 의해 업데이트되며, v_corrected에 제곱근을 더한 것으로 스케일링됩니다. 이 단계는 실제 매개변수 업데이트가 발생하는 곳으로, 모델의 학습에 직접적인 영향을 미칩니다.\u003c/p\u003e\n\u003ch2\u003e3.2: 선형 회귀 모델 클래스\u003c/h2\u003e\n\u003cp\u003e이제 간단한 회귀 모델을 구축하고, Nadam 옵티마이저를 적용해 보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 선형 회귀 모델\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLinearRegression\u003c/span\u003e:\n    def \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(self, n_features):\n        self.\u003cspan class=\"hljs-property\"\u003eweights\u003c/span\u003e = np.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandn\u003c/span\u003e(n_features)\n        self.\u003cspan class=\"hljs-property\"\u003ebias\u003c/span\u003e = np.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandn\u003c/span\u003e()\n\n    def \u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(self, X):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e np.\u003cspan class=\"hljs-title function_\"\u003edot\u003c/span\u003e(X, self.\u003cspan class=\"hljs-property\"\u003eweights\u003c/span\u003e) + self.\u003cspan class=\"hljs-property\"\u003ebias\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003cstrong\u003einit\u003c/strong\u003e 메서드는 features 수에 기반하여 랜덤한 weights와 biases로 모델을 초기화합니다.\u003c/p\u003e\n\u003cp\u003e그런 다음 predict 메서드는 입력과 weights 및 bias의 내적을 사용하여 예측을 계산합니다.\u003c/p\u003e\n\u003cp\u003e여기서 선형 회귀는 Nadam이 어떻게 작동하는지 이해하는 간단한 방법을 제공하지만, 실제로는 더 복잡한 딥러닝 모델에서 Nadam을 사용하려고 할 것입니다. 그렇다면, 가장 인기 있는 딥러닝 모델 중 일부를 포괄적으로 이해할 수 있는 다음의 글을 살펴보고 그 코드를 수정하여 Nadam을 구현해보기를 강력히 추천합니다:```\u003c/p\u003e\n\u003ch2\u003e3.3: Model Trainer Class\u003c/h2\u003e\n\u003cp\u003e앞으로 나아가봅시다. 이제는 지정된 최적화 도구를 사용하여 머신 러닝 모델을 훈련시키는 전체 과정을 캡슐화하는 클래스가 필요합니다. 이것이 바로 ModelTrainer 클래스가 할 일입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eModelTrainer\u003c/span\u003e:\n    def \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(self, model, optimizer, n_epochs):\n        self.\u003cspan class=\"hljs-property\"\u003emodel\u003c/span\u003e = model\n        self.\u003cspan class=\"hljs-property\"\u003eoptimizer\u003c/span\u003e = optimizer\n        self.\u003cspan class=\"hljs-property\"\u003en_epochs\u003c/span\u003e = n_epochs\n\n    def \u003cspan class=\"hljs-title function_\"\u003ecompute_gradients\u003c/span\u003e(self, X, y):\n        predictions = self.\u003cspan class=\"hljs-property\"\u003emodel\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(X)\n        errors = predictions - y\n        dW = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * np.\u003cspan class=\"hljs-title function_\"\u003edot\u003c/span\u003e(X.\u003cspan class=\"hljs-property\"\u003eT\u003c/span\u003e, errors) / \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(y)\n        db = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * np.\u003cspan class=\"hljs-title function_\"\u003emean\u003c/span\u003e(errors)\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\u003cspan class=\"hljs-string\"\u003e'weights'\u003c/span\u003e: dW, \u003cspan class=\"hljs-string\"\u003e'bias'\u003c/span\u003e: db}\n\n    def \u003cspan class=\"hljs-title function_\"\u003etrain\u003c/span\u003e(self, X, y, verbose=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e epoch \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(self.\u003cspan class=\"hljs-property\"\u003en_epochs\u003c/span\u003e):\n            grads = self.\u003cspan class=\"hljs-title function_\"\u003ecompute_gradients\u003c/span\u003e(X, y)\n            params = {\u003cspan class=\"hljs-string\"\u003e'weights'\u003c/span\u003e: self.\u003cspan class=\"hljs-property\"\u003emodel\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eweights\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'bias'\u003c/span\u003e: self.\u003cspan class=\"hljs-property\"\u003emodel\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ebias\u003c/span\u003e}\n            updated_params = self.\u003cspan class=\"hljs-property\"\u003eoptimizer\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eupdate_params\u003c/span\u003e(params, grads)\n\n            self.\u003cspan class=\"hljs-property\"\u003emodel\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eweights\u003c/span\u003e = updated_params[\u003cspan class=\"hljs-string\"\u003e'weights'\u003c/span\u003e]\n            self.\u003cspan class=\"hljs-property\"\u003emodel\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ebias\u003c/span\u003e = updated_params[\u003cspan class=\"hljs-string\"\u003e'bias'\u003c/span\u003e]\n\n            # \u003cspan class=\"hljs-title class_\"\u003eOptionally\u003c/span\u003e, print loss here to observe training\n            loss = np.\u003cspan class=\"hljs-title function_\"\u003emean\u003c/span\u003e((self.\u003cspan class=\"hljs-property\"\u003emodel\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(X) - y) ** \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e epoch % \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e and \u003cspan class=\"hljs-attr\"\u003everbose\u003c/span\u003e:\n                \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"Epoch {epoch}, Loss: {loss}\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003einit\u003c/strong\u003e 메서드\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, model, optimizer, n_epochs\u003c/span\u003e):\n        self.model = model\n        self.optimizer = optimizer\n        self.n_epochs = n_epochs\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 생성자 메서드는 세 가지 주요 구성 요소로 트레이너를 초기화합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emodel: 훈련될 머신러닝 모델이며, 예측을 수행하는 메서드와 매개변수(가중치 및 편향)에 대한 속성이 있어야 합니다.\u003c/li\u003e\n\u003cli\u003eoptimizer: Nadam과 같은 옵티마이저 클래스의 인스턴스로, 계산된 그래디언트에 기초하여 모델의 매개변수를 업데이트하는 역할을 담당합니다.\u003c/li\u003e\n\u003cli\u003en_epochs: 훈련 프로세스가 실행할 훈련 데이터 세트를 전체적으로 순회하는 횟수입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 구성 요소는 손실 함수를 최소화하기 위해 모델의 매개변수가 반복적으로 업데이트되는 훈련 프로세스를 설정하는 데 필수적입니다.\u003c/p\u003e\n\u003cp\u003ecompute_gradients 메서드\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecompute_gradients\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, X, y\u003c/span\u003e):\n    predictions = self.model.predict(X)\n    errors = predictions - y\n    dW = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * np.dot(X.T, errors) / \u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(y)\n    db = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * np.mean(errors)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\u003cspan class=\"hljs-string\"\u003e'weights'\u003c/span\u003e: dW, \u003cspan class=\"hljs-string\"\u003e'bias'\u003c/span\u003e: db}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 메서드는 모델 매개변수에 대한 손실 함수의 그래디언트를 계산합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003epredictions = self.model.predict(X)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음은 모델이 현재 매개변수를 사용하여 입력 X를 기반으로 출력을 예측하는 부분입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e오류 = 예측 - y\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드 라인은 예측된 출력과 실제 출력인 y와의 차이, 즉 오차를 나타냅니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edW = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * np.\u003cspan class=\"hljs-title function_\"\u003edot\u003c/span\u003e(X.\u003cspan class=\"hljs-property\"\u003eT\u003c/span\u003e, 오류) / \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(y)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 가중치의 기울기를 계산합니다. 가중치에 대한 평균 제곱 오차 손실 함수의 도함수는 len(y)의 데이터 포인트에 의해 조정된 표현으로 주어집니다. 이는 모든 특성과 데이터 포인트에 대한 기울기를 효율적으로 계산하는 벡터화된 구현입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edb = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * np.\u003cspan class=\"hljs-title function_\"\u003emean\u003c/span\u003e(errors)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마찬가지로, 이는 편향의 기울기를 계산하며, 이는 단순히 오차의 평균에 2를 곱한 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\u003cspan class=\"hljs-string\"\u003e'weights'\u003c/span\u003e: dW, \u003cspan class=\"hljs-string\"\u003e'bias'\u003c/span\u003e: db}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러면 메서드는 이러한 그래디언트를 딕셔너리로 반환하여 모델의 매개변수를 업데이트하는 데 사용할 수 있도록 합니다. 이 메서드는 옵티마이저가 손실을 최소화하기 위해 매개변수를 조정해야 하는 필수적인 기울기 계산 단계를 캡슐화합니다.\u003c/p\u003e\n\u003cp\u003etrain 메서드\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etrain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, X, y, verbose=\u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e epoch \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003erange\u003c/span\u003e(self.n_epochs):\n            grads = self.compute_gradients(X, y)\n            params = {\u003cspan class=\"hljs-string\"\u003e'weights'\u003c/span\u003e: self.model.weights, \u003cspan class=\"hljs-string\"\u003e'bias'\u003c/span\u003e: self.model.bias}\n            updated_params = self.optimizer.update_params(params, grads)\n\n            self.model.weights = updated_params[\u003cspan class=\"hljs-string\"\u003e'weights'\u003c/span\u003e]\n            self.model.bias = updated_params[\u003cspan class=\"hljs-string\"\u003e'bias'\u003c/span\u003e]\n\n            \u003cspan class=\"hljs-comment\"\u003e# 선택사항: 여기서 손실을 출력하여 학습을 관찰합니다\u003c/span\u003e\n            loss = np.mean((self.model.predict(X) - y) ** \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e epoch % \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eand\u003c/span\u003e verbose:\n                \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef\"Epoch \u003cspan class=\"hljs-subst\"\u003e{epoch}\u003c/span\u003e, Loss: \u003cspan class=\"hljs-subst\"\u003e{loss}\u003c/span\u003e\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 메서드는 각 epoch(데이터를 완전히 통과하는 단계)마다 n_epochs에 이르기까지 반복됩니다. 루프 내에서 현재 매개변수와 데이터 집합에 대해 compute_gradients를 사용하여 그래디언트를 먼저 계산합니다.\u003c/p\u003e\n\u003cp\u003e그런 다음 이러한 그래디언트를 현재 매개변수와 함께 옵티마이저(self.optimizer.update_params(params, grads))에 전달하고, 옵티마이저는 최적화 알고리즘(예: Nadam)을 기반으로 업데이트된 매개변수를 반환합니다.\u003c/p\u003e\n\u003cp\u003e모델의 매개변수는 이러한 새 값으로 업데이트되어 손실을 최소화하는 상태로 움직이게 됩니다.\u003c/p\u003e\n\u003cp\u003everbose가 True로 설정되어 있는 경우, 메서드는 1000번의 epoch마다 손실을 인쇄하여 교육 진행 상황을 모니터링합니다. 손실은 예측 값과 실제 출력 사이의 평균 제곱 오차로 계산되며, 모델의 성능을 얼마나 잘 평가하고 있는지에 대한 간단한 지표를 제공합니다.\u003c/p\u003e\n\u003cp\u003etrain 메서드는 따라서 전체 교육 과정을 조정하며, 손실 함수의 피드백에 기초하여 옵티마이저를 통해 모델의 매개변수를 반복적으로 조정합니다. 이 메서드는 머신러닝에서 사용되는 반복적 최적화 기법의 실용적 구현이며, 그래디언트 하강과 매개변수 업데이트의 이론적 원리를 직접 적용하여 여러 번의 반복을 통해 미리 정의된 손실 함수를 최소화합니다.\u003c/p\u003e\n\u003ch2\u003e3.4: 데이터셋 처리 및 모델 훈련\u003c/h2\u003e\n\u003cp\u003e마지막으로, Nadam 옵티마이저를 사용하여 머신러닝 모델을 설정, 훈련 및 평가해 봅시다. 이 접근 방식은 데이터 조작, Optuna를 사용한 하이퍼파라미터 튜닝, 그리고 모델의 효과를 개선하고 평가하기 위한 반복적인 훈련 및 테스트를 포함합니다.\u003c/p\u003e\n\u003ch3\u003e3.4.1: 데이터 준비\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-comment\"\u003e# 입력 피처(X) 및 타겟 값(y) 가져오기\u003c/span\u003e\nX = diabetes.data\ny = diabetes.target\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우선, 당뇨 데이터셋에서 피처 데이터(X)와 타겟값(y)을 불러옵니다. 이 데이터셋은 sci-kit learn에서 가져오며 상업적 이용이 가능합니다. (Scikit-learn: Python의 머신 러닝, Pedregosa et al., JMLR 12, pp. 2825–2830, 2011.)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 데이터셋을 훈련 세트와 테스트 세트로 나눕니다\ndef \u003cspan class=\"hljs-title function_\"\u003esplit_dataset\u003c/span\u003e(X, y, test_ratio=\u003cspan class=\"hljs-number\"\u003e0.2\u003c/span\u003e):\n    indices = np.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epermutation\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(X))\n    test_size = \u003cspan class=\"hljs-title function_\"\u003eint\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(X) * test_ratio)\n    test_indices = indices[:test_size]\n    train_indices = indices[\u003cspan class=\"hljs-attr\"\u003etest_size\u003c/span\u003e:]\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e X[train_indices], X[test_indices], y[train_indices], y[test_indices]\n\nX_train, X_test, y_train, y_test = \u003cspan class=\"hljs-title function_\"\u003esplit_dataset\u003c/span\u003e(X, y)\nX_train, X_val, y_train, y_val = \u003cspan class=\"hljs-title function_\"\u003esplit_dataset\u003c/span\u003e(X_train, y_train)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003esplit_dataset 함수는 지정된 비율에 따라 데이터셋을 훈련 세트와 테스트 세트로 무작위로 분할합니다. 데이터셋 인덱스를 섞어 분할을 무작위로 다양하게 만들어 모델 평가를 견고하게 합니다. 훈련 세트는 모델 매개변수를 학습하는 데 사용되고, 테스트 세트는 모델이 보지 못한 데이터에서 얼마나 잘 수행되는지를 평가합니다.\u003c/p\u003e\n\u003cp\u003e3.4.2: Optuna을 이용한 하이퍼파라미터 튜닝\n우리는 Optuna를 사용하여 모델의 하이퍼파라미터를 최적화할 것이며, 이는 훈련 동적과 Nadam 옵티마이저의 효과에 상당한 영향을 미칩니다.\u003c/p\u003e\n\u003cp\u003e다른 기사에서 우리는 옵투나(optuna)를 광범위하게 다루었습니다. 거기에서는 이를 신경망에 적용하여 성공적으로 세밀하게 조정하는 방법을 보여주었습니다. 만약 Nadam을 더 복잡한 모델에 적용하고 싶다면, 이 기사를 읽어보시면 좋을 것 같아요:\u003c/p\u003e\n\u003cp\u003e목적 함수 정의\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eobjective\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etrial\u003c/span\u003e):\n    n_features = X_train.shape[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n\n    learning_rate = trial.suggest_loguniform(\u003cspan class=\"hljs-string\"\u003e'learning_rate'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1e-5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1e-1\u003c/span\u003e)\n    beta1 = trial.suggest_uniform(\u003cspan class=\"hljs-string\"\u003e'beta1'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.9\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.999\u003c/span\u003e)\n    beta2 = trial.suggest_uniform(\u003cspan class=\"hljs-string\"\u003e'beta2'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.99\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.9999\u003c/span\u003e)\n    epsilon = trial.suggest_loguniform(\u003cspan class=\"hljs-string\"\u003e'epsilon'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1e-10\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1e-5\u003c/span\u003e)\n\n    n_epochs = trial.suggest_int(\u003cspan class=\"hljs-string\"\u003e'epochs'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e100000\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-comment\"\u003e# Define the model\u003c/span\u003e\n    model = LinearRegression(n_features)\n    optimizer = NadamOptimizer(learning_rate=learning_rate, beta1=beta1, beta2=beta2, epsilon=epsilon)\n    trainer = ModelTrainer(model, optimizer, n_epochs=n_epochs)\n\n    \u003cspan class=\"hljs-comment\"\u003e# Train the model\u003c/span\u003e\n    trainer.train(X_train, y_train, verbose=\u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-comment\"\u003e# Compute the validation loss\u003c/span\u003e\n    val_loss = np.mean((model.predict(X_val) - y_val) ** \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e val_loss\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리의 목적 함수는 옵투나(optuna)의 최적화 과정을 안내하는 중요한 역할을 합니다. 각 시도는 다음 값을 제안합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e학습률: 매개변수 업데이트의 단계 크기에 영향을 줍니다.\u003c/li\u003e\n\u003cli\u003ebeta1 및 beta2: 그래디언트 및 그들의 제곱값에 대한 평균의 감쇠율을 조절합니다.\u003c/li\u003e\n\u003cli\u003eepsilon: 업데이트 중에 0으로 나누는 것을 방지하기 위해 작은 값이 추가됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e각 시도는 이러한 매개변수를 사용하여 LinearRegression 모델과 NadamOptimizer를 설정하고, ModelTrainer를 사용하여 모델을 훈련합니다. 훈련 후, 검증 세트에서의 검증 손실을 계산하여 하이퍼파라미터의 효과를 Optuna에 제공합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 연구 객체 생성\noptuna.\u003cspan class=\"hljs-property\"\u003elogging\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eset_verbosity\u003c/span\u003e(optuna.\u003cspan class=\"hljs-property\"\u003elogging\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eWARNING\u003c/span\u003e)\nstudy = optuna.\u003cspan class=\"hljs-title function_\"\u003ecreate_study\u003c/span\u003e(direction=\u003cspan class=\"hljs-string\"\u003e'minimize'\u003c/span\u003e, sampler=optuna.\u003cspan class=\"hljs-property\"\u003esamplers\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eTPESampler\u003c/span\u003e(seed=\u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e))\n\n# 연구 개선, 더 많은 시행을 사용하여 더 나은 결과를 얻거나, 더 적은 시행을 사용하여 더 비용 효율적일 수 있습니다\nstudy.\u003cspan class=\"hljs-title function_\"\u003eoptimize\u003c/span\u003e(objective, n_trials=\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOptuna가 최적의 매개변수를 식별한 후, 최종 모델이 구성되고 훈련됩니다. 이 단계에서는 테스트 세트에서 모델의 일반화 능력을 평가합니다.\u003c/p\u003e\n\u003cp\u003e훈련 및 평가\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 최적 모델 가져오기\nn_features = X_train.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\nbest_model = \u003cspan class=\"hljs-title class_\"\u003eLinearRegression\u003c/span\u003e(n_features)\noptimizer = \u003cspan class=\"hljs-title class_\"\u003eNadamOptimizer\u003c/span\u003e(learning_rate=study.\u003cspan class=\"hljs-property\"\u003ebest_params\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e'learning_rate'\u003c/span\u003e],\n                          beta1=study.\u003cspan class=\"hljs-property\"\u003ebest_params\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e'beta1'\u003c/span\u003e],\n                          beta2=study.\u003cspan class=\"hljs-property\"\u003ebest_params\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e'beta2'\u003c/span\u003e],\n                          epsilon=study.\u003cspan class=\"hljs-property\"\u003ebest_params\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e'epsilon'\u003c/span\u003e])\n\n# 모델 훈련하기\ntrainer = \u003cspan class=\"hljs-title class_\"\u003eModelTrainer\u003c/span\u003e(best_model, optimizer, n_epochs=study.\u003cspan class=\"hljs-property\"\u003ebest_params\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e'epochs'\u003c/span\u003e])\ntrainer.\u003cspan class=\"hljs-title function_\"\u003etrain\u003c/span\u003e(X_train, y_train)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOptuna의 최적 매개변수를 사용하여 모델은 추가 훈련을 받습니다. 이 추가 훈련을 통해 모델이 데이터에 완전히 적응하도록 보장합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 테스트 손실 계산하기\ntest_loss = np.\u003cspan class=\"hljs-title function_\"\u003emean\u003c/span\u003e((best_model.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(X_test) - y_test) ** \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)**\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'테스트 손실: {test_loss:.2f}'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마침내, 새로운, 보지 못했던 데이터에 대한 모델의 예측 정확도를 평가하기 위해 시험 손실을 계산합니다. 이 측정값은 모델의 실용적 성능을 평가하는 데 중요합니다.\u003c/p\u003e\n\u003ch1\u003e4. 장점과 고려 사항\u003c/h1\u003e\n\u003ch2\u003e4.1 Nadam이 뛰어난 점\u003c/h2\u003e\n\u003cp\u003eNadam은 Adam을 바탕으로 네스테로프 모멘텀을 통합하여, 그레이디언트가 믿을 수 없거나 에포크 간 크게 다를 수 있는 복잡한 최적화 작업을 처리할 수 있는 능력을 향상시킵니다. 여기에서 Nadam이 빛을 발합니다:\u003c/p\u003e\n\u003cp\u003e딥 뉴럴 네트워크: Nadam은 수렴 속도가 중요한 딥 뉴럴 네트워크의 학습에서 뛰어납니다. 미래를 예측하는 기능이 수렴 속도를 높이는 데 도움을 주어 모델이 최적이 아닌 해결책에 갇히지 않도록 합니다.\u003c/p\u003e\n\u003cp\u003e희소한 데이터: 텍스트나 대규모 범주형 데이터와 같은 많은 영 피처를 포함한 데이터셋에 대해서는 Nadam이 매개변수 업데이트를 더 효과적으로 조정하여 희소한 정보를 더 잘 관리합니다.\u003c/p\u003e\n\u003cp\u003e잡음이 많은 데이터: 실시간 스트림이나 온라인 학습과 같이 잡음이 많은 데이터 환경에서는 Nadam의 변동 데이터 처리 및 적응형 학습률 조정이 특히 유용합니다.\u003c/p\u003e\n\u003ch2\u003e4.2 한계와 도전과제\u003c/h2\u003e\n\u003cp\u003e그 강점에도 불구하고, Nadam은 항상 최적의 선택이 되지는 않습니다:\u003c/p\u003e\n\u003cp\u003e간단한 문제: 오차 함수가 잘 행동하고 국소 최솟값이 적은 간단한 작업의 경우, SGD와 같은 간단한 옵티마이저가 연산 요구가 적어 더 효율적일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e메모리 집약적 모델: Nadam은 그래디언트와 제곱 그래디언트의 모멘트 추정 값을 저장해야 하므로, 더 간단한 방법과 비교하여 메모리 사용량이 증가합니다. 이는 메모리 제한 환경에서 문제가 될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e하이퍼파라미터 민감도: Nadam의 성능은 𝛽1, 𝛽2 및 학습률과 같은 하이퍼파라미터의 설정에 민감합니다. 올바른 조정을 위해 포괄적인 테스트 또는 하이퍼파라미터 최적화 도구가 필요할 수 있으며, 최적의 성능을 위해 필수적입니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003eNadam을 탐색하는 것은 Nesterov 운동량과 Adam의 적응형 모멘트 추정을 결합하여 복잡한 머신 러닝 모델을 최적화하는데 중요한 발전을 나타냅니다. Nadam은 Adam에 선행 지식을 추가하여 매개변수 업데이트를 개선하고 수렴 속도를 향상시키며 다양한 어려운 데이터 환경에서 학습 과정을 안정화시킵니다.\u003c/p\u003e\n\u003cp\u003eNadam은 최적화 알고리즘 분야에서 상당한 향상을 제공하지만, Adam보다 선택하는 것은 머신 러닝 프로젝트의 특정 요구 사항과 제약 사항을 신중히 고려해야 합니다. 최적화 기술의 지속적인 진화는 능력을 향상시키고 새로운 가능성을 열어주며, 더 많은 연구와 실험을 위한 활기찬 분야로 만들어 냅니다.\u003c/p\u003e\n\u003ch1\u003e참고문헌\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eDozat, T. (2016). “Incorporating Nesterov Momentum into Adam.” ICLR Workshop.\u003c/li\u003e\n\u003cli\u003eKingma, D. P., \u0026#x26; Ba, J. (2014). “Adam: A Method for Stochastic Optimization.” arXiv preprint arXiv:1412.6980.\u003c/li\u003e\n\u003cli\u003eNesterov, Y. (1983). “A Method for Unconstrained Convex Minimization Problem with the Rate of Convergence 𝑂(1/𝑘2)O(1/k2).” Doklady AN USSR.\u003c/li\u003e\n\u003cli\u003eRuder, S. (2016). “An overview of gradient descent optimization algorithms.” arXiv preprint arXiv:1609.04747.\u003c/li\u003e\n\u003cli\u003eBottou, L., Curtis, F. E., \u0026#x26; Nocedal, J. (2018). “Optimization Methods for Large-Scale Machine Learning.” SIAM Review, 60(2), 223–311.\u003c/li\u003e\n\u003cli\u003eZhang, M. R., Lucas, J., Ba, J., \u0026#x26; Hinton, G. E. (2019). “Lookahead Optimizer: k steps forward, 1 step back.” arXiv preprint arXiv:1907.08610.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e당신은 끝까지 왔습니다. 축하해요! 이 기사를 즐겼다면 좋아요를 누르고 저를 팔로우해주시면 감사하겠습니다. 저는 주기적으로 비슷한 기사를 게시할 것이기 때문에, 재미있게 보아 주실 것을 희망합니다. 제 목표는 가장 인기 있는 알고리즘을 모두 처음부터 다시 만들어 기계 학습을 모두에게 접근 가능하게 하는 것입니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-20-TheMathBehindNadamOptimizer"},"buildId":"RZIEBQ2aNAp_DXFVTV6eL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>