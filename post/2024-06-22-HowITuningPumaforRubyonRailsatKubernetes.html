<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Kubernetes 환경에서 Ruby on Rails의 Puma 튜닝 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Kubernetes 환경에서 Ruby on Rails의 Puma 튜닝 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Kubernetes 환경에서 Ruby on Rails의 Puma 튜닝 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes" data-gatsby-head="true"/><meta name="twitter:title" content="Kubernetes 환경에서 Ruby on Rails의 Puma 튜닝 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 22:29" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/-dPCbnM2yhdKNgXe92VJV/_buildManifest.js" defer=""></script><script src="/_next/static/-dPCbnM2yhdKNgXe92VJV/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Kubernetes 환경에서 Ruby on Rails의 Puma 튜닝 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Kubernetes 환경에서 Ruby on Rails의 Puma 튜닝 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">14<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>쿠버네티스에 맞게 Puma 튜닝하기</h2>
<p>Puma는 Ruby on Rails용 인기 있는 웹 서버 패키지이며, Puma 구성을 잘 튜닝하면 서비스 효율성이 더욱 향상됩니다.</p>
<p>Puma 젬: <a href="https://rubygems.org/gems/puma" rel="nofollow" target="_blank">https://rubygems.org/gems/puma</a></p>
<p><img src="/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_0.png" alt="이미지"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>왜 리팩토링 해야 하나요?</h1>
<p>가장 중요한 이유는 도커에서 쿠버네티스 아키텍처로 마이그레이션할 때, Puma 구성을 새 아키텍처에 맞게 업데이트해야 할 수도 있다는 것입니다. 따라서, 저는 많은 기사와 소스 저장소를 재조사하여 이를 다시 작성하는 데 도움을 받았어요.</p>
<h1>Puma 구성 튜닝을 하기 전, 확인해야 할 사항</h1>
<ul>
<li>처음에는 가장 중요한 서비스를 사용하지 마세요. 그 대신 부수적인 서비스를 사용하세요.
예를 들어, 먼저 테스트할 때 회원 OAuth 서비스를 사용하지 마세요. 이 예에서, 저는 테스트용으로 메일 센터를 사용했어요. (대부분의 요청이 내부 호출이며, 요청이 실패하면 다시 시도합니다.)</li>
<li>서비스의 온라인 상태를 확인하기 위해 모니터링 서비스 중 하나가 반드시 필요해요. 저는 서비스와 쿠버네티스 상태를 확인하기 위해 Datadog를 사용하고 있어요.</li>
<li>각 구성 설정과 단계별 튜닝을 위해 왜 그리고 어떻게 하는지 알아야 해요.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>Puma 구성 리팩터링</h1>
<h2>우리의 초기 Puma 구성</h2>
<p>첫 번째 구성은 다음과 같습니다.</p>
<pre><code class="hljs language-js">#!<span class="hljs-regexp">/usr/</span>bin/env puma

environment <span class="hljs-variable constant_">ENV</span>.<span class="hljs-title function_">fetch</span>(<span class="hljs-params"><span class="hljs-string">"RAILS_ENV"</span></span>) { <span class="hljs-string">"development"</span> }

<span class="hljs-keyword">if</span> <span class="hljs-variable constant_">ENV</span>[<span class="hljs-string">'RAILS_ENV'</span>].<span class="hljs-property">nil</span>? || <span class="hljs-variable constant_">ENV</span>[<span class="hljs-string">'RAILS_ENV'</span>] == <span class="hljs-string">'development'</span>
  threads_count = <span class="hljs-variable constant_">ENV</span>.<span class="hljs-title function_">fetch</span>(<span class="hljs-params"><span class="hljs-string">"RAILS_MAX_THREADS"</span></span>) { <span class="hljs-number">5</span> }
  threads threads_count, threads_count

  port <span class="hljs-variable constant_">ENV</span>.<span class="hljs-title function_">fetch</span>(<span class="hljs-params"><span class="hljs-string">"PORT"</span></span>) { <span class="hljs-number">3000</span> }

  plugin :tmp_restart
<span class="hljs-keyword">else</span>
  directory <span class="hljs-string">'./'</span>
  rackup <span class="hljs-string">"./config.ru"</span>

  pidfile <span class="hljs-string">"./tmp/pids/puma.pid"</span>
  state_path <span class="hljs-string">"./tmp/pids/puma.state"</span>

  threads <span class="hljs-number">0</span>,<span class="hljs-number">16</span>

  port <span class="hljs-variable constant_">ENV</span>.<span class="hljs-title function_">fetch</span>(<span class="hljs-params"><span class="hljs-string">"PORT"</span></span>) { <span class="hljs-number">3000</span> }

  workers <span class="hljs-number">2</span>

  prune_bundler

  on_restart <span class="hljs-keyword">do</span>
    puts <span class="hljs-string">'Refreshing Gemfile'</span>
    <span class="hljs-variable constant_">ENV</span>[<span class="hljs-string">"BUNDLE_GEMFILE"</span>] = <span class="hljs-string">"./Gemfile"</span>
  end
end
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>리팩터링 키포인트 1: 스레드 용량 감소</h2>
<p>일부 참조 링크를 조사했는데, 먼저 그것들을 확인해보세요.</p>
<ul>
<li>[문서] 쿠버네티스에 적합한 Puma 튜닝 방법</li>
<li>최대 효율을 위한 Puma, Unicorn 및 Passenger 구성</li>
<li>Pod 당 워커 및 기타 구성 문제</li>
</ul>
<p>마지막 문제 토론에 따르면, 너무 많은 스레드를 사용하는 것은 더 많은 요청을 수용하기에 적합하지 않으며, 리소스가 Global VM 락에 직면할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우리 설정에서는 각 워커에 너무 많은 스레드를 설정했어요. 그래서 이것이 제 첫 번째 반응 대상이 됐어요.</p>
<p>Puma 문서의 기사에 따르면, 쿠버네티스 팟 _ Puma 워커 _ 스레드가 최종 총 용량이라는 걸 알 수 있어요.</p>
<p>이전에 우리의 용량은 64였어요. 2 (팟) _ 2 (워커) _ 16 (최대 스레드)인거죠. 큰 감소가 심각한 문제를 일으킬 것을 두려워해서, 처음에는 스레드를 8로 순차적으로 감소시켰고, 마지막에 5로 줄였어요 (총 용량은 20이 될 거예요).</p>
<pre><code class="hljs language-js"># puma.<span class="hljs-property">rb</span>
# <span class="hljs-title class_">Puma</span>에게 <span class="hljs-number">1</span>에서 <span class="hljs-number">5</span> 범위 내에서 스레드를 자동 조정하도록 설정합니다.
# 각 스레드가 더 많은 <span class="hljs-variable constant_">CPU</span> / 메모리 리소스를 갖으므로 <span class="hljs-number">16</span>에서 <span class="hljs-number">5</span>로 줄였어요.
threads <span class="hljs-number">0</span>, <span class="hljs-number">5</span>
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>Refactor Key 2: CPU 코어의 수를 신뢰성 있게 감지할 수 있어야 합니다.</h2>
<p>초기 설정에서는 이전 도커 인프라에서 각 서비스가 사용할 수 있는 2개의 vCPU를 가지고 있기 때문에, 종업원을 두 명으로 설정했습니다.</p>
<p>첫 번째 시도에서, 새로운 Rails 버전의 Puma 구성 설정을 참조하여 CPU를 감지하였습니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Specifies</span> that the worker count should equal the number <span class="hljs-keyword">of</span> processors <span class="hljs-keyword">in</span> production.
<span class="hljs-keyword">if</span> <span class="hljs-variable constant_">ENV</span>[<span class="hljs-string">"RAILS_ENV"</span>] == <span class="hljs-string">"production"</span>
  worker_count = <span class="hljs-title class_">Integer</span>(<span class="hljs-variable constant_">ENV</span>.<span class="hljs-title function_">fetch</span>(<span class="hljs-params"><span class="hljs-string">"WEB_CONCURRENCY"</span></span>) { <span class="hljs-title class_">Concurrent</span>.<span class="hljs-property">physical_processor_count</span> })
  workers worker_count <span class="hljs-keyword">if</span> worker_count > <span class="hljs-number">1</span>
end
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>루비 메소드를 사용하여 CPU 프로세서 카운트를 감지하는 것은 좋은 아이디어에요. "물리 프로세서 수" 또는 "OS에서 보이는 프로세서 및 프로세스 스케줄링에 사용되는 프로세서"를 기준으로 결정할 수 있어요.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Module</span>: <span class="hljs-title class_">Concurrent</span>

<span class="hljs-built_in">require</span> <span class="hljs-string">"concurrent-ruby"</span>

# 현재 시스템의 물리 프로세서 코어 수.
# 성능상의 이유로 처음 호출될 때 계산된 값은 메모이즈될 거에요.
<span class="hljs-title class_">Concurrent</span>.<span class="hljs-property">physical_processor_count</span>

# <span class="hljs-variable constant_">OS</span>에서 보이는 프로세서 및 프로세스 스케줄링에 사용되는 프로세서 수.
# 성능상의 이유로 처음 호출될 때 계산된 값은 메모이즈될 거에요.
<span class="hljs-title class_">Concurrent</span>.<span class="hljs-property">processor_count</span>
</code></pre>
<p>만약 Kubernetes 베이스 클러스터 노드에 CPU가 4개 있고, 서비스를 1000(µs) CPU 리소스로 제한한다면, Coucurrnet 메소드를 사용하면 항상 4를 반환할 거에요 (호스트 수준 리소스가 보이기 때문에 팟 수준 리소스가 아니에요).</p>
<p>그래서 Puma가 Kubernetes 설정을 직접 읽을 수 있도록 해야 해요. 다음과 같이 시도해 봤어요:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>K8S CPU 제한을 설정하는 방법을 확인하세요.</h1>
<h2>cpu.cfs_quota_us는 그룹이 해당 창기간 동안 사용할 수 있는 최대 CPU 시간(마이크로초 단위)을 지정합니다.</h2>
<h2>cpu.cfs_period_us는 CPU 액세스를 위한 시간 창문의 길이(마이크로초 단위)를 나타냅니다.</h2>
<h2>quota가 -1이면 CPU 자원 사용에 대한 제한이 없는 것을 의미합니다.</h2>
<p>"concurrent-ruby"을 요구합니다.
quota_file = '/sys/fs/cgroup/cpu/cpu.cfs_quota_us'
period_file = '/sys/fs/cgroup/cpu/cpu.cfs_period_us'
quota = File.read(quota_file).strip.to_i
period = File.read(period_file).strip.to_i</p>
<p>if quota != -1
processors_count = (quota.to_f / period.to_f).ceil
else
processors_count = Integer(ENV.fetch("WEB_CONCURRENCY") { Concurrent.physical_processor_count })
end</p>
<p>CPU 자원이 제한되지 않는 경우에는 서비스가 노드의 CPU 최대 범위를 사용할 수 있으므로 물리적 프로세서 개수를 기반으로 설계되었습니다. 제한이 있는 경우 계산하세요!</p>
<h2>리팩터링 핵심 3: 항상 서비스에 시간 제한을 설정하세요.</h2>
<p>Sidekiq 작성자인 마이크의 글을 예전에 읽었는데도 기억이 싱싱합니다. 모든 네트워크 요청에는 타임아웃을 설정해야 한다는 교훈을 주었습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>제가 참고한 GitHub은 puma 타임아웃 설정을 위해 the-ultimate-guide-to-ruby-timeouts입니다. 매우 유용합니다.</p>
<p><img src="/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_1.png" alt="이미지"></p>
<h2>리팩터링 핵심 4: 에러 처리 설정하기.</h2>
<p>Puma에는 기본 에러 처리 구성이 내장되어 있습니다. 또한 오류를 캡처하는 Sentry 시스템도 있으므로 에러가 발생할 때 Sentry 캡처를 추가하는 것이 좋아 보입니다!</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"># 참조: <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/puma/puma?tab=readme-ov-file#error-handling</span>

lowlevel_error_handler <span class="hljs-keyword">do</span> |e|
  <span class="hljs-title class_">Sentry</span>.<span class="hljs-title function_">capture_exception</span>(e)
  [<span class="hljs-number">500</span>, {}, [<span class="hljs-string">"오류가 발생했습니다"</span>]]
end
</code></pre>
<h2>최종 Puma 설정</h2>
<pre><code class="hljs language-js"># 이 구성 파일은 <span class="hljs-title class_">Puma</span>에 의해 평가될 것입니다. 여기에서 호출되는 최상위 메서드들은
# <span class="hljs-title class_">Puma</span>의 구성 <span class="hljs-variable constant_">DSL</span>의 일부입니다. <span class="hljs-variable constant_">DSL</span>에서 제공하는 메서드에 대한 자세한 정보는 <span class="hljs-attr">https</span>:<span class="hljs-comment">//puma.io/puma/Puma/DSL.html에서 확인하세요.</span>

# <span class="hljs-title class_">Puma</span>는 설정 가능한 일정 수의 프로세스(작업자)를 시작하고 각 프로세스는 내부 스레드 풀에서 스레드로 각 요청을 처리합니다.
#
# 각 작업자당 이상적인 스레드 수는 응용 프로그램이 <span class="hljs-variable constant_">IO</span> 작업을 기다리는 시간과
# 처리량을 지연 시간보다 우선시할지에 따라 다릅니다.
#
# 일반적으로 스레드 수를 늘리면 특정 프로세스가 처리할 수 있는 트래픽 양(처리량)이 늘어납니다.
# 그러나 <span class="hljs-title class_">CRuby</span>의 <span class="hljs-title class_">Global</span> <span class="hljs-variable constant_">VM</span> <span class="hljs-title class_">Lock</span> (<span class="hljs-variable constant_">GVL</span>)로 인해 반응 시간(지연 시간)이 악화될 수 있고
# 수응용 프로그램의 경우 감소하기 때문에 이 형벌이 선뜻 좋은 결정이라고 할 수 없습니다.
#
# 평균적인 <span class="hljs-title class_">Rails</span> 응용 프로그램에 대한 처리량과 지연 시간 사이의 괜찮은 절충으로 간주되는 <span class="hljs-number">3</span>개의 스레드로 설정됩니다.
#
# 연결 풀이나 다른 리소스 풀을 사용하는 모든 라이브러리는
# 스레드 수와 동일하거나 그 이상의 연결을 제공하도록 구성되어야 합니다.
# 이에는 <span class="hljs-string">`database.yml`</span>의 <span class="hljs-title class_">Active</span> <span class="hljs-title class_">Record</span>의 <span class="hljs-string">`pool`</span> 매개변수가 포함됩니다.
default_threads_count = <span class="hljs-variable constant_">ENV</span>.<span class="hljs-title function_">fetch</span>(<span class="hljs-params"><span class="hljs-string">"RAILS_MAX_THREADS"</span></span>) { <span class="hljs-number">3</span> }
threads default_threads_count, default_threads_count

# 프로덕션 및 준비 단계에서 작업자 수를 프로세서 수와 동일하게 설정
<span class="hljs-keyword">if</span> rails_env == <span class="hljs-string">"production"</span> || rails_env == <span class="hljs-string">"preparing"</span>
  # 프로세스 당 <span class="hljs-number">1</span>개 이상의 스레드를 실행중인 경우 작업자 수
  # 기본적으로 프로세서(컴퓨터 코어)의 수와 동일하게 설정해야합니다.
  #
  # 이것은 신뢰할 수 없te, <span class="hljs-variable constant_">CPU</span> 코어의 수를 신뢰할 수없습니다.
  # <span class="hljs-string">`WEB_CONCURRENCY`</span> 환경 변수를 프로세서 수와 일치하도록 설정하는지 확인하세요.
  <span class="hljs-built_in">require</span> <span class="hljs-string">"concurrent-ruby"</span>

  # config 파일로부터 <span class="hljs-variable constant_">K8S</span> <span class="hljs-variable constant_">CPU</span> 한정 메모리 확인
  ## cpu.<span class="hljs-property">cfs_quota_us</span>는 그 그룹이 그 창에서 사용할 수 있는 최대 <span class="hljs-variable constant_">CPU</span> 시간(밀리 초 단위)을 지정합니다.
  ## cpu.<span class="hljs-property">cfs_period_us</span>는 <span class="hljs-variable constant_">CPU</span> 액세스 시간 창의 길이를 지정합니다.
  quota_file = <span class="hljs-string">'/sys/fs/cgroup/cpu/cpu.cfs_quota_us'</span>
  period_file = <span class="hljs-string">'/sys/fs/cgroup/cpu/cpu.cfs_period_us'</span>
  quota = <span class="hljs-title class_">File</span>.<span class="hljs-title function_">read</span>(quota_file).<span class="hljs-property">strip</span>.<span class="hljs-property">to_i</span>
  period = <span class="hljs-title class_">File</span>.<span class="hljs-title function_">read</span>(period_file).<span class="hljs-property">strip</span>.<span class="hljs-property">to_i</span>

  <span class="hljs-keyword">if</span> quota != -<span class="hljs-number">1</span>
    processors_count = (quota.<span class="hljs-property">to_f</span> / period.<span class="hljs-property">to_f</span>).<span class="hljs-property">ceil</span>
  <span class="hljs-keyword">else</span>
    processors_count = <span class="hljs-title class_">Integer</span>(<span class="hljs-variable constant_">ENV</span>.<span class="hljs-title function_">fetch</span>(<span class="hljs-params"><span class="hljs-string">"WEB_CONCURRENCY"</span></span>) { <span class="hljs-title class_">Concurrent</span>.<span class="hljs-property">physical_processor_count</span> })
  end

  # 작업자 및 스레드 설정
  <span class="hljs-keyword">if</span> processors_count > <span class="hljs-number">1</span>
    workers processors_count
    threads <span class="hljs-number">0</span>, <span class="hljs-number">5</span>

    on_worker_boot <span class="hljs-keyword">do</span>
      <span class="hljs-title class_">ActiveRecord</span>::<span class="hljs-title class_">Base</span>.<span class="hljs-property">establish_connection</span> <span class="hljs-keyword">if</span> defined?(<span class="hljs-title class_">ActiveRecord</span>)
    end
  <span class="hljs-keyword">else</span>
    preload_app!
  end

  worker_timeout <span class="hljs-number">15</span>
  worker_shutdown_timeout <span class="hljs-number">8</span>
end

# <span class="hljs-title class_">Puma</span>가 요청을 수신하기 위해 청취하는 <span class="hljs-string">`포트`</span>를 지정; 기본값은 <span class="hljs-number">3000</span>입니다.
port <span class="hljs-variable constant_">ENV</span>.<span class="hljs-title function_">fetch</span>(<span class="hljs-params"><span class="hljs-string">"PORT"</span></span>) { <span class="hljs-number">3000</span> }

# <span class="hljs-title class_">Puma</span>가 실행할 <span class="hljs-string">`환경`</span>을 지정합니다.
environment rails_env

# <span class="hljs-string">`bin/rails restart`</span> 명령으로 <span class="hljs-title class_">Puma</span>를 다시 시작할 수 있도록 허용
plugin :tmp_restart
pidfile <span class="hljs-variable constant_">ENV</span>[<span class="hljs-string">"PIDFILE"</span>] <span class="hljs-keyword">if</span> <span class="hljs-variable constant_">ENV</span>[<span class="hljs-string">"PIDFILE"</span>]

<span class="hljs-keyword">if</span> rails_env == <span class="hljs-string">"development"</span>
  # 디버거에 의해 일시 중단되었을 때 <span class="hljs-title class_">Puma</span>에 의해 작업자가 종료되지 않도록 매우 넉넉한 <span class="hljs-string">`worker_timeout`</span>를 지정합니다.
  worker_timeout <span class="hljs-number">3600</span>
end

# 응용 프로그램의 범위를 벗어난 오류가 발생하면 <span class="hljs-title class_">Puma</span>가 <span class="hljs-number">500</span> 및 간단한 텍스트 오류 메시지와 함께 응답
lowlevel_error_handler <span class="hljs-keyword">do</span> |e|
  <span class="hljs-title class_">Sentry</span>.<span class="hljs-title function_">capture_exception</span>(e)
  [<span class="hljs-number">500</span>, {}, [<span class="hljs-string">"오류가 발생했습니다"</span>]]
end
</code></pre>
<p>이전에 언급하지 않았던 몇 가지 작은 변경 사항이 있지만 참고하실 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>
<p><strong>on_worker_boot</strong> 메소드를 사용해보세요.
작업자가 부팅될 때 항상 ActiveRecord가 데이터베이스에 연결되어 있는지 확인하세요 (필요하다면 Redis를 추가할 수도 있습니다).</p>
</li>
<li>
<p>여러 작업자를 사용하는 경우 **preload_app!**는 기본적으로 켜져 있습니다.
Rails에서는 새로운 Puma 템플릿이 작업자 수가 1인 경우에도 preload_app를 사용합니다.
<a href="https://github.com/rails/rails/blob/main/railties/lib/rails/generators/rails/app/templates/config/puma.rb.tt" rel="nofollow" target="_blank">https://github.com/rails/rails/blob/main/railties/lib/rails/generators/rails/app/templates/config/puma.rb.tt</a></p>
</li>
</ul>
<h1>모든 것을 모니터링하세요</h1>
<p>만든 변경사항은 항상 모니터링되어야 함을 기억하세요.</p>
<p>새로운 환경 설정을 프로덕션에 배포할 때 문제가 없어야 합니다. (물론, 우리는 준비된 환경이 있고 서비스가 작동하는지 확인하기 위해 몇 가지 스트레스 테스트를 수행하였지만, 요청량은 프로덕션 환경과 비교할 수 없을 정도로 상이합니다.)</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>요청 용량을 64에서 20으로 줄인 후에도 서비스는 잘 작동했어요. CPU 및 메모리 사용량이 크게 개선되지는 않았지만, 스레드 용량을 더 적합한 상황으로 줄여 GVL을 피하려고 성공적으로 조정했습니다.</p>
<p><img src="/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_2.png" alt="그림 1"></p>
<p><img src="/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_3.png" alt="그림 2"></p>
<h1>결론</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>멀티스레드인 경우, Puma 워커 당 1개의 CPU를 할당하세요.
참고: <a href="https://github.com/puma/puma/issues/2645#issuecomment-867629826" rel="nofollow" target="_blank">https://github.com/puma/puma/issues/2645#issuecomment-867629826</a></li>
<li>대부분의 Puma는 워커 당 약 512MB ~ 1GB의 메모리를 사용하며, 마스터 프로세스에 대략 1GB를 사용합니다.
참고: <a href="https://github.com/puma/puma/issues/2645#issuecomment-867629826" rel="nofollow" target="_blank">https://github.com/puma/puma/issues/2645#issuecomment-867629826</a></li>
<li>대부분의 Puma는 각 쓰레드 당 약 300MB ~ 500MB의 메모리를 사용합니다.
이는 웹 서비스의 유형과 기능에 따라 다를 수 있으며, Ruby 3 및 Rails 6 응용 프로그램을 실험하면서 각 프로세스가 약 200MB ~ 400MB 정도 사용한다는 기사를 참조했습니다.
참고: <a href="https://www.speedshop.co/2017/10/12/appserver.html" rel="nofollow" target="_blank">https://www.speedshop.co/2017/10/12/appserver.html</a></li>
<li>각 Puma 워커를 3 ~ 5개의 쓰레드로 설정하는 것이 일반 목적에 가장 적합합니다.
참고 1: <a href="https://github.com/rails/rails/issues/50450" rel="nofollow" target="_blank">https://github.com/rails/rails/issues/50450</a>
참고 2: <a href="https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#recommended-default-puma-process-and-thread-configuration" rel="nofollow" target="_blank">https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#recommended-default-puma-process-and-thread-configuration</a></li>
<li>자원에 따라 구성이 동적으로 조정되도록 하세요.</li>
<li>웹 서비스에 대한 시간 초과 및 오류 처리 메커니즘을 항상 설정하세요.
참고 1: <a href="https://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/" rel="nofollow" target="_blank">https://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/</a>
참고 2: <a href="https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts" rel="nofollow" target="_blank">https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts</a></li>
<li>생산 환경에 배포하기 전에 중요하지 않은 서비스부터 사용하고, 배포 전에 더 많은 테스트를 수행하세요.</li>
<li>생산 환경에 배포할 때 모니터링 서비스를 사용하여 모든 변경 사항을 처리하고 기록하는 데 도움을 받으세요.</li>
</ul>
<h1>참고 자료</h1>
<ul>
<li><a href="https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server" rel="nofollow" target="_blank">https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server</a></li>
<li><a href="https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts?tab=readme-ov-file#puma" rel="nofollow" target="_blank">https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts?tab=readme-ov-file#puma</a></li>
<li><a href="https://github.com/puma/puma/blob/master/docs/kubernetes.md#workers-per-pod-and-other-config-issues" rel="nofollow" target="_blank">https://github.com/puma/puma/blob/master/docs/kubernetes.md#workers-per-pod-and-other-config-issues</a></li>
<li><a href="https://github.com/puma/puma?tab=readme-ov-file#clustered-mode" rel="nofollow" target="_blank">https://github.com/puma/puma?tab=readme-ov-file#clustered-mode</a></li>
<li><a href="https://github.com/puma/puma?tab=readme-ov-file#error-handling" rel="nofollow" target="_blank">https://github.com/puma/puma?tab=readme-ov-file#error-handling</a></li>
<li><a href="https://github.com/puma/puma/issues/2645" rel="nofollow" target="_blank">https://github.com/puma/puma/issues/2645</a></li>
<li><a href="https://github.com/rails/rails/blob/main/activestorage/test/dummy/config/puma.rb" rel="nofollow" target="_blank">https://github.com/rails/rails/blob/main/activestorage/test/dummy/config/puma.rb</a></li>
<li><a href="https://github.com/rails/rails/blob/main/railties/lib/rails/generators/rails/app/templates/config/puma.rb.tt" rel="nofollow" target="_blank">https://github.com/rails/rails/blob/main/railties/lib/rails/generators/rails/app/templates/config/puma.rb.tt</a></li>
<li><a href="https://github.com/rails/rails/issues/50450" rel="nofollow" target="_blank">https://github.com/rails/rails/issues/50450</a></li>
<li><a href="https://puma.io/puma/Puma/DSL.html" rel="nofollow" target="_blank">https://puma.io/puma/Puma/DSL.html</a></li>
<li><a href="https://ruby-concurrency.github.io/concurrent-ruby/master/Concurrent.html#physical_processor_count-class_method" rel="nofollow" target="_blank">https://ruby-concurrency.github.io/concurrent-ruby/master/Concurrent.html#physical_processor_count-class_method</a></li>
<li><a href="https://www.speedshop.co/2017/10/12/appserver.html" rel="nofollow" target="_blank">https://www.speedshop.co/2017/10/12/appserver.html</a></li>
<li><a href="https://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/" rel="nofollow" target="_blank">https://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/</a></li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Kubernetes 환경에서 Ruby on Rails의 Puma 튜닝 방법","description":"","date":"2024-06-22 22:29","slug":"2024-06-22-HowITuningPumaforRubyonRailsatKubernetes","content":"\n## 쿠버네티스에 맞게 Puma 튜닝하기\n\nPuma는 Ruby on Rails용 인기 있는 웹 서버 패키지이며, Puma 구성을 잘 튜닝하면 서비스 효율성이 더욱 향상됩니다.\n\nPuma 젬: [https://rubygems.org/gems/puma](https://rubygems.org/gems/puma)\n\n![이미지](/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 왜 리팩토링 해야 하나요?\n\n가장 중요한 이유는 도커에서 쿠버네티스 아키텍처로 마이그레이션할 때, Puma 구성을 새 아키텍처에 맞게 업데이트해야 할 수도 있다는 것입니다. 따라서, 저는 많은 기사와 소스 저장소를 재조사하여 이를 다시 작성하는 데 도움을 받았어요.\n\n# Puma 구성 튜닝을 하기 전, 확인해야 할 사항\n\n- 처음에는 가장 중요한 서비스를 사용하지 마세요. 그 대신 부수적인 서비스를 사용하세요.\n  예를 들어, 먼저 테스트할 때 회원 OAuth 서비스를 사용하지 마세요. 이 예에서, 저는 테스트용으로 메일 센터를 사용했어요. (대부분의 요청이 내부 호출이며, 요청이 실패하면 다시 시도합니다.)\n- 서비스의 온라인 상태를 확인하기 위해 모니터링 서비스 중 하나가 반드시 필요해요. 저는 서비스와 쿠버네티스 상태를 확인하기 위해 Datadog를 사용하고 있어요.\n- 각 구성 설정과 단계별 튜닝을 위해 왜 그리고 어떻게 하는지 알아야 해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Puma 구성 리팩터링\n\n## 우리의 초기 Puma 구성\n\n첫 번째 구성은 다음과 같습니다.\n\n```js\n#!/usr/bin/env puma\n\nenvironment ENV.fetch(\"RAILS_ENV\") { \"development\" }\n\nif ENV['RAILS_ENV'].nil? || ENV['RAILS_ENV'] == 'development'\n  threads_count = ENV.fetch(\"RAILS_MAX_THREADS\") { 5 }\n  threads threads_count, threads_count\n\n  port ENV.fetch(\"PORT\") { 3000 }\n\n  plugin :tmp_restart\nelse\n  directory './'\n  rackup \"./config.ru\"\n\n  pidfile \"./tmp/pids/puma.pid\"\n  state_path \"./tmp/pids/puma.state\"\n\n  threads 0,16\n\n  port ENV.fetch(\"PORT\") { 3000 }\n\n  workers 2\n\n  prune_bundler\n\n  on_restart do\n    puts 'Refreshing Gemfile'\n    ENV[\"BUNDLE_GEMFILE\"] = \"./Gemfile\"\n  end\nend\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 리팩터링 키포인트 1: 스레드 용량 감소\n\n일부 참조 링크를 조사했는데, 먼저 그것들을 확인해보세요.\n\n- [문서] 쿠버네티스에 적합한 Puma 튜닝 방법\n- 최대 효율을 위한 Puma, Unicorn 및 Passenger 구성\n- Pod 당 워커 및 기타 구성 문제\n\n마지막 문제 토론에 따르면, 너무 많은 스레드를 사용하는 것은 더 많은 요청을 수용하기에 적합하지 않으며, 리소스가 Global VM 락에 직면할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 설정에서는 각 워커에 너무 많은 스레드를 설정했어요. 그래서 이것이 제 첫 번째 반응 대상이 됐어요.\n\nPuma 문서의 기사에 따르면, 쿠버네티스 팟 _ Puma 워커 _ 스레드가 최종 총 용량이라는 걸 알 수 있어요.\n\n이전에 우리의 용량은 64였어요. 2 (팟) _ 2 (워커) _ 16 (최대 스레드)인거죠. 큰 감소가 심각한 문제를 일으킬 것을 두려워해서, 처음에는 스레드를 8로 순차적으로 감소시켰고, 마지막에 5로 줄였어요 (총 용량은 20이 될 거예요).\n\n```js\n# puma.rb\n# Puma에게 1에서 5 범위 내에서 스레드를 자동 조정하도록 설정합니다.\n# 각 스레드가 더 많은 CPU / 메모리 리소스를 갖으므로 16에서 5로 줄였어요.\nthreads 0, 5\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Refactor Key 2: CPU 코어의 수를 신뢰성 있게 감지할 수 있어야 합니다.\n\n초기 설정에서는 이전 도커 인프라에서 각 서비스가 사용할 수 있는 2개의 vCPU를 가지고 있기 때문에, 종업원을 두 명으로 설정했습니다.\n\n첫 번째 시도에서, 새로운 Rails 버전의 Puma 구성 설정을 참조하여 CPU를 감지하였습니다.\n\n```js\n# Specifies that the worker count should equal the number of processors in production.\nif ENV[\"RAILS_ENV\"] == \"production\"\n  worker_count = Integer(ENV.fetch(\"WEB_CONCURRENCY\") { Concurrent.physical_processor_count })\n  workers worker_count if worker_count \u003e 1\nend\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n루비 메소드를 사용하여 CPU 프로세서 카운트를 감지하는 것은 좋은 아이디어에요. \"물리 프로세서 수\" 또는 \"OS에서 보이는 프로세서 및 프로세스 스케줄링에 사용되는 프로세서\"를 기준으로 결정할 수 있어요.\n\n```js\n# Module: Concurrent\n\nrequire \"concurrent-ruby\"\n\n# 현재 시스템의 물리 프로세서 코어 수.\n# 성능상의 이유로 처음 호출될 때 계산된 값은 메모이즈될 거에요.\nConcurrent.physical_processor_count\n\n# OS에서 보이는 프로세서 및 프로세스 스케줄링에 사용되는 프로세서 수.\n# 성능상의 이유로 처음 호출될 때 계산된 값은 메모이즈될 거에요.\nConcurrent.processor_count\n```\n\n만약 Kubernetes 베이스 클러스터 노드에 CPU가 4개 있고, 서비스를 1000(µs) CPU 리소스로 제한한다면, Coucurrnet 메소드를 사용하면 항상 4를 반환할 거에요 (호스트 수준 리소스가 보이기 때문에 팟 수준 리소스가 아니에요).\n\n그래서 Puma가 Kubernetes 설정을 직접 읽을 수 있도록 해야 해요. 다음과 같이 시도해 봤어요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# K8S CPU 제한을 설정하는 방법을 확인하세요.\n\n## cpu.cfs_quota_us는 그룹이 해당 창기간 동안 사용할 수 있는 최대 CPU 시간(마이크로초 단위)을 지정합니다.\n\n## cpu.cfs_period_us는 CPU 액세스를 위한 시간 창문의 길이(마이크로초 단위)를 나타냅니다.\n\n## quota가 -1이면 CPU 자원 사용에 대한 제한이 없는 것을 의미합니다.\n\n\"concurrent-ruby\"을 요구합니다.\nquota_file = '/sys/fs/cgroup/cpu/cpu.cfs_quota_us'\nperiod_file = '/sys/fs/cgroup/cpu/cpu.cfs_period_us'\nquota = File.read(quota_file).strip.to_i\nperiod = File.read(period_file).strip.to_i\n\nif quota != -1\nprocessors_count = (quota.to_f / period.to_f).ceil\nelse\nprocessors_count = Integer(ENV.fetch(\"WEB_CONCURRENCY\") { Concurrent.physical_processor_count })\nend\n\nCPU 자원이 제한되지 않는 경우에는 서비스가 노드의 CPU 최대 범위를 사용할 수 있으므로 물리적 프로세서 개수를 기반으로 설계되었습니다. 제한이 있는 경우 계산하세요!\n\n## 리팩터링 핵심 3: 항상 서비스에 시간 제한을 설정하세요.\n\nSidekiq 작성자인 마이크의 글을 예전에 읽었는데도 기억이 싱싱합니다. 모든 네트워크 요청에는 타임아웃을 설정해야 한다는 교훈을 주었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제가 참고한 GitHub은 puma 타임아웃 설정을 위해 the-ultimate-guide-to-ruby-timeouts입니다. 매우 유용합니다.\n\n![이미지](/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_1.png)\n\n## 리팩터링 핵심 4: 에러 처리 설정하기.\n\nPuma에는 기본 에러 처리 구성이 내장되어 있습니다. 또한 오류를 캡처하는 Sentry 시스템도 있으므로 에러가 발생할 때 Sentry 캡처를 추가하는 것이 좋아 보입니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 참조: https://github.com/puma/puma?tab=readme-ov-file#error-handling\n\nlowlevel_error_handler do |e|\n  Sentry.capture_exception(e)\n  [500, {}, [\"오류가 발생했습니다\"]]\nend\n```\n\n## 최종 Puma 설정\n\n```js\n# 이 구성 파일은 Puma에 의해 평가될 것입니다. 여기에서 호출되는 최상위 메서드들은\n# Puma의 구성 DSL의 일부입니다. DSL에서 제공하는 메서드에 대한 자세한 정보는 https://puma.io/puma/Puma/DSL.html에서 확인하세요.\n\n# Puma는 설정 가능한 일정 수의 프로세스(작업자)를 시작하고 각 프로세스는 내부 스레드 풀에서 스레드로 각 요청을 처리합니다.\n#\n# 각 작업자당 이상적인 스레드 수는 응용 프로그램이 IO 작업을 기다리는 시간과\n# 처리량을 지연 시간보다 우선시할지에 따라 다릅니다.\n#\n# 일반적으로 스레드 수를 늘리면 특정 프로세스가 처리할 수 있는 트래픽 양(처리량)이 늘어납니다.\n# 그러나 CRuby의 Global VM Lock (GVL)로 인해 반응 시간(지연 시간)이 악화될 수 있고\n# 수응용 프로그램의 경우 감소하기 때문에 이 형벌이 선뜻 좋은 결정이라고 할 수 없습니다.\n#\n# 평균적인 Rails 응용 프로그램에 대한 처리량과 지연 시간 사이의 괜찮은 절충으로 간주되는 3개의 스레드로 설정됩니다.\n#\n# 연결 풀이나 다른 리소스 풀을 사용하는 모든 라이브러리는\n# 스레드 수와 동일하거나 그 이상의 연결을 제공하도록 구성되어야 합니다.\n# 이에는 `database.yml`의 Active Record의 `pool` 매개변수가 포함됩니다.\ndefault_threads_count = ENV.fetch(\"RAILS_MAX_THREADS\") { 3 }\nthreads default_threads_count, default_threads_count\n\n# 프로덕션 및 준비 단계에서 작업자 수를 프로세서 수와 동일하게 설정\nif rails_env == \"production\" || rails_env == \"preparing\"\n  # 프로세스 당 1개 이상의 스레드를 실행중인 경우 작업자 수\n  # 기본적으로 프로세서(컴퓨터 코어)의 수와 동일하게 설정해야합니다.\n  #\n  # 이것은 신뢰할 수 없te, CPU 코어의 수를 신뢰할 수없습니다.\n  # `WEB_CONCURRENCY` 환경 변수를 프로세서 수와 일치하도록 설정하는지 확인하세요.\n  require \"concurrent-ruby\"\n\n  # config 파일로부터 K8S CPU 한정 메모리 확인\n  ## cpu.cfs_quota_us는 그 그룹이 그 창에서 사용할 수 있는 최대 CPU 시간(밀리 초 단위)을 지정합니다.\n  ## cpu.cfs_period_us는 CPU 액세스 시간 창의 길이를 지정합니다.\n  quota_file = '/sys/fs/cgroup/cpu/cpu.cfs_quota_us'\n  period_file = '/sys/fs/cgroup/cpu/cpu.cfs_period_us'\n  quota = File.read(quota_file).strip.to_i\n  period = File.read(period_file).strip.to_i\n\n  if quota != -1\n    processors_count = (quota.to_f / period.to_f).ceil\n  else\n    processors_count = Integer(ENV.fetch(\"WEB_CONCURRENCY\") { Concurrent.physical_processor_count })\n  end\n\n  # 작업자 및 스레드 설정\n  if processors_count \u003e 1\n    workers processors_count\n    threads 0, 5\n\n    on_worker_boot do\n      ActiveRecord::Base.establish_connection if defined?(ActiveRecord)\n    end\n  else\n    preload_app!\n  end\n\n  worker_timeout 15\n  worker_shutdown_timeout 8\nend\n\n# Puma가 요청을 수신하기 위해 청취하는 `포트`를 지정; 기본값은 3000입니다.\nport ENV.fetch(\"PORT\") { 3000 }\n\n# Puma가 실행할 `환경`을 지정합니다.\nenvironment rails_env\n\n# `bin/rails restart` 명령으로 Puma를 다시 시작할 수 있도록 허용\nplugin :tmp_restart\npidfile ENV[\"PIDFILE\"] if ENV[\"PIDFILE\"]\n\nif rails_env == \"development\"\n  # 디버거에 의해 일시 중단되었을 때 Puma에 의해 작업자가 종료되지 않도록 매우 넉넉한 `worker_timeout`를 지정합니다.\n  worker_timeout 3600\nend\n\n# 응용 프로그램의 범위를 벗어난 오류가 발생하면 Puma가 500 및 간단한 텍스트 오류 메시지와 함께 응답\nlowlevel_error_handler do |e|\n  Sentry.capture_exception(e)\n  [500, {}, [\"오류가 발생했습니다\"]]\nend\n```\n\n이전에 언급하지 않았던 몇 가지 작은 변경 사항이 있지만 참고하실 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- **on_worker_boot** 메소드를 사용해보세요.\n  작업자가 부팅될 때 항상 ActiveRecord가 데이터베이스에 연결되어 있는지 확인하세요 (필요하다면 Redis를 추가할 수도 있습니다).\n\n- 여러 작업자를 사용하는 경우 **preload_app!**는 기본적으로 켜져 있습니다.\n  Rails에서는 새로운 Puma 템플릿이 작업자 수가 1인 경우에도 preload_app를 사용합니다.\n  https://github.com/rails/rails/blob/main/railties/lib/rails/generators/rails/app/templates/config/puma.rb.tt\n\n# 모든 것을 모니터링하세요\n\n만든 변경사항은 항상 모니터링되어야 함을 기억하세요.\n\n새로운 환경 설정을 프로덕션에 배포할 때 문제가 없어야 합니다. (물론, 우리는 준비된 환경이 있고 서비스가 작동하는지 확인하기 위해 몇 가지 스트레스 테스트를 수행하였지만, 요청량은 프로덕션 환경과 비교할 수 없을 정도로 상이합니다.)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요청 용량을 64에서 20으로 줄인 후에도 서비스는 잘 작동했어요. CPU 및 메모리 사용량이 크게 개선되지는 않았지만, 스레드 용량을 더 적합한 상황으로 줄여 GVL을 피하려고 성공적으로 조정했습니다.\n\n![그림 1](/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_2.png)\n\n![그림 2](/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_3.png)\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 멀티스레드인 경우, Puma 워커 당 1개의 CPU를 할당하세요.\n  참고: https://github.com/puma/puma/issues/2645#issuecomment-867629826\n- 대부분의 Puma는 워커 당 약 512MB ~ 1GB의 메모리를 사용하며, 마스터 프로세스에 대략 1GB를 사용합니다.\n  참고: https://github.com/puma/puma/issues/2645#issuecomment-867629826\n- 대부분의 Puma는 각 쓰레드 당 약 300MB ~ 500MB의 메모리를 사용합니다.\n  이는 웹 서비스의 유형과 기능에 따라 다를 수 있으며, Ruby 3 및 Rails 6 응용 프로그램을 실험하면서 각 프로세스가 약 200MB ~ 400MB 정도 사용한다는 기사를 참조했습니다.\n  참고: https://www.speedshop.co/2017/10/12/appserver.html\n- 각 Puma 워커를 3 ~ 5개의 쓰레드로 설정하는 것이 일반 목적에 가장 적합합니다.\n  참고 1: https://github.com/rails/rails/issues/50450\n  참고 2: https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#recommended-default-puma-process-and-thread-configuration\n- 자원에 따라 구성이 동적으로 조정되도록 하세요.\n- 웹 서비스에 대한 시간 초과 및 오류 처리 메커니즘을 항상 설정하세요.\n  참고 1: https://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/\n  참고 2: https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts\n- 생산 환경에 배포하기 전에 중요하지 않은 서비스부터 사용하고, 배포 전에 더 많은 테스트를 수행하세요.\n- 생산 환경에 배포할 때 모니터링 서비스를 사용하여 모든 변경 사항을 처리하고 기록하는 데 도움을 받으세요.\n\n# 참고 자료\n\n- https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server\n- https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts?tab=readme-ov-file#puma\n- https://github.com/puma/puma/blob/master/docs/kubernetes.md#workers-per-pod-and-other-config-issues\n- https://github.com/puma/puma?tab=readme-ov-file#clustered-mode\n- https://github.com/puma/puma?tab=readme-ov-file#error-handling\n- https://github.com/puma/puma/issues/2645\n- https://github.com/rails/rails/blob/main/activestorage/test/dummy/config/puma.rb\n- https://github.com/rails/rails/blob/main/railties/lib/rails/generators/rails/app/templates/config/puma.rb.tt\n- https://github.com/rails/rails/issues/50450\n- https://puma.io/puma/Puma/DSL.html\n- https://ruby-concurrency.github.io/concurrent-ruby/master/Concurrent.html#physical_processor_count-class_method\n- https://www.speedshop.co/2017/10/12/appserver.html\n- https://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/\n","ogImage":{"url":"/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_0.png"},"coverImage":"/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_0.png","tag":["Tech"],"readingTime":14},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e쿠버네티스에 맞게 Puma 튜닝하기\u003c/h2\u003e\n\u003cp\u003ePuma는 Ruby on Rails용 인기 있는 웹 서버 패키지이며, Puma 구성을 잘 튜닝하면 서비스 효율성이 더욱 향상됩니다.\u003c/p\u003e\n\u003cp\u003ePuma 젬: \u003ca href=\"https://rubygems.org/gems/puma\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://rubygems.org/gems/puma\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e왜 리팩토링 해야 하나요?\u003c/h1\u003e\n\u003cp\u003e가장 중요한 이유는 도커에서 쿠버네티스 아키텍처로 마이그레이션할 때, Puma 구성을 새 아키텍처에 맞게 업데이트해야 할 수도 있다는 것입니다. 따라서, 저는 많은 기사와 소스 저장소를 재조사하여 이를 다시 작성하는 데 도움을 받았어요.\u003c/p\u003e\n\u003ch1\u003ePuma 구성 튜닝을 하기 전, 확인해야 할 사항\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e처음에는 가장 중요한 서비스를 사용하지 마세요. 그 대신 부수적인 서비스를 사용하세요.\n예를 들어, 먼저 테스트할 때 회원 OAuth 서비스를 사용하지 마세요. 이 예에서, 저는 테스트용으로 메일 센터를 사용했어요. (대부분의 요청이 내부 호출이며, 요청이 실패하면 다시 시도합니다.)\u003c/li\u003e\n\u003cli\u003e서비스의 온라인 상태를 확인하기 위해 모니터링 서비스 중 하나가 반드시 필요해요. 저는 서비스와 쿠버네티스 상태를 확인하기 위해 Datadog를 사용하고 있어요.\u003c/li\u003e\n\u003cli\u003e각 구성 설정과 단계별 튜닝을 위해 왜 그리고 어떻게 하는지 알아야 해요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003ePuma 구성 리팩터링\u003c/h1\u003e\n\u003ch2\u003e우리의 초기 Puma 구성\u003c/h2\u003e\n\u003cp\u003e첫 번째 구성은 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#!\u003cspan class=\"hljs-regexp\"\u003e/usr/\u003c/span\u003ebin/env puma\n\nenvironment \u003cspan class=\"hljs-variable constant_\"\u003eENV\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"RAILS_ENV\"\u003c/span\u003e\u003c/span\u003e) { \u003cspan class=\"hljs-string\"\u003e\"development\"\u003c/span\u003e }\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eENV\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e'RAILS_ENV'\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003enil\u003c/span\u003e? || \u003cspan class=\"hljs-variable constant_\"\u003eENV\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e'RAILS_ENV'\u003c/span\u003e] == \u003cspan class=\"hljs-string\"\u003e'development'\u003c/span\u003e\n  threads_count = \u003cspan class=\"hljs-variable constant_\"\u003eENV\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"RAILS_MAX_THREADS\"\u003c/span\u003e\u003c/span\u003e) { \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e }\n  threads threads_count, threads_count\n\n  port \u003cspan class=\"hljs-variable constant_\"\u003eENV\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"PORT\"\u003c/span\u003e\u003c/span\u003e) { \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e }\n\n  plugin :tmp_restart\n\u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e\n  directory \u003cspan class=\"hljs-string\"\u003e'./'\u003c/span\u003e\n  rackup \u003cspan class=\"hljs-string\"\u003e\"./config.ru\"\u003c/span\u003e\n\n  pidfile \u003cspan class=\"hljs-string\"\u003e\"./tmp/pids/puma.pid\"\u003c/span\u003e\n  state_path \u003cspan class=\"hljs-string\"\u003e\"./tmp/pids/puma.state\"\u003c/span\u003e\n\n  threads \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e\n\n  port \u003cspan class=\"hljs-variable constant_\"\u003eENV\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"PORT\"\u003c/span\u003e\u003c/span\u003e) { \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e }\n\n  workers \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n\n  prune_bundler\n\n  on_restart \u003cspan class=\"hljs-keyword\"\u003edo\u003c/span\u003e\n    puts \u003cspan class=\"hljs-string\"\u003e'Refreshing Gemfile'\u003c/span\u003e\n    \u003cspan class=\"hljs-variable constant_\"\u003eENV\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"BUNDLE_GEMFILE\"\u003c/span\u003e] = \u003cspan class=\"hljs-string\"\u003e\"./Gemfile\"\u003c/span\u003e\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e리팩터링 키포인트 1: 스레드 용량 감소\u003c/h2\u003e\n\u003cp\u003e일부 참조 링크를 조사했는데, 먼저 그것들을 확인해보세요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e[문서] 쿠버네티스에 적합한 Puma 튜닝 방법\u003c/li\u003e\n\u003cli\u003e최대 효율을 위한 Puma, Unicorn 및 Passenger 구성\u003c/li\u003e\n\u003cli\u003ePod 당 워커 및 기타 구성 문제\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e마지막 문제 토론에 따르면, 너무 많은 스레드를 사용하는 것은 더 많은 요청을 수용하기에 적합하지 않으며, 리소스가 Global VM 락에 직면할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우리 설정에서는 각 워커에 너무 많은 스레드를 설정했어요. 그래서 이것이 제 첫 번째 반응 대상이 됐어요.\u003c/p\u003e\n\u003cp\u003ePuma 문서의 기사에 따르면, 쿠버네티스 팟 _ Puma 워커 _ 스레드가 최종 총 용량이라는 걸 알 수 있어요.\u003c/p\u003e\n\u003cp\u003e이전에 우리의 용량은 64였어요. 2 (팟) _ 2 (워커) _ 16 (최대 스레드)인거죠. 큰 감소가 심각한 문제를 일으킬 것을 두려워해서, 처음에는 스레드를 8로 순차적으로 감소시켰고, 마지막에 5로 줄였어요 (총 용량은 20이 될 거예요).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# puma.\u003cspan class=\"hljs-property\"\u003erb\u003c/span\u003e\n# \u003cspan class=\"hljs-title class_\"\u003ePuma\u003c/span\u003e에게 \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e에서 \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e 범위 내에서 스레드를 자동 조정하도록 설정합니다.\n# 각 스레드가 더 많은 \u003cspan class=\"hljs-variable constant_\"\u003eCPU\u003c/span\u003e / 메모리 리소스를 갖으므로 \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e에서 \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e로 줄였어요.\nthreads \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003eRefactor Key 2: CPU 코어의 수를 신뢰성 있게 감지할 수 있어야 합니다.\u003c/h2\u003e\n\u003cp\u003e초기 설정에서는 이전 도커 인프라에서 각 서비스가 사용할 수 있는 2개의 vCPU를 가지고 있기 때문에, 종업원을 두 명으로 설정했습니다.\u003c/p\u003e\n\u003cp\u003e첫 번째 시도에서, 새로운 Rails 버전의 Puma 구성 설정을 참조하여 CPU를 감지하였습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eSpecifies\u003c/span\u003e that the worker count should equal the number \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e processors \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e production.\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eENV\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"RAILS_ENV\"\u003c/span\u003e] == \u003cspan class=\"hljs-string\"\u003e\"production\"\u003c/span\u003e\n  worker_count = \u003cspan class=\"hljs-title class_\"\u003eInteger\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eENV\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"WEB_CONCURRENCY\"\u003c/span\u003e\u003c/span\u003e) { \u003cspan class=\"hljs-title class_\"\u003eConcurrent\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ephysical_processor_count\u003c/span\u003e })\n  workers worker_count \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e worker_count \u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e루비 메소드를 사용하여 CPU 프로세서 카운트를 감지하는 것은 좋은 아이디어에요. \"물리 프로세서 수\" 또는 \"OS에서 보이는 프로세서 및 프로세스 스케줄링에 사용되는 프로세서\"를 기준으로 결정할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eModule\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eConcurrent\u003c/span\u003e\n\n\u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"concurrent-ruby\"\u003c/span\u003e\n\n# 현재 시스템의 물리 프로세서 코어 수.\n# 성능상의 이유로 처음 호출될 때 계산된 값은 메모이즈될 거에요.\n\u003cspan class=\"hljs-title class_\"\u003eConcurrent\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ephysical_processor_count\u003c/span\u003e\n\n# \u003cspan class=\"hljs-variable constant_\"\u003eOS\u003c/span\u003e에서 보이는 프로세서 및 프로세스 스케줄링에 사용되는 프로세서 수.\n# 성능상의 이유로 처음 호출될 때 계산된 값은 메모이즈될 거에요.\n\u003cspan class=\"hljs-title class_\"\u003eConcurrent\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eprocessor_count\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 Kubernetes 베이스 클러스터 노드에 CPU가 4개 있고, 서비스를 1000(µs) CPU 리소스로 제한한다면, Coucurrnet 메소드를 사용하면 항상 4를 반환할 거에요 (호스트 수준 리소스가 보이기 때문에 팟 수준 리소스가 아니에요).\u003c/p\u003e\n\u003cp\u003e그래서 Puma가 Kubernetes 설정을 직접 읽을 수 있도록 해야 해요. 다음과 같이 시도해 봤어요:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eK8S CPU 제한을 설정하는 방법을 확인하세요.\u003c/h1\u003e\n\u003ch2\u003ecpu.cfs_quota_us는 그룹이 해당 창기간 동안 사용할 수 있는 최대 CPU 시간(마이크로초 단위)을 지정합니다.\u003c/h2\u003e\n\u003ch2\u003ecpu.cfs_period_us는 CPU 액세스를 위한 시간 창문의 길이(마이크로초 단위)를 나타냅니다.\u003c/h2\u003e\n\u003ch2\u003equota가 -1이면 CPU 자원 사용에 대한 제한이 없는 것을 의미합니다.\u003c/h2\u003e\n\u003cp\u003e\"concurrent-ruby\"을 요구합니다.\nquota_file = '/sys/fs/cgroup/cpu/cpu.cfs_quota_us'\nperiod_file = '/sys/fs/cgroup/cpu/cpu.cfs_period_us'\nquota = File.read(quota_file).strip.to_i\nperiod = File.read(period_file).strip.to_i\u003c/p\u003e\n\u003cp\u003eif quota != -1\nprocessors_count = (quota.to_f / period.to_f).ceil\nelse\nprocessors_count = Integer(ENV.fetch(\"WEB_CONCURRENCY\") { Concurrent.physical_processor_count })\nend\u003c/p\u003e\n\u003cp\u003eCPU 자원이 제한되지 않는 경우에는 서비스가 노드의 CPU 최대 범위를 사용할 수 있으므로 물리적 프로세서 개수를 기반으로 설계되었습니다. 제한이 있는 경우 계산하세요!\u003c/p\u003e\n\u003ch2\u003e리팩터링 핵심 3: 항상 서비스에 시간 제한을 설정하세요.\u003c/h2\u003e\n\u003cp\u003eSidekiq 작성자인 마이크의 글을 예전에 읽었는데도 기억이 싱싱합니다. 모든 네트워크 요청에는 타임아웃을 설정해야 한다는 교훈을 주었습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e제가 참고한 GitHub은 puma 타임아웃 설정을 위해 the-ultimate-guide-to-ruby-timeouts입니다. 매우 유용합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e리팩터링 핵심 4: 에러 처리 설정하기.\u003c/h2\u003e\n\u003cp\u003ePuma에는 기본 에러 처리 구성이 내장되어 있습니다. 또한 오류를 캡처하는 Sentry 시스템도 있으므로 에러가 발생할 때 Sentry 캡처를 추가하는 것이 좋아 보입니다!\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 참조: \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//github.com/puma/puma?tab=readme-ov-file#error-handling\u003c/span\u003e\n\nlowlevel_error_handler \u003cspan class=\"hljs-keyword\"\u003edo\u003c/span\u003e |e|\n  \u003cspan class=\"hljs-title class_\"\u003eSentry\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecapture_exception\u003c/span\u003e(e)\n  [\u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e, {}, [\u003cspan class=\"hljs-string\"\u003e\"오류가 발생했습니다\"\u003c/span\u003e]]\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e최종 Puma 설정\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 이 구성 파일은 \u003cspan class=\"hljs-title class_\"\u003ePuma\u003c/span\u003e에 의해 평가될 것입니다. 여기에서 호출되는 최상위 메서드들은\n# \u003cspan class=\"hljs-title class_\"\u003ePuma\u003c/span\u003e의 구성 \u003cspan class=\"hljs-variable constant_\"\u003eDSL\u003c/span\u003e의 일부입니다. \u003cspan class=\"hljs-variable constant_\"\u003eDSL\u003c/span\u003e에서 제공하는 메서드에 대한 자세한 정보는 \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//puma.io/puma/Puma/DSL.html에서 확인하세요.\u003c/span\u003e\n\n# \u003cspan class=\"hljs-title class_\"\u003ePuma\u003c/span\u003e는 설정 가능한 일정 수의 프로세스(작업자)를 시작하고 각 프로세스는 내부 스레드 풀에서 스레드로 각 요청을 처리합니다.\n#\n# 각 작업자당 이상적인 스레드 수는 응용 프로그램이 \u003cspan class=\"hljs-variable constant_\"\u003eIO\u003c/span\u003e 작업을 기다리는 시간과\n# 처리량을 지연 시간보다 우선시할지에 따라 다릅니다.\n#\n# 일반적으로 스레드 수를 늘리면 특정 프로세스가 처리할 수 있는 트래픽 양(처리량)이 늘어납니다.\n# 그러나 \u003cspan class=\"hljs-title class_\"\u003eCRuby\u003c/span\u003e의 \u003cspan class=\"hljs-title class_\"\u003eGlobal\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eVM\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLock\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003eGVL\u003c/span\u003e)로 인해 반응 시간(지연 시간)이 악화될 수 있고\n# 수응용 프로그램의 경우 감소하기 때문에 이 형벌이 선뜻 좋은 결정이라고 할 수 없습니다.\n#\n# 평균적인 \u003cspan class=\"hljs-title class_\"\u003eRails\u003c/span\u003e 응용 프로그램에 대한 처리량과 지연 시간 사이의 괜찮은 절충으로 간주되는 \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e개의 스레드로 설정됩니다.\n#\n# 연결 풀이나 다른 리소스 풀을 사용하는 모든 라이브러리는\n# 스레드 수와 동일하거나 그 이상의 연결을 제공하도록 구성되어야 합니다.\n# 이에는 \u003cspan class=\"hljs-string\"\u003e`database.yml`\u003c/span\u003e의 \u003cspan class=\"hljs-title class_\"\u003eActive\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRecord\u003c/span\u003e의 \u003cspan class=\"hljs-string\"\u003e`pool`\u003c/span\u003e 매개변수가 포함됩니다.\ndefault_threads_count = \u003cspan class=\"hljs-variable constant_\"\u003eENV\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"RAILS_MAX_THREADS\"\u003c/span\u003e\u003c/span\u003e) { \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e }\nthreads default_threads_count, default_threads_count\n\n# 프로덕션 및 준비 단계에서 작업자 수를 프로세서 수와 동일하게 설정\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e rails_env == \u003cspan class=\"hljs-string\"\u003e\"production\"\u003c/span\u003e || rails_env == \u003cspan class=\"hljs-string\"\u003e\"preparing\"\u003c/span\u003e\n  # 프로세스 당 \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e개 이상의 스레드를 실행중인 경우 작업자 수\n  # 기본적으로 프로세서(컴퓨터 코어)의 수와 동일하게 설정해야합니다.\n  #\n  # 이것은 신뢰할 수 없te, \u003cspan class=\"hljs-variable constant_\"\u003eCPU\u003c/span\u003e 코어의 수를 신뢰할 수없습니다.\n  # \u003cspan class=\"hljs-string\"\u003e`WEB_CONCURRENCY`\u003c/span\u003e 환경 변수를 프로세서 수와 일치하도록 설정하는지 확인하세요.\n  \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"concurrent-ruby\"\u003c/span\u003e\n\n  # config 파일로부터 \u003cspan class=\"hljs-variable constant_\"\u003eK8S\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCPU\u003c/span\u003e 한정 메모리 확인\n  ## cpu.\u003cspan class=\"hljs-property\"\u003ecfs_quota_us\u003c/span\u003e는 그 그룹이 그 창에서 사용할 수 있는 최대 \u003cspan class=\"hljs-variable constant_\"\u003eCPU\u003c/span\u003e 시간(밀리 초 단위)을 지정합니다.\n  ## cpu.\u003cspan class=\"hljs-property\"\u003ecfs_period_us\u003c/span\u003e는 \u003cspan class=\"hljs-variable constant_\"\u003eCPU\u003c/span\u003e 액세스 시간 창의 길이를 지정합니다.\n  quota_file = \u003cspan class=\"hljs-string\"\u003e'/sys/fs/cgroup/cpu/cpu.cfs_quota_us'\u003c/span\u003e\n  period_file = \u003cspan class=\"hljs-string\"\u003e'/sys/fs/cgroup/cpu/cpu.cfs_period_us'\u003c/span\u003e\n  quota = \u003cspan class=\"hljs-title class_\"\u003eFile\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eread\u003c/span\u003e(quota_file).\u003cspan class=\"hljs-property\"\u003estrip\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eto_i\u003c/span\u003e\n  period = \u003cspan class=\"hljs-title class_\"\u003eFile\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eread\u003c/span\u003e(period_file).\u003cspan class=\"hljs-property\"\u003estrip\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eto_i\u003c/span\u003e\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e quota != -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n    processors_count = (quota.\u003cspan class=\"hljs-property\"\u003eto_f\u003c/span\u003e / period.\u003cspan class=\"hljs-property\"\u003eto_f\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003eceil\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e\n    processors_count = \u003cspan class=\"hljs-title class_\"\u003eInteger\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eENV\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"WEB_CONCURRENCY\"\u003c/span\u003e\u003c/span\u003e) { \u003cspan class=\"hljs-title class_\"\u003eConcurrent\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ephysical_processor_count\u003c/span\u003e })\n  end\n\n  # 작업자 및 스레드 설정\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e processors_count \u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n    workers processors_count\n    threads \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\n\n    on_worker_boot \u003cspan class=\"hljs-keyword\"\u003edo\u003c/span\u003e\n      \u003cspan class=\"hljs-title class_\"\u003eActiveRecord\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eBase\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eestablish_connection\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e defined?(\u003cspan class=\"hljs-title class_\"\u003eActiveRecord\u003c/span\u003e)\n    end\n  \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e\n    preload_app!\n  end\n\n  worker_timeout \u003cspan class=\"hljs-number\"\u003e15\u003c/span\u003e\n  worker_shutdown_timeout \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e\nend\n\n# \u003cspan class=\"hljs-title class_\"\u003ePuma\u003c/span\u003e가 요청을 수신하기 위해 청취하는 \u003cspan class=\"hljs-string\"\u003e`포트`\u003c/span\u003e를 지정; 기본값은 \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e입니다.\nport \u003cspan class=\"hljs-variable constant_\"\u003eENV\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"PORT\"\u003c/span\u003e\u003c/span\u003e) { \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e }\n\n# \u003cspan class=\"hljs-title class_\"\u003ePuma\u003c/span\u003e가 실행할 \u003cspan class=\"hljs-string\"\u003e`환경`\u003c/span\u003e을 지정합니다.\nenvironment rails_env\n\n# \u003cspan class=\"hljs-string\"\u003e`bin/rails restart`\u003c/span\u003e 명령으로 \u003cspan class=\"hljs-title class_\"\u003ePuma\u003c/span\u003e를 다시 시작할 수 있도록 허용\nplugin :tmp_restart\npidfile \u003cspan class=\"hljs-variable constant_\"\u003eENV\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"PIDFILE\"\u003c/span\u003e] \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eENV\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"PIDFILE\"\u003c/span\u003e]\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e rails_env == \u003cspan class=\"hljs-string\"\u003e\"development\"\u003c/span\u003e\n  # 디버거에 의해 일시 중단되었을 때 \u003cspan class=\"hljs-title class_\"\u003ePuma\u003c/span\u003e에 의해 작업자가 종료되지 않도록 매우 넉넉한 \u003cspan class=\"hljs-string\"\u003e`worker_timeout`\u003c/span\u003e를 지정합니다.\n  worker_timeout \u003cspan class=\"hljs-number\"\u003e3600\u003c/span\u003e\nend\n\n# 응용 프로그램의 범위를 벗어난 오류가 발생하면 \u003cspan class=\"hljs-title class_\"\u003ePuma\u003c/span\u003e가 \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e 및 간단한 텍스트 오류 메시지와 함께 응답\nlowlevel_error_handler \u003cspan class=\"hljs-keyword\"\u003edo\u003c/span\u003e |e|\n  \u003cspan class=\"hljs-title class_\"\u003eSentry\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecapture_exception\u003c/span\u003e(e)\n  [\u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e, {}, [\u003cspan class=\"hljs-string\"\u003e\"오류가 발생했습니다\"\u003c/span\u003e]]\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이전에 언급하지 않았던 몇 가지 작은 변경 사항이 있지만 참고하실 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eon_worker_boot\u003c/strong\u003e 메소드를 사용해보세요.\n작업자가 부팅될 때 항상 ActiveRecord가 데이터베이스에 연결되어 있는지 확인하세요 (필요하다면 Redis를 추가할 수도 있습니다).\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e여러 작업자를 사용하는 경우 **preload_app!**는 기본적으로 켜져 있습니다.\nRails에서는 새로운 Puma 템플릿이 작업자 수가 1인 경우에도 preload_app를 사용합니다.\n\u003ca href=\"https://github.com/rails/rails/blob/main/railties/lib/rails/generators/rails/app/templates/config/puma.rb.tt\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/rails/rails/blob/main/railties/lib/rails/generators/rails/app/templates/config/puma.rb.tt\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e모든 것을 모니터링하세요\u003c/h1\u003e\n\u003cp\u003e만든 변경사항은 항상 모니터링되어야 함을 기억하세요.\u003c/p\u003e\n\u003cp\u003e새로운 환경 설정을 프로덕션에 배포할 때 문제가 없어야 합니다. (물론, 우리는 준비된 환경이 있고 서비스가 작동하는지 확인하기 위해 몇 가지 스트레스 테스트를 수행하였지만, 요청량은 프로덕션 환경과 비교할 수 없을 정도로 상이합니다.)\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e요청 용량을 64에서 20으로 줄인 후에도 서비스는 잘 작동했어요. CPU 및 메모리 사용량이 크게 개선되지는 않았지만, 스레드 용량을 더 적합한 상황으로 줄여 GVL을 피하려고 성공적으로 조정했습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_2.png\" alt=\"그림 1\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_3.png\" alt=\"그림 2\"\u003e\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e멀티스레드인 경우, Puma 워커 당 1개의 CPU를 할당하세요.\n참고: \u003ca href=\"https://github.com/puma/puma/issues/2645#issuecomment-867629826\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/puma/puma/issues/2645#issuecomment-867629826\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e대부분의 Puma는 워커 당 약 512MB ~ 1GB의 메모리를 사용하며, 마스터 프로세스에 대략 1GB를 사용합니다.\n참고: \u003ca href=\"https://github.com/puma/puma/issues/2645#issuecomment-867629826\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/puma/puma/issues/2645#issuecomment-867629826\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e대부분의 Puma는 각 쓰레드 당 약 300MB ~ 500MB의 메모리를 사용합니다.\n이는 웹 서비스의 유형과 기능에 따라 다를 수 있으며, Ruby 3 및 Rails 6 응용 프로그램을 실험하면서 각 프로세스가 약 200MB ~ 400MB 정도 사용한다는 기사를 참조했습니다.\n참고: \u003ca href=\"https://www.speedshop.co/2017/10/12/appserver.html\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.speedshop.co/2017/10/12/appserver.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e각 Puma 워커를 3 ~ 5개의 쓰레드로 설정하는 것이 일반 목적에 가장 적합합니다.\n참고 1: \u003ca href=\"https://github.com/rails/rails/issues/50450\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/rails/rails/issues/50450\u003c/a\u003e\n참고 2: \u003ca href=\"https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#recommended-default-puma-process-and-thread-configuration\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#recommended-default-puma-process-and-thread-configuration\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e자원에 따라 구성이 동적으로 조정되도록 하세요.\u003c/li\u003e\n\u003cli\u003e웹 서비스에 대한 시간 초과 및 오류 처리 메커니즘을 항상 설정하세요.\n참고 1: \u003ca href=\"https://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/\u003c/a\u003e\n참고 2: \u003ca href=\"https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/ankane/the-ultimate-guide-to-ruby-timeouts\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e생산 환경에 배포하기 전에 중요하지 않은 서비스부터 사용하고, 배포 전에 더 많은 테스트를 수행하세요.\u003c/li\u003e\n\u003cli\u003e생산 환경에 배포할 때 모니터링 서비스를 사용하여 모든 변경 사항을 처리하고 기록하는 데 도움을 받으세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e참고 자료\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts?tab=readme-ov-file#puma\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/ankane/the-ultimate-guide-to-ruby-timeouts?tab=readme-ov-file#puma\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/puma/puma/blob/master/docs/kubernetes.md#workers-per-pod-and-other-config-issues\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/puma/puma/blob/master/docs/kubernetes.md#workers-per-pod-and-other-config-issues\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/puma/puma?tab=readme-ov-file#clustered-mode\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/puma/puma?tab=readme-ov-file#clustered-mode\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/puma/puma?tab=readme-ov-file#error-handling\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/puma/puma?tab=readme-ov-file#error-handling\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/puma/puma/issues/2645\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/puma/puma/issues/2645\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/rails/rails/blob/main/activestorage/test/dummy/config/puma.rb\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/rails/rails/blob/main/activestorage/test/dummy/config/puma.rb\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/rails/rails/blob/main/railties/lib/rails/generators/rails/app/templates/config/puma.rb.tt\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/rails/rails/blob/main/railties/lib/rails/generators/rails/app/templates/config/puma.rb.tt\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/rails/rails/issues/50450\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/rails/rails/issues/50450\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://puma.io/puma/Puma/DSL.html\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://puma.io/puma/Puma/DSL.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://ruby-concurrency.github.io/concurrent-ruby/master/Concurrent.html#physical_processor_count-class_method\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://ruby-concurrency.github.io/concurrent-ruby/master/Concurrent.html#physical_processor_count-class_method\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.speedshop.co/2017/10/12/appserver.html\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.speedshop.co/2017/10/12/appserver.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-HowITuningPumaforRubyonRailsatKubernetes"},"buildId":"-dPCbnM2yhdKNgXe92VJV","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>