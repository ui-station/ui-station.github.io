<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>악용하지 말아야 할 멋진 Swift 기능들 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="악용하지 말아야 할 멋진 Swift 기능들 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="악용하지 말아야 할 멋진 Swift 기능들 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse" data-gatsby-head="true"/><meta name="twitter:title" content="악용하지 말아야 할 멋진 Swift 기능들 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-17 18:48" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_buildManifest.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">악용하지 말아야 할 멋진 Swift 기능들</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="악용하지 말아야 할 멋진 Swift 기능들" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 17, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse_0.png" alt="ThecoolSwiftfeaturesthatyoushouldnotabuse"></p>
<p>iOS 개발자로서, 나는 많은 기존 코드에서 작업하거나 몇 가지 Swift 기능을 시도해 본 적이 있습니다. 그들을 사용하거나 악용 당하는 것을 보면서, 적어도 조심스럽게 사용해야 할 상위 6개의 Swift 언어 기능을 공유하고, 왜 그것들을 팀에서 금지해야 할지 생각했습니다. 간단히 살펴보겠습니다. 동의하지 않거나 다른 예제가 있는 경우 댓글에서 공유해주세요 💬.</p>
<h1>.init() 인스턴스화</h1>
<p>.init()을 사용하는 것은 처음 봤을 때 몇 가지 경우에 편리할 수 있지만 (클래스/구조체 이름 바꿀 때 노이즈가 적음), 코드 검토 및 유지보수 시 가독성이 저하됩니다. 코드 검토에서는 호출자로 이동하여 객체의 유형을 확인해야 하며, 유지보수 중에는 객체를 확인하려면 이동해야 합니다. 팀의 생산성을 높이기 위해 사용하지 않아야 합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-comment">//To avoid ❌</span>
<span class="hljs-keyword">let</span> example = .<span class="hljs-title function_">init</span>(<span class="hljs-attr">title</span>: <span class="hljs-string">"title"</span>)
<span class="hljs-comment">//To prefer ✅</span>
<span class="hljs-keyword">let</span> example = <span class="hljs-title class_">Example</span>(<span class="hljs-attr">title</span>: <span class="hljs-string">"title"</span>)
</code></pre>
<p>Swiftlint을 사용하면 이 좋은 규칙을 강제로 적용할 수 있어요.
Swiftlint를 사용하신다면, 프로젝트에서 사용해야 하는 최상의 Swiftlint 설정에 관한 기술적인 문서를 작성했어요 ⬇️</p>
<h1>$0, $1, 등...</h1>
<p>$0는 매우 편리하지만 코드 리뷰에서는 코드를 덜 가독성 있게 만들 수 있어요(이 게시물이 말합니다).</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>// ❌를 피하기 위해
numbers.sort { $0 > $1 }
// ✅를 선호하기 위해
numbers.sort { leftNumber, rightNumber in leftNumber > rightNumber }</p>
<h1>서브스크립트</h1>
<p>서브스크립트 기능은 처음 봤을 때 매우 매력적으로 보입니다:</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">TimesTable</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-attr">multiplier</span>: <span class="hljs-title class_">Int</span>

    <span class="hljs-title function_">subscript</span>(<span class="hljs-attr">index</span>: <span class="hljs-title class_">Int</span>) -> <span class="hljs-title class_">Int</span> {
        <span class="hljs-keyword">return</span> multiplier * index
    }
}

<span class="hljs-keyword">let</span> table = <span class="hljs-title class_">TimesTable</span>(<span class="hljs-attr">multiplier</span>: <span class="hljs-number">3</span>)
<span class="hljs-keyword">let</span> result = table[<span class="hljs-number">5</span>]  <span class="hljs-comment">// 결과 = 15</span>
<span class="hljs-title function_">print</span>(result)
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>서브스크립트가 그렇게 나쁘지는 않지만 테이블[5]을 읽는 일반적인 개발자들은 테이블이 배열이라고 생각하고 다섯 번째 항목에 접근하려는 것으로 생각할 것입니다. 이는 바로 그게 아니기 때문에 코드 리뷰나 파일 간, 모듈 간 사용 시 가독성이 떨어집니다. 논리적인 코드 난독화는 피해야 합니다. 이겪하고자 하는 점이 명확하지 않아서 널리 사용되지 않는 것 때문에 이것을 추천하지는 않습니다.</p>
<h1>확장(Extensions) 남용</h1>
<p>확장은 가독성과 모듈화를 높입니다. 디자인 상, 보호기능이 없는 특성이며 난잡한 코드나 불필요한 사용 또는 안티패턴으로 이어질 수 있습니다.</p>
<p>먼저, 이 규칙을 활성화하지 않았다면, 활성화해야 합니다. 이 규칙은 확장의 일부 불필요한 사용을 감지합니다. 예를 들어, ViewController의 델리게이트를 같은 파일에서 확장을 사용해 구현하지만 어떤 프로토콜 준수 제한도 없거나 그러한 것을 분할하는 경우 등을 감지합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewController</span>: <span class="hljs-title class_">UIViewController</span>{
  private <span class="hljs-keyword">var</span> <span class="hljs-title class_">IBOutlet</span> <span class="hljs-attr">textfield</span>: <span class="hljs-title class_">UITextField</span>

  textfield.<span class="hljs-property">delegate</span> = self
...
}

<span class="hljs-comment">// To Avoid❌</span>
extension <span class="hljs-title class_">UIViewController</span>: <span class="hljs-title class_">UITextViewDelegate</span> {

}
</code></pre>
<p>올바르지 않은 SOLID 확장 사용 예시:</p>
<pre><code class="hljs language-js">container.<span class="hljs-title function_">register</span>(<span class="hljs-title class_">Buyable</span>.<span class="hljs-property">self</span>, <span class="hljs-title class_">NetworkManager</span>())

<span class="hljs-keyword">class</span> <span class="hljs-title class_">NetworkManager</span> {
  <span class="hljs-keyword">var</span> <span class="hljs-attr">user</span>: <span class="hljs-title class_">User</span>
}

protocol <span class="hljs-title class_">Buyable</span> {
  func <span class="hljs-title function_">canBuy</span>() -> <span class="hljs-title class_">Bool</span>
}

<span class="hljs-title class_">In</span> <span class="hljs-title class_">Buy</span>.<span class="hljs-property">swift</span>
extension <span class="hljs-title class_">NetworkManager</span>: <span class="hljs-title class_">Buyable</span> {
  @<span class="hljs-title class_">Inject</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">cart</span>: <span class="hljs-title class_">CartStore</span>

  func <span class="hljs-title function_">canBuy</span>() -> <span class="hljs-title class_">Bool</span> {
    <span class="hljs-keyword">if</span> cart.<span class="hljs-property">hasEnough</span> { <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>} <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> }
    <span class="hljs-comment">//we can still access to user here...</span>
  }

}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">CartViewModel</span> {
  @<span class="hljs-title class_">Inject</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">buy</span>: <span class="hljs-title class_">Buyable</span> <span class="hljs-comment">// Illusion to have a Buyable</span>

  func <span class="hljs-title function_">addItem</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> buy.<span class="hljs-title function_">canBuy</span>(<span class="hljs-params"></span>) { <span class="hljs-comment">/* */</span> }

  }

}
</code></pre>
<p>우리는 Buyable이 Buy 객체의 프로토콜일 수 있다는 환상을 갖고 있지만, 전혀 그렇지 않습니다. 이를 서로 다른 파일에 걸쳐 사용하면서 매우 지저분한데다가 혼란스럽습니다. 하지만... 작동합니다. (코틀린에서는 이렇게 하는 것이 불가능합니다).</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>Property wrappers</h1>
<p>테이블 태그를 Markdown 형식으로 변경하면 다음과 같습니다.</p>
<p>I love them, for writing cross native code, property wrappers is an awesome feature. First usecase from the swift community was to use them for improving the usage of Injection (like Swinject), can lead to read source code like a dagger-hilt style and it’s the equivalent of the delegated properties in Kotlin. But like Kotlin, it has the same drawbacks: readability / logic obfuscation / spagetthi architecture.</p>
<pre><code class="hljs language-js">@propertyWrapper
struct <span class="hljs-title class_">Sanitized</span> {
    <span class="hljs-title function_">private</span>(set) <span class="hljs-keyword">var</span> <span class="hljs-attr">value</span>: <span class="hljs-title class_">String</span> = <span class="hljs-string">""</span>

    <span class="hljs-keyword">var</span> <span class="hljs-attr">wrappedValue</span>: <span class="hljs-title class_">String</span> {
        get { value }
        set { value = newValue.<span class="hljs-title function_">trimmingCharacters</span>(<span class="hljs-attr">in</span>: .<span class="hljs-property">whitespacesAndNewlines</span>) }
    }

    <span class="hljs-title function_">init</span>(<span class="hljs-params">wrappedValue initialValue: <span class="hljs-built_in">String</span></span>) {
        self.<span class="hljs-property">wrappedValue</span> = initialValue
    }
}

struct <span class="hljs-title class_">User</span> {
    @<span class="hljs-title class_">Sanitized</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">username</span>: <span class="hljs-title class_">String</span>
}

<span class="hljs-comment">// Exemple d'utilisation</span>
<span class="hljs-keyword">var</span> user = <span class="hljs-title class_">User</span>(<span class="hljs-attr">username</span>: <span class="hljs-string">"   Chris   "</span>)
user.
<span class="hljs-title function_">print</span>(user.<span class="hljs-property">username</span>) <span class="hljs-comment">// Output: "Chris"</span>
</code></pre>
<p>How can we really use this as a business rule implementation? If we want to add additional features to our string, we will have to add them inside our Sanitized property wrapper or write them outside to maintain a single responsibility principle. Why isn`t Sanitized a function of your User? It may create inconsistency. Property wrappers should be used wisely and could be replaced by small extensions 💡.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>게터/세터 재정의</h1>
<p>이것은 정사각형/속성 감싸기와 거의 비슷합니다. didSet의 사용은 로직을 혼란스럽게 만들 수 있으며 이해하기 어렵게 만들 수 있습니다:</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">Temperature</span> {
    <span class="hljs-keyword">var</span> <span class="hljs-attr">celsiusValue</span>: <span class="hljs-title class_">Double</span> {
        didSet {
            <span class="hljs-title function_">print</span>(<span class="hljs-string">"무슨 일이 일어났어요"</span>)
        }
    }

    <span class="hljs-title function_">init</span>(<span class="hljs-params">celsiusValue: Double</span>) {
        self.<span class="hljs-property">celsiusValue</span> = celsiusValue
    }
}

<span class="hljs-keyword">var</span> temp = <span class="hljs-title class_">Temperature</span>(<span class="hljs-attr">celsiusValue</span>: <span class="hljs-number">20</span>)
temp.<span class="hljs-property">celsiusValue</span> = <span class="hljs-number">25</span>
<span class="hljs-comment">//무슨 일이 일어났어요</span>
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이건 명백해 보일지 모르지만 때로는 강제 언래핑 할 때 어떻게 해야할지 모르겠어요 (그리고 이것이 꼭 멋진 기능은 아닐 수 있어요) - 함수 호출이 확실히 동작할 것이라고 가정하는 것이 유혹스러울 수 있습니다 (하지만 옵셔널 값을 반환할 수도 있어요). 그렇다면, 만약 여러분의 코드가 아니라면 결국 실패할 수 있는 가능성을 가정해야 해요. 예를 들면:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// SPM에서 UIFont를 로드하려고 하는 경우</span>
<span class="hljs-title function_">registerFont</span>(<span class="hljs-string">"font.ttf"</span>) <span class="hljs-comment">// font가 로드된 것으로 가정합니다</span>

<span class="hljs-comment">// ❌ 하지마세요</span>
<span class="hljs-keyword">let</span> font = <span class="hljs-title class_">UIFont</span>(<span class="hljs-attr">name</span>: <span class="hljs-string">"font.ttf"</span>)!

<span class="hljs-comment">// 하세요</span>
guard <span class="hljs-keyword">let</span> font = <span class="hljs-title class_">UIFont</span>(<span class="hljs-attr">name</span>: <span class="hljs-string">"font.ttf"</span>) <span class="hljs-keyword">else</span> {
    <span class="hljs-title class_">Crashlytics</span>.<span class="hljs-title function_">record</span>(<span class="hljs-string">"font.ttf failed to be registered"</span>) <span class="hljs-comment">// 충돌을 모니터링합니다</span>
    <span class="hljs-keyword">return</span> <span class="hljs-comment">// 또는 fatalError() 또는 기본 폰트를 인스턴스화하세요</span>
}
</code></pre>
<h1>결론</h1>
<p>고급 언어 기능 사용은 라이브러리나 구조적인 프레임워크/사용자 정의 아키텍처를 사용하는 것과 유사합니다: 현명하게 사용되어야 하며, 팀으로 수용되어야 합니다. 새로운 프로젝트에 참여하는 새로운 사람이 이 코드 라인을 읽었을 때, 쉽게 이해할 수 있는지 아닌지 고려해야 합니다. 학습은 함의하거나 빛나는 새로운 기능을 남용하지 않는 시점을 인식하거나 더 전통적인 방식으로 돌아가야 하는 시점을 받아들이는 것 또한 포함됩니다 😀.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"악용하지 말아야 할 멋진 Swift 기능들","description":"","date":"2024-05-17 18:48","slug":"2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse","content":"\n![ThecoolSwiftfeaturesthatyoushouldnotabuse](/assets/img/2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse_0.png)\n\niOS 개발자로서, 나는 많은 기존 코드에서 작업하거나 몇 가지 Swift 기능을 시도해 본 적이 있습니다. 그들을 사용하거나 악용 당하는 것을 보면서, 적어도 조심스럽게 사용해야 할 상위 6개의 Swift 언어 기능을 공유하고, 왜 그것들을 팀에서 금지해야 할지 생각했습니다. 간단히 살펴보겠습니다. 동의하지 않거나 다른 예제가 있는 경우 댓글에서 공유해주세요 💬.\n\n# .init() 인스턴스화\n\n.init()을 사용하는 것은 처음 봤을 때 몇 가지 경우에 편리할 수 있지만 (클래스/구조체 이름 바꿀 때 노이즈가 적음), 코드 검토 및 유지보수 시 가독성이 저하됩니다. 코드 검토에서는 호출자로 이동하여 객체의 유형을 확인해야 하며, 유지보수 중에는 객체를 확인하려면 이동해야 합니다. 팀의 생산성을 높이기 위해 사용하지 않아야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n//To avoid ❌\nlet example = .init(title: \"title\")\n//To prefer ✅\nlet example = Example(title: \"title\")\n```\n\nSwiftlint을 사용하면 이 좋은 규칙을 강제로 적용할 수 있어요.\nSwiftlint를 사용하신다면, 프로젝트에서 사용해야 하는 최상의 Swiftlint 설정에 관한 기술적인 문서를 작성했어요 ⬇️\n\n# $0, $1, 등...\n\n$0는 매우 편리하지만 코드 리뷰에서는 코드를 덜 가독성 있게 만들 수 있어요(이 게시물이 말합니다).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n// ❌를 피하기 위해\nnumbers.sort { $0 \u003e $1 }\n// ✅를 선호하기 위해\nnumbers.sort { leftNumber, rightNumber in leftNumber \u003e rightNumber }\n\n# 서브스크립트\n\n서브스크립트 기능은 처음 봤을 때 매우 매력적으로 보입니다:\n\n```js\nstruct TimesTable {\n    let multiplier: Int\n\n    subscript(index: Int) -\u003e Int {\n        return multiplier * index\n    }\n}\n\nlet table = TimesTable(multiplier: 3)\nlet result = table[5]  // 결과 = 15\nprint(result)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서브스크립트가 그렇게 나쁘지는 않지만 테이블[5]을 읽는 일반적인 개발자들은 테이블이 배열이라고 생각하고 다섯 번째 항목에 접근하려는 것으로 생각할 것입니다. 이는 바로 그게 아니기 때문에 코드 리뷰나 파일 간, 모듈 간 사용 시 가독성이 떨어집니다. 논리적인 코드 난독화는 피해야 합니다. 이겪하고자 하는 점이 명확하지 않아서 널리 사용되지 않는 것 때문에 이것을 추천하지는 않습니다.\n\n# 확장(Extensions) 남용\n\n확장은 가독성과 모듈화를 높입니다. 디자인 상, 보호기능이 없는 특성이며 난잡한 코드나 불필요한 사용 또는 안티패턴으로 이어질 수 있습니다.\n\n먼저, 이 규칙을 활성화하지 않았다면, 활성화해야 합니다. 이 규칙은 확장의 일부 불필요한 사용을 감지합니다. 예를 들어, ViewController의 델리게이트를 같은 파일에서 확장을 사용해 구현하지만 어떤 프로토콜 준수 제한도 없거나 그러한 것을 분할하는 경우 등을 감지합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nclass MyViewController: UIViewController{\n  private var IBOutlet textfield: UITextField\n\n  textfield.delegate = self\n...\n}\n\n// To Avoid❌\nextension UIViewController: UITextViewDelegate {\n\n}\n```\n\n올바르지 않은 SOLID 확장 사용 예시:\n\n```js\ncontainer.register(Buyable.self, NetworkManager())\n\nclass NetworkManager {\n  var user: User\n}\n\nprotocol Buyable {\n  func canBuy() -\u003e Bool\n}\n\nIn Buy.swift\nextension NetworkManager: Buyable {\n  @Inject var cart: CartStore\n\n  func canBuy() -\u003e Bool {\n    if cart.hasEnough { return true} else { return false }\n    //we can still access to user here...\n  }\n\n}\n\nclass CartViewModel {\n  @Inject var buy: Buyable // Illusion to have a Buyable\n\n  func addItem() {\n    if buy.canBuy() { /* */ }\n\n  }\n\n}\n```\n\n우리는 Buyable이 Buy 객체의 프로토콜일 수 있다는 환상을 갖고 있지만, 전혀 그렇지 않습니다. 이를 서로 다른 파일에 걸쳐 사용하면서 매우 지저분한데다가 혼란스럽습니다. 하지만... 작동합니다. (코틀린에서는 이렇게 하는 것이 불가능합니다).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Property wrappers\n\n테이블 태그를 Markdown 형식으로 변경하면 다음과 같습니다.\n\nI love them, for writing cross native code, property wrappers is an awesome feature. First usecase from the swift community was to use them for improving the usage of Injection (like Swinject), can lead to read source code like a dagger-hilt style and it’s the equivalent of the delegated properties in Kotlin. But like Kotlin, it has the same drawbacks: readability / logic obfuscation / spagetthi architecture.\n\n```js\n@propertyWrapper\nstruct Sanitized {\n    private(set) var value: String = \"\"\n\n    var wrappedValue: String {\n        get { value }\n        set { value = newValue.trimmingCharacters(in: .whitespacesAndNewlines) }\n    }\n\n    init(wrappedValue initialValue: String) {\n        self.wrappedValue = initialValue\n    }\n}\n\nstruct User {\n    @Sanitized var username: String\n}\n\n// Exemple d'utilisation\nvar user = User(username: \"   Chris   \")\nuser.\nprint(user.username) // Output: \"Chris\"\n```\n\nHow can we really use this as a business rule implementation? If we want to add additional features to our string, we will have to add them inside our Sanitized property wrapper or write them outside to maintain a single responsibility principle. Why isn`t Sanitized a function of your User? It may create inconsistency. Property wrappers should be used wisely and could be replaced by small extensions 💡.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 게터/세터 재정의\n\n이것은 정사각형/속성 감싸기와 거의 비슷합니다. didSet의 사용은 로직을 혼란스럽게 만들 수 있으며 이해하기 어렵게 만들 수 있습니다:\n\n```js\nstruct Temperature {\n    var celsiusValue: Double {\n        didSet {\n            print(\"무슨 일이 일어났어요\")\n        }\n    }\n\n    init(celsiusValue: Double) {\n        self.celsiusValue = celsiusValue\n    }\n}\n\nvar temp = Temperature(celsiusValue: 20)\ntemp.celsiusValue = 25\n//무슨 일이 일어났어요\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이건 명백해 보일지 모르지만 때로는 강제 언래핑 할 때 어떻게 해야할지 모르겠어요 (그리고 이것이 꼭 멋진 기능은 아닐 수 있어요) - 함수 호출이 확실히 동작할 것이라고 가정하는 것이 유혹스러울 수 있습니다 (하지만 옵셔널 값을 반환할 수도 있어요). 그렇다면, 만약 여러분의 코드가 아니라면 결국 실패할 수 있는 가능성을 가정해야 해요. 예를 들면:\n\n```js\n// SPM에서 UIFont를 로드하려고 하는 경우\nregisterFont(\"font.ttf\") // font가 로드된 것으로 가정합니다\n\n// ❌ 하지마세요\nlet font = UIFont(name: \"font.ttf\")!\n\n// 하세요\nguard let font = UIFont(name: \"font.ttf\") else {\n    Crashlytics.record(\"font.ttf failed to be registered\") // 충돌을 모니터링합니다\n    return // 또는 fatalError() 또는 기본 폰트를 인스턴스화하세요\n}\n```\n\n# 결론\n\n고급 언어 기능 사용은 라이브러리나 구조적인 프레임워크/사용자 정의 아키텍처를 사용하는 것과 유사합니다: 현명하게 사용되어야 하며, 팀으로 수용되어야 합니다. 새로운 프로젝트에 참여하는 새로운 사람이 이 코드 라인을 읽었을 때, 쉽게 이해할 수 있는지 아닌지 고려해야 합니다. 학습은 함의하거나 빛나는 새로운 기능을 남용하지 않는 시점을 인식하거나 더 전통적인 방식으로 돌아가야 하는 시점을 받아들이는 것 또한 포함됩니다 😀.\n","ogImage":{"url":"/assets/img/2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse_0.png"},"coverImage":"/assets/img/2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse_0.png\" alt=\"ThecoolSwiftfeaturesthatyoushouldnotabuse\"\u003e\u003c/p\u003e\n\u003cp\u003eiOS 개발자로서, 나는 많은 기존 코드에서 작업하거나 몇 가지 Swift 기능을 시도해 본 적이 있습니다. 그들을 사용하거나 악용 당하는 것을 보면서, 적어도 조심스럽게 사용해야 할 상위 6개의 Swift 언어 기능을 공유하고, 왜 그것들을 팀에서 금지해야 할지 생각했습니다. 간단히 살펴보겠습니다. 동의하지 않거나 다른 예제가 있는 경우 댓글에서 공유해주세요 💬.\u003c/p\u003e\n\u003ch1\u003e.init() 인스턴스화\u003c/h1\u003e\n\u003cp\u003e.init()을 사용하는 것은 처음 봤을 때 몇 가지 경우에 편리할 수 있지만 (클래스/구조체 이름 바꿀 때 노이즈가 적음), 코드 검토 및 유지보수 시 가독성이 저하됩니다. 코드 검토에서는 호출자로 이동하여 객체의 유형을 확인해야 하며, 유지보수 중에는 객체를 확인하려면 이동해야 합니다. 팀의 생산성을 높이기 위해 사용하지 않아야 합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//To avoid ❌\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e example = .\u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"title\"\u003c/span\u003e)\n\u003cspan class=\"hljs-comment\"\u003e//To prefer ✅\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e example = \u003cspan class=\"hljs-title class_\"\u003eExample\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"title\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSwiftlint을 사용하면 이 좋은 규칙을 강제로 적용할 수 있어요.\nSwiftlint를 사용하신다면, 프로젝트에서 사용해야 하는 최상의 Swiftlint 설정에 관한 기술적인 문서를 작성했어요 ⬇️\u003c/p\u003e\n\u003ch1\u003e$0, $1, 등...\u003c/h1\u003e\n\u003cp\u003e$0는 매우 편리하지만 코드 리뷰에서는 코드를 덜 가독성 있게 만들 수 있어요(이 게시물이 말합니다).\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e// ❌를 피하기 위해\nnumbers.sort { $0 \u003e $1 }\n// ✅를 선호하기 위해\nnumbers.sort { leftNumber, rightNumber in leftNumber \u003e rightNumber }\u003c/p\u003e\n\u003ch1\u003e서브스크립트\u003c/h1\u003e\n\u003cp\u003e서브스크립트 기능은 처음 봤을 때 매우 매력적으로 보입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eTimesTable\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emultiplier\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eInt\u003c/span\u003e\n\n    \u003cspan class=\"hljs-title function_\"\u003esubscript\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eindex\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eInt\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-title class_\"\u003eInt\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e multiplier * index\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e table = \u003cspan class=\"hljs-title class_\"\u003eTimesTable\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003emultiplier\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e result = table[\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e]  \u003cspan class=\"hljs-comment\"\u003e// 결과 = 15\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(result)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e서브스크립트가 그렇게 나쁘지는 않지만 테이블[5]을 읽는 일반적인 개발자들은 테이블이 배열이라고 생각하고 다섯 번째 항목에 접근하려는 것으로 생각할 것입니다. 이는 바로 그게 아니기 때문에 코드 리뷰나 파일 간, 모듈 간 사용 시 가독성이 떨어집니다. 논리적인 코드 난독화는 피해야 합니다. 이겪하고자 하는 점이 명확하지 않아서 널리 사용되지 않는 것 때문에 이것을 추천하지는 않습니다.\u003c/p\u003e\n\u003ch1\u003e확장(Extensions) 남용\u003c/h1\u003e\n\u003cp\u003e확장은 가독성과 모듈화를 높입니다. 디자인 상, 보호기능이 없는 특성이며 난잡한 코드나 불필요한 사용 또는 안티패턴으로 이어질 수 있습니다.\u003c/p\u003e\n\u003cp\u003e먼저, 이 규칙을 활성화하지 않았다면, 활성화해야 합니다. 이 규칙은 확장의 일부 불필요한 사용을 감지합니다. 예를 들어, ViewController의 델리게이트를 같은 파일에서 확장을 사용해 구현하지만 어떤 프로토콜 준수 제한도 없거나 그러한 것을 분할하는 경우 등을 감지합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyViewController\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUIViewController\u003c/span\u003e{\n  private \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIBOutlet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etextfield\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUITextField\u003c/span\u003e\n\n  textfield.\u003cspan class=\"hljs-property\"\u003edelegate\u003c/span\u003e = self\n...\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// To Avoid❌\u003c/span\u003e\nextension \u003cspan class=\"hljs-title class_\"\u003eUIViewController\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUITextViewDelegate\u003c/span\u003e {\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e올바르지 않은 SOLID 확장 사용 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003econtainer.\u003cspan class=\"hljs-title function_\"\u003eregister\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBuyable\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eself\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eNetworkManager\u003c/span\u003e())\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNetworkManager\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003euser\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e\n}\n\nprotocol \u003cspan class=\"hljs-title class_\"\u003eBuyable\u003c/span\u003e {\n  func \u003cspan class=\"hljs-title function_\"\u003ecanBuy\u003c/span\u003e() -\u003e \u003cspan class=\"hljs-title class_\"\u003eBool\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-title class_\"\u003eIn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBuy\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eswift\u003c/span\u003e\nextension \u003cspan class=\"hljs-title class_\"\u003eNetworkManager\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBuyable\u003c/span\u003e {\n  @\u003cspan class=\"hljs-title class_\"\u003eInject\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecart\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCartStore\u003c/span\u003e\n\n  func \u003cspan class=\"hljs-title function_\"\u003ecanBuy\u003c/span\u003e() -\u003e \u003cspan class=\"hljs-title class_\"\u003eBool\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e cart.\u003cspan class=\"hljs-property\"\u003ehasEnough\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e} \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e }\n    \u003cspan class=\"hljs-comment\"\u003e//we can still access to user here...\u003c/span\u003e\n  }\n\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCartViewModel\u003c/span\u003e {\n  @\u003cspan class=\"hljs-title class_\"\u003eInject\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebuy\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBuyable\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// Illusion to have a Buyable\u003c/span\u003e\n\n  func \u003cspan class=\"hljs-title function_\"\u003eaddItem\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e buy.\u003cspan class=\"hljs-title function_\"\u003ecanBuy\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) { \u003cspan class=\"hljs-comment\"\u003e/* */\u003c/span\u003e }\n\n  }\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 Buyable이 Buy 객체의 프로토콜일 수 있다는 환상을 갖고 있지만, 전혀 그렇지 않습니다. 이를 서로 다른 파일에 걸쳐 사용하면서 매우 지저분한데다가 혼란스럽습니다. 하지만... 작동합니다. (코틀린에서는 이렇게 하는 것이 불가능합니다).\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eProperty wrappers\u003c/h1\u003e\n\u003cp\u003e테이블 태그를 Markdown 형식으로 변경하면 다음과 같습니다.\u003c/p\u003e\n\u003cp\u003eI love them, for writing cross native code, property wrappers is an awesome feature. First usecase from the swift community was to use them for improving the usage of Injection (like Swinject), can lead to read source code like a dagger-hilt style and it’s the equivalent of the delegated properties in Kotlin. But like Kotlin, it has the same drawbacks: readability / logic obfuscation / spagetthi architecture.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@propertyWrapper\nstruct \u003cspan class=\"hljs-title class_\"\u003eSanitized\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003eprivate\u003c/span\u003e(set) \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewrappedValue\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e {\n        get { value }\n        set { value = newValue.\u003cspan class=\"hljs-title function_\"\u003etrimmingCharacters\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ein\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003ewhitespacesAndNewlines\u003c/span\u003e) }\n    }\n\n    \u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ewrappedValue initialValue: \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e\u003c/span\u003e) {\n        self.\u003cspan class=\"hljs-property\"\u003ewrappedValue\u003c/span\u003e = initialValue\n    }\n}\n\nstruct \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e {\n    @\u003cspan class=\"hljs-title class_\"\u003eSanitized\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eusername\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// Exemple d'utilisation\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e user = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eusername\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"   Chris   \"\u003c/span\u003e)\nuser.\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(user.\u003cspan class=\"hljs-property\"\u003eusername\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// Output: \"Chris\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHow can we really use this as a business rule implementation? If we want to add additional features to our string, we will have to add them inside our Sanitized property wrapper or write them outside to maintain a single responsibility principle. Why isn`t Sanitized a function of your User? It may create inconsistency. Property wrappers should be used wisely and could be replaced by small extensions 💡.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e게터/세터 재정의\u003c/h1\u003e\n\u003cp\u003e이것은 정사각형/속성 감싸기와 거의 비슷합니다. didSet의 사용은 로직을 혼란스럽게 만들 수 있으며 이해하기 어렵게 만들 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eTemperature\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecelsiusValue\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDouble\u003c/span\u003e {\n        didSet {\n            \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"무슨 일이 일어났어요\"\u003c/span\u003e)\n        }\n    }\n\n    \u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecelsiusValue: Double\u003c/span\u003e) {\n        self.\u003cspan class=\"hljs-property\"\u003ecelsiusValue\u003c/span\u003e = celsiusValue\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e temp = \u003cspan class=\"hljs-title class_\"\u003eTemperature\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ecelsiusValue\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e)\ntemp.\u003cspan class=\"hljs-property\"\u003ecelsiusValue\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//무슨 일이 일어났어요\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이건 명백해 보일지 모르지만 때로는 강제 언래핑 할 때 어떻게 해야할지 모르겠어요 (그리고 이것이 꼭 멋진 기능은 아닐 수 있어요) - 함수 호출이 확실히 동작할 것이라고 가정하는 것이 유혹스러울 수 있습니다 (하지만 옵셔널 값을 반환할 수도 있어요). 그렇다면, 만약 여러분의 코드가 아니라면 결국 실패할 수 있는 가능성을 가정해야 해요. 예를 들면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// SPM에서 UIFont를 로드하려고 하는 경우\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eregisterFont\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"font.ttf\"\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// font가 로드된 것으로 가정합니다\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// ❌ 하지마세요\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e font = \u003cspan class=\"hljs-title class_\"\u003eUIFont\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"font.ttf\"\u003c/span\u003e)!\n\n\u003cspan class=\"hljs-comment\"\u003e// 하세요\u003c/span\u003e\nguard \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e font = \u003cspan class=\"hljs-title class_\"\u003eUIFont\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"font.ttf\"\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-title class_\"\u003eCrashlytics\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erecord\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"font.ttf failed to be registered\"\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// 충돌을 모니터링합니다\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 또는 fatalError() 또는 기본 폰트를 인스턴스화하세요\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e고급 언어 기능 사용은 라이브러리나 구조적인 프레임워크/사용자 정의 아키텍처를 사용하는 것과 유사합니다: 현명하게 사용되어야 하며, 팀으로 수용되어야 합니다. 새로운 프로젝트에 참여하는 새로운 사람이 이 코드 라인을 읽었을 때, 쉽게 이해할 수 있는지 아닌지 고려해야 합니다. 학습은 함의하거나 빛나는 새로운 기능을 남용하지 않는 시점을 인식하거나 더 전통적인 방식으로 돌아가야 하는 시점을 받아들이는 것 또한 포함됩니다 😀.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse"},"buildId":"wOkGEDZCvEs3S_XaNsdwr","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>