<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>오픈AI ChatGPT API를 SQL에서 사용하는 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="오픈AI ChatGPT API를 SQL에서 사용하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="오픈AI ChatGPT API를 SQL에서 사용하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL" data-gatsby-head="true"/><meta name="twitter:title" content="오픈AI ChatGPT API를 SQL에서 사용하는 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-17 19:12" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_buildManifest.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">오픈AI ChatGPT API를 SQL에서 사용하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="오픈AI ChatGPT API를 SQL에서 사용하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 17, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>챗GPT 및 OpenAI API를 사용할 때 SQL이 먼저 떠오르지는 않겠지만, 데이터의 언어이기 때문에 SQL을 활용할 수 있다는 사실을 명심해야 합니다. SQL에서 HTTP 요청을 보낼 수 있다는 점은 다양한 가능성을 열어 줍니다.</p>
<p>오늘의 글에서는 PL/SQL을 사용하여 사용자 지정 Oracle SQL 함수를 작성하는 방법을 보여 드리겠습니다. 질문 문자열을 입력으로 받아서 형식화된 JSON을 반환합니다. Oracle의 dbms_cloud 패키지가 API 호출을 수행하는 데 주로 사용되며, 다른 데이터베이스 공급업체를 사용하는 경우 해당 작업을 수행할 수 있는 대체 패키지 및 함수 세트를 찾을 수 있을 것입니다.</p>
<p>따라서, 먼저 함께 따라 해야 할 전제 조건에 대해 설명하겠습니다.</p>
<p></p>
<h1>ChatGPT in SQL — 필수 사항</h1>
<p>소개에서 언급했듯이, 저는 오라클 클라우드에서 프로비저닝된 항상 무료 인스턴스에서 실행되는 Oracle SQL을 사용하고 있습니다. 만약 따라하기를 원한다면 무료 계정을 등록하고 데이터베이스 인스턴스를 프로비저닝하고 연결 지갑을 다운로드해야 합니다.</p>
<p>또한 필요한 것은 OpenAI API 키입니다. 링크된 기사를 통해 몇 분 안에 얻는 방법을 알 수 있습니다.</p>
<p>그게 거의 다에요! 이제 본격적으로 시작해 봅시다.</p>
<p></p>
<h1>OpenAI API — 대화 완성 엔드포인트 테스트</h1>
<p>SQL에서 구현할 대화 완성 예제는 매우 간단합니다. OpenAI의 공식 문서에서는 API에 요청하는 방법을 보여줍니다:</p>
<p><img src="/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_1.png" alt="image"></p>
<p>SQL에서는 Python과 같이 OpenAI를 위한 서드파티 라이브러리가 없기 때문에 좀 더 수동적인 방법을 선택해야 합니다. 이론적으로는 — 위의 curl 명령을 실행하고 응답을 받는다면 SQL에서도 동일한 작업을 수행할 수 있습니다.</p>
<p></p>
<p>이것을 시연하는 가장 쉬운 방법은 Postman을 통해 하는 것입니다. <a href="https://api.openai.com/v1/chat/completions%EC%97%90" rel="nofollow" target="_blank">https://api.openai.com/v1/chat/completions에</a> 새로운 POST 요청의 헤더와 JSON 본문을 채우고, 나와 비슷한 응답을 받을 수 있습니다:</p>
<p><img src="/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_2.png" alt="이미지"></p>
<p>가장 인상적인 GPT 응답은 아닙니다만, 동작은 합니다. 이제 SQL로 가져와 봅시다.</p>
<h1>SQL에서 ChatGPT 사용하기 — 사용자 지정 PL/SQL 함수에서 OpenAI API 사용 방법</h1>
<p></p>
<p>PL/SQL을 사용하면 사용자 정의 함수를 정의할 수 있습니다. get_gpt_response() 함수는 문자열 질문을 받아 CLOB를 반환합니다. CLOB는 기본 VARCHAR2 타입으로는 너무 큰 문자열을 저장하는 데 사용되는 특별한 데이터 유형입니다.</p>
<p>이 함수 내에서 v_api_key 상수는 OpenAI API 키의 값을 보유하고 있습니다. 따라서 꼭 바꾸지 않도록 주의하세요.</p>
<p>이 함수는 Oracle의 dbms_cloud 패키지를 사용하여 OpenAI의 채팅 완료 엔드포인트로 HTTP 요청을 보냅니다. send_request() 프로시저는 다음 매개변수가 필요합니다:</p>
<ul>
<li>uri — 엔드포인트의 URL입니다.</li>
<li>method — 요청에 사용되는 HTTP 메서드입니다. 여러분은 POST로 설정해야 합니다.</li>
<li>headers — 요청 헤더를 지정하는 JSON 객체입니다. 이전에 본 바와 같이 Content-Type 및 Authorization을 명시해야 합니다.</li>
<li>body — BLOB로 변환된 JSON 객체입니다. 보내는 데이터를 포함하며, 사용할 모델, 온도 매개변수(랜덤성) 및 GPT가 답변할 질문과 같은 정보가 포함됩니다.</li>
</ul>
<p></p>
<p>send_request() 함수의 결과는 v_response 변수에 저장되며, 그것은 사용자에게 텍스트로 반환됩니다:</p>
<pre><code class="hljs language-js">create or replace <span class="hljs-keyword">function</span> <span class="hljs-title function_">get_gpt_response</span>(<span class="hljs-params">
    p_question varchar2
</span>) <span class="hljs-keyword">return</span> clob
is
    v_api_key constant <span class="hljs-title function_">varchar2</span>(<span class="hljs-number">100</span>) := <span class="hljs-string">'&#x3C;your-api-key>'</span>;
    v_response dbms_cloud_types.<span class="hljs-property">resp</span>;
begin
    v_response := dbms_cloud.<span class="hljs-title function_">send_request</span>(
        <span class="hljs-function"><span class="hljs-params">uri</span>     =></span> <span class="hljs-string">'https://api.openai.com/v1/chat/completions'</span>,
        <span class="hljs-function"><span class="hljs-params">method</span>  =></span> dbms_cloud.<span class="hljs-property">method_post</span>,
        -- <span class="hljs-title class_">Headers</span> must be <span class="hljs-keyword">of</span> type <span class="hljs-title class_">JSON</span>_OBJECT
        headers => <span class="hljs-title function_">json_object</span>(
            <span class="hljs-string">'Content-Type'</span>  value <span class="hljs-string">'application/json'</span>,
            <span class="hljs-string">'Authorization'</span> value <span class="hljs-string">'Bearer '</span> || v_api_key
        ),
        -- <span class="hljs-title class_">Request</span> body must be a <span class="hljs-title class_">JSON</span> structure converted to <span class="hljs-variable constant_">BLOB</span>
        body    => utl_raw.<span class="hljs-title function_">cast_to_raw</span>(
            <span class="hljs-title function_">json_object</span>(
                <span class="hljs-string">'model'</span>    value <span class="hljs-string">'gpt-3.5-turbo'</span>,
                <span class="hljs-string">'messages'</span> value <span class="hljs-title function_">json_array</span>(
                    <span class="hljs-title function_">json_object</span>(
                        <span class="hljs-string">'role'</span>    value <span class="hljs-string">'user'</span>,
                        <span class="hljs-string">'content'</span> value p_question
                    )
                ),
                <span class="hljs-string">'temperature'</span> value <span class="hljs-number">0.5</span>
            )
        )
    );
    <span class="hljs-keyword">return</span> dbms_cloud.<span class="hljs-title function_">get_response_text</span>(v_response);
end get_gpt_response;
/
</code></pre>
<p>위 스니펫을 실행하면 해당 함수를 사용할 수 있게 됩니다.</p>
<p>예상대로 작동하는지 확인해 봅시다:</p>
<p></p>
<pre><code class="hljs language-js">select
    <span class="hljs-title function_">json_query</span>(<span class="hljs-title function_">get_gpt_response</span>(<span class="hljs-string">'What is the capital of United States?'</span>), <span class="hljs-string">'$'</span> returning clob pretty) <span class="hljs-keyword">as</span> response
<span class="hljs-keyword">from</span> dual;
</code></pre>
<p>여기에 얻은 응답이 있어요:</p>
<p>매우 좋은 결과 나왔네요! 하지만 하나 문제가 있는데요 — 반환된 응답이 JSON 형식으로 표시되는데, 이는 관계형 데이터베이스를 다룰 때 기본적으로 원하는 형식은 아니죠.</p>
<p></p>
<p>다행히도, Oracle은 탁월한 JSON 지원을 제공하기 때문에 관련 필드를 추출하고 응답을 일반 데이터베이스 테이블 형식으로 포맷할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">with</span> response <span class="hljs-keyword">as</span> (
    select <span class="hljs-title function_">get_gpt_response</span>(<span class="hljs-string">'What is the capital of United States?'</span>) <span class="hljs-keyword">as</span> data
    <span class="hljs-keyword">from</span> dual
)
select
    jt.*
<span class="hljs-keyword">from</span> response r,
    <span class="hljs-title function_">json_table</span>(
        r.<span class="hljs-property">data</span>,
        <span class="hljs-string">'$'</span>
        <span class="hljs-title function_">columns</span>(
            id                <span class="hljs-title function_">varchar2</span>(<span class="hljs-number">50</span>)   path <span class="hljs-string">'$.id'</span>,
            answer            <span class="hljs-title function_">varchar2</span>(<span class="hljs-number">1000</span>) path <span class="hljs-string">'$.choices[0].message.content'</span>,
            prompt_tokens     number         path <span class="hljs-string">'$.usage.prompt_tokens'</span>,
            completion_tokens number         path <span class="hljs-string">'$.usage.completion_tokens'</span>,
            total_tokens      number         path <span class="hljs-string">'$.usage.total_tokens'</span>
        )
    ) jt;
</code></pre>
<p>아래는 출력 결과입니다:</p>
<p><img src="/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_4.png" alt="출력 이미지"></p>
<p></p>
<p>여기서부터는 세상이 당신의 조개껍질처럼 열립니다. 결과를 그대로 사용하거나 표로 저장할 수도 있습니다. 토큰 사용 정보는 자주 이 함수를 실행할 계획이 있다면 사용된 리소스를 잘 보여주는 지표가 될 것입니다.</p>
<h1>개선할 수 있는 점 (하고야 할 것)</h1>
<p>오늘 구현한 솔루션은 작동하지만 상당히 기본적이며 몇 가지 조정이 필요합니다:</p>
<ul>
<li>예외 처리 — 현재 전혀 구현되지 않았습니다. dbms_cloud 오류뿐만 아니라 일반적인 다른 오류도 잡을 수 있도록 해야 합니다.</li>
<li>하드코딩된 엔드포인트 — 현재 상태에서 함수는 채팅 완성 엔드포인트로만 요청을 보냅니다. 엔드포인트를 동적으로 만드는 것이 더 좋을 것입니다.</li>
<li>응답이 저장되지 않음 — 사용자에게 반환하기 전에 응답을 데이터베이스 테이블에 저장하는 것이 좋을 것입니다.</li>
</ul>
<p></p>
<p>위의 모든 부분은 기본적인 SQL 기술이 있다면 쉽게 해결할 수 있기 때문에 여러분에게 맡기겠습니다.</p>
<h1>SQL에서 OpenAI API 요약</h1>
<p>많은 사람들이 SQL이 OpenAI API에 HTTP 호출을 위한 유효한 옵션으로 여겨지지 않는다고 생각하지만, 실제로 많은 신입사원들은 SQL이 기본적인 데이터 조작 이상의 기능을 수행할 수 있다는 것을 알지 못합니다. SQL은 데이터의 언어이며, 이에 따라 Python이 할 수 있는 거의 모든 작업을 데이터 이동 없이 수행할 수 있습니다.</p>
<p>오늘의 예시는 Oracle SQL과 PL/SQL로 한정되어 있지만, 여러분이 나의 해결책을 SQL Server, MySQL 및 Postgres에 구현할 방법을 찾을 수 있을 것입니다.</p>
<p></p>
<p>SQL 사용 사례 중에서 머신 러닝과 공간 데이터 분석과 같은 더 흥미로운 내용이 추가로 올라올 예정이니 기대해 주세요.</p>
<p>읽어 주셔서 감사합니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"오픈AI ChatGPT API를 SQL에서 사용하는 방법","description":"","date":"2024-05-17 19:12","slug":"2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL","content":"\n\u003cimg src=\"/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_0.png\" /\u003e\n\n챗GPT 및 OpenAI API를 사용할 때 SQL이 먼저 떠오르지는 않겠지만, 데이터의 언어이기 때문에 SQL을 활용할 수 있다는 사실을 명심해야 합니다. SQL에서 HTTP 요청을 보낼 수 있다는 점은 다양한 가능성을 열어 줍니다.\n\n오늘의 글에서는 PL/SQL을 사용하여 사용자 지정 Oracle SQL 함수를 작성하는 방법을 보여 드리겠습니다. 질문 문자열을 입력으로 받아서 형식화된 JSON을 반환합니다. Oracle의 dbms_cloud 패키지가 API 호출을 수행하는 데 주로 사용되며, 다른 데이터베이스 공급업체를 사용하는 경우 해당 작업을 수행할 수 있는 대체 패키지 및 함수 세트를 찾을 수 있을 것입니다.\n\n따라서, 먼저 함께 따라 해야 할 전제 조건에 대해 설명하겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# ChatGPT in SQL — 필수 사항\n\n소개에서 언급했듯이, 저는 오라클 클라우드에서 프로비저닝된 항상 무료 인스턴스에서 실행되는 Oracle SQL을 사용하고 있습니다. 만약 따라하기를 원한다면 무료 계정을 등록하고 데이터베이스 인스턴스를 프로비저닝하고 연결 지갑을 다운로드해야 합니다.\n\n또한 필요한 것은 OpenAI API 키입니다. 링크된 기사를 통해 몇 분 안에 얻는 방법을 알 수 있습니다.\n\n그게 거의 다에요! 이제 본격적으로 시작해 봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# OpenAI API — 대화 완성 엔드포인트 테스트\n\nSQL에서 구현할 대화 완성 예제는 매우 간단합니다. OpenAI의 공식 문서에서는 API에 요청하는 방법을 보여줍니다:\n\n![image](/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_1.png)\n\nSQL에서는 Python과 같이 OpenAI를 위한 서드파티 라이브러리가 없기 때문에 좀 더 수동적인 방법을 선택해야 합니다. 이론적으로는 — 위의 curl 명령을 실행하고 응답을 받는다면 SQL에서도 동일한 작업을 수행할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것을 시연하는 가장 쉬운 방법은 Postman을 통해 하는 것입니다. https://api.openai.com/v1/chat/completions에 새로운 POST 요청의 헤더와 JSON 본문을 채우고, 나와 비슷한 응답을 받을 수 있습니다:\n\n![이미지](/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_2.png)\n\n가장 인상적인 GPT 응답은 아닙니다만, 동작은 합니다. 이제 SQL로 가져와 봅시다.\n\n# SQL에서 ChatGPT 사용하기 — 사용자 지정 PL/SQL 함수에서 OpenAI API 사용 방법\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPL/SQL을 사용하면 사용자 정의 함수를 정의할 수 있습니다. get_gpt_response() 함수는 문자열 질문을 받아 CLOB를 반환합니다. CLOB는 기본 VARCHAR2 타입으로는 너무 큰 문자열을 저장하는 데 사용되는 특별한 데이터 유형입니다.\n\n이 함수 내에서 v_api_key 상수는 OpenAI API 키의 값을 보유하고 있습니다. 따라서 꼭 바꾸지 않도록 주의하세요.\n\n이 함수는 Oracle의 dbms_cloud 패키지를 사용하여 OpenAI의 채팅 완료 엔드포인트로 HTTP 요청을 보냅니다. send_request() 프로시저는 다음 매개변수가 필요합니다:\n\n- uri — 엔드포인트의 URL입니다.\n- method — 요청에 사용되는 HTTP 메서드입니다. 여러분은 POST로 설정해야 합니다.\n- headers — 요청 헤더를 지정하는 JSON 객체입니다. 이전에 본 바와 같이 Content-Type 및 Authorization을 명시해야 합니다.\n- body — BLOB로 변환된 JSON 객체입니다. 보내는 데이터를 포함하며, 사용할 모델, 온도 매개변수(랜덤성) 및 GPT가 답변할 질문과 같은 정보가 포함됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nsend_request() 함수의 결과는 v_response 변수에 저장되며, 그것은 사용자에게 텍스트로 반환됩니다:\n\n```js\ncreate or replace function get_gpt_response(\n    p_question varchar2\n) return clob\nis\n    v_api_key constant varchar2(100) := '\u003cyour-api-key\u003e';\n    v_response dbms_cloud_types.resp;\nbegin\n    v_response := dbms_cloud.send_request(\n        uri     =\u003e 'https://api.openai.com/v1/chat/completions',\n        method  =\u003e dbms_cloud.method_post,\n        -- Headers must be of type JSON_OBJECT\n        headers =\u003e json_object(\n            'Content-Type'  value 'application/json',\n            'Authorization' value 'Bearer ' || v_api_key\n        ),\n        -- Request body must be a JSON structure converted to BLOB\n        body    =\u003e utl_raw.cast_to_raw(\n            json_object(\n                'model'    value 'gpt-3.5-turbo',\n                'messages' value json_array(\n                    json_object(\n                        'role'    value 'user',\n                        'content' value p_question\n                    )\n                ),\n                'temperature' value 0.5\n            )\n        )\n    );\n    return dbms_cloud.get_response_text(v_response);\nend get_gpt_response;\n/\n```\n\n위 스니펫을 실행하면 해당 함수를 사용할 수 있게 됩니다.\n\n예상대로 작동하는지 확인해 봅시다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nselect\n    json_query(get_gpt_response('What is the capital of United States?'), '$' returning clob pretty) as response\nfrom dual;\n```\n\n여기에 얻은 응답이 있어요:\n\n\u003cimg src=\"/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_3.png\" /\u003e\n\n매우 좋은 결과 나왔네요! 하지만 하나 문제가 있는데요 — 반환된 응답이 JSON 형식으로 표시되는데, 이는 관계형 데이터베이스를 다룰 때 기본적으로 원하는 형식은 아니죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다행히도, Oracle은 탁월한 JSON 지원을 제공하기 때문에 관련 필드를 추출하고 응답을 일반 데이터베이스 테이블 형식으로 포맷할 수 있습니다:\n\n```js\nwith response as (\n    select get_gpt_response('What is the capital of United States?') as data\n    from dual\n)\nselect\n    jt.*\nfrom response r,\n    json_table(\n        r.data,\n        '$'\n        columns(\n            id                varchar2(50)   path '$.id',\n            answer            varchar2(1000) path '$.choices[0].message.content',\n            prompt_tokens     number         path '$.usage.prompt_tokens',\n            completion_tokens number         path '$.usage.completion_tokens',\n            total_tokens      number         path '$.usage.total_tokens'\n        )\n    ) jt;\n```\n\n아래는 출력 결과입니다:\n\n![출력 이미지](/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서부터는 세상이 당신의 조개껍질처럼 열립니다. 결과를 그대로 사용하거나 표로 저장할 수도 있습니다. 토큰 사용 정보는 자주 이 함수를 실행할 계획이 있다면 사용된 리소스를 잘 보여주는 지표가 될 것입니다.\n\n# 개선할 수 있는 점 (하고야 할 것)\n\n오늘 구현한 솔루션은 작동하지만 상당히 기본적이며 몇 가지 조정이 필요합니다:\n\n- 예외 처리 — 현재 전혀 구현되지 않았습니다. dbms_cloud 오류뿐만 아니라 일반적인 다른 오류도 잡을 수 있도록 해야 합니다.\n- 하드코딩된 엔드포인트 — 현재 상태에서 함수는 채팅 완성 엔드포인트로만 요청을 보냅니다. 엔드포인트를 동적으로 만드는 것이 더 좋을 것입니다.\n- 응답이 저장되지 않음 — 사용자에게 반환하기 전에 응답을 데이터베이스 테이블에 저장하는 것이 좋을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 모든 부분은 기본적인 SQL 기술이 있다면 쉽게 해결할 수 있기 때문에 여러분에게 맡기겠습니다.\n\n# SQL에서 OpenAI API 요약\n\n많은 사람들이 SQL이 OpenAI API에 HTTP 호출을 위한 유효한 옵션으로 여겨지지 않는다고 생각하지만, 실제로 많은 신입사원들은 SQL이 기본적인 데이터 조작 이상의 기능을 수행할 수 있다는 것을 알지 못합니다. SQL은 데이터의 언어이며, 이에 따라 Python이 할 수 있는 거의 모든 작업을 데이터 이동 없이 수행할 수 있습니다.\n\n오늘의 예시는 Oracle SQL과 PL/SQL로 한정되어 있지만, 여러분이 나의 해결책을 SQL Server, MySQL 및 Postgres에 구현할 방법을 찾을 수 있을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSQL 사용 사례 중에서 머신 러닝과 공간 데이터 분석과 같은 더 흥미로운 내용이 추가로 올라올 예정이니 기대해 주세요.\n\n읽어 주셔서 감사합니다.\n","ogImage":{"url":"/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_0.png"},"coverImage":"/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e챗GPT 및 OpenAI API를 사용할 때 SQL이 먼저 떠오르지는 않겠지만, 데이터의 언어이기 때문에 SQL을 활용할 수 있다는 사실을 명심해야 합니다. SQL에서 HTTP 요청을 보낼 수 있다는 점은 다양한 가능성을 열어 줍니다.\u003c/p\u003e\n\u003cp\u003e오늘의 글에서는 PL/SQL을 사용하여 사용자 지정 Oracle SQL 함수를 작성하는 방법을 보여 드리겠습니다. 질문 문자열을 입력으로 받아서 형식화된 JSON을 반환합니다. Oracle의 dbms_cloud 패키지가 API 호출을 수행하는 데 주로 사용되며, 다른 데이터베이스 공급업체를 사용하는 경우 해당 작업을 수행할 수 있는 대체 패키지 및 함수 세트를 찾을 수 있을 것입니다.\u003c/p\u003e\n\u003cp\u003e따라서, 먼저 함께 따라 해야 할 전제 조건에 대해 설명하겠습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003eChatGPT in SQL — 필수 사항\u003c/h1\u003e\n\u003cp\u003e소개에서 언급했듯이, 저는 오라클 클라우드에서 프로비저닝된 항상 무료 인스턴스에서 실행되는 Oracle SQL을 사용하고 있습니다. 만약 따라하기를 원한다면 무료 계정을 등록하고 데이터베이스 인스턴스를 프로비저닝하고 연결 지갑을 다운로드해야 합니다.\u003c/p\u003e\n\u003cp\u003e또한 필요한 것은 OpenAI API 키입니다. 링크된 기사를 통해 몇 분 안에 얻는 방법을 알 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그게 거의 다에요! 이제 본격적으로 시작해 봅시다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003eOpenAI API — 대화 완성 엔드포인트 테스트\u003c/h1\u003e\n\u003cp\u003eSQL에서 구현할 대화 완성 예제는 매우 간단합니다. OpenAI의 공식 문서에서는 API에 요청하는 방법을 보여줍니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eSQL에서는 Python과 같이 OpenAI를 위한 서드파티 라이브러리가 없기 때문에 좀 더 수동적인 방법을 선택해야 합니다. 이론적으로는 — 위의 curl 명령을 실행하고 응답을 받는다면 SQL에서도 동일한 작업을 수행할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e이것을 시연하는 가장 쉬운 방법은 Postman을 통해 하는 것입니다. \u003ca href=\"https://api.openai.com/v1/chat/completions%EC%97%90\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://api.openai.com/v1/chat/completions에\u003c/a\u003e 새로운 POST 요청의 헤더와 JSON 본문을 채우고, 나와 비슷한 응답을 받을 수 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e가장 인상적인 GPT 응답은 아닙니다만, 동작은 합니다. 이제 SQL로 가져와 봅시다.\u003c/p\u003e\n\u003ch1\u003eSQL에서 ChatGPT 사용하기 — 사용자 지정 PL/SQL 함수에서 OpenAI API 사용 방법\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003ePL/SQL을 사용하면 사용자 정의 함수를 정의할 수 있습니다. get_gpt_response() 함수는 문자열 질문을 받아 CLOB를 반환합니다. CLOB는 기본 VARCHAR2 타입으로는 너무 큰 문자열을 저장하는 데 사용되는 특별한 데이터 유형입니다.\u003c/p\u003e\n\u003cp\u003e이 함수 내에서 v_api_key 상수는 OpenAI API 키의 값을 보유하고 있습니다. 따라서 꼭 바꾸지 않도록 주의하세요.\u003c/p\u003e\n\u003cp\u003e이 함수는 Oracle의 dbms_cloud 패키지를 사용하여 OpenAI의 채팅 완료 엔드포인트로 HTTP 요청을 보냅니다. send_request() 프로시저는 다음 매개변수가 필요합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003euri — 엔드포인트의 URL입니다.\u003c/li\u003e\n\u003cli\u003emethod — 요청에 사용되는 HTTP 메서드입니다. 여러분은 POST로 설정해야 합니다.\u003c/li\u003e\n\u003cli\u003eheaders — 요청 헤더를 지정하는 JSON 객체입니다. 이전에 본 바와 같이 Content-Type 및 Authorization을 명시해야 합니다.\u003c/li\u003e\n\u003cli\u003ebody — BLOB로 변환된 JSON 객체입니다. 보내는 데이터를 포함하며, 사용할 모델, 온도 매개변수(랜덤성) 및 GPT가 답변할 질문과 같은 정보가 포함됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003esend_request() 함수의 결과는 v_response 변수에 저장되며, 그것은 사용자에게 텍스트로 반환됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecreate or replace \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eget_gpt_response\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n    p_question varchar2\n\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e clob\nis\n    v_api_key constant \u003cspan class=\"hljs-title function_\"\u003evarchar2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e) := \u003cspan class=\"hljs-string\"\u003e'\u0026#x3C;your-api-key\u003e'\u003c/span\u003e;\n    v_response dbms_cloud_types.\u003cspan class=\"hljs-property\"\u003eresp\u003c/span\u003e;\nbegin\n    v_response := dbms_cloud.\u003cspan class=\"hljs-title function_\"\u003esend_request\u003c/span\u003e(\n        \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003euri\u003c/span\u003e     =\u003e\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'https://api.openai.com/v1/chat/completions'\u003c/span\u003e,\n        \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003emethod\u003c/span\u003e  =\u003e\u003c/span\u003e dbms_cloud.\u003cspan class=\"hljs-property\"\u003emethod_post\u003c/span\u003e,\n        -- \u003cspan class=\"hljs-title class_\"\u003eHeaders\u003c/span\u003e must be \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e type \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e_OBJECT\n        headers =\u003e \u003cspan class=\"hljs-title function_\"\u003ejson_object\u003c/span\u003e(\n            \u003cspan class=\"hljs-string\"\u003e'Content-Type'\u003c/span\u003e  value \u003cspan class=\"hljs-string\"\u003e'application/json'\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e'Authorization'\u003c/span\u003e value \u003cspan class=\"hljs-string\"\u003e'Bearer '\u003c/span\u003e || v_api_key\n        ),\n        -- \u003cspan class=\"hljs-title class_\"\u003eRequest\u003c/span\u003e body must be a \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e structure converted to \u003cspan class=\"hljs-variable constant_\"\u003eBLOB\u003c/span\u003e\n        body    =\u003e utl_raw.\u003cspan class=\"hljs-title function_\"\u003ecast_to_raw\u003c/span\u003e(\n            \u003cspan class=\"hljs-title function_\"\u003ejson_object\u003c/span\u003e(\n                \u003cspan class=\"hljs-string\"\u003e'model'\u003c/span\u003e    value \u003cspan class=\"hljs-string\"\u003e'gpt-3.5-turbo'\u003c/span\u003e,\n                \u003cspan class=\"hljs-string\"\u003e'messages'\u003c/span\u003e value \u003cspan class=\"hljs-title function_\"\u003ejson_array\u003c/span\u003e(\n                    \u003cspan class=\"hljs-title function_\"\u003ejson_object\u003c/span\u003e(\n                        \u003cspan class=\"hljs-string\"\u003e'role'\u003c/span\u003e    value \u003cspan class=\"hljs-string\"\u003e'user'\u003c/span\u003e,\n                        \u003cspan class=\"hljs-string\"\u003e'content'\u003c/span\u003e value p_question\n                    )\n                ),\n                \u003cspan class=\"hljs-string\"\u003e'temperature'\u003c/span\u003e value \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e\n            )\n        )\n    );\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e dbms_cloud.\u003cspan class=\"hljs-title function_\"\u003eget_response_text\u003c/span\u003e(v_response);\nend get_gpt_response;\n/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 스니펫을 실행하면 해당 함수를 사용할 수 있게 됩니다.\u003c/p\u003e\n\u003cp\u003e예상대로 작동하는지 확인해 봅시다:\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eselect\n    \u003cspan class=\"hljs-title function_\"\u003ejson_query\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eget_gpt_response\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'What is the capital of United States?'\u003c/span\u003e), \u003cspan class=\"hljs-string\"\u003e'$'\u003c/span\u003e returning clob pretty) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e response\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e dual;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기에 얻은 응답이 있어요:\u003c/p\u003e\n\u003cp\u003e매우 좋은 결과 나왔네요! 하지만 하나 문제가 있는데요 — 반환된 응답이 JSON 형식으로 표시되는데, 이는 관계형 데이터베이스를 다룰 때 기본적으로 원하는 형식은 아니죠.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e다행히도, Oracle은 탁월한 JSON 지원을 제공하기 때문에 관련 필드를 추출하고 응답을 일반 데이터베이스 테이블 형식으로 포맷할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e response \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e (\n    select \u003cspan class=\"hljs-title function_\"\u003eget_gpt_response\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'What is the capital of United States?'\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e data\n    \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e dual\n)\nselect\n    jt.*\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e response r,\n    \u003cspan class=\"hljs-title function_\"\u003ejson_table\u003c/span\u003e(\n        r.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'$'\u003c/span\u003e\n        \u003cspan class=\"hljs-title function_\"\u003ecolumns\u003c/span\u003e(\n            id                \u003cspan class=\"hljs-title function_\"\u003evarchar2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e)   path \u003cspan class=\"hljs-string\"\u003e'$.id'\u003c/span\u003e,\n            answer            \u003cspan class=\"hljs-title function_\"\u003evarchar2\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e) path \u003cspan class=\"hljs-string\"\u003e'$.choices[0].message.content'\u003c/span\u003e,\n            prompt_tokens     number         path \u003cspan class=\"hljs-string\"\u003e'$.usage.prompt_tokens'\u003c/span\u003e,\n            completion_tokens number         path \u003cspan class=\"hljs-string\"\u003e'$.usage.completion_tokens'\u003c/span\u003e,\n            total_tokens      number         path \u003cspan class=\"hljs-string\"\u003e'$.usage.total_tokens'\u003c/span\u003e\n        )\n    ) jt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래는 출력 결과입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_4.png\" alt=\"출력 이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e여기서부터는 세상이 당신의 조개껍질처럼 열립니다. 결과를 그대로 사용하거나 표로 저장할 수도 있습니다. 토큰 사용 정보는 자주 이 함수를 실행할 계획이 있다면 사용된 리소스를 잘 보여주는 지표가 될 것입니다.\u003c/p\u003e\n\u003ch1\u003e개선할 수 있는 점 (하고야 할 것)\u003c/h1\u003e\n\u003cp\u003e오늘 구현한 솔루션은 작동하지만 상당히 기본적이며 몇 가지 조정이 필요합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e예외 처리 — 현재 전혀 구현되지 않았습니다. dbms_cloud 오류뿐만 아니라 일반적인 다른 오류도 잡을 수 있도록 해야 합니다.\u003c/li\u003e\n\u003cli\u003e하드코딩된 엔드포인트 — 현재 상태에서 함수는 채팅 완성 엔드포인트로만 요청을 보냅니다. 엔드포인트를 동적으로 만드는 것이 더 좋을 것입니다.\u003c/li\u003e\n\u003cli\u003e응답이 저장되지 않음 — 사용자에게 반환하기 전에 응답을 데이터베이스 테이블에 저장하는 것이 좋을 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e위의 모든 부분은 기본적인 SQL 기술이 있다면 쉽게 해결할 수 있기 때문에 여러분에게 맡기겠습니다.\u003c/p\u003e\n\u003ch1\u003eSQL에서 OpenAI API 요약\u003c/h1\u003e\n\u003cp\u003e많은 사람들이 SQL이 OpenAI API에 HTTP 호출을 위한 유효한 옵션으로 여겨지지 않는다고 생각하지만, 실제로 많은 신입사원들은 SQL이 기본적인 데이터 조작 이상의 기능을 수행할 수 있다는 것을 알지 못합니다. SQL은 데이터의 언어이며, 이에 따라 Python이 할 수 있는 거의 모든 작업을 데이터 이동 없이 수행할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e오늘의 예시는 Oracle SQL과 PL/SQL로 한정되어 있지만, 여러분이 나의 해결책을 SQL Server, MySQL 및 Postgres에 구현할 방법을 찾을 수 있을 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eSQL 사용 사례 중에서 머신 러닝과 공간 데이터 분석과 같은 더 흥미로운 내용이 추가로 올라올 예정이니 기대해 주세요.\u003c/p\u003e\n\u003cp\u003e읽어 주셔서 감사합니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL"},"buildId":"bb_yO9GbCvdfc_n71SfUf","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>