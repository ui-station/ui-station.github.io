<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>안드로이드에서 Work Manager 이해하기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-23-UnderstandingWorkManagerinAndroid" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="안드로이드에서 Work Manager 이해하기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="안드로이드에서 Work Manager 이해하기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-23-UnderstandingWorkManagerinAndroid_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-23-UnderstandingWorkManagerinAndroid" data-gatsby-head="true"/><meta name="twitter:title" content="안드로이드에서 Work Manager 이해하기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-23-UnderstandingWorkManagerinAndroid_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-23 12:54" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-561ae49ab5aab7f5.js" defer=""></script><script src="/_next/static/PgdIX9e0tvkvkdAmDT6qR/_buildManifest.js" defer=""></script><script src="/_next/static/PgdIX9e0tvkvkdAmDT6qR/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">안드로이드에서 Work Manager 이해하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="안드로이드에서 Work Manager 이해하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 23, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-23-UnderstandingWorkManagerinAndroid&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p><img src="/assets/img/2024-05-23-UnderstandingWorkManagerinAndroid_0.png" alt="Work Manager"/></p>
<p>워크 매니저(Work Manager)는 안드로이드 젯팩(Android Jetpack)의 중요한 구성 요소로, 백그라운드 작업의 미룰 수 있고 보장된 실행을 간단하게 만들기 위해 설계되었습니다. 앱이 종료되거나 장치가 다시 시작되더라도 실행이 보장되어야 하는 작업을 수행해야 하는 경우, Work Manager는 견고하고 유연하며 효율적인 솔루션을 제공합니다. 다양한 안드로이드 버전에서 작동하는 통합 API를 제공하여 현대적인 안드로이드 개발에 필수적인 도구입니다.</p>
<h2>Work Manager의 주요 기능</h2>
<ul>
<li>보장된 실행: Work Manager는 앱이 종료되거나 장치가 다시 시작되더라도 백그라운드 작업이 완료되도록 보장합니다. 로그 업로드, 데이터 동기화, 파일 처리와 같은 작업에 특히 유용합니다.</li>
<li>미룰 수 있고 비동기적: 미룰 수 있고 비동기적으로 실행될 수 있는 작업에 대해 설계되었습니다. 이러한 작업은 즉시 실행되지 않아도 되지만 결국 완료되어야 합니다.</li>
<li>배터리 효율적: Work Manager는 JobScheduler, AlarmManager 및 BroadcastReceiver를 내부적으로 사용하여 API 수준과 제공된 제약 조건에 따라 가장 적합한 구현을 선택하여 배터리 수명을 최적화합니다.</li>
<li>제약 조건: 개발자는 네트워크 가용성, 충전 상태 및 작업이 실행되기 전에 충족해야 하는 저장소 조건과 같은 제약 조건을 지정할 수 있습니다. 이는 리소스를 효율적으로 관리하는 데 도움이 됩니다.</li>
<li>작업 연결: Work Manager를 사용하면 여러 작업을 연결하고 복잡한 작업 시퀀스를 관리할 수 있습니다. 이는 이전 작업이 완료된 후에 다음 작업이 시작되어야 하는 종속 작업에 유용합니다.</li>
<li>모니터링 기능<div></div> 또는 콜백 리스너를 통해 작업 상태를 모니터링하고 작업 실행에 대한 제어 및 통찰력을 제공할 수 있습니다.</li>
</ul>
<div class="content-ad"></div>
<h2>Work Manager 시작하기</h2>
<p>안드로이드 프로젝트에 Work Manager를 통합하려면 다음 단계를 따르세요:</p>
<ol>
<li>의존성 추가: build.gradle 파일에 필요한 종속 항목을 포함해야 합니다:</li>
</ol>
<pre><code class="hljs language-js">implementation <span class="hljs-string">&quot;androidx.work:work-runtime-ktx:2.7.1&quot;</span>
</code></pre>
<div class="content-ad"></div>
<p>테이블 태그를 마크다운 형식으로 변경해주세요.</p>
<pre><code class="hljs language-md">| Header One | Header Two | Header Three  |
| ---------- | ---------- | ------------- |
| Row 1      | Data 1     | Description 1 |
| Row 2      | Data 2     | Description 2 |
</code></pre>
<div class="content-ad"></div>
<ol start="4">
<li>제약 조건 처리: 작업에 제약 조건을 지정할 수 있습니다. 네트워크 연결이 필요한 경우와 같이:</li>
</ol>
<pre><code class="hljs language-js">val constraints = <span class="hljs-title class_">Constraints</span>.<span class="hljs-title class_">Builder</span>()
    .<span class="hljs-title function_">setRequiredNetworkType</span>(<span class="hljs-title class_">NetworkType</span>.<span class="hljs-property">CONNECTED</span>)
    .<span class="hljs-title function_">build</span>()

val workRequest = <span class="hljs-title class_">OneTimeWorkRequestBuilder</span>&lt;<span class="hljs-title class_">MyWorker</span>&gt;()
    .<span class="hljs-title function_">setConstraints</span>(constraints)
    .<span class="hljs-title function_">build</span>()
<span class="hljs-title class_">WorkManager</span>.<span class="hljs-title function_">getInstance</span>(context).<span class="hljs-title function_">enqueue</span>(workRequest)
</code></pre>
<h2>고급 사용법</h2>
<ol>
<li>주기적인 작업: 정기적으로 반복되어야 하는 작업에는 PeriodicWorkRequest을 사용하세요:</li>
</ol>
<div class="content-ad"></div>
<pre><code class="hljs language-js">val periodicWorkRequest = <span class="hljs-title class_">PeriodicWorkRequestBuilder</span>&lt;<span class="hljs-title class_">MyWorker</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">HOURS</span>)
    .<span class="hljs-title function_">setConstraints</span>(constraints)
    .<span class="hljs-title function_">build</span>()
<span class="hljs-title class_">WorkManager</span>.<span class="hljs-title function_">getInstance</span>(context).<span class="hljs-title function_">enqueue</span>(periodicWorkRequest)
</code></pre>
<ol start="2">
<li>Chaining Tasks: Work Manager allows chaining multiple tasks sequentially:</li>
</ol>
<pre><code class="hljs language-js">val workRequest1 = <span class="hljs-title class_">OneTimeWorkRequestBuilder</span>&lt;<span class="hljs-title class_">Worker1</span>&gt;().<span class="hljs-title function_">build</span>()
val workRequest2 = <span class="hljs-title class_">OneTimeWorkRequestBuilder</span>&lt;<span class="hljs-title class_">Worker2</span>&gt;().<span class="hljs-title function_">build</span>()

<span class="hljs-title class_">WorkManager</span>.<span class="hljs-title function_">getInstance</span>(context)
    .<span class="hljs-title function_">beginWith</span>(workRequest1)
    .<span class="hljs-title function_">then</span>(workRequest2)
    .<span class="hljs-title function_">enqueue</span>()
</code></pre>
<ol start="3">
<li>Observing Work Status: You can observe the status of your work requests using LiveData:```</li>
</ol>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-title class_">WorkManager</span>.<span class="hljs-title function_">getInstance</span>(context).<span class="hljs-title function_">getWorkInfoByIdLiveData</span>(workRequest.<span class="hljs-property">id</span>)
    .<span class="hljs-title function_">observe</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-title class_">Observer</span> { workInfo -&gt;
        <span class="hljs-keyword">if</span> (workInfo != <span class="hljs-literal">null</span> &amp;&amp; workInfo.<span class="hljs-property">state</span>.<span class="hljs-property">isFinished</span>) {
            <span class="hljs-comment">// 작업 완료 처리</span>
        }
    })
</code></pre>
<h1>안드로이드에서 Work Manager 사용하는 데 최선의 방법</h1>
<p>Work Manager는 안드로이드 애플리케이션의 백그라운드 작업을 효율적으로 관리하는 강력한 도구입니다. 이를 효과적으로 활용하기 위해서는 특정한 최상의 방법을 준수해야 합니다. 이러한 관행은 작업이 효율적으로, 신뢰성 있게 실행되며 시스템 리소스에 미미한 영향을 미칠 수 있도록 보장합니다.</p>
<h2>1. 적절한 유형의 Work Request 선택하기</h2>
<div class="content-ad"></div>
<p><strong>일회성 작업 요청 대 비주기적 작업 요청:</strong></p>
<ul>
<li>한 번만 실행해야 하는 작업(예: 단일 파일 업로드 또는 특정 시간에 데이터 동기화)은 일회성 작업 요청을 사용합니다.</li>
<li>주기적으로 발생하는 작업(예: 정기적 데이터 동기화 또는 주기적 정리 작업)은 비주기적 작업 요청을 사용합니다.</li>
</ul>
<h2>2. 적절한 제약 조건 설정하기</h2>
<p>제약 조건을 현명하게 사용하세요:</p>
<div class="content-ad"></div>
<ul>
<li>필요한 제약 조건만 설정하여 작업 수행이 불필요하게 지연되지 않도록 합니다. 일반적인 제약 조건으로는 네트워크 가용성, 장치 충전 상태 및 배터리 레벨이 있습니다.</li>
<li>예시:</li>
</ul>
<pre><code class="hljs language-js">val constraints = <span class="hljs-title class_">Constraints</span>.<span class="hljs-title class_">Builder</span>()
    .<span class="hljs-title function_">setRequiredNetworkType</span>(<span class="hljs-title class_">NetworkType</span>.<span class="hljs-property">CONNECTED</span>)
    .<span class="hljs-title function_">setRequiresCharging</span>(<span class="hljs-literal">true</span>)
    .<span class="hljs-title function_">build</span>()
</code></pre>
<h2>3. 작업 실행 적절히 처리하기</h2>
<p>긴 실행 시간이 걸리는 작업을 피하세요:</p>
<div class="content-ad"></div>
<ul>
<li>긴 실행 시간이 소요되는 작업을 작은 관리 가능한 조각으로 나눠보세요. 작업이 상당한 시간이 걸릴 것으로 예상된다면, 여러 작업 요청으로 분할하고 연결하는 것을 고려해보세요.</li>
</ul>
<p>복잡한 작업에는 ListenableWorker를 사용하세요:</p>
<ul>
<li>비동기 처리가 필요한 작업에는 Worker 대신 ListenableWorker를 사용하세요. 이를 통해 비동기 작업을 더 효율적으로 관리할 수 있습니다.</li>
</ul>
<h2>4. 작업 체인 관리</h2>
<div class="content-ad"></div>
<p>의존 작업 체인:</p>
<ul>
<li>의존 작업을 연속적으로 실행하도록 작업 체이닝을 사용하십시오. 이는 한 작업의 출력이 다음 작업에서 필요한 워크플로우에 유용합니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-title class_">WorkManager</span>.<span class="hljs-title function_">getInstance</span>(context).<span class="hljs-title function_">beginWith</span>(workRequest1).<span class="hljs-title function_">then</span>(workRequest2).<span class="hljs-title function_">enqueue</span>();
</code></pre>
<p>체인된 작업에서 오류 처리:</p>
<div class="content-ad"></div>
<ul>
<li>워커 클래스에서 적절한 오류 처리를 구현하여 연쇄적으로 발생하는 실패를 관리하세요. 필요한 경우 Result.retry()를 사용하여 작업을 다시 예약하세요.</li>
</ul>
<h2>5. 작업 상태 관찰</h2>
<p>작업 상태 관찰을 위해 Flow 사용:</p>
<ul>
<li>Kotlin의 Flow를 활용하여 작업 요청의 상태를 관찰하세요. 이는 LiveData보다 더 현대적이고 유연한 접근 방식을 제공합니다.</li>
</ul>
<div class="content-ad"></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">import</span> kotlinx.coroutines.flow.collect
<span class="hljs-keyword">import</span> kotlinx.coroutines.flow.map

<span class="hljs-keyword">val</span> workInfoFlow = WorkManager.getInstance(context)
    .getWorkInfoByIdLiveData(workRequest.id)
    .asFlow()

lifecycleScope.launch {
    workInfoFlow.collect { workInfo -&gt;
        <span class="hljs-keyword">if</span> (workInfo != <span class="hljs-literal">null</span> &amp;&amp; workInfo.state.isFinished) {
            <span class="hljs-comment">// Handle the completion of the work</span>
        }
    }
}
</code></pre>
<h2>6. 작업 요청에 태그 사용</h2>
<p>식별을 위해 태그 할당:</p>
<ul>
<li>작업 요청에 태그를 할당하여 특정 작업을 쉽게 관리하고 쿼리할 수 있습니다. 특히 특정 작업 세트를 취소하거나 관찰하는 데 유용합니다.</li>
</ul>
<div class="content-ad"></div>
<pre><code class="hljs language-js">val workRequest = <span class="hljs-title class_">OneTimeWorkRequestBuilder</span>&lt;<span class="hljs-title class_">MyWorker</span>&gt;()
    .<span class="hljs-title function_">addTag</span>(<span class="hljs-string">&quot;syncWork&quot;</span>)
    .<span class="hljs-title function_">build</span>()
</code></pre>
<p>태그를 사용하여 작업 취소할 수 있어요:</p>
<ul>
<li>필요한 경우 태그별로 작업 요청을 취소하세요.</li>
</ul>
<h2>7. 고유한 작업 요청 처리하기</h2>
<div class="content-ad"></div>
<p>유효한 작업에 고유한 작업 사용하기:</p>
<ul>
<li>중복 작업을 피하기 위해 고유한 작업 요청을 사용하세요. enqueueUniqueWork을 사용하면 특정 작업 요청의 인스턴스가 한 번에 하나만 실행됩니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-title class_">WorkManager</span>.<span class="hljs-title function_">getInstance</span>(context).<span class="hljs-title function_">enqueueUniqueWork</span>(<span class="hljs-string">&quot;고유작업이름&quot;</span>, <span class="hljs-title class_">ExistingWorkPolicy</span>.<span class="hljs-property">REPLACE</span>, workRequest);
</code></pre>
<h2>8. 자원 사용량 최적화</h2>
<div class="content-ad"></div>
<p>리소스 영향 최소화:</p>
<ul>
<li>시스템 리소스에 미치는 영향을 최소화하기 위해 적절한 제약 조건을 사용합니다. 예를 들어, 필요할 때만 네트워크 연결을 요구합니다.</li>
<li>장치에 부하를 줄이기 위해 재시도에 지수 백오프를 고려해보세요.</li>
</ul>
<p>배경 최적화 활용:</p>
<ul>
<li>Work Manager의 내장 최적화 기능을 활용하여 배터리 및 네트워크를 고려한 스케줄링을 통해 효율적인 작업 실행을 보장하세요.</li>
</ul>
<div class="content-ad"></div>
<h2>9. 테스트 및 디버깅</h2>
<p>작업 요청을 철저히 테스트하세요:</p>
<ul>
<li>다양한 조건에서 작업 요청을 테스트하여 예상대로 작동하는지 확인하세요. 온라인이 아닌, 배터리 부족 또는 재부팅 중인 등 다양한 장치 상태를 포함합니다.</li>
</ul>
<p>로깅 및 디버깅 도구 사용하기:</p>
<div class="content-ad"></div>
<ul>
<li>작업 실행 문제를 해결하기 위해 로깅 및 Work Manager의 디버깅 도구를 활용해보세요. adb shell dumpsys activity service를 사용하면 Work Manager의 내부 상태를 확인할 수 있습니다.</li>
</ul>
<h2>결론</h2>
<p>Work Manager는 Android 애플리케이션에서 백그라운드 작업을 처리하는 필수 도구로, 앱이 실행되지 않을 때에도 일을 수행할 수 있는 일관적이고 신뢰할 수 있는 방법을 제공합니다. 제약 조건, 작업 체인, 주기적 작업과 같은 기능들을 통해 다양한 유즈케이스에 유연성을 제공합니다. Android 프로젝트에 Work Manager를 통합하면 백그라운드 작업 실행의 효율성과 신뢰성이 크게 향상될 수 있습니다.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"안드로이드에서 Work Manager 이해하기","description":"","date":"2024-05-23 12:54","slug":"2024-05-23-UnderstandingWorkManagerinAndroid","content":"\n\n![Work Manager](/assets/img/2024-05-23-UnderstandingWorkManagerinAndroid_0.png)\n\n워크 매니저(Work Manager)는 안드로이드 젯팩(Android Jetpack)의 중요한 구성 요소로, 백그라운드 작업의 미룰 수 있고 보장된 실행을 간단하게 만들기 위해 설계되었습니다. 앱이 종료되거나 장치가 다시 시작되더라도 실행이 보장되어야 하는 작업을 수행해야 하는 경우, Work Manager는 견고하고 유연하며 효율적인 솔루션을 제공합니다. 다양한 안드로이드 버전에서 작동하는 통합 API를 제공하여 현대적인 안드로이드 개발에 필수적인 도구입니다.\n\n## Work Manager의 주요 기능\n\n- 보장된 실행: Work Manager는 앱이 종료되거나 장치가 다시 시작되더라도 백그라운드 작업이 완료되도록 보장합니다. 로그 업로드, 데이터 동기화, 파일 처리와 같은 작업에 특히 유용합니다.\n- 미룰 수 있고 비동기적: 미룰 수 있고 비동기적으로 실행될 수 있는 작업에 대해 설계되었습니다. 이러한 작업은 즉시 실행되지 않아도 되지만 결국 완료되어야 합니다.\n- 배터리 효율적: Work Manager는 JobScheduler, AlarmManager 및 BroadcastReceiver를 내부적으로 사용하여 API 수준과 제공된 제약 조건에 따라 가장 적합한 구현을 선택하여 배터리 수명을 최적화합니다.\n- 제약 조건: 개발자는 네트워크 가용성, 충전 상태 및 작업이 실행되기 전에 충족해야 하는 저장소 조건과 같은 제약 조건을 지정할 수 있습니다. 이는 리소스를 효율적으로 관리하는 데 도움이 됩니다.\n- 작업 연결: Work Manager를 사용하면 여러 작업을 연결하고 복잡한 작업 시퀀스를 관리할 수 있습니다. 이는 이전 작업이 완료된 후에 다음 작업이 시작되어야 하는 종속 작업에 유용합니다.\n- 모니터링 기능:LiveData 또는 콜백 리스너를 통해 작업 상태를 모니터링하고 작업 실행에 대한 제어 및 통찰력을 제공할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Work Manager 시작하기\n\n안드로이드 프로젝트에 Work Manager를 통합하려면 다음 단계를 따르세요:\n\n1. 의존성 추가: build.gradle 파일에 필요한 종속 항목을 포함해야 합니다:\n\n```js\nimplementation \"androidx.work:work-runtime-ktx:2.7.1\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n```md\n| Header One | Header Two | Header Three  |\n| ---------- | ---------- | ------------- |\n| Row 1      | Data 1     | Description 1 |\n| Row 2      | Data 2     | Description 2 |\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. 제약 조건 처리: 작업에 제약 조건을 지정할 수 있습니다. 네트워크 연결이 필요한 경우와 같이:\n\n```js\nval constraints = Constraints.Builder()\n    .setRequiredNetworkType(NetworkType.CONNECTED)\n    .build()\n\nval workRequest = OneTimeWorkRequestBuilder\u003cMyWorker\u003e()\n    .setConstraints(constraints)\n    .build()\nWorkManager.getInstance(context).enqueue(workRequest)\n```\n\n## 고급 사용법\n\n1. 주기적인 작업: 정기적으로 반복되어야 하는 작업에는 PeriodicWorkRequest을 사용하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nval periodicWorkRequest = PeriodicWorkRequestBuilder\u003cMyWorker\u003e(1, TimeUnit.HOURS)\n    .setConstraints(constraints)\n    .build()\nWorkManager.getInstance(context).enqueue(periodicWorkRequest)\n```\n\n2. Chaining Tasks: Work Manager allows chaining multiple tasks sequentially:\n\n```js\nval workRequest1 = OneTimeWorkRequestBuilder\u003cWorker1\u003e().build()\nval workRequest2 = OneTimeWorkRequestBuilder\u003cWorker2\u003e().build()\n\nWorkManager.getInstance(context)\n    .beginWith(workRequest1)\n    .then(workRequest2)\n    .enqueue()\n```\n\n3. Observing Work Status: You can observe the status of your work requests using LiveData:```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nWorkManager.getInstance(context).getWorkInfoByIdLiveData(workRequest.id)\n    .observe(this, Observer { workInfo -\u003e\n        if (workInfo != null \u0026\u0026 workInfo.state.isFinished) {\n            // 작업 완료 처리\n        }\n    })\n```\n\n# 안드로이드에서 Work Manager 사용하는 데 최선의 방법\n\nWork Manager는 안드로이드 애플리케이션의 백그라운드 작업을 효율적으로 관리하는 강력한 도구입니다. 이를 효과적으로 활용하기 위해서는 특정한 최상의 방법을 준수해야 합니다. 이러한 관행은 작업이 효율적으로, 신뢰성 있게 실행되며 시스템 리소스에 미미한 영향을 미칠 수 있도록 보장합니다.\n\n## 1. 적절한 유형의 Work Request 선택하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**일회성 작업 요청 대 비주기적 작업 요청:**\n\n- 한 번만 실행해야 하는 작업(예: 단일 파일 업로드 또는 특정 시간에 데이터 동기화)은 일회성 작업 요청을 사용합니다.\n- 주기적으로 발생하는 작업(예: 정기적 데이터 동기화 또는 주기적 정리 작업)은 비주기적 작업 요청을 사용합니다.\n\n## 2. 적절한 제약 조건 설정하기\n\n제약 조건을 현명하게 사용하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 필요한 제약 조건만 설정하여 작업 수행이 불필요하게 지연되지 않도록 합니다. 일반적인 제약 조건으로는 네트워크 가용성, 장치 충전 상태 및 배터리 레벨이 있습니다.\n- 예시:\n\n```js\nval constraints = Constraints.Builder()\n    .setRequiredNetworkType(NetworkType.CONNECTED)\n    .setRequiresCharging(true)\n    .build()\n```\n\n## 3. 작업 실행 적절히 처리하기\n\n긴 실행 시간이 걸리는 작업을 피하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 긴 실행 시간이 소요되는 작업을 작은 관리 가능한 조각으로 나눠보세요. 작업이 상당한 시간이 걸릴 것으로 예상된다면, 여러 작업 요청으로 분할하고 연결하는 것을 고려해보세요.\n\n복잡한 작업에는 ListenableWorker를 사용하세요:\n\n- 비동기 처리가 필요한 작업에는 Worker 대신 ListenableWorker를 사용하세요. 이를 통해 비동기 작업을 더 효율적으로 관리할 수 있습니다.\n\n## 4. 작업 체인 관리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n의존 작업 체인:\n\n- 의존 작업을 연속적으로 실행하도록 작업 체이닝을 사용하십시오. 이는 한 작업의 출력이 다음 작업에서 필요한 워크플로우에 유용합니다.\n\n```js\nWorkManager.getInstance(context).beginWith(workRequest1).then(workRequest2).enqueue();\n```\n\n체인된 작업에서 오류 처리:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 워커 클래스에서 적절한 오류 처리를 구현하여 연쇄적으로 발생하는 실패를 관리하세요. 필요한 경우 Result.retry()를 사용하여 작업을 다시 예약하세요.\n\n## 5. 작업 상태 관찰\n\n작업 상태 관찰을 위해 Flow 사용:\n\n- Kotlin의 Flow를 활용하여 작업 요청의 상태를 관찰하세요. 이는 LiveData보다 더 현대적이고 유연한 접근 방식을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nimport kotlinx.coroutines.flow.collect\nimport kotlinx.coroutines.flow.map\n\nval workInfoFlow = WorkManager.getInstance(context)\n    .getWorkInfoByIdLiveData(workRequest.id)\n    .asFlow()\n\nlifecycleScope.launch {\n    workInfoFlow.collect { workInfo -\u003e\n        if (workInfo != null \u0026\u0026 workInfo.state.isFinished) {\n            // Handle the completion of the work\n        }\n    }\n}\n```\n\n## 6. 작업 요청에 태그 사용\n\n식별을 위해 태그 할당:\n\n- 작업 요청에 태그를 할당하여 특정 작업을 쉽게 관리하고 쿼리할 수 있습니다. 특히 특정 작업 세트를 취소하거나 관찰하는 데 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nval workRequest = OneTimeWorkRequestBuilder\u003cMyWorker\u003e()\n    .addTag(\"syncWork\")\n    .build()\n```\n\n태그를 사용하여 작업 취소할 수 있어요:\n\n- 필요한 경우 태그별로 작업 요청을 취소하세요.\n\n## 7. 고유한 작업 요청 처리하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n유효한 작업에 고유한 작업 사용하기:\n\n- 중복 작업을 피하기 위해 고유한 작업 요청을 사용하세요. enqueueUniqueWork을 사용하면 특정 작업 요청의 인스턴스가 한 번에 하나만 실행됩니다.\n\n```js\nWorkManager.getInstance(context).enqueueUniqueWork(\"고유작업이름\", ExistingWorkPolicy.REPLACE, workRequest);\n```\n\n## 8. 자원 사용량 최적화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리소스 영향 최소화:\n\n- 시스템 리소스에 미치는 영향을 최소화하기 위해 적절한 제약 조건을 사용합니다. 예를 들어, 필요할 때만 네트워크 연결을 요구합니다.\n- 장치에 부하를 줄이기 위해 재시도에 지수 백오프를 고려해보세요.\n\n배경 최적화 활용:\n\n- Work Manager의 내장 최적화 기능을 활용하여 배터리 및 네트워크를 고려한 스케줄링을 통해 효율적인 작업 실행을 보장하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 9. 테스트 및 디버깅\n\n작업 요청을 철저히 테스트하세요:\n\n- 다양한 조건에서 작업 요청을 테스트하여 예상대로 작동하는지 확인하세요. 온라인이 아닌, 배터리 부족 또는 재부팅 중인 등 다양한 장치 상태를 포함합니다.\n\n로깅 및 디버깅 도구 사용하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 작업 실행 문제를 해결하기 위해 로깅 및 Work Manager의 디버깅 도구를 활용해보세요. adb shell dumpsys activity service를 사용하면 Work Manager의 내부 상태를 확인할 수 있습니다.\n\n## 결론\n\nWork Manager는 Android 애플리케이션에서 백그라운드 작업을 처리하는 필수 도구로, 앱이 실행되지 않을 때에도 일을 수행할 수 있는 일관적이고 신뢰할 수 있는 방법을 제공합니다. 제약 조건, 작업 체인, 주기적 작업과 같은 기능들을 통해 다양한 유즈케이스에 유연성을 제공합니다. Android 프로젝트에 Work Manager를 통합하면 백그라운드 작업 실행의 효율성과 신뢰성이 크게 향상될 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-UnderstandingWorkManagerinAndroid_0.png"},"coverImage":"/assets/img/2024-05-23-UnderstandingWorkManagerinAndroid_0.png","tag":["Tech"],"readingTime":7},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h2: \"h2\",\n    ul: \"ul\",\n    li: \"li\",\n    div: \"div\",\n    ol: \"ol\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    h1: \"h1\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-UnderstandingWorkManagerinAndroid_0.png\",\n        alt: \"Work Manager\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"워크 매니저(Work Manager)는 안드로이드 젯팩(Android Jetpack)의 중요한 구성 요소로, 백그라운드 작업의 미룰 수 있고 보장된 실행을 간단하게 만들기 위해 설계되었습니다. 앱이 종료되거나 장치가 다시 시작되더라도 실행이 보장되어야 하는 작업을 수행해야 하는 경우, Work Manager는 견고하고 유연하며 효율적인 솔루션을 제공합니다. 다양한 안드로이드 버전에서 작동하는 통합 API를 제공하여 현대적인 안드로이드 개발에 필수적인 도구입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Work Manager의 주요 기능\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"보장된 실행: Work Manager는 앱이 종료되거나 장치가 다시 시작되더라도 백그라운드 작업이 완료되도록 보장합니다. 로그 업로드, 데이터 동기화, 파일 처리와 같은 작업에 특히 유용합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"미룰 수 있고 비동기적: 미룰 수 있고 비동기적으로 실행될 수 있는 작업에 대해 설계되었습니다. 이러한 작업은 즉시 실행되지 않아도 되지만 결국 완료되어야 합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"배터리 효율적: Work Manager는 JobScheduler, AlarmManager 및 BroadcastReceiver를 내부적으로 사용하여 API 수준과 제공된 제약 조건에 따라 가장 적합한 구현을 선택하여 배터리 수명을 최적화합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"제약 조건: 개발자는 네트워크 가용성, 충전 상태 및 작업이 실행되기 전에 충족해야 하는 저장소 조건과 같은 제약 조건을 지정할 수 있습니다. 이는 리소스를 효율적으로 관리하는 데 도움이 됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"작업 연결: Work Manager를 사용하면 여러 작업을 연결하고 복잡한 작업 시퀀스를 관리할 수 있습니다. 이는 이전 작업이 완료된 후에 다음 작업이 시작되어야 하는 종속 작업에 유용합니다.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"모니터링 기능\", _jsx(_components.div, {}), \" 또는 콜백 리스너를 통해 작업 상태를 모니터링하고 작업 실행에 대한 제어 및 통찰력을 제공할 수 있습니다.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Work Manager 시작하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"안드로이드 프로젝트에 Work Manager를 통합하려면 다음 단계를 따르세요:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"의존성 추가: build.gradle 파일에 필요한 종속 항목을 포함해야 합니다:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"implementation \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"androidx.work:work-runtime-ktx:2.7.1\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"테이블 태그를 마크다운 형식으로 변경해주세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-md\",\n        children: \"| Header One | Header Two | Header Three  |\\n| ---------- | ---------- | ------------- |\\n| Row 1      | Data 1     | Description 1 |\\n| Row 2      | Data 2     | Description 2 |\\n\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"4\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"제약 조건 처리: 작업에 제약 조건을 지정할 수 있습니다. 네트워크 연결이 필요한 경우와 같이:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"val constraints = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Constraints\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Builder\"\n        }), \"()\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setRequiredNetworkType\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NetworkType\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"CONNECTED\"\n        }), \")\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"build\"\n        }), \"()\\n\\nval workRequest = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"OneTimeWorkRequestBuilder\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MyWorker\"\n        }), \"\u003e()\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setConstraints\"\n        }), \"(constraints)\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"build\"\n        }), \"()\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"WorkManager\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getInstance\"\n        }), \"(context).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"enqueue\"\n        }), \"(workRequest)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"고급 사용법\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"주기적인 작업: 정기적으로 반복되어야 하는 작업에는 PeriodicWorkRequest을 사용하세요:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"val periodicWorkRequest = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PeriodicWorkRequestBuilder\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MyWorker\"\n        }), \"\u003e(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"TimeUnit\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"HOURS\"\n        }), \")\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setConstraints\"\n        }), \"(constraints)\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"build\"\n        }), \"()\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"WorkManager\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getInstance\"\n        }), \"(context).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"enqueue\"\n        }), \"(periodicWorkRequest)\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"2\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Chaining Tasks: Work Manager allows chaining multiple tasks sequentially:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"val workRequest1 = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"OneTimeWorkRequestBuilder\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Worker1\"\n        }), \"\u003e().\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"build\"\n        }), \"()\\nval workRequest2 = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"OneTimeWorkRequestBuilder\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Worker2\"\n        }), \"\u003e().\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"build\"\n        }), \"()\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"WorkManager\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getInstance\"\n        }), \"(context)\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"beginWith\"\n        }), \"(workRequest1)\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"then\"\n        }), \"(workRequest2)\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"enqueue\"\n        }), \"()\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"3\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Observing Work Status: You can observe the status of your work requests using LiveData:```\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"WorkManager\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getInstance\"\n        }), \"(context).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getWorkInfoByIdLiveData\"\n        }), \"(workRequest.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"id\"\n        }), \")\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"observe\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"this\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Observer\"\n        }), \" { workInfo -\u003e\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (workInfo != \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \" \u0026\u0026 workInfo.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"state\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"isFinished\"\n        }), \") {\\n            \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 작업 완료 처리\"\n        }), \"\\n        }\\n    })\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"안드로이드에서 Work Manager 사용하는 데 최선의 방법\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Work Manager는 안드로이드 애플리케이션의 백그라운드 작업을 효율적으로 관리하는 강력한 도구입니다. 이를 효과적으로 활용하기 위해서는 특정한 최상의 방법을 준수해야 합니다. 이러한 관행은 작업이 효율적으로, 신뢰성 있게 실행되며 시스템 리소스에 미미한 영향을 미칠 수 있도록 보장합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"1. 적절한 유형의 Work Request 선택하기\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"일회성 작업 요청 대 비주기적 작업 요청:\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"한 번만 실행해야 하는 작업(예: 단일 파일 업로드 또는 특정 시간에 데이터 동기화)은 일회성 작업 요청을 사용합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"주기적으로 발생하는 작업(예: 정기적 데이터 동기화 또는 주기적 정리 작업)은 비주기적 작업 요청을 사용합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. 적절한 제약 조건 설정하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제약 조건을 현명하게 사용하세요:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"필요한 제약 조건만 설정하여 작업 수행이 불필요하게 지연되지 않도록 합니다. 일반적인 제약 조건으로는 네트워크 가용성, 장치 충전 상태 및 배터리 레벨이 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"예시:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"val constraints = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Constraints\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Builder\"\n        }), \"()\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setRequiredNetworkType\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NetworkType\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"CONNECTED\"\n        }), \")\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setRequiresCharging\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \")\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"build\"\n        }), \"()\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3. 작업 실행 적절히 처리하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"긴 실행 시간이 걸리는 작업을 피하세요:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"긴 실행 시간이 소요되는 작업을 작은 관리 가능한 조각으로 나눠보세요. 작업이 상당한 시간이 걸릴 것으로 예상된다면, 여러 작업 요청으로 분할하고 연결하는 것을 고려해보세요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"복잡한 작업에는 ListenableWorker를 사용하세요:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"비동기 처리가 필요한 작업에는 Worker 대신 ListenableWorker를 사용하세요. 이를 통해 비동기 작업을 더 효율적으로 관리할 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4. 작업 체인 관리\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"의존 작업 체인:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"의존 작업을 연속적으로 실행하도록 작업 체이닝을 사용하십시오. 이는 한 작업의 출력이 다음 작업에서 필요한 워크플로우에 유용합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"WorkManager\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getInstance\"\n        }), \"(context).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"beginWith\"\n        }), \"(workRequest1).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"then\"\n        }), \"(workRequest2).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"enqueue\"\n        }), \"();\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"체인된 작업에서 오류 처리:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"워커 클래스에서 적절한 오류 처리를 구현하여 연쇄적으로 발생하는 실패를 관리하세요. 필요한 경우 Result.retry()를 사용하여 작업을 다시 예약하세요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"5. 작업 상태 관찰\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"작업 상태 관찰을 위해 Flow 사용:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Kotlin의 Flow를 활용하여 작업 요청의 상태를 관찰하세요. 이는 LiveData보다 더 현대적이고 유연한 접근 방식을 제공합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" kotlinx.coroutines.flow.collect\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" kotlinx.coroutines.flow.map\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" workInfoFlow = WorkManager.getInstance(context)\\n    .getWorkInfoByIdLiveData(workRequest.id)\\n    .asFlow()\\n\\nlifecycleScope.launch {\\n    workInfoFlow.collect { workInfo -\u003e\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (workInfo != \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \" \u0026\u0026 workInfo.state.isFinished) {\\n            \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Handle the completion of the work\"\n        }), \"\\n        }\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"6. 작업 요청에 태그 사용\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"식별을 위해 태그 할당:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"작업 요청에 태그를 할당하여 특정 작업을 쉽게 관리하고 쿼리할 수 있습니다. 특히 특정 작업 세트를 취소하거나 관찰하는 데 유용합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"val workRequest = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"OneTimeWorkRequestBuilder\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MyWorker\"\n        }), \"\u003e()\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"addTag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"syncWork\\\"\"\n        }), \")\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"build\"\n        }), \"()\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"태그를 사용하여 작업 취소할 수 있어요:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"필요한 경우 태그별로 작업 요청을 취소하세요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"7. 고유한 작업 요청 처리하기\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"유효한 작업에 고유한 작업 사용하기:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"중복 작업을 피하기 위해 고유한 작업 요청을 사용하세요. enqueueUniqueWork을 사용하면 특정 작업 요청의 인스턴스가 한 번에 하나만 실행됩니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"WorkManager\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getInstance\"\n        }), \"(context).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"enqueueUniqueWork\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"고유작업이름\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ExistingWorkPolicy\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"REPLACE\"\n        }), \", workRequest);\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"8. 자원 사용량 최적화\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"리소스 영향 최소화:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"시스템 리소스에 미치는 영향을 최소화하기 위해 적절한 제약 조건을 사용합니다. 예를 들어, 필요할 때만 네트워크 연결을 요구합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"장치에 부하를 줄이기 위해 재시도에 지수 백오프를 고려해보세요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"배경 최적화 활용:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Work Manager의 내장 최적화 기능을 활용하여 배터리 및 네트워크를 고려한 스케줄링을 통해 효율적인 작업 실행을 보장하세요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"9. 테스트 및 디버깅\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"작업 요청을 철저히 테스트하세요:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"다양한 조건에서 작업 요청을 테스트하여 예상대로 작동하는지 확인하세요. 온라인이 아닌, 배터리 부족 또는 재부팅 중인 등 다양한 장치 상태를 포함합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"로깅 및 디버깅 도구 사용하기:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"작업 실행 문제를 해결하기 위해 로깅 및 Work Manager의 디버깅 도구를 활용해보세요. adb shell dumpsys activity service를 사용하면 Work Manager의 내부 상태를 확인할 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Work Manager는 Android 애플리케이션에서 백그라운드 작업을 처리하는 필수 도구로, 앱이 실행되지 않을 때에도 일을 수행할 수 있는 일관적이고 신뢰할 수 있는 방법을 제공합니다. 제약 조건, 작업 체인, 주기적 작업과 같은 기능들을 통해 다양한 유즈케이스에 유연성을 제공합니다. Android 프로젝트에 Work Manager를 통합하면 백그라운드 작업 실행의 효율성과 신뢰성이 크게 향상될 수 있습니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-23-UnderstandingWorkManagerinAndroid"},"buildId":"PgdIX9e0tvkvkdAmDT6qR","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>