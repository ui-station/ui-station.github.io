<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Swift에서의 고급 오류 처리 Try-Catch를 넘어서 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Swift에서의 고급 오류 처리 Try-Catch를 넘어서 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Swift에서의 고급 오류 처리 Try-Catch를 넘어서 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch" data-gatsby-head="true"/><meta name="twitter:title" content="Swift에서의 고급 오류 처리 Try-Catch를 넘어서 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-23 13:13" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-561ae49ab5aab7f5.js" defer=""></script><script src="/_next/static/PgdIX9e0tvkvkdAmDT6qR/_buildManifest.js" defer=""></script><script src="/_next/static/PgdIX9e0tvkvkdAmDT6qR/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Swift에서의 고급 오류 처리 Try-Catch를 넘어서</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Swift에서의 고급 오류 처리 Try-Catch를 넘어서" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 23, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><img src="/assets/img/2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch_0.png"/>
<p>소개</p>
<p>오류 처리는 견고한 응용 프로그램 구축의 중요한 측면입니다. Swift의 try, catch, throw 및 do로 소개된 오류 처리 모델은 오류를 우아하게 처리하는 강력하고 유연한 메커니즘을 제공합니다. 그러나 응용 프로그램이 복잡해지면 오류를 효과적으로 관리하기 위해 더 고급 기술이 필요할 수 있습니다. 이 글에서는 Swift에서 고급 오류 처리 전략인 Result 타입, async/await 오류 전파, 사용자 정의 오류 타입, 견고한 오류 처리 시스템을 만드는 데 가장 좋은 방법 등을 탐색해 보겠습니다.</p>
<p>왜 고급 오류 처리가 중요한가요?</p>
<div class="content-ad"></div>
<p>기본 try-catch를 사용한 기본적인 오류 처리는 많은 시나리오에 효과적이지만, 고급 기술은 다음과 같은 여러 가지 이점을 제공합니다:</p>
<ul>
<li>가독성 향상: 더 명확한 오류 처리 경로는 코드의 가독성과 유지보수성을 향상시킵니다.</li>
<li>더 좋은 제어: 오류 전파 및 복구에 대한 더 많은 제어.</li>
<li>디버깅 향상: 더 구체적인 오류 유형으로 문제를 진단하고 수정하기가 더 쉬워집니다.</li>
<li>비동기 컨텍스트: 비동기 코드에서의 오류를 효과적으로 관리합니다.</li>
</ul>
<p>결과 유형 사용하기</p>
<p>결과 유형은 성공 또는 실패를 나타내며, 값이나 오류를 캡슐화합니다. 오류 처리에 대해 더 함수형 접근 방식을 제공하며 비동기 작업에서 특히 유용합니다.</p>
<div class="content-ad"></div>
<p>기본 예제 및 결과</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">NetworkError</span>: <span class="hljs-title class_">Error</span> {
    <span class="hljs-keyword">case</span> invalidURL
    <span class="hljs-keyword">case</span> requestFailed
}

<span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params">from</span> <span class="hljs-params">urlString</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Data</span>, <span class="hljs-type">NetworkError</span>&gt; {
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> url <span class="hljs-operator">=</span> <span class="hljs-type">URL</span>(string: urlString) <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> .failure(.invalidURL)
    }

    <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">let</span> data <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">Data</span>(contentsOf: url)
        <span class="hljs-keyword">return</span> .success(data)
    } <span class="hljs-keyword">catch</span> {
        <span class="hljs-keyword">return</span> .failure(.requestFailed)
    }
}

<span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> fetchData(from: <span class="hljs-string">&quot;https://example.com/data&quot;</span>)

<span class="hljs-keyword">switch</span> result {
<span class="hljs-keyword">case</span> .success(<span class="hljs-keyword">let</span> data):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;데이터 수신 성공: <span class="hljs-subst">\(data)</span>&quot;</span>)
<span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;데이터 가져오기 실패: <span class="hljs-subst">\(error)</span>&quot;</span>)
}
</code></pre>
<p>이 예제에서 fetchData 함수는 가져온 데이터 또는 오류를 캡슐화하는 Result 타입을 반환합니다.</p>
<p>Async/Await으로 에러 처리</p>
<div class="content-ad"></div>
<p>Swift의 새로운 동시성 모델은 async/await를 도입하여 비동기 코드를 처리하기 쉬워졌어요. 이 문맥에서 오류를 처리하는 방법을 살펴봅시다.</p>
<p>Async/Await 예제</p>
<pre><code class="hljs language-js">enum <span class="hljs-title class_">NetworkError</span>: <span class="hljs-title class_">Error</span> {
    <span class="hljs-keyword">case</span> invalidURL
    <span class="hljs-keyword">case</span> requestFailed
}

func <span class="hljs-title function_">fetchData</span>(<span class="hljs-keyword">from</span> <span class="hljs-attr">urlString</span>: <span class="hljs-title class_">String</span>) <span class="hljs-keyword">async</span> throws -&gt; <span class="hljs-title class_">Data</span> {
    guard <span class="hljs-keyword">let</span> url = <span class="hljs-title function_">URL</span>(<span class="hljs-attr">string</span>: urlString) <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">NetworkError</span>.<span class="hljs-property">invalidURL</span>
    }

    <span class="hljs-keyword">let</span> (data, _) = <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> <span class="hljs-title class_">URLSession</span>.<span class="hljs-property">shared</span>.<span class="hljs-title function_">data</span>(<span class="hljs-attr">from</span>: url)
    <span class="hljs-keyword">return</span> data
}

func <span class="hljs-title function_">processData</span>() <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-attr">from</span>: <span class="hljs-string">&quot;https://example.com/data&quot;</span>)
        <span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;Data fetched: \(data)&quot;</span>)
    } <span class="hljs-keyword">catch</span> {
        <span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;Failed to fetch data: \(error)&quot;</span>)
    }
}

<span class="hljs-title class_">Task</span> {
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">processData</span>()
}
</code></pre>
<p>이 예제에서 fetchData 함수는 비동기이며 오류를 던질 수 있습니다. 이 오류는 processData 함수 내에서 try-catch를 사용하여 처리됩니다.</p>
<div class="content-ad"></div>
<p>사용자 정의 오류 유형 만들기</p>
<p>사용자 정의 오류 유형은 오류 처리를 더 정확하고 의미 있게 만들어줍니다.</p>
<p>사용자 정의 오류 유형을 이용한 예제</p>
<pre><code class="hljs language-js">enum <span class="hljs-title class_">FileError</span>: <span class="hljs-title class_">Error</span> {
    <span class="hljs-keyword">case</span> fileNotFound
    <span class="hljs-keyword">case</span> unreadable
    <span class="hljs-keyword">case</span> encodingFailed
}

func <span class="hljs-title function_">readFile</span>(named <span class="hljs-attr">fileName</span>: <span class="hljs-title class_">String</span>) throws -&gt; <span class="hljs-title class_">String</span> {
    guard <span class="hljs-keyword">let</span> filePath = <span class="hljs-title class_">Bundle</span>.<span class="hljs-property">main</span>.<span class="hljs-title function_">path</span>(<span class="hljs-attr">forResource</span>: fileName, <span class="hljs-attr">ofType</span>: nil) <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">FileError</span>.<span class="hljs-property">fileNotFound</span>
    }

    guard <span class="hljs-keyword">let</span> data = <span class="hljs-title class_">FileManager</span>.<span class="hljs-property">default</span>.<span class="hljs-title function_">contents</span>(<span class="hljs-attr">atPath</span>: filePath) <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">FileError</span>.<span class="hljs-property">unreadable</span>
    }

    guard <span class="hljs-keyword">let</span> content = <span class="hljs-title class_">String</span>(<span class="hljs-attr">data</span>: data, <span class="hljs-attr">encoding</span>: .<span class="hljs-property">utf8</span>) <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">FileError</span>.<span class="hljs-property">encodingFailed</span>
    }

    <span class="hljs-keyword">return</span> content
}

<span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">let</span> content = <span class="hljs-keyword">try</span> <span class="hljs-title function_">readFile</span>(<span class="hljs-attr">named</span>: <span class="hljs-string">&quot;example.txt&quot;</span>)
    <span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;파일 내용: \(content)&quot;</span>)
} <span class="hljs-keyword">catch</span> {
    <span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;파일 읽기 실패: \(error)&quot;</span>)
}
</code></pre>
<div class="content-ad"></div>
<p>여기에서 FileError는 파일 작업과 관련된 특정 오류를 정의합니다. readFile 함수는 이러한 오류 유형을 사용하여 상세한 오류 정보를 제공합니다.</p>
<p>에러 처리를 위한 최상의 모법</p>
<ul>
<li>기술적인 오류 유형 사용: 오류에 대한 의미 있는 컨텍스트를 제공하는 사용자 정의 오류 유형을 정의하세요.</li>
</ul>
<pre><code class="hljs language-swift"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">ValidationError</span>: <span class="hljs-title class_">Error</span> {
    <span class="hljs-keyword">case</span> invalidEmail
    <span class="hljs-keyword">case</span> passwordTooShort
}
</code></pre>
<div class="content-ad"></div>
<ol start="2">
<li>적절한 수준으로 오류 전파하기: 오류를 효과적으로 처리할 수 있는 적절한 수준으로 전파하십시오.</li>
</ol>
<pre><code class="hljs language-js">func <span class="hljs-title function_">performOperation</span>() throws {
    <span class="hljs-keyword">try</span> <span class="hljs-title function_">validateInput</span>()
    <span class="hljs-keyword">try</span> <span class="hljs-title function_">processData</span>()
}
</code></pre>
<ol start="3">
<li>우아한 복구: 가능한 경우에는 오류로부터 복구할 수 있는 전략을 구현하여 실패하는 것이 아닌 대처하십시오.</li>
</ol>
<pre><code class="hljs language-js">func <span class="hljs-title function_">fetchData</span>() <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-attr">from</span>: <span class="hljs-string">&quot;https://example.com&quot;</span>)
        <span class="hljs-title function_">process</span>(data)
    } <span class="hljs-keyword">catch</span> {
        <span class="hljs-title function_">recoverFromError</span>(error)
    }
}
</code></pre>
<div class="content-ad"></div>
<ol start="4">
<li>중앙 집중식 오류 로깅: 디버깅을 간소화하기 위해 오류를 기록하는 데 중앙 집중식 방법을 사용하세요.</li>
</ol>
<pre><code class="hljs language-js">func <span class="hljs-title function_">logError</span>(<span class="hljs-params">_ error: <span class="hljs-built_in">Error</span></span>) {
    <span class="hljs-comment">// 모니터링 서비스나 콘솔에 오류 기록</span>
    <span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;오류: \(error)&quot;</span>)
}
</code></pre>
<ol start="5">
<li>사용자 친화적인 오류 메시지: 사용자에게 명확하고 실행 가능한 오류 메시지를 제공하세요.</li>
</ol>
<pre><code class="hljs language-js">func <span class="hljs-title function_">displayError</span>(<span class="hljs-params">_ error: <span class="hljs-built_in">Error</span></span>) {
    <span class="hljs-keyword">let</span> <span class="hljs-attr">message</span>: <span class="hljs-title class_">String</span>
    <span class="hljs-keyword">switch</span> error {
    <span class="hljs-keyword">case</span> is <span class="hljs-title class_">NetworkError</span>:
        message = <span class="hljs-string">&quot;네트워크 오류가 발생했습니다. 나중에 다시 시도해 주세요.&quot;</span>
    <span class="hljs-attr">default</span>:
        message = <span class="hljs-string">&quot;예기치 못한 오류가 발생했습니다.&quot;</span>
    }
    <span class="hljs-title function_">showAlert</span>(<span class="hljs-attr">with</span>: message)
}
</code></pre>
<div class="content-ad"></div>
<p>결론</p>
<p>Swift에서의 고급 오류 처리는 기본적인 try-catch 블록을 넘어서 Result 타입, async/await, 그리고 사용자 정의 오류 타입과 같은 강력한 기능을 활용합니다. 이러한 고급 기술을 채택함으로써 더 견고하고 가독성이 높고 유지보수가 용이한 코드를 작성할 수 있습니다. 효과적인 오류 처리는 응용 프로그램이 오류를 우아하게 처리하여 개발자와 사용자 모두에게 더 나은 경험을 제공할 수 있도록 합니다. 이러한 전략을 받아들여 Swift 개발 기술을 향상시키고 더 견고한 응용 프로그램을 구축하세요. 즐거운 코딩 되세요!</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Swift에서의 고급 오류 처리 Try-Catch를 넘어서","description":"","date":"2024-05-23 13:13","slug":"2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch","content":"\n\n\u003cimg src=\"/assets/img/2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch_0.png\" /\u003e\n\n소개\n\n오류 처리는 견고한 응용 프로그램 구축의 중요한 측면입니다. Swift의 try, catch, throw 및 do로 소개된 오류 처리 모델은 오류를 우아하게 처리하는 강력하고 유연한 메커니즘을 제공합니다. 그러나 응용 프로그램이 복잡해지면 오류를 효과적으로 관리하기 위해 더 고급 기술이 필요할 수 있습니다. 이 글에서는 Swift에서 고급 오류 처리 전략인 Result 타입, async/await 오류 전파, 사용자 정의 오류 타입, 견고한 오류 처리 시스템을 만드는 데 가장 좋은 방법 등을 탐색해 보겠습니다.\n\n왜 고급 오류 처리가 중요한가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본 try-catch를 사용한 기본적인 오류 처리는 많은 시나리오에 효과적이지만, 고급 기술은 다음과 같은 여러 가지 이점을 제공합니다:\n\n- 가독성 향상: 더 명확한 오류 처리 경로는 코드의 가독성과 유지보수성을 향상시킵니다.\n- 더 좋은 제어: 오류 전파 및 복구에 대한 더 많은 제어.\n- 디버깅 향상: 더 구체적인 오류 유형으로 문제를 진단하고 수정하기가 더 쉬워집니다.\n- 비동기 컨텍스트: 비동기 코드에서의 오류를 효과적으로 관리합니다.\n\n결과 유형 사용하기\n\n결과 유형은 성공 또는 실패를 나타내며, 값이나 오류를 캡슐화합니다. 오류 처리에 대해 더 함수형 접근 방식을 제공하며 비동기 작업에서 특히 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본 예제 및 결과\n\n```swift\nenum NetworkError: Error {\n    case invalidURL\n    case requestFailed\n}\n\nfunc fetchData(from urlString: String) -\u003e Result\u003cData, NetworkError\u003e {\n    guard let url = URL(string: urlString) else {\n        return .failure(.invalidURL)\n    }\n\n    do {\n        let data = try Data(contentsOf: url)\n        return .success(data)\n    } catch {\n        return .failure(.requestFailed)\n    }\n}\n\nlet result = fetchData(from: \"https://example.com/data\")\n\nswitch result {\ncase .success(let data):\n    print(\"데이터 수신 성공: \\(data)\")\ncase .failure(let error):\n    print(\"데이터 가져오기 실패: \\(error)\")\n}\n```\n\n이 예제에서 fetchData 함수는 가져온 데이터 또는 오류를 캡슐화하는 Result 타입을 반환합니다.\n\nAsync/Await으로 에러 처리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSwift의 새로운 동시성 모델은 async/await를 도입하여 비동기 코드를 처리하기 쉬워졌어요. 이 문맥에서 오류를 처리하는 방법을 살펴봅시다.\n\nAsync/Await 예제\n\n```js\nenum NetworkError: Error {\n    case invalidURL\n    case requestFailed\n}\n\nfunc fetchData(from urlString: String) async throws -\u003e Data {\n    guard let url = URL(string: urlString) else {\n        throw NetworkError.invalidURL\n    }\n\n    let (data, _) = try await URLSession.shared.data(from: url)\n    return data\n}\n\nfunc processData() async {\n    do {\n        let data = try await fetchData(from: \"https://example.com/data\")\n        print(\"Data fetched: \\(data)\")\n    } catch {\n        print(\"Failed to fetch data: \\(error)\")\n    }\n}\n\nTask {\n    await processData()\n}\n```\n\n이 예제에서 fetchData 함수는 비동기이며 오류를 던질 수 있습니다. 이 오류는 processData 함수 내에서 try-catch를 사용하여 처리됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자 정의 오류 유형 만들기\n\n사용자 정의 오류 유형은 오류 처리를 더 정확하고 의미 있게 만들어줍니다.\n\n사용자 정의 오류 유형을 이용한 예제\n\n```js\nenum FileError: Error {\n    case fileNotFound\n    case unreadable\n    case encodingFailed\n}\n\nfunc readFile(named fileName: String) throws -\u003e String {\n    guard let filePath = Bundle.main.path(forResource: fileName, ofType: nil) else {\n        throw FileError.fileNotFound\n    }\n\n    guard let data = FileManager.default.contents(atPath: filePath) else {\n        throw FileError.unreadable\n    }\n\n    guard let content = String(data: data, encoding: .utf8) else {\n        throw FileError.encodingFailed\n    }\n\n    return content\n}\n\ndo {\n    let content = try readFile(named: \"example.txt\")\n    print(\"파일 내용: \\(content)\")\n} catch {\n    print(\"파일 읽기 실패: \\(error)\")\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에서 FileError는 파일 작업과 관련된 특정 오류를 정의합니다. readFile 함수는 이러한 오류 유형을 사용하여 상세한 오류 정보를 제공합니다.\n\n에러 처리를 위한 최상의 모법\n\n- 기술적인 오류 유형 사용: 오류에 대한 의미 있는 컨텍스트를 제공하는 사용자 정의 오류 유형을 정의하세요.\n\n```swift\nenum ValidationError: Error {\n    case invalidEmail\n    case passwordTooShort\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 적절한 수준으로 오류 전파하기: 오류를 효과적으로 처리할 수 있는 적절한 수준으로 전파하십시오.\n\n```js\nfunc performOperation() throws {\n    try validateInput()\n    try processData()\n}\n```\n\n3. 우아한 복구: 가능한 경우에는 오류로부터 복구할 수 있는 전략을 구현하여 실패하는 것이 아닌 대처하십시오.\n\n```js\nfunc fetchData() async {\n    do {\n        let data = try await fetchData(from: \"https://example.com\")\n        process(data)\n    } catch {\n        recoverFromError(error)\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. 중앙 집중식 오류 로깅: 디버깅을 간소화하기 위해 오류를 기록하는 데 중앙 집중식 방법을 사용하세요.\n\n```js\nfunc logError(_ error: Error) {\n    // 모니터링 서비스나 콘솔에 오류 기록\n    print(\"오류: \\(error)\")\n}\n```\n\n5. 사용자 친화적인 오류 메시지: 사용자에게 명확하고 실행 가능한 오류 메시지를 제공하세요.\n\n```js\nfunc displayError(_ error: Error) {\n    let message: String\n    switch error {\n    case is NetworkError:\n        message = \"네트워크 오류가 발생했습니다. 나중에 다시 시도해 주세요.\"\n    default:\n        message = \"예기치 못한 오류가 발생했습니다.\"\n    }\n    showAlert(with: message)\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결론\n\nSwift에서의 고급 오류 처리는 기본적인 try-catch 블록을 넘어서 Result 타입, async/await, 그리고 사용자 정의 오류 타입과 같은 강력한 기능을 활용합니다. 이러한 고급 기술을 채택함으로써 더 견고하고 가독성이 높고 유지보수가 용이한 코드를 작성할 수 있습니다. 효과적인 오류 처리는 응용 프로그램이 오류를 우아하게 처리하여 개발자와 사용자 모두에게 더 나은 경험을 제공할 수 있도록 합니다. 이러한 전략을 받아들여 Swift 개발 기술을 향상시키고 더 견고한 응용 프로그램을 구축하세요. 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch_0.png"},"coverImage":"/assets/img/2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch_0.png","tag":["Tech"],"readingTime":5},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    ol: \"ol\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(\"img\", {\n      src: \"/assets/img/2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch_0.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"소개\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"오류 처리는 견고한 응용 프로그램 구축의 중요한 측면입니다. Swift의 try, catch, throw 및 do로 소개된 오류 처리 모델은 오류를 우아하게 처리하는 강력하고 유연한 메커니즘을 제공합니다. 그러나 응용 프로그램이 복잡해지면 오류를 효과적으로 관리하기 위해 더 고급 기술이 필요할 수 있습니다. 이 글에서는 Swift에서 고급 오류 처리 전략인 Result 타입, async/await 오류 전파, 사용자 정의 오류 타입, 견고한 오류 처리 시스템을 만드는 데 가장 좋은 방법 등을 탐색해 보겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"왜 고급 오류 처리가 중요한가요?\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"기본 try-catch를 사용한 기본적인 오류 처리는 많은 시나리오에 효과적이지만, 고급 기술은 다음과 같은 여러 가지 이점을 제공합니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"가독성 향상: 더 명확한 오류 처리 경로는 코드의 가독성과 유지보수성을 향상시킵니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"더 좋은 제어: 오류 전파 및 복구에 대한 더 많은 제어.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"디버깅 향상: 더 구체적인 오류 유형으로 문제를 진단하고 수정하기가 더 쉬워집니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"비동기 컨텍스트: 비동기 코드에서의 오류를 효과적으로 관리합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"결과 유형 사용하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"결과 유형은 성공 또는 실패를 나타내며, 값이나 오류를 캡슐화합니다. 오류 처리에 대해 더 함수형 접근 방식을 제공하며 비동기 작업에서 특히 유용합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"기본 예제 및 결과\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-swift\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"enum\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NetworkError\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Error\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"case\"\n        }), \" invalidURL\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"case\"\n        }), \" requestFailed\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"func\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetchData\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"urlString\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"String\"\n        }), \") -\u003e \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Result\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Data\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"NetworkError\"\n        }), \"\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"guard\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" url \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"URL\"\n        }), \"(string: urlString) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" .failure(.invalidURL)\\n    }\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"do\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" data \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"try\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Data\"\n        }), \"(contentsOf: url)\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" .success(data)\\n    } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"catch\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" .failure(.requestFailed)\\n    }\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" result \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" fetchData(from: \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"https://example.com/data\\\"\"\n        }), \")\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"switch\"\n        }), \" result {\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"case\"\n        }), \" .success(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" data):\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\"데이터 수신 성공: \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"\\\\(data)\"\n          }), \"\\\"\"]\n        }), \")\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"case\"\n        }), \" .failure(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" error):\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\"데이터 가져오기 실패: \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"\\\\(error)\"\n          }), \"\\\"\"]\n        }), \")\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 예제에서 fetchData 함수는 가져온 데이터 또는 오류를 캡슐화하는 Result 타입을 반환합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Async/Await으로 에러 처리\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Swift의 새로운 동시성 모델은 async/await를 도입하여 비동기 코드를 처리하기 쉬워졌어요. 이 문맥에서 오류를 처리하는 방법을 살펴봅시다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Async/Await 예제\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"enum \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NetworkError\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Error\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"case\"\n        }), \" invalidURL\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"case\"\n        }), \" requestFailed\\n}\\n\\nfunc \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetchData\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"urlString\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" throws -\u003e \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Data\"\n        }), \" {\\n    guard \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" url = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"URL\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"string\"\n        }), \": urlString) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"throw\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NetworkError\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"invalidURL\"\n        }), \"\\n    }\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" (data, _) = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"try\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"URLSession\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shared\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"data\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"from\"\n        }), \": url)\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" data\\n}\\n\\nfunc \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"processData\"\n        }), \"() \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"do\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" data = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"try\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetchData\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"from\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"https://example.com/data\\\"\"\n        }), \")\\n        \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Data fetched: \\\\(data)\\\"\"\n        }), \")\\n    } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"catch\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Failed to fetch data: \\\\(error)\\\"\"\n        }), \")\\n    }\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Task\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"processData\"\n        }), \"()\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 예제에서 fetchData 함수는 비동기이며 오류를 던질 수 있습니다. 이 오류는 processData 함수 내에서 try-catch를 사용하여 처리됩니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사용자 정의 오류 유형 만들기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사용자 정의 오류 유형은 오류 처리를 더 정확하고 의미 있게 만들어줍니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사용자 정의 오류 유형을 이용한 예제\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"enum \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FileError\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Error\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"case\"\n        }), \" fileNotFound\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"case\"\n        }), \" unreadable\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"case\"\n        }), \" encodingFailed\\n}\\n\\nfunc \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"readFile\"\n        }), \"(named \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"fileName\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \") throws -\u003e \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \" {\\n    guard \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" filePath = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Bundle\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"main\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"path\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"forResource\"\n        }), \": fileName, \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"ofType\"\n        }), \": nil) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"throw\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FileError\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"fileNotFound\"\n        }), \"\\n    }\\n\\n    guard \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" data = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FileManager\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"default\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"contents\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"atPath\"\n        }), \": filePath) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"throw\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FileError\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"unreadable\"\n        }), \"\\n    }\\n\\n    guard \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" content = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"data\"\n        }), \": data, \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"encoding\"\n        }), \": .\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"utf8\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"throw\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FileError\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"encodingFailed\"\n        }), \"\\n    }\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" content\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"do\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" content = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"try\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"readFile\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"named\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"example.txt\\\"\"\n        }), \")\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"파일 내용: \\\\(content)\\\"\"\n        }), \")\\n} \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"catch\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"파일 읽기 실패: \\\\(error)\\\"\"\n        }), \")\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기에서 FileError는 파일 작업과 관련된 특정 오류를 정의합니다. readFile 함수는 이러한 오류 유형을 사용하여 상세한 오류 정보를 제공합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"에러 처리를 위한 최상의 모법\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"기술적인 오류 유형 사용: 오류에 대한 의미 있는 컨텍스트를 제공하는 사용자 정의 오류 유형을 정의하세요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-swift\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"enum\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ValidationError\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Error\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"case\"\n        }), \" invalidEmail\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"case\"\n        }), \" passwordTooShort\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"2\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"적절한 수준으로 오류 전파하기: 오류를 효과적으로 처리할 수 있는 적절한 수준으로 전파하십시오.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"func \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"performOperation\"\n        }), \"() throws {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"try\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"validateInput\"\n        }), \"()\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"try\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"processData\"\n        }), \"()\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"3\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"우아한 복구: 가능한 경우에는 오류로부터 복구할 수 있는 전략을 구현하여 실패하는 것이 아닌 대처하십시오.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"func \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetchData\"\n        }), \"() \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"do\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" data = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"try\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetchData\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"from\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"https://example.com\\\"\"\n        }), \")\\n        \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"process\"\n        }), \"(data)\\n    } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"catch\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"recoverFromError\"\n        }), \"(error)\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"4\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"중앙 집중식 오류 로깅: 디버깅을 간소화하기 위해 오류를 기록하는 데 중앙 집중식 방법을 사용하세요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"func \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"logError\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"_ error: \", _jsx(_components.span, {\n            className: \"hljs-built_in\",\n            children: \"Error\"\n          })]\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 모니터링 서비스나 콘솔에 오류 기록\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"오류: \\\\(error)\\\"\"\n        }), \")\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"5\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"사용자 친화적인 오류 메시지: 사용자에게 명확하고 실행 가능한 오류 메시지를 제공하세요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"func \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"displayError\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"_ error: \", _jsx(_components.span, {\n            className: \"hljs-built_in\",\n            children: \"Error\"\n          })]\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"message\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"switch\"\n        }), \" error {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"case\"\n        }), \" is \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NetworkError\"\n        }), \":\\n        message = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"네트워크 오류가 발생했습니다. 나중에 다시 시도해 주세요.\\\"\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"default\"\n        }), \":\\n        message = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"예기치 못한 오류가 발생했습니다.\\\"\"\n        }), \"\\n    }\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"showAlert\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"with\"\n        }), \": message)\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Swift에서의 고급 오류 처리는 기본적인 try-catch 블록을 넘어서 Result 타입, async/await, 그리고 사용자 정의 오류 타입과 같은 강력한 기능을 활용합니다. 이러한 고급 기술을 채택함으로써 더 견고하고 가독성이 높고 유지보수가 용이한 코드를 작성할 수 있습니다. 효과적인 오류 처리는 응용 프로그램이 오류를 우아하게 처리하여 개발자와 사용자 모두에게 더 나은 경험을 제공할 수 있도록 합니다. 이러한 전략을 받아들여 Swift 개발 기술을 향상시키고 더 견고한 응용 프로그램을 구축하세요. 즐거운 코딩 되세요!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch"},"buildId":"PgdIX9e0tvkvkdAmDT6qR","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>