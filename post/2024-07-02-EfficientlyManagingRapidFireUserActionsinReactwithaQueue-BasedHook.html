<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>큐 기반 훅으로 빠른 사용자 액션을 효율적으로 관리하는 방법 React | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-07-02-EfficientlyManagingRapidFireUserActionsinReactwithaQueue-BasedHook" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="큐 기반 훅으로 빠른 사용자 액션을 효율적으로 관리하는 방법 React | ui-station" data-gatsby-head="true"/><meta property="og:title" content="큐 기반 훅으로 빠른 사용자 액션을 효율적으로 관리하는 방법 React | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-07-02-EfficientlyManagingRapidFireUserActionsinReactwithaQueue-BasedHook_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-07-02-EfficientlyManagingRapidFireUserActionsinReactwithaQueue-BasedHook" data-gatsby-head="true"/><meta name="twitter:title" content="큐 기반 훅으로 빠른 사용자 액션을 효율적으로 관리하는 방법 React | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-07-02-EfficientlyManagingRapidFireUserActionsinReactwithaQueue-BasedHook_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-02 21:59" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_buildManifest.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">큐 기반 훅으로 빠른 사용자 액션을 효율적으로 관리하는 방법 React</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="큐 기반 훅으로 빠른 사용자 액션을 효율적으로 관리하는 방법 React" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 2, 2024</span><span class="posts_reading_time__f7YPP">14<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-02-EfficientlyManagingRapidFireUserActionsinReactwithaQueue-BasedHook&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>내 React Native 기반 소셜 네트워킹 앱에서 프로필 페이지를 구축하면서 흥미로운 문제를 마주했어요:</p>
<p>만약 사용자가 좋아요 버튼을 스팸하는 경우 API 엔드포인트 남용을 어떻게 관리할까요?</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*_KQNCttwub7NvtykSKLv3g.gif" alt="이미지"></p>
<ul>
<li>사용자가 좋아요 버튼을 스팸하면 취약해집니다.</li>
<li>버튼을 누를 때마다 API 호출이 발생하여 서버에 사용자의 작업을 알리고, 서버에서는 데이터베이스 상태를 업데이트하는 DB 호출이 이어집니다.</li>
<li>첫눈에는 무해한 호출이라고 생각되지만 반복해서 발생할 경우 앱의 캐싱 아키텍처에 심각한 차질을 일으킬 수 있습니다. 효율적으로 관리되지 않은 경우 데이터베이스 상태 업데이트로 인해 여러 번 캐시를 몇 초 내에 여러 번 재설정해야 할 수도 있습니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>문제와 UI 요구 사항을 명확히 하기</h1>
<p>이 문제를 효율적으로 해결하기 위해 필요한 모든 요구 사항을 기록해 봅시다. 최종 사용자는 부드러운 UX를 필요로 하고, 서버는 최소한의 부하를 원합니다.</p>
<h2>UX 요구 사항</h2>
<ul>
<li>'좋아요' 동작은 앱에 즉시 반영되어야 합니다. 서버의 응답이 늦게 올 경우에도, 게시물을 좋아하는 경우 하트 아이콘이 즉시 채워지고, 싫어하는 경우 비워져야 합니다.
이는 일반적인 API 호출 흐름과는 다릅니다. 일반적으로 서버 응답을 기다리는 동안 로더를 표시하고 동작 버튼을 비활성화하는 것이 일반적이지만, 이 접근 방식을 여기서 사용하면 UX를 망치게 됩니다. 전체 경험을 느릿느릿하게 만들어 버릴 수 있습니다.</li>
<li>UI 상태는 결국 서버의 상태와 일관되어야 합니다. 즉, API 호출이 성공하지 않는 경우(사용자의 조치) 좋아요 아이콘과 좋아요 수가 표시되어야 합니다.</li>
<li>좋아요 및 싫어요 동작은 번갈아가며 일어납니다. 따라서 서버의 5xx 응답으로 인해 API 호출 중 하나가 실패할 경우 우리는 이 사실을 우리의 이점으로 활용할 수 있습니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>서버 요구 사항</h2>
<ul>
<li>서버 호출은 최소화되어야 합니다.</li>
<li>당신이 좋아하지 않은 게시물에 싫어요를 표시할 수 없습니다. 시도하면 400 BAD REQUEST 응답이 반환됩니다.</li>
<li>당신이 이미 좋아한 게시물을 좋아할 수 없습니다. 시도하면 다시 한 번 400 BAD REQUEST 응답이 반환됩니다.</li>
<li>서버는 요청을 처리하는 데 어려움을 겪으면 5xx 응답을 보낼 수 있습니다.</li>
</ul>
<h1>용어</h1>
<p>더 나아가기 전에, 다음 용어의 의미를 명확하게 설명하고 싶습니다. 만약 명백하지 않다면:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>클라이언트 상태 또는 UI 상태는 사용자에게 표시되는 상태입니다. 이에는 "좋아요" 아이콘(좋아요 시 채워지고 좋아요 취소 시 비워짐)와 좋아요 수가 포함됩니다.</li>
<li>서버 상태는 데이터베이스의 상태로, 우리 데이터의 실제 상태입니다.</li>
</ul>
<p>서버 상태 업데이트(API 호출)는 클라이언트 상태 업데이트(React 상태 업데이트)보다 수십 배 시간이 더 소요됩니다.
우리의 목표는 클라이언트 상태 업데이트가 서버 상태 업데이트로 인해 느려지지 않으면서 이 두 상태를 최종적으로 조율하는 것입니다.</p>
<h1>가능한 해결책</h1>
<p>이 문제에 대한 전통적인 해결책에는 UI에서 디바운싱 및 함수 쓰로틀링 또는 서버에서 API의 속도 제한이 포함됩니다.
이 큐 기반 접근 방식에서 나의 생각 프로세스는 API 호출이 수백 밀리초가 걸릴 수 있다는 사실을 활용하고 호출을 자연적인 디바운서로 사용하는 것이었습니다. API의 속도 제한도 여전히 유효합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>최종 솔루션</h1>
<p>잠재적인 해결책에 대한 심사숙고 끝에 사용자의 작업(좋아요/싫어요)을 유지하는 React 훅을 만들었습니다. pushToQueue 메서드를 노출하여 작업을 추가할 수 있게 했습니다.</p>
<ul>
<li>사용자 상태는 즉시 업데이트됩니다.
서버 상태를 업데이트하는 네트워크 호출은 큐에 추가됩니다.</li>
<li>비어 있지 않은 큐가 감지되면 앱은 처리 상태로 전환됩니다. 큐를 파싱하여 최종 작업(좋아요/싫어요)이 결정되고, 서버에 해당 작업을 알리는 API 호출이 발생합니다.</li>
<li>이제 API 호출은 여러 밀리초가 걸릴 수 있습니다.
사용자는 통화 중에 동일한 버튼에 추가 상호작용을 실행할 수 있습니다. 이 작업들은 나중에 처리하기 위해 큐에 추가됩니다. (다시 말해, 클라이언트 상태는 이러한 상호작용 발생 즉시 업데이트됩니다. 큐가 처리된 후에 다시 업데이트되며, 서버 상태를 반영합니다.)</li>
<li>API 호출이 완료되면 큐에 처리할 추가 항목이 있는지 확인합니다. 존재하는 경우 전체 프로세스가 반복됩니다. 그렇지 않으면 처리가 완료되고 클라이언트 상태가 그에 맞게 업데이트됩니다.
API 호출에 의한 지연은 자연스러운 디바운서 역할을 합니다.</li>
</ul>
<p>수고하셨습니다. 이제 코드를 빌드해 봅시다!</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>구현</h1>
<h2>앱 초기화</h2>
<p>먼저, 좋아요 아이콘과 좋아요 수를 표시하는 간단한 앱을 만들어봅시다:</p>
<p>그 상태에는 다음이 저장됩니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>게시물이 좋아요를 받았는지 아닌지를 저장하는 부울 값</li>
<li>좋아요 수 (숫자).</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>({
  <span class="hljs-attr">liked</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">likeCount</span>: <span class="hljs-number">0</span>,
});
</code></pre>
<p>하트 아이콘과 텍스트를 사용하여 정보를 표시합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"App"</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"heart_container"</span>></span>
        /*Fill the icon if liked, else no fill (transparent)*/
        <span class="hljs-tag">&#x3C;<span class="hljs-name">HeartIcon</span>
          <span class="hljs-attr">height</span>=<span class="hljs-string">{96}</span>
          <span class="hljs-attr">width</span>=<span class="hljs-string">{96}</span>
          <span class="hljs-attr">stroke</span>=<span class="hljs-string">"#aaa"</span>
          <span class="hljs-attr">fill</span>=<span class="hljs-string">{liked</span> ? "<span class="hljs-attr">rgb</span>(<span class="hljs-attr">207</span>, <span class="hljs-attr">102</span>, <span class="hljs-attr">121</span>)" <span class="hljs-attr">:</span> "<span class="hljs-attr">transparent</span>"}
        /></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      /* 좋아요 수를 표시 */
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>{likeCount}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다음으로, 좋아요/싫어요를 설정하는 간단한 onClick Handler를 정의합니다:</p>
<ul>
<li>좋아요는 boolean 값을 true로 설정하고 좋아요 수를 증가시킵니다.</li>
<li>싫어요는 boolean 값을 false로 설정하고 좋아요 수를 감소시킵니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> like = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">prevState</span>) =></span> ({
      <span class="hljs-attr">liked</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">likeCount</span>: prevState.<span class="hljs-property">likeCount</span> + <span class="hljs-number">1</span>,
    }));
  }, []);

  <span class="hljs-keyword">const</span> dislike = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">prevState</span>) =></span> ({
      <span class="hljs-attr">liked</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">likeCount</span>: prevState.<span class="hljs-property">likeCount</span> - <span class="hljs-number">1</span>,
    }));
  }, []);

  <span class="hljs-keyword">const</span> onClick = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">if</span> (liked) {
      <span class="hljs-title function_">dislike</span>();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">like</span>();
    }
  }, [liked]);
</code></pre>
<p>스타일링을 조금 추가하면 앱이 이렇게 보입니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>마지막으로, 훅을 설정해 봅시다.</p>
<h2>훅 — Props</h2>
<p>우리의 훅은 다음과 같은 프롭스를 받을 것입니다:</p>
<ul>
<li>postId: 숫자: 좋아요를 눌러야 할 게시물의 ID. 이 ID와 결합된 API 호출이 실행될 것입니다.</li>
<li>mutate(postId: number, liked: boolean, postId: number) =<code> Promise</code>boolean` :
API를 호출하기 위한 책임을 지는 비동기 함수입니다. 이 함수는 응답의 상태를 부울 값으로 반환해야 합니다 (호출이 성공했는지 여부).
모든 네트워크 호출과 마찬가지로, 오류가 발생할 수도 있습니다.</li>
<li>setLikedState: (liked: boolean) =` React.SetStateAction:
UI 상태를 업데이트하는 함수입니다.</li>
<li>onError?: (error: Error) =` unknown: 만약 API 호출이 오류를 발생시킬 경우 실행할 콜백 함수입니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>The Hook — 큐 저장하기</h2>
<p>액션의 큐를 React ref에 저장할 것입니다. 그 값들은 가능한 액션인 '좋아요' 또는 '싫어요'일 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> queueRef = useRef&#x3C;(<span class="hljs-string">"like"</span> | <span class="hljs-string">"dislike"</span>)[]>([]);
</code></pre>
<p>마지막으로, 현재 큐가 처리 중인지 여부를 알려주는 상태를 저장할 것입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> [processing, setProcessing] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
</code></pre>
<p>최종 작업이 결정되고 API 호출이 이루어질 때 <code>processing</code>이 true로 설정됩니다. 큐가 비어있을 때 (처리된 경우) false로 설정됩니다.</p>
<h2>훅 — 큐 처리하기</h2>
<p>다음은 우리 큐의 작동 메커니즘입니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>처리 상태를 True로 설정합니다.</li>
<li>원본 큐를 변경하지 않기 위해 큐의 복사본을 만듭니다.</li>
<li>복사본을 이용하여 최종 동작을 결정하기 위해 반복합니다 (좋아요, 싫어요 또는 아무 작업도 안 함):</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-title function_">setProcessing</span>(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">const</span> initialQueueLength = queueRef.<span class="hljs-property">current</span>.<span class="hljs-property">length</span>;
<span class="hljs-comment">// 처리 중에 참조를 변경하지 않기 위한 참조의 복사본.</span>
<span class="hljs-keyword">const</span> queueCopy = [...queueRef.<span class="hljs-property">current</span>];
<span class="hljs-keyword">let</span> <span class="hljs-attr">finalAction</span>: <span class="hljs-string">"like"</span> | <span class="hljs-string">"dislike"</span> | <span class="hljs-string">"none"</span> = <span class="hljs-string">"none"</span>;
<span class="hljs-keyword">while</span> (queueCopy.<span class="hljs-property">length</span>) {
    <span class="hljs-keyword">const</span> type = queueCopy.<span class="hljs-title function_">shift</span>();
    <span class="hljs-keyword">if</span> (type === <span class="hljs-string">"like"</span>) {
      finalAction = finalAction === <span class="hljs-string">"dislike"</span> ? <span class="hljs-string">"none"</span> : <span class="hljs-string">"like"</span>;
    } <span class="hljs-keyword">else</span> {
      finalAction = finalAction === <span class="hljs-string">"like"</span> ? <span class="hljs-string">"none"</span> : <span class="hljs-string">"dislike"</span>;
    }
}
</code></pre>
<p>이제 결정을 내려야 합니다 — API를 호출해야 할까요?
최종 동작이 아무 작업도 안 함으로 결정된 경우 API 호출이 필요하지 않습니다. 다음을 수행합니다:</p>
<ul>
<li>초기 처리된 항목의 수( initialQueueLength)만큼 참조를 잘라냅니다.</li>
<li>큐가 비어 있는지 확인합니다. 루프가 실행 중에 사용자가 좋아요 버튼을 눌렀다면 큐는 비어 있지 않을 수 있습니다.</li>
<li>큐가 비어 있지 않으면 프로세스를 반복하고 processQueue 함수를 다시 호출합니다. 그렇지 않으면 함수를 종료합니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> (finalAction === <span class="hljs-string">"none"</span>) {
  queueRef.<span class="hljs-property">current</span> =
    queueRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">slice</span>(initialQueueLength);
  <span class="hljs-keyword">if</span> (queueRef.<span class="hljs-property">current</span>.<span class="hljs-property">length</span> > <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">processQueue</span>();
  }
  <span class="hljs-title function_">setProcessing</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">return</span>;
}
</code></pre>
<p>만일 최종 작업이 '좋아요' 또는 '좋아요 취소'인 경우, API를 호출합니다. 호출이 성공했는지 여부를 추적하는 execSuccess 변수를 유지합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> execSuccess = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">try</span> {
    execSuccess = <span class="hljs-keyword">await</span> <span class="hljs-title function_">mutate</span>(postId, finalAction === <span class="hljs-string">"like"</span>);
} <span class="hljs-keyword">catch</span>(error) {
    execSuccess = <span class="hljs-literal">false</span>;
    <span class="hljs-title function_">onError</span>(error);
}
</code></pre>
<p>마지막으로, 큐에 더 이상 항목이 없다면 서버 응답에 따라 UI 상태를 업데이트해야 합니다.
API 호출이 실패했고 큐가 비어 있지 않으면 큐의 첫 번째 요소를 삭제할 수 있습니다. 작업은 대체로 번갈아가며 발생하기 때문입니다.
예: 만일 '좋아요' 호출이 실패했다면 큐에 추가된 다음 작업은 '좋아요 취소'일 것입니다. 따라서 우리는 처리되기 전에 큐에 추가된 '좋아요 취소' 작업을 삭제할 수 있습니다. '좋아요' 작업이 실패하면 UI 상태에선 '좋아요 취소' 작업과 동일하기 때문입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">마지막으로, 푸시 함수를 정의할 것입니다.

이 함수는 like 또는 dislike와 같은 액션을 인수로 받아서 간단히 큐에 푸시합니다.
큐가 처리 중이 아닌 경우(처리 상태 변수가 <span class="hljs-literal">false</span>인 경우), processQueue 함수를 호출합니다.
우리의 훅은 이 함수를 반환합니다.

<span class="hljs-keyword">const</span> pushToQueue = <span class="hljs-title function_">useCallback</span>(
  <span class="hljs-function">(<span class="hljs-params">action: <span class="hljs-string">"like"</span> | <span class="hljs-string">"dislike"</span></span>) =></span> {
    <span class="hljs-keyword">const</span> newQueue = [...queueRef.<span class="hljs-property">current</span>, action];
    queueRef.<span class="hljs-property">current</span> = newQueue;
    <span class="hljs-keyword">if</span> (!processing) <span class="hljs-title function_">processQueue</span>();
  },
  [processing]
);

<span class="hljs-keyword">return</span> [pushToQueue];

&#x3C;!-- ui-station 사각형 -->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ins</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"adsbygoogle"</span>
<span class="hljs-attr">style</span>=<span class="hljs-string">"display:block"</span>
<span class="hljs-attr">data-ad-client</span>=<span class="hljs-string">"ca-pub-4877378276818686"</span>
<span class="hljs-attr">data-ad-slot</span>=<span class="hljs-string">"7249294152"</span>
<span class="hljs-attr">data-ad-format</span>=<span class="hljs-string">"auto"</span>
<span class="hljs-attr">data-full-width-responsive</span>=<span class="hljs-string">"true"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">ins</span>></span></span>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
(adsbygoogle = <span class="hljs-variable language_">window</span>.<span class="hljs-property">adsbygoogle</span> || []).<span class="hljs-title function_">push</span>({});
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span></span>

# <span class="hljs-title class_">Hook</span> 사용 및 앱 테스트하기

## <span class="hljs-variable constant_">API</span>

우리는 코드를 테스트하기 위해 모의 <span class="hljs-variable constant_">API</span>를 사용할 것입니다. 이 <span class="hljs-variable constant_">API</span>는 <span class="hljs-number">20</span>%의 실패 비율을 가지며, 성공하면 <span class="hljs-literal">true</span>를 반환하고 그렇지 않으면 <span class="hljs-literal">false</span>를 반환합니다. 500ms의 인위적 지연이 발생할 것입니다.

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">API_DELAY</span> = <span class="hljs-number">500</span>;
<span class="hljs-keyword">const</span> responses = [<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>];
<span class="hljs-keyword">let</span> idx = <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> postLikeMapping = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&#x3C;number, boolean>();
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">mockedApiCall</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">postId: number, liked: boolean</span>) => {
  <span class="hljs-comment">// 가짜 지연</span>
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =></span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-variable constant_">API_DELAY</span>));
  <span class="hljs-keyword">if</span> (!postLikeMapping.<span class="hljs-title function_">get</span>(postId) &#x26;&#x26; !liked) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"좋아요 표시하지 않은 게시물에 싫어요를 표시할 수 없습니다."</span>);
  }
  <span class="hljs-keyword">if</span> (postLikeMapping.<span class="hljs-title function_">get</span>(postId) &#x26;&#x26; liked) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"이미 좋아요한 게시물에 또 다시 좋아요를 표시할 수 없습니다."</span>);
  }
  <span class="hljs-comment">//   80% 성공 확률 시뮬레이션</span>
  <span class="hljs-keyword">if</span> (responses[idx++ % responses.<span class="hljs-property">length</span>]) {
    postLikeMapping.<span class="hljs-title function_">set</span>(postId, liked);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
};

&#x3C;!-- ui-station 사각형 -->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ins</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"adsbygoogle"</span>
<span class="hljs-attr">style</span>=<span class="hljs-string">"display:block"</span>
<span class="hljs-attr">data-ad-client</span>=<span class="hljs-string">"ca-pub-4877378276818686"</span>
<span class="hljs-attr">data-ad-slot</span>=<span class="hljs-string">"7249294152"</span>
<span class="hljs-attr">data-ad-format</span>=<span class="hljs-string">"auto"</span>
<span class="hljs-attr">data-full-width-responsive</span>=<span class="hljs-string">"true"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">ins</span>></span></span>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
(adsbygoogle = <span class="hljs-variable language_">window</span>.<span class="hljs-property">adsbygoogle</span> || []).<span class="hljs-title function_">push</span>({});
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span></span>

우리 앱은 사용자가 좋아요 또는 싫어요 버튼을 누를 때마다 이 함수를 호출합니다.

## 우리 앱에서 <span class="hljs-title class_">Hook</span> 사용

마지막으로, 우리가 만든 훅을 앱에 통합합니다.

- 좋아하는 상태를 <span class="hljs-title class_">React</span> 리듀서로 변경합니다.
- 동일한 작업이 연속적으로 호출될 때(한 번은 <span class="hljs-variable constant_">UI</span>에서 즉시 호출되고 다른 한 번은 훅이 성공적인 <span class="hljs-variable constant_">API</span> 호출 후 호출될 때), 리듀서는 상태를 변경하지 않습니다.
- <span class="hljs-variable constant_">UI</span>가 상태를 즉시 업데이트하지만 <span class="hljs-variable constant_">API</span> 호출이 실패하여 상태가 재설정될 때 작업에 의해 상태가 업데이트됩니다.
- <span class="hljs-title class_">Hook</span>을 소비하고 사용자 상호작용 시 훅이 노출하는 pushToLikeQueue 메서드를 호출합니다.

&#x3C;!-- ui-station 사각형 -->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ins</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"adsbygoogle"</span>
<span class="hljs-attr">style</span>=<span class="hljs-string">"display:block"</span>
<span class="hljs-attr">data-ad-client</span>=<span class="hljs-string">"ca-pub-4877378276818686"</span>
<span class="hljs-attr">data-ad-slot</span>=<span class="hljs-string">"7249294152"</span>
<span class="hljs-attr">data-ad-format</span>=<span class="hljs-string">"auto"</span>
<span class="hljs-attr">data-full-width-responsive</span>=<span class="hljs-string">"true"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">ins</span>></span></span>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
(adsbygoogle = <span class="hljs-variable language_">window</span>.<span class="hljs-property">adsbygoogle</span> || []).<span class="hljs-title function_">push</span>({});
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span></span>

<span class="hljs-comment">// Reducer 코드</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">likedReducer</span>: <span class="hljs-title class_">Reducer</span>&#x3C;{ <span class="hljs-attr">liked</span>: boolean; <span class="hljs-attr">likeCount</span>: number }, boolean>
= <span class="hljs-function">(<span class="hljs-params">
    state,
    liked
  </span>) =></span> {
  <span class="hljs-keyword">const</span> { likeCount } = state;
  <span class="hljs-keyword">if</span> (liked === state.<span class="hljs-property">liked</span>) {
    <span class="hljs-keyword">return</span> state;
  }
  <span class="hljs-keyword">return</span> {
    liked,
    <span class="hljs-attr">likeCount</span>: liked ? likeCount + <span class="hljs-number">1</span> : likeCount - <span class="hljs-number">1</span>,
  };
};

<span class="hljs-comment">// Hook 사용하기</span>
<span class="hljs-keyword">const</span> [pushToLikeQueue] = <span class="hljs-title function_">useLikes</span>({
  <span class="hljs-attr">setLikedState</span>: dispatchLiked,
  <span class="hljs-attr">postId</span>: <span class="hljs-number">1</span>,
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">mutate</span>(<span class="hljs-params">postId, liked</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">mockedApiCall</span>(postId, liked);
  },
});

<span class="hljs-keyword">const</span> like = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =></span> {
  <span class="hljs-title function_">dispatchLiked</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 바로 UI 상태 업데이트</span>
  <span class="hljs-title function_">pushToLikeQueue</span>(<span class="hljs-string">"like"</span>); <span class="hljs-comment">// API 호출을 대기열에 추가</span>
}, [pushToLikeQueue]);

<span class="hljs-keyword">const</span> dislike = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =></span> {
  <span class="hljs-title function_">dispatchLiked</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 바로 UI 상태 업데이트</span>
  <span class="hljs-title function_">pushToLikeQueue</span>(<span class="hljs-string">"dislike"</span>); <span class="hljs-comment">// API 호출을 대기열에 추가</span>
}, [pushToLikeQueue]);

## <span class="hljs-title class_">Logic</span> 테스트

우리의 mocked <span class="hljs-variable constant_">API</span> 코드는 매 다섯 번째 시도마다 실패할 것입니다. 아래에서 라이브 데모를 확인할 수 있습니다: 왼쪽에는 <span class="hljs-variable constant_">UI</span>가 있고, 오른쪽에는 뒷단에서 무슨 일이 벌어지고 있는지가 나와 있습니다.

&#x3C;!-- ui-station 사각형 -->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ins</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"adsbygoogle"</span>
<span class="hljs-attr">style</span>=<span class="hljs-string">"display:block"</span>
<span class="hljs-attr">data-ad-client</span>=<span class="hljs-string">"ca-pub-4877378276818686"</span>
<span class="hljs-attr">data-ad-slot</span>=<span class="hljs-string">"7249294152"</span>
<span class="hljs-attr">data-ad-format</span>=<span class="hljs-string">"auto"</span>
<span class="hljs-attr">data-full-width-responsive</span>=<span class="hljs-string">"true"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">ins</span>></span></span>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
(adsbygoogle = <span class="hljs-variable language_">window</span>.<span class="hljs-property">adsbygoogle</span> || []).<span class="hljs-title function_">push</span>({});
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span></span>

# 결론

에헤! 이제 신뢰할 수 있는 좋아요 / 싫어요 메커니즘이 생겼습니다. 이 방법은 <span class="hljs-variable constant_">API</span> 호출을 최소화하고 <span class="hljs-variable constant_">UI</span>를 반응적으로 유지하며 최신 상태로 유지합니다!

이 훅을 만드는 <span class="hljs-variable constant_">PR</span>을 볼 수 있습니다.
이 앱을 데모하려면 다음 단계를 따라주세요:

- <span class="hljs-title class_">Playgrounds</span> 리포지토리를 복제하세요.
- react/use-likes-hook-demo로 이동하십시오.
- 폴더에서 npm install을 실행하십시오.
- 폴더에서 npm start를 실행하십시오.
- 앱을 사용해보세요.
</code></pre>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"큐 기반 훅으로 빠른 사용자 액션을 효율적으로 관리하는 방법 React","description":"","date":"2024-07-02 21:59","slug":"2024-07-02-EfficientlyManagingRapidFireUserActionsinReactwithaQueue-BasedHook","content":"\n\n내 React Native 기반 소셜 네트워킹 앱에서 프로필 페이지를 구축하면서 흥미로운 문제를 마주했어요:\n\n만약 사용자가 좋아요 버튼을 스팸하는 경우 API 엔드포인트 남용을 어떻게 관리할까요?\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*_KQNCttwub7NvtykSKLv3g.gif)\n\n- 사용자가 좋아요 버튼을 스팸하면 취약해집니다.\n- 버튼을 누를 때마다 API 호출이 발생하여 서버에 사용자의 작업을 알리고, 서버에서는 데이터베이스 상태를 업데이트하는 DB 호출이 이어집니다.\n- 첫눈에는 무해한 호출이라고 생각되지만 반복해서 발생할 경우 앱의 캐싱 아키텍처에 심각한 차질을 일으킬 수 있습니다. 효율적으로 관리되지 않은 경우 데이터베이스 상태 업데이트로 인해 여러 번 캐시를 몇 초 내에 여러 번 재설정해야 할 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 문제와 UI 요구 사항을 명확히 하기\n\n이 문제를 효율적으로 해결하기 위해 필요한 모든 요구 사항을 기록해 봅시다. 최종 사용자는 부드러운 UX를 필요로 하고, 서버는 최소한의 부하를 원합니다.\n\n## UX 요구 사항\n\n- '좋아요' 동작은 앱에 즉시 반영되어야 합니다. 서버의 응답이 늦게 올 경우에도, 게시물을 좋아하는 경우 하트 아이콘이 즉시 채워지고, 싫어하는 경우 비워져야 합니다.\n이는 일반적인 API 호출 흐름과는 다릅니다. 일반적으로 서버 응답을 기다리는 동안 로더를 표시하고 동작 버튼을 비활성화하는 것이 일반적이지만, 이 접근 방식을 여기서 사용하면 UX를 망치게 됩니다. 전체 경험을 느릿느릿하게 만들어 버릴 수 있습니다.\n- UI 상태는 결국 서버의 상태와 일관되어야 합니다. 즉, API 호출이 성공하지 않는 경우(사용자의 조치) 좋아요 아이콘과 좋아요 수가 표시되어야 합니다.\n- 좋아요 및 싫어요 동작은 번갈아가며 일어납니다. 따라서 서버의 5xx 응답으로 인해 API 호출 중 하나가 실패할 경우 우리는 이 사실을 우리의 이점으로 활용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 서버 요구 사항\n\n- 서버 호출은 최소화되어야 합니다.\n- 당신이 좋아하지 않은 게시물에 싫어요를 표시할 수 없습니다. 시도하면 400 BAD REQUEST 응답이 반환됩니다.\n- 당신이 이미 좋아한 게시물을 좋아할 수 없습니다. 시도하면 다시 한 번 400 BAD REQUEST 응답이 반환됩니다.\n- 서버는 요청을 처리하는 데 어려움을 겪으면 5xx 응답을 보낼 수 있습니다.\n\n# 용어\n\n더 나아가기 전에, 다음 용어의 의미를 명확하게 설명하고 싶습니다. 만약 명백하지 않다면:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 클라이언트 상태 또는 UI 상태는 사용자에게 표시되는 상태입니다. 이에는 \"좋아요\" 아이콘(좋아요 시 채워지고 좋아요 취소 시 비워짐)와 좋아요 수가 포함됩니다.\n- 서버 상태는 데이터베이스의 상태로, 우리 데이터의 실제 상태입니다.\n\n서버 상태 업데이트(API 호출)는 클라이언트 상태 업데이트(React 상태 업데이트)보다 수십 배 시간이 더 소요됩니다. \n우리의 목표는 클라이언트 상태 업데이트가 서버 상태 업데이트로 인해 느려지지 않으면서 이 두 상태를 최종적으로 조율하는 것입니다.\n\n# 가능한 해결책\n\n이 문제에 대한 전통적인 해결책에는 UI에서 디바운싱 및 함수 쓰로틀링 또는 서버에서 API의 속도 제한이 포함됩니다.\n이 큐 기반 접근 방식에서 나의 생각 프로세스는 API 호출이 수백 밀리초가 걸릴 수 있다는 사실을 활용하고 호출을 자연적인 디바운서로 사용하는 것이었습니다. API의 속도 제한도 여전히 유효합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 최종 솔루션\n\n잠재적인 해결책에 대한 심사숙고 끝에 사용자의 작업(좋아요/싫어요)을 유지하는 React 훅을 만들었습니다. pushToQueue 메서드를 노출하여 작업을 추가할 수 있게 했습니다.\n\n- 사용자 상태는 즉시 업데이트됩니다.\n서버 상태를 업데이트하는 네트워크 호출은 큐에 추가됩니다.\n- 비어 있지 않은 큐가 감지되면 앱은 처리 상태로 전환됩니다. 큐를 파싱하여 최종 작업(좋아요/싫어요)이 결정되고, 서버에 해당 작업을 알리는 API 호출이 발생합니다.\n- 이제 API 호출은 여러 밀리초가 걸릴 수 있습니다.\n사용자는 통화 중에 동일한 버튼에 추가 상호작용을 실행할 수 있습니다. 이 작업들은 나중에 처리하기 위해 큐에 추가됩니다. (다시 말해, 클라이언트 상태는 이러한 상호작용 발생 즉시 업데이트됩니다. 큐가 처리된 후에 다시 업데이트되며, 서버 상태를 반영합니다.)\n- API 호출이 완료되면 큐에 처리할 추가 항목이 있는지 확인합니다. 존재하는 경우 전체 프로세스가 반복됩니다. 그렇지 않으면 처리가 완료되고 클라이언트 상태가 그에 맞게 업데이트됩니다.\nAPI 호출에 의한 지연은 자연스러운 디바운서 역할을 합니다.\n\n수고하셨습니다. 이제 코드를 빌드해 봅시다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 구현\n\n## 앱 초기화\n\n먼저, 좋아요 아이콘과 좋아요 수를 표시하는 간단한 앱을 만들어봅시다:\n\n그 상태에는 다음이 저장됩니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 게시물이 좋아요를 받았는지 아닌지를 저장하는 부울 값\n- 좋아요 수 (숫자).\n\n```js\nconst [state, setState] = useState({\n  liked: false,\n  likeCount: 0,\n});\n```\n\n하트 아이콘과 텍스트를 사용하여 정보를 표시합니다:\n\n```js\nreturn (\n    \u003cdiv className=\"App\"\u003e\n      \u003cdiv id=\"heart_container\"\u003e\n        /*Fill the icon if liked, else no fill (transparent)*/\n        \u003cHeartIcon\n          height={96}\n          width={96}\n          stroke=\"#aaa\"\n          fill={liked ? \"rgb(207, 102, 121)\" : \"transparent\"}\n        /\u003e\n      \u003c/div\u003e\n      /* 좋아요 수를 표시 */\n      \u003cp\u003e{likeCount}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음으로, 좋아요/싫어요를 설정하는 간단한 onClick Handler를 정의합니다:\n\n- 좋아요는 boolean 값을 true로 설정하고 좋아요 수를 증가시킵니다.\n- 싫어요는 boolean 값을 false로 설정하고 좋아요 수를 감소시킵니다.\n\n```js\nconst like = useCallback(() =\u003e {\n    setState((prevState) =\u003e ({\n      liked: true,\n      likeCount: prevState.likeCount + 1,\n    }));\n  }, []);\n\n  const dislike = useCallback(() =\u003e {\n    setState((prevState) =\u003e ({\n      liked: false,\n      likeCount: prevState.likeCount - 1,\n    }));\n  }, []);\n\n  const onClick = useCallback(() =\u003e {\n    if (liked) {\n      dislike();\n    } else {\n      like();\n    }\n  }, [liked]);\n```\n\n스타일링을 조금 추가하면 앱이 이렇게 보입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로, 훅을 설정해 봅시다.\n\n## 훅 — Props\n\n우리의 훅은 다음과 같은 프롭스를 받을 것입니다:\n\n- postId: 숫자: 좋아요를 눌러야 할 게시물의 ID. 이 ID와 결합된 API 호출이 실행될 것입니다.\n- mutate(postId: number, liked: boolean, postId: number) =` Promise`boolean` :\nAPI를 호출하기 위한 책임을 지는 비동기 함수입니다. 이 함수는 응답의 상태를 부울 값으로 반환해야 합니다 (호출이 성공했는지 여부).\n모든 네트워크 호출과 마찬가지로, 오류가 발생할 수도 있습니다.\n- setLikedState: (liked: boolean) =` React.SetStateAction:\nUI 상태를 업데이트하는 함수입니다.\n- onError?: (error: Error) =` unknown: 만약 API 호출이 오류를 발생시킬 경우 실행할 콜백 함수입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## The Hook — 큐 저장하기\n\n액션의 큐를 React ref에 저장할 것입니다. 그 값들은 가능한 액션인 '좋아요' 또는 '싫어요'일 것입니다.\n\n```js\nconst queueRef = useRef\u003c(\"like\" | \"dislike\")[]\u003e([]);\n```\n\n마지막으로, 현재 큐가 처리 중인지 여부를 알려주는 상태를 저장할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nconst [processing, setProcessing] = useState(false);\n```\n\n최종 작업이 결정되고 API 호출이 이루어질 때 `processing`이 true로 설정됩니다. 큐가 비어있을 때 (처리된 경우) false로 설정됩니다.\n\n## 훅 — 큐 처리하기\n\n다음은 우리 큐의 작동 메커니즘입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 처리 상태를 True로 설정합니다.\n- 원본 큐를 변경하지 않기 위해 큐의 복사본을 만듭니다.\n- 복사본을 이용하여 최종 동작을 결정하기 위해 반복합니다 (좋아요, 싫어요 또는 아무 작업도 안 함):\n\n```js\nsetProcessing(true);\nconst initialQueueLength = queueRef.current.length;\n// 처리 중에 참조를 변경하지 않기 위한 참조의 복사본.\nconst queueCopy = [...queueRef.current];\nlet finalAction: \"like\" | \"dislike\" | \"none\" = \"none\";\nwhile (queueCopy.length) {\n    const type = queueCopy.shift();\n    if (type === \"like\") {\n      finalAction = finalAction === \"dislike\" ? \"none\" : \"like\";\n    } else {\n      finalAction = finalAction === \"like\" ? \"none\" : \"dislike\";\n    }\n}\n```\n\n이제 결정을 내려야 합니다 — API를 호출해야 할까요?\n최종 동작이 아무 작업도 안 함으로 결정된 경우 API 호출이 필요하지 않습니다. 다음을 수행합니다:\n\n- 초기 처리된 항목의 수( initialQueueLength)만큼 참조를 잘라냅니다.\n- 큐가 비어 있는지 확인합니다. 루프가 실행 중에 사용자가 좋아요 버튼을 눌렀다면 큐는 비어 있지 않을 수 있습니다.\n- 큐가 비어 있지 않으면 프로세스를 반복하고 processQueue 함수를 다시 호출합니다. 그렇지 않으면 함수를 종료합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nif (finalAction === \"none\") {\n  queueRef.current =\n    queueRef.current.slice(initialQueueLength);\n  if (queueRef.current.length \u003e 0) {\n    await processQueue();\n  }\n  setProcessing(false);\n  return;\n}\n```\n\n만일 최종 작업이 '좋아요' 또는 '좋아요 취소'인 경우, API를 호출합니다. 호출이 성공했는지 여부를 추적하는 execSuccess 변수를 유지합니다.\n\n```js\nlet execSuccess = false;\ntry {\n    execSuccess = await mutate(postId, finalAction === \"like\");\n} catch(error) {\n    execSuccess = false;\n    onError(error);\n}\n```\n\n마지막으로, 큐에 더 이상 항목이 없다면 서버 응답에 따라 UI 상태를 업데이트해야 합니다. \nAPI 호출이 실패했고 큐가 비어 있지 않으면 큐의 첫 번째 요소를 삭제할 수 있습니다. 작업은 대체로 번갈아가며 발생하기 때문입니다.\n예: 만일 '좋아요' 호출이 실패했다면 큐에 추가된 다음 작업은 '좋아요 취소'일 것입니다. 따라서 우리는 처리되기 전에 큐에 추가된 '좋아요 취소' 작업을 삭제할 수 있습니다. '좋아요' 작업이 실패하면 UI 상태에선 '좋아요 취소' 작업과 동일하기 때문입니다.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\n마지막으로, 푸시 함수를 정의할 것입니다.\n\n이 함수는 like 또는 dislike와 같은 액션을 인수로 받아서 간단히 큐에 푸시합니다.\n큐가 처리 중이 아닌 경우(처리 상태 변수가 false인 경우), processQueue 함수를 호출합니다.\n우리의 훅은 이 함수를 반환합니다.\n\nconst pushToQueue = useCallback(\n  (action: \"like\" | \"dislike\") =\u003e {\n    const newQueue = [...queueRef.current, action];\n    queueRef.current = newQueue;\n    if (!processing) processQueue();\n  },\n  [processing]\n);\n\nreturn [pushToQueue];\r\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Hook 사용 및 앱 테스트하기\n\n## API\n\n우리는 코드를 테스트하기 위해 모의 API를 사용할 것입니다. 이 API는 20%의 실패 비율을 가지며, 성공하면 true를 반환하고 그렇지 않으면 false를 반환합니다. 500ms의 인위적 지연이 발생할 것입니다.\n\nconst API_DELAY = 500;\nconst responses = [true, true, false, true, true];\nlet idx = 0;\nconst postLikeMapping = new Map\u003cnumber, boolean\u003e();\nexport const mockedApiCall = async (postId: number, liked: boolean) =\u003e {\n  // 가짜 지연\n  await new Promise((resolve) =\u003e setTimeout(resolve, API_DELAY));\n  if (!postLikeMapping.get(postId) \u0026\u0026 !liked) {\n    throw new Error(\"좋아요 표시하지 않은 게시물에 싫어요를 표시할 수 없습니다.\");\n  }\n  if (postLikeMapping.get(postId) \u0026\u0026 liked) {\n    throw new Error(\"이미 좋아요한 게시물에 또 다시 좋아요를 표시할 수 없습니다.\");\n  }\n  //   80% 성공 확률 시뮬레이션\n  if (responses[idx++ % responses.length]) {\n    postLikeMapping.set(postId, liked);\n    return true;\n  }\n  return false;\n};\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 앱은 사용자가 좋아요 또는 싫어요 버튼을 누를 때마다 이 함수를 호출합니다.\n\n## 우리 앱에서 Hook 사용\n\n마지막으로, 우리가 만든 훅을 앱에 통합합니다.\n\n- 좋아하는 상태를 React 리듀서로 변경합니다.\n- 동일한 작업이 연속적으로 호출될 때(한 번은 UI에서 즉시 호출되고 다른 한 번은 훅이 성공적인 API 호출 후 호출될 때), 리듀서는 상태를 변경하지 않습니다.\n- UI가 상태를 즉시 업데이트하지만 API 호출이 실패하여 상태가 재설정될 때 작업에 의해 상태가 업데이트됩니다.\n- Hook을 소비하고 사용자 상호작용 시 훅이 노출하는 pushToLikeQueue 메서드를 호출합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n// Reducer 코드\nconst likedReducer: Reducer\u003c{ liked: boolean; likeCount: number }, boolean\u003e\n= (\n    state,\n    liked\n  ) =\u003e {\n  const { likeCount } = state;\n  if (liked === state.liked) {\n    return state;\n  }\n  return {\n    liked,\n    likeCount: liked ? likeCount + 1 : likeCount - 1,\n  };\n};\n\n// Hook 사용하기\nconst [pushToLikeQueue] = useLikes({\n  setLikedState: dispatchLiked,\n  postId: 1,\n  async mutate(postId, liked) {\n    return await mockedApiCall(postId, liked);\n  },\n});\n\nconst like = useCallback(() =\u003e {\n  dispatchLiked(true); // 바로 UI 상태 업데이트\n  pushToLikeQueue(\"like\"); // API 호출을 대기열에 추가\n}, [pushToLikeQueue]);\n\nconst dislike = useCallback(() =\u003e {\n  dispatchLiked(false); // 바로 UI 상태 업데이트\n  pushToLikeQueue(\"dislike\"); // API 호출을 대기열에 추가\n}, [pushToLikeQueue]);\n\n## Logic 테스트\n\n우리의 mocked API 코드는 매 다섯 번째 시도마다 실패할 것입니다. 아래에서 라이브 데모를 확인할 수 있습니다: 왼쪽에는 UI가 있고, 오른쪽에는 뒷단에서 무슨 일이 벌어지고 있는지가 나와 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n에헤! 이제 신뢰할 수 있는 좋아요 / 싫어요 메커니즘이 생겼습니다. 이 방법은 API 호출을 최소화하고 UI를 반응적으로 유지하며 최신 상태로 유지합니다!\n\n이 훅을 만드는 PR을 볼 수 있습니다.\n이 앱을 데모하려면 다음 단계를 따라주세요:\n\n- Playgrounds 리포지토리를 복제하세요.\n- react/use-likes-hook-demo로 이동하십시오.\n- 폴더에서 npm install을 실행하십시오.\n- 폴더에서 npm start를 실행하십시오.\n- 앱을 사용해보세요.","ogImage":{"url":"/assets/img/2024-07-02-EfficientlyManagingRapidFireUserActionsinReactwithaQueue-BasedHook_0.png"},"coverImage":"/assets/img/2024-07-02-EfficientlyManagingRapidFireUserActionsinReactwithaQueue-BasedHook_0.png","tag":["Tech"],"readingTime":14},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e내 React Native 기반 소셜 네트워킹 앱에서 프로필 페이지를 구축하면서 흥미로운 문제를 마주했어요:\u003c/p\u003e\n\u003cp\u003e만약 사용자가 좋아요 버튼을 스팸하는 경우 API 엔드포인트 남용을 어떻게 관리할까요?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*_KQNCttwub7NvtykSKLv3g.gif\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e사용자가 좋아요 버튼을 스팸하면 취약해집니다.\u003c/li\u003e\n\u003cli\u003e버튼을 누를 때마다 API 호출이 발생하여 서버에 사용자의 작업을 알리고, 서버에서는 데이터베이스 상태를 업데이트하는 DB 호출이 이어집니다.\u003c/li\u003e\n\u003cli\u003e첫눈에는 무해한 호출이라고 생각되지만 반복해서 발생할 경우 앱의 캐싱 아키텍처에 심각한 차질을 일으킬 수 있습니다. 효율적으로 관리되지 않은 경우 데이터베이스 상태 업데이트로 인해 여러 번 캐시를 몇 초 내에 여러 번 재설정해야 할 수도 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e문제와 UI 요구 사항을 명확히 하기\u003c/h1\u003e\n\u003cp\u003e이 문제를 효율적으로 해결하기 위해 필요한 모든 요구 사항을 기록해 봅시다. 최종 사용자는 부드러운 UX를 필요로 하고, 서버는 최소한의 부하를 원합니다.\u003c/p\u003e\n\u003ch2\u003eUX 요구 사항\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e'좋아요' 동작은 앱에 즉시 반영되어야 합니다. 서버의 응답이 늦게 올 경우에도, 게시물을 좋아하는 경우 하트 아이콘이 즉시 채워지고, 싫어하는 경우 비워져야 합니다.\n이는 일반적인 API 호출 흐름과는 다릅니다. 일반적으로 서버 응답을 기다리는 동안 로더를 표시하고 동작 버튼을 비활성화하는 것이 일반적이지만, 이 접근 방식을 여기서 사용하면 UX를 망치게 됩니다. 전체 경험을 느릿느릿하게 만들어 버릴 수 있습니다.\u003c/li\u003e\n\u003cli\u003eUI 상태는 결국 서버의 상태와 일관되어야 합니다. 즉, API 호출이 성공하지 않는 경우(사용자의 조치) 좋아요 아이콘과 좋아요 수가 표시되어야 합니다.\u003c/li\u003e\n\u003cli\u003e좋아요 및 싫어요 동작은 번갈아가며 일어납니다. 따라서 서버의 5xx 응답으로 인해 API 호출 중 하나가 실패할 경우 우리는 이 사실을 우리의 이점으로 활용할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e서버 요구 사항\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e서버 호출은 최소화되어야 합니다.\u003c/li\u003e\n\u003cli\u003e당신이 좋아하지 않은 게시물에 싫어요를 표시할 수 없습니다. 시도하면 400 BAD REQUEST 응답이 반환됩니다.\u003c/li\u003e\n\u003cli\u003e당신이 이미 좋아한 게시물을 좋아할 수 없습니다. 시도하면 다시 한 번 400 BAD REQUEST 응답이 반환됩니다.\u003c/li\u003e\n\u003cli\u003e서버는 요청을 처리하는 데 어려움을 겪으면 5xx 응답을 보낼 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e용어\u003c/h1\u003e\n\u003cp\u003e더 나아가기 전에, 다음 용어의 의미를 명확하게 설명하고 싶습니다. 만약 명백하지 않다면:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e클라이언트 상태 또는 UI 상태는 사용자에게 표시되는 상태입니다. 이에는 \"좋아요\" 아이콘(좋아요 시 채워지고 좋아요 취소 시 비워짐)와 좋아요 수가 포함됩니다.\u003c/li\u003e\n\u003cli\u003e서버 상태는 데이터베이스의 상태로, 우리 데이터의 실제 상태입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e서버 상태 업데이트(API 호출)는 클라이언트 상태 업데이트(React 상태 업데이트)보다 수십 배 시간이 더 소요됩니다.\n우리의 목표는 클라이언트 상태 업데이트가 서버 상태 업데이트로 인해 느려지지 않으면서 이 두 상태를 최종적으로 조율하는 것입니다.\u003c/p\u003e\n\u003ch1\u003e가능한 해결책\u003c/h1\u003e\n\u003cp\u003e이 문제에 대한 전통적인 해결책에는 UI에서 디바운싱 및 함수 쓰로틀링 또는 서버에서 API의 속도 제한이 포함됩니다.\n이 큐 기반 접근 방식에서 나의 생각 프로세스는 API 호출이 수백 밀리초가 걸릴 수 있다는 사실을 활용하고 호출을 자연적인 디바운서로 사용하는 것이었습니다. API의 속도 제한도 여전히 유효합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e최종 솔루션\u003c/h1\u003e\n\u003cp\u003e잠재적인 해결책에 대한 심사숙고 끝에 사용자의 작업(좋아요/싫어요)을 유지하는 React 훅을 만들었습니다. pushToQueue 메서드를 노출하여 작업을 추가할 수 있게 했습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e사용자 상태는 즉시 업데이트됩니다.\n서버 상태를 업데이트하는 네트워크 호출은 큐에 추가됩니다.\u003c/li\u003e\n\u003cli\u003e비어 있지 않은 큐가 감지되면 앱은 처리 상태로 전환됩니다. 큐를 파싱하여 최종 작업(좋아요/싫어요)이 결정되고, 서버에 해당 작업을 알리는 API 호출이 발생합니다.\u003c/li\u003e\n\u003cli\u003e이제 API 호출은 여러 밀리초가 걸릴 수 있습니다.\n사용자는 통화 중에 동일한 버튼에 추가 상호작용을 실행할 수 있습니다. 이 작업들은 나중에 처리하기 위해 큐에 추가됩니다. (다시 말해, 클라이언트 상태는 이러한 상호작용 발생 즉시 업데이트됩니다. 큐가 처리된 후에 다시 업데이트되며, 서버 상태를 반영합니다.)\u003c/li\u003e\n\u003cli\u003eAPI 호출이 완료되면 큐에 처리할 추가 항목이 있는지 확인합니다. 존재하는 경우 전체 프로세스가 반복됩니다. 그렇지 않으면 처리가 완료되고 클라이언트 상태가 그에 맞게 업데이트됩니다.\nAPI 호출에 의한 지연은 자연스러운 디바운서 역할을 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e수고하셨습니다. 이제 코드를 빌드해 봅시다!\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e구현\u003c/h1\u003e\n\u003ch2\u003e앱 초기화\u003c/h2\u003e\n\u003cp\u003e먼저, 좋아요 아이콘과 좋아요 수를 표시하는 간단한 앱을 만들어봅시다:\u003c/p\u003e\n\u003cp\u003e그 상태에는 다음이 저장됩니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e게시물이 좋아요를 받았는지 아닌지를 저장하는 부울 값\u003c/li\u003e\n\u003cli\u003e좋아요 수 (숫자).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [state, setState] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eliked\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003elikeCount\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e하트 아이콘과 텍스트를 사용하여 정보를 표시합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"App\"\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"heart_container\"\u003c/span\u003e\u003e\u003c/span\u003e\n        /*Fill the icon if liked, else no fill (transparent)*/\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eHeartIcon\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{96}\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{96}\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003estroke\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"#aaa\"\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003efill\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{liked\u003c/span\u003e ? \"\u003cspan class=\"hljs-attr\"\u003ergb\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003e207\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003e102\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003e121\u003c/span\u003e)\" \u003cspan class=\"hljs-attr\"\u003e:\u003c/span\u003e \"\u003cspan class=\"hljs-attr\"\u003etransparent\u003c/span\u003e\"}\n        /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      /* 좋아요 수를 표시 */\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e{likeCount}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다음으로, 좋아요/싫어요를 설정하는 간단한 onClick Handler를 정의합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e좋아요는 boolean 값을 true로 설정하고 좋아요 수를 증가시킵니다.\u003c/li\u003e\n\u003cli\u003e싫어요는 boolean 값을 false로 설정하고 좋아요 수를 감소시킵니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e like = \u003cspan class=\"hljs-title function_\"\u003euseCallback\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003esetState\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprevState\u003c/span\u003e) =\u003e\u003c/span\u003e ({\n      \u003cspan class=\"hljs-attr\"\u003eliked\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003elikeCount\u003c/span\u003e: prevState.\u003cspan class=\"hljs-property\"\u003elikeCount\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n    }));\n  }, []);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dislike = \u003cspan class=\"hljs-title function_\"\u003euseCallback\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003esetState\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprevState\u003c/span\u003e) =\u003e\u003c/span\u003e ({\n      \u003cspan class=\"hljs-attr\"\u003eliked\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003elikeCount\u003c/span\u003e: prevState.\u003cspan class=\"hljs-property\"\u003elikeCount\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n    }));\n  }, []);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e onClick = \u003cspan class=\"hljs-title function_\"\u003euseCallback\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (liked) {\n      \u003cspan class=\"hljs-title function_\"\u003edislike\u003c/span\u003e();\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-title function_\"\u003elike\u003c/span\u003e();\n    }\n  }, [liked]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e스타일링을 조금 추가하면 앱이 이렇게 보입니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e마지막으로, 훅을 설정해 봅시다.\u003c/p\u003e\n\u003ch2\u003e훅 — Props\u003c/h2\u003e\n\u003cp\u003e우리의 훅은 다음과 같은 프롭스를 받을 것입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003epostId: 숫자: 좋아요를 눌러야 할 게시물의 ID. 이 ID와 결합된 API 호출이 실행될 것입니다.\u003c/li\u003e\n\u003cli\u003emutate(postId: number, liked: boolean, postId: number) =\u003ccode\u003e Promise\u003c/code\u003eboolean` :\nAPI를 호출하기 위한 책임을 지는 비동기 함수입니다. 이 함수는 응답의 상태를 부울 값으로 반환해야 합니다 (호출이 성공했는지 여부).\n모든 네트워크 호출과 마찬가지로, 오류가 발생할 수도 있습니다.\u003c/li\u003e\n\u003cli\u003esetLikedState: (liked: boolean) =` React.SetStateAction:\nUI 상태를 업데이트하는 함수입니다.\u003c/li\u003e\n\u003cli\u003eonError?: (error: Error) =` unknown: 만약 API 호출이 오류를 발생시킬 경우 실행할 콜백 함수입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003eThe Hook — 큐 저장하기\u003c/h2\u003e\n\u003cp\u003e액션의 큐를 React ref에 저장할 것입니다. 그 값들은 가능한 액션인 '좋아요' 또는 '싫어요'일 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e queueRef = useRef\u0026#x3C;(\u003cspan class=\"hljs-string\"\u003e\"like\"\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e\"dislike\"\u003c/span\u003e)[]\u003e([]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막으로, 현재 큐가 처리 중인지 여부를 알려주는 상태를 저장할 것입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [processing, setProcessing] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e최종 작업이 결정되고 API 호출이 이루어질 때 \u003ccode\u003eprocessing\u003c/code\u003e이 true로 설정됩니다. 큐가 비어있을 때 (처리된 경우) false로 설정됩니다.\u003c/p\u003e\n\u003ch2\u003e훅 — 큐 처리하기\u003c/h2\u003e\n\u003cp\u003e다음은 우리 큐의 작동 메커니즘입니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e처리 상태를 True로 설정합니다.\u003c/li\u003e\n\u003cli\u003e원본 큐를 변경하지 않기 위해 큐의 복사본을 만듭니다.\u003c/li\u003e\n\u003cli\u003e복사본을 이용하여 최종 동작을 결정하기 위해 반복합니다 (좋아요, 싫어요 또는 아무 작업도 안 함):\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003esetProcessing\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e initialQueueLength = queueRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 처리 중에 참조를 변경하지 않기 위한 참조의 복사본.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e queueCopy = [...queueRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efinalAction\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"like\"\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e\"dislike\"\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e\"none\"\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"none\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (queueCopy.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e type = queueCopy.\u003cspan class=\"hljs-title function_\"\u003eshift\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (type === \u003cspan class=\"hljs-string\"\u003e\"like\"\u003c/span\u003e) {\n      finalAction = finalAction === \u003cspan class=\"hljs-string\"\u003e\"dislike\"\u003c/span\u003e ? \u003cspan class=\"hljs-string\"\u003e\"none\"\u003c/span\u003e : \u003cspan class=\"hljs-string\"\u003e\"like\"\u003c/span\u003e;\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      finalAction = finalAction === \u003cspan class=\"hljs-string\"\u003e\"like\"\u003c/span\u003e ? \u003cspan class=\"hljs-string\"\u003e\"none\"\u003c/span\u003e : \u003cspan class=\"hljs-string\"\u003e\"dislike\"\u003c/span\u003e;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 결정을 내려야 합니다 — API를 호출해야 할까요?\n최종 동작이 아무 작업도 안 함으로 결정된 경우 API 호출이 필요하지 않습니다. 다음을 수행합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e초기 처리된 항목의 수( initialQueueLength)만큼 참조를 잘라냅니다.\u003c/li\u003e\n\u003cli\u003e큐가 비어 있는지 확인합니다. 루프가 실행 중에 사용자가 좋아요 버튼을 눌렀다면 큐는 비어 있지 않을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e큐가 비어 있지 않으면 프로세스를 반복하고 processQueue 함수를 다시 호출합니다. 그렇지 않으면 함수를 종료합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (finalAction === \u003cspan class=\"hljs-string\"\u003e\"none\"\u003c/span\u003e) {\n  queueRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e =\n    queueRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eslice\u003c/span\u003e(initialQueueLength);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (queueRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e \u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprocessQueue\u003c/span\u003e();\n  }\n  \u003cspan class=\"hljs-title function_\"\u003esetProcessing\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만일 최종 작업이 '좋아요' 또는 '좋아요 취소'인 경우, API를 호출합니다. 호출이 성공했는지 여부를 추적하는 execSuccess 변수를 유지합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e execSuccess = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n    execSuccess = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emutate\u003c/span\u003e(postId, finalAction === \u003cspan class=\"hljs-string\"\u003e\"like\"\u003c/span\u003e);\n} \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e(error) {\n    execSuccess = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    \u003cspan class=\"hljs-title function_\"\u003eonError\u003c/span\u003e(error);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막으로, 큐에 더 이상 항목이 없다면 서버 응답에 따라 UI 상태를 업데이트해야 합니다.\nAPI 호출이 실패했고 큐가 비어 있지 않으면 큐의 첫 번째 요소를 삭제할 수 있습니다. 작업은 대체로 번갈아가며 발생하기 때문입니다.\n예: 만일 '좋아요' 호출이 실패했다면 큐에 추가된 다음 작업은 '좋아요 취소'일 것입니다. 따라서 우리는 처리되기 전에 큐에 추가된 '좋아요 취소' 작업을 삭제할 수 있습니다. '좋아요' 작업이 실패하면 UI 상태에선 '좋아요 취소' 작업과 동일하기 때문입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e마지막으로, 푸시 함수를 정의할 것입니다.\n\n이 함수는 like 또는 dislike와 같은 액션을 인수로 받아서 간단히 큐에 푸시합니다.\n큐가 처리 중이 아닌 경우(처리 상태 변수가 \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e인 경우), processQueue 함수를 호출합니다.\n우리의 훅은 이 함수를 반환합니다.\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e pushToQueue = \u003cspan class=\"hljs-title function_\"\u003euseCallback\u003c/span\u003e(\n  \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eaction: \u003cspan class=\"hljs-string\"\u003e\"like\"\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e\"dislike\"\u003c/span\u003e\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newQueue = [...queueRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e, action];\n    queueRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e = newQueue;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!processing) \u003cspan class=\"hljs-title function_\"\u003eprocessQueue\u003c/span\u003e();\n  },\n  [processing]\n);\n\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [pushToQueue];\r\n\n\u0026#x3C;!-- ui-station 사각형 --\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"adsbygoogle\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"display:block\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-client\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ca-pub-4877378276818686\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-slot\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"7249294152\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-format\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"auto\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-full-width-responsive\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"true\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"javascript\"\u003e\n(adsbygoogle = \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eadsbygoogle\u003c/span\u003e || []).\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e({});\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n# \u003cspan class=\"hljs-title class_\"\u003eHook\u003c/span\u003e 사용 및 앱 테스트하기\n\n## \u003cspan class=\"hljs-variable constant_\"\u003eAPI\u003c/span\u003e\n\n우리는 코드를 테스트하기 위해 모의 \u003cspan class=\"hljs-variable constant_\"\u003eAPI\u003c/span\u003e를 사용할 것입니다. 이 \u003cspan class=\"hljs-variable constant_\"\u003eAPI\u003c/span\u003e는 \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e%의 실패 비율을 가지며, 성공하면 \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e를 반환하고 그렇지 않으면 \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e를 반환합니다. 500ms의 인위적 지연이 발생할 것입니다.\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAPI_DELAY\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e responses = [\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e idx = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e postLikeMapping = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMap\u003c/span\u003e\u0026#x3C;number, boolean\u003e();\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emockedApiCall\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003epostId: number, liked: boolean\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 가짜 지연\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(resolve, \u003cspan class=\"hljs-variable constant_\"\u003eAPI_DELAY\u003c/span\u003e));\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!postLikeMapping.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(postId) \u0026#x26;\u0026#x26; !liked) {\n    \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"좋아요 표시하지 않은 게시물에 싫어요를 표시할 수 없습니다.\"\u003c/span\u003e);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (postLikeMapping.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(postId) \u0026#x26;\u0026#x26; liked) {\n    \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이미 좋아요한 게시물에 또 다시 좋아요를 표시할 수 없습니다.\"\u003c/span\u003e);\n  }\n  \u003cspan class=\"hljs-comment\"\u003e//   80% 성공 확률 시뮬레이션\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (responses[idx++ % responses.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e]) {\n    postLikeMapping.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(postId, liked);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n};\n\n\u0026#x3C;!-- ui-station 사각형 --\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"adsbygoogle\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"display:block\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-client\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ca-pub-4877378276818686\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-slot\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"7249294152\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-format\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"auto\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-full-width-responsive\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"true\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"javascript\"\u003e\n(adsbygoogle = \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eadsbygoogle\u003c/span\u003e || []).\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e({});\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n우리 앱은 사용자가 좋아요 또는 싫어요 버튼을 누를 때마다 이 함수를 호출합니다.\n\n## 우리 앱에서 \u003cspan class=\"hljs-title class_\"\u003eHook\u003c/span\u003e 사용\n\n마지막으로, 우리가 만든 훅을 앱에 통합합니다.\n\n- 좋아하는 상태를 \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e 리듀서로 변경합니다.\n- 동일한 작업이 연속적으로 호출될 때(한 번은 \u003cspan class=\"hljs-variable constant_\"\u003eUI\u003c/span\u003e에서 즉시 호출되고 다른 한 번은 훅이 성공적인 \u003cspan class=\"hljs-variable constant_\"\u003eAPI\u003c/span\u003e 호출 후 호출될 때), 리듀서는 상태를 변경하지 않습니다.\n- \u003cspan class=\"hljs-variable constant_\"\u003eUI\u003c/span\u003e가 상태를 즉시 업데이트하지만 \u003cspan class=\"hljs-variable constant_\"\u003eAPI\u003c/span\u003e 호출이 실패하여 상태가 재설정될 때 작업에 의해 상태가 업데이트됩니다.\n- \u003cspan class=\"hljs-title class_\"\u003eHook\u003c/span\u003e을 소비하고 사용자 상호작용 시 훅이 노출하는 pushToLikeQueue 메서드를 호출합니다.\n\n\u0026#x3C;!-- ui-station 사각형 --\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"adsbygoogle\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"display:block\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-client\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ca-pub-4877378276818686\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-slot\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"7249294152\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-format\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"auto\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-full-width-responsive\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"true\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"javascript\"\u003e\n(adsbygoogle = \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eadsbygoogle\u003c/span\u003e || []).\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e({});\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// Reducer 코드\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003elikedReducer\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eReducer\u003c/span\u003e\u0026#x3C;{ \u003cspan class=\"hljs-attr\"\u003eliked\u003c/span\u003e: boolean; \u003cspan class=\"hljs-attr\"\u003elikeCount\u003c/span\u003e: number }, boolean\u003e\n= \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e\n    state,\n    liked\n  \u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { likeCount } = state;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (liked === state.\u003cspan class=\"hljs-property\"\u003eliked\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e state;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    liked,\n    \u003cspan class=\"hljs-attr\"\u003elikeCount\u003c/span\u003e: liked ? likeCount + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e : likeCount - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n  };\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// Hook 사용하기\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [pushToLikeQueue] = \u003cspan class=\"hljs-title function_\"\u003euseLikes\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003esetLikedState\u003c/span\u003e: dispatchLiked,\n  \u003cspan class=\"hljs-attr\"\u003epostId\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emutate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003epostId, liked\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emockedApiCall\u003c/span\u003e(postId, liked);\n  },\n});\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e like = \u003cspan class=\"hljs-title function_\"\u003euseCallback\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003edispatchLiked\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 바로 UI 상태 업데이트\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003epushToLikeQueue\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"like\"\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// API 호출을 대기열에 추가\u003c/span\u003e\n}, [pushToLikeQueue]);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dislike = \u003cspan class=\"hljs-title function_\"\u003euseCallback\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003edispatchLiked\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 바로 UI 상태 업데이트\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003epushToLikeQueue\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"dislike\"\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// API 호출을 대기열에 추가\u003c/span\u003e\n}, [pushToLikeQueue]);\n\n## \u003cspan class=\"hljs-title class_\"\u003eLogic\u003c/span\u003e 테스트\n\n우리의 mocked \u003cspan class=\"hljs-variable constant_\"\u003eAPI\u003c/span\u003e 코드는 매 다섯 번째 시도마다 실패할 것입니다. 아래에서 라이브 데모를 확인할 수 있습니다: 왼쪽에는 \u003cspan class=\"hljs-variable constant_\"\u003eUI\u003c/span\u003e가 있고, 오른쪽에는 뒷단에서 무슨 일이 벌어지고 있는지가 나와 있습니다.\n\n\u0026#x3C;!-- ui-station 사각형 --\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"adsbygoogle\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"display:block\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-client\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ca-pub-4877378276818686\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-slot\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"7249294152\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-format\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"auto\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-full-width-responsive\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"true\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"javascript\"\u003e\n(adsbygoogle = \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eadsbygoogle\u003c/span\u003e || []).\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e({});\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n# 결론\n\n에헤! 이제 신뢰할 수 있는 좋아요 / 싫어요 메커니즘이 생겼습니다. 이 방법은 \u003cspan class=\"hljs-variable constant_\"\u003eAPI\u003c/span\u003e 호출을 최소화하고 \u003cspan class=\"hljs-variable constant_\"\u003eUI\u003c/span\u003e를 반응적으로 유지하며 최신 상태로 유지합니다!\n\n이 훅을 만드는 \u003cspan class=\"hljs-variable constant_\"\u003ePR\u003c/span\u003e을 볼 수 있습니다.\n이 앱을 데모하려면 다음 단계를 따라주세요:\n\n- \u003cspan class=\"hljs-title class_\"\u003ePlaygrounds\u003c/span\u003e 리포지토리를 복제하세요.\n- react/use-likes-hook-demo로 이동하십시오.\n- 폴더에서 npm install을 실행하십시오.\n- 폴더에서 npm start를 실행하십시오.\n- 앱을 사용해보세요.\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-02-EfficientlyManagingRapidFireUserActionsinReactwithaQueue-BasedHook"},"buildId":"JlBEgQDLGRx6DYlBnT8eD","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>