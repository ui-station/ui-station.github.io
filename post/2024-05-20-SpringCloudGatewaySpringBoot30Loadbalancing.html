<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>스프링 클라우드 게이트웨이  스프링 부트 30  로드 밸런싱 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="스프링 클라우드 게이트웨이  스프링 부트 30  로드 밸런싱 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="스프링 클라우드 게이트웨이  스프링 부트 30  로드 밸런싱 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing" data-gatsby-head="true"/><meta name="twitter:title" content="스프링 클라우드 게이트웨이  스프링 부트 30  로드 밸런싱 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-20 15:39" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/RZIEBQ2aNAp_DXFVTV6eL/_buildManifest.js" defer=""></script><script src="/_next/static/RZIEBQ2aNAp_DXFVTV6eL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">스프링 클라우드 게이트웨이  스프링 부트 30  로드 밸런싱</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="스프링 클라우드 게이트웨이  스프링 부트 30  로드 밸런싱" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 20, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_0.png" alt="Spring Cloud Gateway"></p>
<p>Spring Cloud Gateway는 Spring Boot 애플리케이션에서 API 게이트웨이를 구축하는 강력하고 유연한 솔루션을 제공합니다. 다양한 기능을 갖춘 Spring Cloud Gateway는 라우팅, 요금 제한, 보안 및 장애 관리를 처리할 수 있습니다.</p>
<p><img src="/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_1.png" alt="Spring Cloud Gateway"></p>
<p>마이크로서비스 아키텍처 시대에는 견고하고 확장 가능한 시스템 구축이 중요합니다. Spring Boot와 Spring Cloud의 발전으로 개발자들은 이전 Netflix Zuul에 의존하지 않고도 견고한 마이크로서비스 기반 애플리케이션을 생성할 수 있는 강력한 도구를 사용할 수 있습니다. 이 블로그 포스트에서는 Spring Boot 3.0과 함께 Spring Cloud Gateway를 사용하여 현대적인 마이크로서비스 아키텍처를 어떻게 만들 수 있는지 살펴보겠습니다.</p>
<p>Spring Boot이 계속 발전함에 따라 더 최신 기술과 모범 사례에 적응하는 것이 중요합니다. Spring Boot 3.0에서는 마이크로서비스를 구축하기 위한 현대적인 솔루션에 중점을 두고 있습니다. Spring WebFlux 기반으로 구축된 강력한 API 게이트웨이인 Spring Cloud Gateway가 그러한 솔루션 중 하나로, 라우팅, 필터링, 로드 밸런싱과 같은 기능을 제공합니다.</p>
<p>게이트웨이를 설명하기 위해 적합한 아키텍처가 필요합니다.</p>
<ul>
<li>Eureka 서버: 마이크로서비스를 관리하기 위한 서비스 레지스트리 및 디스커버리 서버입니다. Eureka 서버와 함께 스프링 부트 프로젝트를 생성하세요.</li>
<li>Payment MS: 테스트를 위한 사용자 정의 마이크로서비스로, 웹 및 Eureka 클라이언트 종속성 및 설정이 있는 간단한 마이크로서비스입니다.</li>
<li>Spring Cloud Gateway: 적절한 마이크로서비스로 요청을 라우팅하는 API 게이트웨이입니다.</li>
</ul>
<p>아래 종속성을 가진 Spring Boot 애플리케이션을 만들어 보세요. Eureka는 서비스 디스커버리 서버로 사용될 것입니다.</p>
<p>의존성 테이블을 다음과 같이 변경해보세요:</p>
<ul>
<li>@EnableEurekaServer 주석을 사용하여 주 클래스에 Eureka 서버를 활성화하세요.</li>
</ul>
<pre><code class="hljs language-java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableEurekaServer</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyEurekaServerApplication</span> {
</code></pre>
<pre><code class="hljs language-java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
  SpringApplication.run(MyEurekaServerApplication.class, args);
 }
}
</code></pre>
<p>그리고 My application.properties 파일에도 변경을 적용해주세요.</p>
<pre><code class="hljs language-bash">// application.properties
eureka.client.fetch-registry=<span class="hljs-literal">false</span>
eureka.client.register-with-eureka=<span class="hljs-literal">false</span>
server.port=8761
spring.application.name=MY-EUREKA-SERVER
</code></pre>
<p>아래 종속성을 사용하여 Spring Boot 어플리케이션을 생성하세요.</p>
<pre><code class="hljs language-js">&#x3C;dependency>
   <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">groupId</span>></span>org.springframework.boot<span class="hljs-tag">&#x3C;/<span class="hljs-name">groupId</span>></span></span>
   <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">artifactId</span>></span>spring-boot-starter-web<span class="hljs-tag">&#x3C;/<span class="hljs-name">artifactId</span>></span></span>
&#x3C;/dependency>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">dependency</span>></span>
   <span class="hljs-tag">&#x3C;<span class="hljs-name">groupId</span>></span>org.springframework.cloud<span class="hljs-tag">&#x3C;/<span class="hljs-name">groupId</span>></span>
   <span class="hljs-tag">&#x3C;<span class="hljs-name">artifactId</span>></span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&#x3C;/<span class="hljs-name">artifactId</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">dependency</span>></span></span>
</code></pre>
<pre><code class="hljs language-js">&#x3C;dependency>
   <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">groupId</span>></span>org.springframework.boot<span class="hljs-tag">&#x3C;/<span class="hljs-name">groupId</span>></span></span>
   <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">artifactId</span>></span>spring-boot-starter-test<span class="hljs-tag">&#x3C;/<span class="hljs-name">artifactId</span>></span></span>
   <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">scope</span>></span>test<span class="hljs-tag">&#x3C;/<span class="hljs-name">scope</span>></span></span>
&#x3C;/dependency>
</code></pre>
<p>서버 포트를 출력하는 REST API를 작성해보세요. 이것은 테스트 중에 호출된 서비스의 어떤 인스턴스인지 식별하는 데 도움이 될 것입니다 [로드 밸런싱]</p>
<pre><code class="hljs language-java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping("/payment")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PayController</span> {
</code></pre>
<pre><code class="hljs language-java"><span class="hljs-meta">@Value("${server.port}")</span>
<span class="hljs-keyword">private</span> String serverPort;
    
<span class="hljs-meta">@GetMapping("/say")</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMethodName</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"안녕하세요, Payment MS에서 온 메시지입니다. "</span>+serverPort);
}
</code></pre>
<p>그리고 Eureka 서버 세부 정보를 추가하고 메인 클래스에 Eureka 클라이언트를 활성화하는 주석을 추가하는 것을 잊지 마세요 (@EnableDiscoveryClient)</p>
<pre><code class="hljs language-java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableDiscoveryClient</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentMsApplication</span> {
 
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
  SpringApplication.run(PaymentMsApplication.class, args);
 }
}
</code></pre>
<ul>
<li>그리고 나의 MS를 위한 어플리케이션 프로퍼티</li>
</ul>
<pre><code class="hljs language-java">spring.application.name=PAYMENT-SERVICE
eureka.client.service-url.defaultZone=http:<span class="hljs-comment">//localhost:8761/eureka</span>
server.port=<span class="hljs-number">9811</span> (어플리케이션을 실행하기 전에 다른 포트를 사용 중입니다)
eureka.instance.ip-address=localhost
</code></pre>
<pre><code class="hljs language-md"><span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">dependency</span>></span></span>
   <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">groupId</span>></span></span>org.springframework.cloud<span class="xml"><span class="hljs-tag">&#x3C;/<span class="hljs-name">groupId</span>></span></span>
   <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">artifactId</span>></span></span>spring-cloud-starter-netflix-eureka-client<span class="xml"><span class="hljs-tag">&#x3C;/<span class="hljs-name">artifactId</span>></span></span>
<span class="xml"><span class="hljs-tag">&#x3C;/<span class="hljs-name">dependency</span>></span></span>
</code></pre>
<pre><code class="hljs language-md">&#x3C;!--
https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-gateway -->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">dependency</span>></span></span>
   <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">groupId</span>></span></span>org.springframework.cloud<span class="xml"><span class="hljs-tag">&#x3C;/<span class="hljs-name">groupId</span>></span></span>
   <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">artifactId</span>></span></span>spring-cloud-starter-gateway<span class="xml"><span class="hljs-tag">&#x3C;/<span class="hljs-name">artifactId</span>></span></span>
   <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">version</span>></span></span>4.1.2<span class="xml"><span class="hljs-tag">&#x3C;/<span class="hljs-name">version</span>></span></span>
<span class="xml"><span class="hljs-tag">&#x3C;/<span class="hljs-name">dependency</span>></span></span>
</code></pre>
<p>그래서 최신 버전(내 경우 3.2.4v)의 스프링 부트 프로젝트를 만들고 위의 종속성을 추가합니다.</p>
<ul>
<li>application.yml 파일에 라우팅 구성을 추가하십시오. <code>service-name</code> 프로토콜을 사용하여 API 게이트웨이에 서비스 검색을 지시합니다. 두 개의 payment-service 인스턴스가 있으므로 부하 처리가 필요하고 동적으로 처리해야 합니다.</li>
</ul>
<pre><code class="hljs language-yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">payment-service</span>
          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://payment-service</span>
          <span class="hljs-attr">predicates:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/payment/**</span>
</code></pre>
<ul>
<li>API Gateway는 마이크로서비스로도 불리우며 유레카 서버에 등록되어야 합니다. 메인 클래스에 <code>@EnableDiscoveryClient</code>를 추가하지 않는 것을 잊지 마세요.</li>
</ul>
<pre><code class="hljs language-java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableDiscoveryClient</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiGtApplication</span> {
</code></pre>
<pre><code class="hljs language-java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
  SpringApplication.run(ApiGtApplication.class, args);
 }
}
</code></pre>
<h1>지금 테스트해 보세요!</h1>
<p>진행 방법:</p>
<ul>
<li>유레카 서버 실행</li>
<li>포트 9810 및 9811에서 결제 서비스 실행</li>
<li>API 게이트웨이 서비스 실행</li>
</ul>
<p><img src="/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_2.png" alt="이미지"></p>
<p>브라우저에서 게이트웨이 엔드포인트를 방문해서 확인해보세요 (<a href="http://localhost:8080/payment/say" rel="nofollow" target="_blank">http://localhost:8080/payment/say</a>)</p>
<p>/payment은 술어 패턴입니다 — 이 패턴이 발생하면 API 게이트웨이는 요청을 지불 서비스로 라우팅하고 지불 서비스에는 컨트롤러 /payment과 GET 메소드 /say가 있습니다. 이것이 실행되어 응답을 게이트웨이로 반환합니다. 유레카는 API 게이트웨이로 인스턴스 정보를 보내기 위한 것이며 내부 통신을 위한 것이 아닙니다.</p>
<p>독자 여러분의 읽어주셔서 감사합니다. 도움이 되었다면 공유하고 좋아요를 눌러주세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"스프링 클라우드 게이트웨이  스프링 부트 30  로드 밸런싱","description":"","date":"2024-05-20 15:39","slug":"2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing","content":"\n\n\n![Spring Cloud Gateway](/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_0.png)\n\nSpring Cloud Gateway는 Spring Boot 애플리케이션에서 API 게이트웨이를 구축하는 강력하고 유연한 솔루션을 제공합니다. 다양한 기능을 갖춘 Spring Cloud Gateway는 라우팅, 요금 제한, 보안 및 장애 관리를 처리할 수 있습니다.\n\n![Spring Cloud Gateway](/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_1.png)\n\n마이크로서비스 아키텍처 시대에는 견고하고 확장 가능한 시스템 구축이 중요합니다. Spring Boot와 Spring Cloud의 발전으로 개발자들은 이전 Netflix Zuul에 의존하지 않고도 견고한 마이크로서비스 기반 애플리케이션을 생성할 수 있는 강력한 도구를 사용할 수 있습니다. 이 블로그 포스트에서는 Spring Boot 3.0과 함께 Spring Cloud Gateway를 사용하여 현대적인 마이크로서비스 아키텍처를 어떻게 만들 수 있는지 살펴보겠습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSpring Boot이 계속 발전함에 따라 더 최신 기술과 모범 사례에 적응하는 것이 중요합니다. Spring Boot 3.0에서는 마이크로서비스를 구축하기 위한 현대적인 솔루션에 중점을 두고 있습니다. Spring WebFlux 기반으로 구축된 강력한 API 게이트웨이인 Spring Cloud Gateway가 그러한 솔루션 중 하나로, 라우팅, 필터링, 로드 밸런싱과 같은 기능을 제공합니다.\n\n게이트웨이를 설명하기 위해 적합한 아키텍처가 필요합니다.\n\n- Eureka 서버: 마이크로서비스를 관리하기 위한 서비스 레지스트리 및 디스커버리 서버입니다. Eureka 서버와 함께 스프링 부트 프로젝트를 생성하세요.\n- Payment MS: 테스트를 위한 사용자 정의 마이크로서비스로, 웹 및 Eureka 클라이언트 종속성 및 설정이 있는 간단한 마이크로서비스입니다.\n- Spring Cloud Gateway: 적절한 마이크로서비스로 요청을 라우팅하는 API 게이트웨이입니다.\n\n아래 종속성을 가진 Spring Boot 애플리케이션을 만들어 보세요. Eureka는 서비스 디스커버리 서버로 사용될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n의존성 테이블을 다음과 같이 변경해보세요:\n\n\n\u003cdependency\u003e\n    \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e\n    \u003cartifactId\u003espring-cloud-starter-netflix-eureka-server\u003c/artifactId\u003e\n\u003c/dependency\u003e\n\n\n- @EnableEurekaServer 주석을 사용하여 주 클래스에 Eureka 서버를 활성화하세요.\n\n```java\n@SpringBootApplication\n@EnableEurekaServer\npublic class MyEurekaServerApplication {\n```\n\n```java\n public static void main(String[] args) {\n  SpringApplication.run(MyEurekaServerApplication.class, args);\n }\n}\n```\n\n그리고 My application.properties 파일에도 변경을 적용해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\n// application.properties\neureka.client.fetch-registry=false\neureka.client.register-with-eureka=false\nserver.port=8761\nspring.application.name=MY-EUREKA-SERVER\n```\n\n아래 종속성을 사용하여 Spring Boot 어플리케이션을 생성하세요.\n\n```js\n\u003cdependency\u003e\n   \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\n   \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e\n\u003c/dependency\u003e\n\u003cdependency\u003e\n   \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e\n   \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e\n\u003c/dependency\u003e\n```\n\n```js\n\u003cdependency\u003e\n   \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\n   \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e\n   \u003cscope\u003etest\u003c/scope\u003e\n\u003c/dependency\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서버 포트를 출력하는 REST API를 작성해보세요. 이것은 테스트 중에 호출된 서비스의 어떤 인스턴스인지 식별하는 데 도움이 될 것입니다 [로드 밸런싱]\n\n```java\n@RestController\n@RequestMapping(\"/payment\")\npublic class PayController {\n```\n\n```java\n@Value(\"${server.port}\")\nprivate String serverPort;\n    \n@GetMapping(\"/say\")\npublic String getMethodName() {\n    return new String(\"안녕하세요, Payment MS에서 온 메시지입니다. \"+serverPort);\n}\n```\n\n그리고 Eureka 서버 세부 정보를 추가하고 메인 클래스에 Eureka 클라이언트를 활성화하는 주석을 추가하는 것을 잊지 마세요 (@EnableDiscoveryClient)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class PaymentMsApplication {\n \n public static void main(String[] args) {\n  SpringApplication.run(PaymentMsApplication.class, args);\n }\n}\n```\n\n- 그리고 나의 MS를 위한 어플리케이션 프로퍼티\n\n```java\nspring.application.name=PAYMENT-SERVICE\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\nserver.port=9811 (어플리케이션을 실행하기 전에 다른 포트를 사용 중입니다)\neureka.instance.ip-address=localhost\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```md\n\u003cdependency\u003e\n   \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e\n   \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e\n\u003c/dependency\u003e\n```\n\n```md\n\u003c!--\nhttps://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-gateway --\u003e\n\u003cdependency\u003e\n   \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e\n   \u003cartifactId\u003espring-cloud-starter-gateway\u003c/artifactId\u003e\n   \u003cversion\u003e4.1.2\u003c/version\u003e\n\u003c/dependency\u003e\n```\n\n그래서 최신 버전(내 경우 3.2.4v)의 스프링 부트 프로젝트를 만들고 위의 종속성을 추가합니다.\n\n- application.yml 파일에 라우팅 구성을 추가하십시오. `service-name` 프로토콜을 사용하여 API 게이트웨이에 서비스 검색을 지시합니다. 두 개의 payment-service 인스턴스가 있으므로 부하 처리가 필요하고 동적으로 처리해야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\nspring:\n  application:\n    name: gateway\n  cloud:\n    gateway:\n      routes:\n        - id: payment-service\n          uri: lb://payment-service\n          predicates:\n            - Path=/payment/**\n```\n\n- API Gateway는 마이크로서비스로도 불리우며 유레카 서버에 등록되어야 합니다. 메인 클래스에 `@EnableDiscoveryClient`를 추가하지 않는 것을 잊지 마세요.\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class ApiGtApplication {\n```\n\n```java\n public static void main(String[] args) {\n  SpringApplication.run(ApiGtApplication.class, args);\n }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 지금 테스트해 보세요!\n\n진행 방법:\n\n- 유레카 서버 실행\n- 포트 9810 및 9811에서 결제 서비스 실행\n- API 게이트웨이 서비스 실행\n\n![이미지](/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n브라우저에서 게이트웨이 엔드포인트를 방문해서 확인해보세요 (http://localhost:8080/payment/say) \n\n/payment은 술어 패턴입니다 — 이 패턴이 발생하면 API 게이트웨이는 요청을 지불 서비스로 라우팅하고 지불 서비스에는 컨트롤러 /payment과 GET 메소드 /say가 있습니다. 이것이 실행되어 응답을 게이트웨이로 반환합니다. 유레카는 API 게이트웨이로 인스턴스 정보를 보내기 위한 것이며 내부 통신을 위한 것이 아닙니다.\n\n독자 여러분의 읽어주셔서 감사합니다. 도움이 되었다면 공유하고 좋아요를 눌러주세요.","ogImage":{"url":"/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_0.png"},"coverImage":"/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_0.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_0.png\" alt=\"Spring Cloud Gateway\"\u003e\u003c/p\u003e\n\u003cp\u003eSpring Cloud Gateway는 Spring Boot 애플리케이션에서 API 게이트웨이를 구축하는 강력하고 유연한 솔루션을 제공합니다. 다양한 기능을 갖춘 Spring Cloud Gateway는 라우팅, 요금 제한, 보안 및 장애 관리를 처리할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_1.png\" alt=\"Spring Cloud Gateway\"\u003e\u003c/p\u003e\n\u003cp\u003e마이크로서비스 아키텍처 시대에는 견고하고 확장 가능한 시스템 구축이 중요합니다. Spring Boot와 Spring Cloud의 발전으로 개발자들은 이전 Netflix Zuul에 의존하지 않고도 견고한 마이크로서비스 기반 애플리케이션을 생성할 수 있는 강력한 도구를 사용할 수 있습니다. 이 블로그 포스트에서는 Spring Boot 3.0과 함께 Spring Cloud Gateway를 사용하여 현대적인 마이크로서비스 아키텍처를 어떻게 만들 수 있는지 살펴보겠습니다.\u003c/p\u003e\n\u003cp\u003eSpring Boot이 계속 발전함에 따라 더 최신 기술과 모범 사례에 적응하는 것이 중요합니다. Spring Boot 3.0에서는 마이크로서비스를 구축하기 위한 현대적인 솔루션에 중점을 두고 있습니다. Spring WebFlux 기반으로 구축된 강력한 API 게이트웨이인 Spring Cloud Gateway가 그러한 솔루션 중 하나로, 라우팅, 필터링, 로드 밸런싱과 같은 기능을 제공합니다.\u003c/p\u003e\n\u003cp\u003e게이트웨이를 설명하기 위해 적합한 아키텍처가 필요합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eEureka 서버: 마이크로서비스를 관리하기 위한 서비스 레지스트리 및 디스커버리 서버입니다. Eureka 서버와 함께 스프링 부트 프로젝트를 생성하세요.\u003c/li\u003e\n\u003cli\u003ePayment MS: 테스트를 위한 사용자 정의 마이크로서비스로, 웹 및 Eureka 클라이언트 종속성 및 설정이 있는 간단한 마이크로서비스입니다.\u003c/li\u003e\n\u003cli\u003eSpring Cloud Gateway: 적절한 마이크로서비스로 요청을 라우팅하는 API 게이트웨이입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e아래 종속성을 가진 Spring Boot 애플리케이션을 만들어 보세요. Eureka는 서비스 디스커버리 서버로 사용될 것입니다.\u003c/p\u003e\n\u003cp\u003e의존성 테이블을 다음과 같이 변경해보세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e@EnableEurekaServer 주석을 사용하여 주 클래스에 Eureka 서버를 활성화하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-meta\"\u003e@SpringBootApplication\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@EnableEurekaServer\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyEurekaServerApplication\u003c/span\u003e {\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n  SpringApplication.run(MyEurekaServerApplication.class, args);\n }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 My application.properties 파일에도 변경을 적용해주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e// application.properties\neureka.client.fetch-registry=\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\neureka.client.register-with-eureka=\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\nserver.port=8761\nspring.application.name=MY-EUREKA-SERVER\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래 종속성을 사용하여 Spring Boot 어플리케이션을 생성하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;dependency\u003e\n   \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u003e\u003c/span\u003eorg.springframework.boot\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n   \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u003e\u003c/span\u003espring-boot-starter-web\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/dependency\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003edependency\u003c/span\u003e\u003e\u003c/span\u003e\n   \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u003e\u003c/span\u003eorg.springframework.cloud\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u003e\u003c/span\u003e\n   \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u003e\u003c/span\u003espring-cloud-starter-netflix-eureka-client\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003edependency\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;dependency\u003e\n   \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u003e\u003c/span\u003eorg.springframework.boot\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n   \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u003e\u003c/span\u003espring-boot-starter-test\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n   \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escope\u003c/span\u003e\u003e\u003c/span\u003etest\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escope\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/dependency\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e서버 포트를 출력하는 REST API를 작성해보세요. 이것은 테스트 중에 호출된 서비스의 어떤 인스턴스인지 식별하는 데 도움이 될 것입니다 [로드 밸런싱]\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-meta\"\u003e@RestController\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@RequestMapping(\"/payment\")\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePayController\u003c/span\u003e {\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Value(\"${server.port}\")\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e String serverPort;\n    \n\u003cspan class=\"hljs-meta\"\u003e@GetMapping(\"/say\")\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e String \u003cspan class=\"hljs-title function_\"\u003egetMethodName\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"안녕하세요, Payment MS에서 온 메시지입니다. \"\u003c/span\u003e+serverPort);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 Eureka 서버 세부 정보를 추가하고 메인 클래스에 Eureka 클라이언트를 활성화하는 주석을 추가하는 것을 잊지 마세요 (@EnableDiscoveryClient)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-meta\"\u003e@SpringBootApplication\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@EnableDiscoveryClient\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePaymentMsApplication\u003c/span\u003e {\n \n \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n  SpringApplication.run(PaymentMsApplication.class, args);\n }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e그리고 나의 MS를 위한 어플리케이션 프로퍼티\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003espring.application.name=PAYMENT-SERVICE\neureka.client.service-url.defaultZone=http:\u003cspan class=\"hljs-comment\"\u003e//localhost:8761/eureka\u003c/span\u003e\nserver.port=\u003cspan class=\"hljs-number\"\u003e9811\u003c/span\u003e (어플리케이션을 실행하기 전에 다른 포트를 사용 중입니다)\neureka.instance.ip-address=localhost\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-md\"\u003e\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003edependency\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n   \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003eorg.springframework.cloud\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n   \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003espring-cloud-starter-netflix-eureka-client\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003edependency\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-md\"\u003e\u0026#x3C;!--\nhttps://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-gateway --\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003edependency\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n   \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003eorg.springframework.cloud\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n   \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003espring-cloud-starter-gateway\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n   \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eversion\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e4.1.2\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eversion\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003edependency\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그래서 최신 버전(내 경우 3.2.4v)의 스프링 부트 프로젝트를 만들고 위의 종속성을 추가합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eapplication.yml 파일에 라우팅 구성을 추가하십시오. \u003ccode\u003eservice-name\u003c/code\u003e 프로토콜을 사용하여 API 게이트웨이에 서비스 검색을 지시합니다. 두 개의 payment-service 인스턴스가 있으므로 부하 처리가 필요하고 동적으로 처리해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-attr\"\u003espring:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eapplication:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003egateway\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ecloud:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003egateway:\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eroutes:\u003c/span\u003e\n        \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003epayment-service\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003euri:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003elb://payment-service\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003epredicates:\u003c/span\u003e\n            \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ePath=/payment/**\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eAPI Gateway는 마이크로서비스로도 불리우며 유레카 서버에 등록되어야 합니다. 메인 클래스에 \u003ccode\u003e@EnableDiscoveryClient\u003c/code\u003e를 추가하지 않는 것을 잊지 마세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-meta\"\u003e@SpringBootApplication\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@EnableDiscoveryClient\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApiGtApplication\u003c/span\u003e {\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n  SpringApplication.run(ApiGtApplication.class, args);\n }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e지금 테스트해 보세요!\u003c/h1\u003e\n\u003cp\u003e진행 방법:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e유레카 서버 실행\u003c/li\u003e\n\u003cli\u003e포트 9810 및 9811에서 결제 서비스 실행\u003c/li\u003e\n\u003cli\u003eAPI 게이트웨이 서비스 실행\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e브라우저에서 게이트웨이 엔드포인트를 방문해서 확인해보세요 (\u003ca href=\"http://localhost:8080/payment/say\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://localhost:8080/payment/say\u003c/a\u003e)\u003c/p\u003e\n\u003cp\u003e/payment은 술어 패턴입니다 — 이 패턴이 발생하면 API 게이트웨이는 요청을 지불 서비스로 라우팅하고 지불 서비스에는 컨트롤러 /payment과 GET 메소드 /say가 있습니다. 이것이 실행되어 응답을 게이트웨이로 반환합니다. 유레카는 API 게이트웨이로 인스턴스 정보를 보내기 위한 것이며 내부 통신을 위한 것이 아닙니다.\u003c/p\u003e\n\u003cp\u003e독자 여러분의 읽어주셔서 감사합니다. 도움이 되었다면 공유하고 좋아요를 눌러주세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing"},"buildId":"RZIEBQ2aNAp_DXFVTV6eL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>