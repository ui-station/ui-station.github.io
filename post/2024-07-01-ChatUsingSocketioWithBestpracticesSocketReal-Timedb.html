<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Socketio를 사용한 실시간 채팅 최고의 구현 방법 Socket 실시간 DB 활용법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Socketio를 사용한 실시간 채팅 최고의 구현 방법 Socket 실시간 DB 활용법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Socketio를 사용한 실시간 채팅 최고의 구현 방법 Socket 실시간 DB 활용법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb" data-gatsby-head="true"/><meta name="twitter:title" content="Socketio를 사용한 실시간 채팅 최고의 구현 방법 Socket 실시간 DB 활용법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-01 16:14" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_buildManifest.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Socketio를 사용한 실시간 채팅 최고의 구현 방법 Socket 실시간 DB 활용법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Socketio를 사용한 실시간 채팅 최고의 구현 방법 Socket 실시간 DB 활용법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 1, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb_0.png">
<p>현재, 현대 통신 기술에서 실시간 채팅 애플리케이션은 필수품이 되었습니다. React 또는 React Native에서 채팅 앱을 개발하는 경우, 올바른 기술 스택 선택이 중요합니다. 많은 개발자들이 WebSockets 또는 Firebase와 같은 실시간 데이터베이스를 사용해야 하는 딜레마에 직면합니다. 또한, 소켓 연결 중단 처리 및 데이터 신뢰성 확보는 흔한 도전 과제입니다.</p>
<img src="/assets/img/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb_1.png">
<p>본 블로그 포스트에서는 실시간 채팅 기능을 관리하는 최상의 방법에 대해 살펴보고, 소켓 연결 중단 및 데이터 손실과 관련된 문제를 극복하는 데 중점을 둘 것입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>WebSockets 대 실시간 데이터베이스: 적합한 도구 선택하기</h1>
<p>기술적인 세부 사항에 대해 깊이 이해하기 전에 WebSockets와 실시간 데이터베이스 간의 차이점을 이해하는 것이 중요합니다.</p>
<h2>WebSockets</h2>
<p>장점:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>낮은 대기 시간: 웹소켓은 지속적인 연결을 제공하여 낮은 대기 시간으로 양방향 통신이 가능합니다.</li>
<li>효율성: 빈번한 업데이트에 이상적이며, 웹소켓을 사용하면 반복된 HTTP 요청의 오버헤드가 줄어듭니다.</li>
<li>유연성: 사용자 정의 프로토콜과 데이터 형식을 지원하여 더 많은 제어가 가능합니다.</li>
</ul>
<p>단점:</p>
<ul>
<li>복잡성: 웹소켓 서버를 설정하고 관리하는 것이 어려울 수 있습니다.</li>
<li>확장성: 많은 연결을 다루려면 견고한 인프라가 필요합니다.</li>
</ul>
<h2>실시간 데이터베이스 (파이어베이스)</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>장점:</p>
<ul>
<li>사용의 편의성: Firebase는 실시간 데이터 동기화를 위한 직관적인 API를 제공합니다.</li>
<li>확장성: Firebase에서 관리되므로 확장하기 쉽습니다.</li>
<li>내장된 기능: 인증, 분석 및 오프라인 지원이 포함되어 있습니다.</li>
</ul>
<p>단점:</p>
<ul>
<li>대기 시간: WebSockets보다 약간 높은 대기 시간이 발생할 수 있습니다.</li>
<li>비용: 앱이 확장될수록 사용량 기반 요금 체계가 비싸질 수 있습니다.</li>
<li>제어 능력 감소: Firebase는 세부 정보를 추상화하여 사용자 정의를 제한합니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>소켓 연결 문제 극복하기</h1>
<p>특히 모바일 환경에서 소켓 연결은 네트워크 불안정 또는 기기 상태로 인해 끊길 수 있습니다. 안정적인 통신과 데이터 무결성을 보장하기 위한 전략들이 있습니다.</p>
<h2>1. 자동 재연결</h2>
<p>연결이 끊겼을 때 소켓을 자동으로 다시 연결하는 로직을 구현하세요. Socket.IO와 같은 라이브러리는 재연결을 위한 내장 지원 기능을 제공합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">'https://yourserver.com'</span>, {
  <span class="hljs-attr">reconnection</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">reconnectionAttempts</span>: <span class="hljs-title class_">Infinity</span>,
  <span class="hljs-attr">reconnectionDelay</span>: <span class="hljs-number">1000</span>,
  <span class="hljs-attr">reconnectionDelayMax</span>: <span class="hljs-number">5000</span>,
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">20000</span>,
});
</code></pre>
<h2>2. 메시지 확인</h2>
<p>메시지가 수신되었는지 확인하려면 확인을 사용하십시오. 확인되지 않은 경우 메시지를 재전송하십시오.</p>
<pre><code class="hljs language-js">socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'message'</span>, message, <span class="hljs-function">(<span class="hljs-params">response</span>) =></span> {
  <span class="hljs-keyword">if</span> (response.<span class="hljs-property">status</span> !== <span class="hljs-string">'ok'</span>) {
    <span class="hljs-comment">// 메시지 재전송 시도</span>
  }
});
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>3. 메시지 대기열</h2>
<p>연결이 끊어지면 메시지를 대기열에 저장하고 다시 연결되면 다시 전송합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> messageQueue = [];

socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">'connect'</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-keyword">while</span> (messageQueue.<span class="hljs-property">length</span> > <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">const</span> message = messageQueue.<span class="hljs-title function_">shift</span>();
    socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'message'</span>, message);
  }
});

<span class="hljs-keyword">function</span> <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params">message</span>) {
  <span class="hljs-keyword">if</span> (socket.<span class="hljs-property">connected</span>) {
    socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'message'</span>, message);
  } <span class="hljs-keyword">else</span> {
    messageQueue.<span class="hljs-title function_">push</span>(message);
  }
}
</code></pre>
<h2>4. 네트워크 변경 처리</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>네트워크 변경사항을 청취하여 효율적으로 재연결을 처리하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'online'</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-keyword">if</span> (!socket.<span class="hljs-property">connected</span>) {
    socket.<span class="hljs-title function_">connect</span>();
  }
});
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'offline'</span>, <span class="hljs-function">() =></span> {
  socket.<span class="hljs-title function_">disconnect</span>();
});
</code></pre>
<h2>5. 지속적인 저장</h2>
<p>로컬 저장소나 데이터베이스와 같은 지속적인 저장소를 사용하여 메시지를 임시로 저장하세요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">saveMessageToLocal</span>(<span class="hljs-params">message</span>) {
  <span class="hljs-keyword">const</span> messages = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'messages'</span>)) || [];
  messages.<span class="hljs-title function_">push</span>(message);
  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'messages'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(messages));
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">loadMessagesFromLocal</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'messages'</span>)) || [];
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">clearLocalMessages</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'messages'</span>);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params">message</span>) {
  <span class="hljs-keyword">if</span> (socket.<span class="hljs-property">connected</span>) {
    socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'message'</span>, message, <span class="hljs-function">(<span class="hljs-params">response</span>) =></span> {
      <span class="hljs-keyword">if</span> (response.<span class="hljs-property">status</span> === <span class="hljs-string">'ok'</span>) {
        <span class="hljs-comment">// Message sent successfully</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">saveMessageToLocal</span>(message);
      }
    });
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-title function_">saveMessageToLocal</span>(message);
  }
}

socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">'connect'</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-keyword">const</span> messages = <span class="hljs-title function_">loadMessagesFromLocal</span>();
  messages.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">message</span>) =></span> {
    socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'message'</span>, message);
  });
  <span class="hljs-title function_">clearLocalMessages</span>();
});
</code></pre>
<h2>6. Heartbeat/Ping Mechanism</h2>
<p>연결이 끊어진 경우를 감지하고 다시 연결하기 위한 하트비트 메커니즘을 구현합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =></span> {
  <span class="hljs-keyword">if</span> (socket.<span class="hljs-property">connected</span>) {
    socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'ping'</span>);
  }
}, <span class="hljs-number">5000</span>);

socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">'pong'</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-comment">// 연결 유지 중</span>
});
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>결론</h1>
<p>이러한 전략을 구현하면 대화 응용 프로그램의 신뢰성을 크게 향상시킬 수 있습니다. 자동 재연결, 메시지 확인, 메시지 대기열, 네트워크 변경 처리, 영구 저장, 그리고 하트비트 메커니즘을 활용하여 견고하고 원활한 사용자 경험을 보장할 수 있습니다.</p>
<p>블로그 게시물의 어떤 부분이든 스타일이나 응용 프로그램에 대한 구체적인 세부 정보와 더 잘 맞도록 조정하는 데 자유롭게 변경하십시오.</p>
<h1>즐거운 코딩</h1>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Socketio를 사용한 실시간 채팅 최고의 구현 방법 Socket 실시간 DB 활용법","description":"","date":"2024-07-01 16:14","slug":"2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb","content":"\n\n\n\u003cimg src=\"/assets/img/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb_0.png\" /\u003e\n\n현재, 현대 통신 기술에서 실시간 채팅 애플리케이션은 필수품이 되었습니다. React 또는 React Native에서 채팅 앱을 개발하는 경우, 올바른 기술 스택 선택이 중요합니다. 많은 개발자들이 WebSockets 또는 Firebase와 같은 실시간 데이터베이스를 사용해야 하는 딜레마에 직면합니다. 또한, 소켓 연결 중단 처리 및 데이터 신뢰성 확보는 흔한 도전 과제입니다.\n\n\u003cimg src=\"/assets/img/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb_1.png\" /\u003e\n\n본 블로그 포스트에서는 실시간 채팅 기능을 관리하는 최상의 방법에 대해 살펴보고, 소켓 연결 중단 및 데이터 손실과 관련된 문제를 극복하는 데 중점을 둘 것입니다.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# WebSockets 대 실시간 데이터베이스: 적합한 도구 선택하기\n\n기술적인 세부 사항에 대해 깊이 이해하기 전에 WebSockets와 실시간 데이터베이스 간의 차이점을 이해하는 것이 중요합니다.\n\n## WebSockets\n\n장점:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 낮은 대기 시간: 웹소켓은 지속적인 연결을 제공하여 낮은 대기 시간으로 양방향 통신이 가능합니다.\n- 효율성: 빈번한 업데이트에 이상적이며, 웹소켓을 사용하면 반복된 HTTP 요청의 오버헤드가 줄어듭니다.\n- 유연성: 사용자 정의 프로토콜과 데이터 형식을 지원하여 더 많은 제어가 가능합니다.\n\n단점:\n- 복잡성: 웹소켓 서버를 설정하고 관리하는 것이 어려울 수 있습니다.\n- 확장성: 많은 연결을 다루려면 견고한 인프라가 필요합니다.\n\n## 실시간 데이터베이스 (파이어베이스)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n장점:\n\n- 사용의 편의성: Firebase는 실시간 데이터 동기화를 위한 직관적인 API를 제공합니다.\n- 확장성: Firebase에서 관리되므로 확장하기 쉽습니다.\n- 내장된 기능: 인증, 분석 및 오프라인 지원이 포함되어 있습니다.\n\n단점:\n\n- 대기 시간: WebSockets보다 약간 높은 대기 시간이 발생할 수 있습니다.\n- 비용: 앱이 확장될수록 사용량 기반 요금 체계가 비싸질 수 있습니다.\n- 제어 능력 감소: Firebase는 세부 정보를 추상화하여 사용자 정의를 제한합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 소켓 연결 문제 극복하기\n\n특히 모바일 환경에서 소켓 연결은 네트워크 불안정 또는 기기 상태로 인해 끊길 수 있습니다. 안정적인 통신과 데이터 무결성을 보장하기 위한 전략들이 있습니다.\n\n## 1. 자동 재연결\n\n연결이 끊겼을 때 소켓을 자동으로 다시 연결하는 로직을 구현하세요. Socket.IO와 같은 라이브러리는 재연결을 위한 내장 지원 기능을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nconst socket = io('https://yourserver.com', {\n  reconnection: true,\n  reconnectionAttempts: Infinity,\n  reconnectionDelay: 1000,\n  reconnectionDelayMax: 5000,\n  timeout: 20000,\n});\n```\n\n## 2. 메시지 확인\n\n메시지가 수신되었는지 확인하려면 확인을 사용하십시오. 확인되지 않은 경우 메시지를 재전송하십시오.\n\n```js\nsocket.emit('message', message, (response) =\u003e {\n  if (response.status !== 'ok') {\n    // 메시지 재전송 시도\n  }\n});\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 3. 메시지 대기열\n\n연결이 끊어지면 메시지를 대기열에 저장하고 다시 연결되면 다시 전송합니다.\n\n```js\nlet messageQueue = [];\n\nsocket.on('connect', () =\u003e {\n  while (messageQueue.length \u003e 0) {\n    const message = messageQueue.shift();\n    socket.emit('message', message);\n  }\n});\n\nfunction sendMessage(message) {\n  if (socket.connected) {\n    socket.emit('message', message);\n  } else {\n    messageQueue.push(message);\n  }\n}\n```\n\n## 4. 네트워크 변경 처리\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n네트워크 변경사항을 청취하여 효율적으로 재연결을 처리하세요.\n\n```js\nwindow.addEventListener('online', () =\u003e {\n  if (!socket.connected) {\n    socket.connect();\n  }\n});\nwindow.addEventListener('offline', () =\u003e {\n  socket.disconnect();\n});\n```\n\n## 5. 지속적인 저장\n\n로컬 저장소나 데이터베이스와 같은 지속적인 저장소를 사용하여 메시지를 임시로 저장하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfunction saveMessageToLocal(message) {\n  const messages = JSON.parse(localStorage.getItem('messages')) || [];\n  messages.push(message);\n  localStorage.setItem('messages', JSON.stringify(messages));\n}\n\nfunction loadMessagesFromLocal() {\n  return JSON.parse(localStorage.getItem('messages')) || [];\n}\n\nfunction clearLocalMessages() {\n  localStorage.removeItem('messages');\n}\n\nfunction sendMessage(message) {\n  if (socket.connected) {\n    socket.emit('message', message, (response) =\u003e {\n      if (response.status === 'ok') {\n        // Message sent successfully\n      } else {\n        saveMessageToLocal(message);\n      }\n    });\n  } else {\n    saveMessageToLocal(message);\n  }\n}\n\nsocket.on('connect', () =\u003e {\n  const messages = loadMessagesFromLocal();\n  messages.forEach((message) =\u003e {\n    socket.emit('message', message);\n  });\n  clearLocalMessages();\n});\n```\n\n## 6. Heartbeat/Ping Mechanism\n\n연결이 끊어진 경우를 감지하고 다시 연결하기 위한 하트비트 메커니즘을 구현합니다.\n\n```js\nsetInterval(() =\u003e {\n  if (socket.connected) {\n    socket.emit('ping');\n  }\n}, 5000);\n\nsocket.on('pong', () =\u003e {\n  // 연결 유지 중\n});\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n이러한 전략을 구현하면 대화 응용 프로그램의 신뢰성을 크게 향상시킬 수 있습니다. 자동 재연결, 메시지 확인, 메시지 대기열, 네트워크 변경 처리, 영구 저장, 그리고 하트비트 메커니즘을 활용하여 견고하고 원활한 사용자 경험을 보장할 수 있습니다.\n\n블로그 게시물의 어떤 부분이든 스타일이나 응용 프로그램에 대한 구체적인 세부 정보와 더 잘 맞도록 조정하는 데 자유롭게 변경하십시오.\n\n# 즐거운 코딩","ogImage":{"url":"/assets/img/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb_0.png"},"coverImage":"/assets/img/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb_0.png\"\u003e\n\u003cp\u003e현재, 현대 통신 기술에서 실시간 채팅 애플리케이션은 필수품이 되었습니다. React 또는 React Native에서 채팅 앱을 개발하는 경우, 올바른 기술 스택 선택이 중요합니다. 많은 개발자들이 WebSockets 또는 Firebase와 같은 실시간 데이터베이스를 사용해야 하는 딜레마에 직면합니다. 또한, 소켓 연결 중단 처리 및 데이터 신뢰성 확보는 흔한 도전 과제입니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb_1.png\"\u003e\n\u003cp\u003e본 블로그 포스트에서는 실시간 채팅 기능을 관리하는 최상의 방법에 대해 살펴보고, 소켓 연결 중단 및 데이터 손실과 관련된 문제를 극복하는 데 중점을 둘 것입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eWebSockets 대 실시간 데이터베이스: 적합한 도구 선택하기\u003c/h1\u003e\n\u003cp\u003e기술적인 세부 사항에 대해 깊이 이해하기 전에 WebSockets와 실시간 데이터베이스 간의 차이점을 이해하는 것이 중요합니다.\u003c/p\u003e\n\u003ch2\u003eWebSockets\u003c/h2\u003e\n\u003cp\u003e장점:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e낮은 대기 시간: 웹소켓은 지속적인 연결을 제공하여 낮은 대기 시간으로 양방향 통신이 가능합니다.\u003c/li\u003e\n\u003cli\u003e효율성: 빈번한 업데이트에 이상적이며, 웹소켓을 사용하면 반복된 HTTP 요청의 오버헤드가 줄어듭니다.\u003c/li\u003e\n\u003cli\u003e유연성: 사용자 정의 프로토콜과 데이터 형식을 지원하여 더 많은 제어가 가능합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e단점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e복잡성: 웹소켓 서버를 설정하고 관리하는 것이 어려울 수 있습니다.\u003c/li\u003e\n\u003cli\u003e확장성: 많은 연결을 다루려면 견고한 인프라가 필요합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e실시간 데이터베이스 (파이어베이스)\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e장점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e사용의 편의성: Firebase는 실시간 데이터 동기화를 위한 직관적인 API를 제공합니다.\u003c/li\u003e\n\u003cli\u003e확장성: Firebase에서 관리되므로 확장하기 쉽습니다.\u003c/li\u003e\n\u003cli\u003e내장된 기능: 인증, 분석 및 오프라인 지원이 포함되어 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e단점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e대기 시간: WebSockets보다 약간 높은 대기 시간이 발생할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e비용: 앱이 확장될수록 사용량 기반 요금 체계가 비싸질 수 있습니다.\u003c/li\u003e\n\u003cli\u003e제어 능력 감소: Firebase는 세부 정보를 추상화하여 사용자 정의를 제한합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e소켓 연결 문제 극복하기\u003c/h1\u003e\n\u003cp\u003e특히 모바일 환경에서 소켓 연결은 네트워크 불안정 또는 기기 상태로 인해 끊길 수 있습니다. 안정적인 통신과 데이터 무결성을 보장하기 위한 전략들이 있습니다.\u003c/p\u003e\n\u003ch2\u003e1. 자동 재연결\u003c/h2\u003e\n\u003cp\u003e연결이 끊겼을 때 소켓을 자동으로 다시 연결하는 로직을 구현하세요. Socket.IO와 같은 라이브러리는 재연결을 위한 내장 지원 기능을 제공합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e socket = \u003cspan class=\"hljs-title function_\"\u003eio\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://yourserver.com'\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003ereconnection\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ereconnectionAttempts\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eInfinity\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ereconnectionDelay\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ereconnectionDelayMax\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etimeout\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e20000\u003c/span\u003e,\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e2. 메시지 확인\u003c/h2\u003e\n\u003cp\u003e메시지가 수신되었는지 확인하려면 확인을 사용하십시오. 확인되지 않은 경우 메시지를 재전송하십시오.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esocket.\u003cspan class=\"hljs-title function_\"\u003eemit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'message'\u003c/span\u003e, message, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (response.\u003cspan class=\"hljs-property\"\u003estatus\u003c/span\u003e !== \u003cspan class=\"hljs-string\"\u003e'ok'\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 메시지 재전송 시도\u003c/span\u003e\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e3. 메시지 대기열\u003c/h2\u003e\n\u003cp\u003e연결이 끊어지면 메시지를 대기열에 저장하고 다시 연결되면 다시 전송합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e messageQueue = [];\n\nsocket.\u003cspan class=\"hljs-title function_\"\u003eon\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'connect'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (messageQueue.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e \u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e message = messageQueue.\u003cspan class=\"hljs-title function_\"\u003eshift\u003c/span\u003e();\n    socket.\u003cspan class=\"hljs-title function_\"\u003eemit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'message'\u003c/span\u003e, message);\n  }\n});\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esendMessage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003emessage\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (socket.\u003cspan class=\"hljs-property\"\u003econnected\u003c/span\u003e) {\n    socket.\u003cspan class=\"hljs-title function_\"\u003eemit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'message'\u003c/span\u003e, message);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    messageQueue.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(message);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e4. 네트워크 변경 처리\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e네트워크 변경사항을 청취하여 효율적으로 재연결을 처리하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'online'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!socket.\u003cspan class=\"hljs-property\"\u003econnected\u003c/span\u003e) {\n    socket.\u003cspan class=\"hljs-title function_\"\u003econnect\u003c/span\u003e();\n  }\n});\n\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'offline'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  socket.\u003cspan class=\"hljs-title function_\"\u003edisconnect\u003c/span\u003e();\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e5. 지속적인 저장\u003c/h2\u003e\n\u003cp\u003e로컬 저장소나 데이터베이스와 같은 지속적인 저장소를 사용하여 메시지를 임시로 저장하세요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esaveMessageToLocal\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003emessage\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e messages = \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003elocalStorage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetItem\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'messages'\u003c/span\u003e)) || [];\n  messages.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(message);\n  \u003cspan class=\"hljs-variable language_\"\u003elocalStorage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esetItem\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'messages'\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e(messages));\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eloadMessagesFromLocal\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003elocalStorage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetItem\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'messages'\u003c/span\u003e)) || [];\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eclearLocalMessages\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003elocalStorage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eremoveItem\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'messages'\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esendMessage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003emessage\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (socket.\u003cspan class=\"hljs-property\"\u003econnected\u003c/span\u003e) {\n    socket.\u003cspan class=\"hljs-title function_\"\u003eemit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'message'\u003c/span\u003e, message, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (response.\u003cspan class=\"hljs-property\"\u003estatus\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e'ok'\u003c/span\u003e) {\n        \u003cspan class=\"hljs-comment\"\u003e// Message sent successfully\u003c/span\u003e\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        \u003cspan class=\"hljs-title function_\"\u003esaveMessageToLocal\u003c/span\u003e(message);\n      }\n    });\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003esaveMessageToLocal\u003c/span\u003e(message);\n  }\n}\n\nsocket.\u003cspan class=\"hljs-title function_\"\u003eon\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'connect'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e messages = \u003cspan class=\"hljs-title function_\"\u003eloadMessagesFromLocal\u003c/span\u003e();\n  messages.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003emessage\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    socket.\u003cspan class=\"hljs-title function_\"\u003eemit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'message'\u003c/span\u003e, message);\n  });\n  \u003cspan class=\"hljs-title function_\"\u003eclearLocalMessages\u003c/span\u003e();\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e6. Heartbeat/Ping Mechanism\u003c/h2\u003e\n\u003cp\u003e연결이 끊어진 경우를 감지하고 다시 연결하기 위한 하트비트 메커니즘을 구현합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-built_in\"\u003esetInterval\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (socket.\u003cspan class=\"hljs-property\"\u003econnected\u003c/span\u003e) {\n    socket.\u003cspan class=\"hljs-title function_\"\u003eemit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'ping'\u003c/span\u003e);\n  }\n}, \u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e);\n\nsocket.\u003cspan class=\"hljs-title function_\"\u003eon\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'pong'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 연결 유지 중\u003c/span\u003e\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이러한 전략을 구현하면 대화 응용 프로그램의 신뢰성을 크게 향상시킬 수 있습니다. 자동 재연결, 메시지 확인, 메시지 대기열, 네트워크 변경 처리, 영구 저장, 그리고 하트비트 메커니즘을 활용하여 견고하고 원활한 사용자 경험을 보장할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e블로그 게시물의 어떤 부분이든 스타일이나 응용 프로그램에 대한 구체적인 세부 정보와 더 잘 맞도록 조정하는 데 자유롭게 변경하십시오.\u003c/p\u003e\n\u003ch1\u003e즐거운 코딩\u003c/h1\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb"},"buildId":"wOkGEDZCvEs3S_XaNsdwr","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>