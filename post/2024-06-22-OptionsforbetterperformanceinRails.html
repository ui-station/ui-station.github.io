<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Rails 성능 향상을 위한 7가지 옵션 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-22-OptionsforbetterperformanceinRails" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Rails 성능 향상을 위한 7가지 옵션 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Rails 성능 향상을 위한 7가지 옵션 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-OptionsforbetterperformanceinRails_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-22-OptionsforbetterperformanceinRails" data-gatsby-head="true"/><meta name="twitter:title" content="Rails 성능 향상을 위한 7가지 옵션 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-OptionsforbetterperformanceinRails_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 22:21" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/YUMR4jSyk_WlOHHc7UfOk/_buildManifest.js" defer=""></script><script src="/_next/static/YUMR4jSyk_WlOHHc7UfOk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Rails 성능 향상을 위한 7가지 옵션</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Rails 성능 향상을 위한 7가지 옵션" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-OptionsforbetterperformanceinRails&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>소개: 동기부여</h1>
<p>소프트웨어 엔지니어링에서 효율성은 빠른 실행만이 아니라 리소스를 최대화하고 사용자 경험을 향상하는 해결책을 개발하는 것을 의미합니다. 우아함으로 유명한 Ruby에서는 메소드의 선택이 성능에 깊은 영향을 미칠 수 있습니다. 이 글은 일반적인 Ruby 및 Rails 메소드를 비교하여 메모리와 실행 시간 측면에서 어떤 것이 비교적 더 나은 성능을 제공하는지 살펴봅니다.</p>
<p><img src="/assets/img/2024-06-22-OptionsforbetterperformanceinRails_0.png" alt="이미지"></p>
<h1>exists? vs present? vs any?:</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>ActiveRecord에서 present? 또는 any?과 같은 메서드를 사용하면 레코드를 메모리로 로드하여 일치하는 레코드가 있는지 확인할 수 있습니다. 이는 특히 대규모 데이터셋의 경우 비효율적일 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">where</span>(<span class="hljs-attr">email</span>: <span class="hljs-string">'example@gmail.com'</span>).<span class="hljs-property">present</span>?
<span class="hljs-title class_">User</span>.<span class="hljs-title function_">where</span>(<span class="hljs-attr">email</span>: <span class="hljs-string">'example@gmail.com'</span>).<span class="hljs-property">any</span>?
</code></pre>
<p>exists?의 효율성: exists? 메서드는 데이터를로드하지 않고 레코드의 존재 여부 만을 확인하도록 최적화되어 있어 훨씬 더 빠릅니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">where</span>(<span class="hljs-attr">email</span>: <span class="hljs-string">'example@gmail.com'</span>).<span class="hljs-property">exists</span>?
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>update_all 대 update</h1>
<p>업데이트의 오버헤드: 개별 레코드에 대해 업데이트 메서드를 사용하면 여러 개의 데이터베이스 쿼리가 발생합니다.</p>
<pre><code class="hljs language-js">users.<span class="hljs-property">each</span> { |user| user.<span class="hljs-title function_">update</span>(<span class="hljs-attr">active</span>: <span class="hljs-literal">true</span>) }
</code></pre>
<p>update_all의 효율성: update_all 메서드는 조건과 일치하는 모든 레코드를 업데이트하는 데 단일 쿼리를 수행하여 성능을 크게 향상시킵니다. 단, 여기에 주의해야 할 점은 해당 열이 인덱싱되어 있는지 확인하기 위해 신중히 WHERE 절을 사용하여 넓은 범위를 설정해야 합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">where</span>(<span class="hljs-attr">active</span>: <span class="hljs-literal">false</span>).<span class="hljs-title function_">update_all</span>(<span class="hljs-attr">active</span>: <span class="hljs-literal">true</span>)
</code></pre>
<h1>includes vs joins vs preload</h1>
<h2>Eager Loading Associations</h2>
<ul>
<li>N+1 쿼리 문제: 조인을 사용하면 각 관련 레코드가 개별적으로 쿼리될 수 있는 N+1 쿼리 문제가 발생할 수 있습니다.</li>
<li>User.joins(:posts)는 여기서 posts 테이블을 로드하지 않습니다. 포스트를 가진 사용자만을로드합니다. 포스트는 .each를 수행하고 사용자의 포스트를 가져올 때 로드됩니다. 데이터베이스에 다시 쿼리를 실행하게 됩니다. 이것이 고전적인 n +1 쿼리 문제입니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"># 비효율적
<span class="hljs-title class_">User</span>.<span class="hljs-title function_">joins</span>(:posts).<span class="hljs-property">each</span> { |user| user.<span class="hljs-property">posts</span>.<span class="hljs-property">each</span> { |post| puts post.<span class="hljs-property">title</span> } }
</code></pre>
<p>include의 효율성: include 메서드는 관련 레코드를 최소한의 쿼리로 가져오는 것을 목적으로한다. include는 데이터를 가져오기 위해 preload와 eager_load 두 가지 방법을 사용합니다. preload는 기본 테이블과 연관 테이블을 가져오기 위해 두 개의 쿼리가 시작됩니다. eager_load는 왼쪽 조인을 사용하여 기본 및 보조 테이블 모두를 하나의 쿼리로 가져옵니다.</p>
<pre><code class="hljs language-js"># 효율적
<span class="hljs-title class_">User</span>.<span class="hljs-title function_">includes</span>(:posts).<span class="hljs-property">each</span> { |user| user.<span class="hljs-property">posts</span>.<span class="hljs-property">each</span> { |post| puts post.<span class="hljs-property">title</span> } }
</code></pre>
<h1>count vs size vs length</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>레코드 개수 세기</h2>
<ul>
<li>길이의 오버헤드: 길이를 사용하는 것은 모든 레코드를 메모리로 로드하기 때문에 비효율적일 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js"># 비효율적
<span class="hljs-title class_">User</span>.<span class="hljs-property">all</span>.<span class="hljs-property">length</span>
</code></pre>
<p>카운트의 효율성: count 메서드는 SELECT COUNT(*) 쿼리를 수행하여 대규모 데이터셋에 효율적입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-title class_">User</span>.<span class="hljs-property">count</span>;
</code></pre>
<h1>find vs find_each:</h1>
<p>수천 개의 레코드를 처리할 때, find를 사용하면 처리를 시작하기 전에 모든 레코드를 로드해야하기 때문에 지나칠 정도로 비효율적입니다. 한 번에 10,000개의 레코드를 처리하는 경우 find를 사용할 때 약 500ms가 소요되고 많은 메모리가 사용되어 효율성이 떨어지는 것을 명확히 나타냅니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">find</span>(<span class="hljs-number">1.</span><span class="hljs-number">.10000</span>).<span class="hljs-property">each</span> <span class="hljs-keyword">do</span> |user|
  # 일부 처리 작업
end
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>find_each</h1>
<p><code>find_each</code>은 내가 배고플 때 삼키는 만큼만 씹겠다고 하는 것과 비슷해요.</p>
<pre><code class="hljs language-ruby"><span class="hljs-title class_">User</span>.find_each(<span class="hljs-symbol">batch_size:</span> <span class="hljs-number">1000</span>) <span class="hljs-keyword">do</span> |<span class="hljs-params">user</span>|
  <span class="hljs-comment"># 어떤 처리</span>
<span class="hljs-keyword">end</span>
</code></pre>
<ul>
<li>메모리 사용량: 감소</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>select vs pluck</h1>
<h1>Using select</h1>
<p>이 문은 사용자 테이블에서 특정 열 (id, name, email)을 선택하고 ActiveRecord 객체로로드합니다. 그런 다음 each 블록이 이러한 객체를 반복 처리합니다. 특히 그 객체 각각에서 무언가를 확인하려는 경우에 유용합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">select</span>(:id, :name, :email).<span class="hljs-property">each</span> { |user| ... }
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>pluck 사용하기</h1>
<p>이 문은 데이터베이스에서 지정된 열만 직접 검색합니다. 반환값은 값 배열(또는 다수의 열을 pluck하는 경우 값 배열의 배열)이며, Active Record 객체가 아닙니다. 이는 메모리에 덜 영향을 미칩니다. 다만, 결과는 active record 테이블에 대해 아무것도 모르는 값 배열일 뿐입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">pluck</span>(:id, :name, :email)
</code></pre>
<h1>where vs find_by:</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>where를 사용하기</h2>
<p>where는 Rails에서 강력한 쿼리 메서드로, 여러 레코드를 반환할 수 있습니다. 여러 결과를 처리해야 하는 애플리케이션 로직에서 이상적입니다. where로 여러 레코드를 가져 올 때, where 절에 전달된 필드가 인덱싱되어 있지 않은 경우 전체 테이블 스캔을 수행합니다. 인덱스를 사용하면 검색 범위가 제한되어 index scan을 수행합니다. 일부 상황에서는 이 메서드를 사용해야 할 수도 있지만, 최종적으로 .first를 수행한다면 이상적인 방법이 아닙니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">where</span>(<span class="hljs-attr">name</span>: <span class="hljs-string">'John'</span>).<span class="hljs-property">first</span>
</code></pre>
<p>find_by 사용하기</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>특정 기준과 일치하는 첫 번째 레코드만 필요할 때는 find_by를 사용하는 것이 더 빠릅니다. 일치하는 항목을 찾자마자 쿼리가 중단되어 시간과 자원을 절약합니다. 필터 열이 인덱싱되어 있는 경우 런타임이 더 향상됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">find_by</span>(<span class="hljs-attr">name</span>: <span class="hljs-string">'John'</span>)
</code></pre>
<h1>delete_all vs destroy_all</h1>
<h1>delete_all</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>delete_all은 데이터베이스에 직접 레코드를 로드하지 않고 빠른 삭제를 위한 메서드입니다. 빠르지만 콜백을 건너뜁니다. 빠르지만 결정적이며 콜백이 없습니다. 콜백을 실행하지 않으면 외래 키 참조가 있는 레코드에서 오류가 발생할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">where</span>(<span class="hljs-attr">active</span>: <span class="hljs-literal">false</span>).<span class="hljs-property">delete_all</span>
</code></pre>
<p>destroy_all</p>
<p>콜백을 실행하면서 레코드를 삭제하려면 destroy_all이 필요합니다. 데이터 무결성을 유지하지만 성능에 비용이 발생합니다. 더 많은 시간이 소요되지만 체계적이며 필요한 콜백을 실행합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-title class_">User</span>.<span class="hljs-title function_">where</span>(<span class="hljs-attr">active</span>: <span class="hljs-literal">false</span>).<span class="hljs-property">destroy_all</span>
</code></pre>
<p>이 글이 도움이 되었으면 좋겠어요.</p>
<p>즐거운 코딩하세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Rails 성능 향상을 위한 7가지 옵션","description":"","date":"2024-06-22 22:21","slug":"2024-06-22-OptionsforbetterperformanceinRails","content":"\n# 소개: 동기부여\n\n소프트웨어 엔지니어링에서 효율성은 빠른 실행만이 아니라 리소스를 최대화하고 사용자 경험을 향상하는 해결책을 개발하는 것을 의미합니다. 우아함으로 유명한 Ruby에서는 메소드의 선택이 성능에 깊은 영향을 미칠 수 있습니다. 이 글은 일반적인 Ruby 및 Rails 메소드를 비교하여 메모리와 실행 시간 측면에서 어떤 것이 비교적 더 나은 성능을 제공하는지 살펴봅니다.\n\n![이미지](/assets/img/2024-06-22-OptionsforbetterperformanceinRails_0.png)\n\n# exists? vs present? vs any?:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nActiveRecord에서 present? 또는 any?과 같은 메서드를 사용하면 레코드를 메모리로 로드하여 일치하는 레코드가 있는지 확인할 수 있습니다. 이는 특히 대규모 데이터셋의 경우 비효율적일 수 있습니다.\n\n```js\nUser.where(email: 'example@gmail.com').present?\nUser.where(email: 'example@gmail.com').any?\n```\n\nexists?의 효율성: exists? 메서드는 데이터를로드하지 않고 레코드의 존재 여부 만을 확인하도록 최적화되어 있어 훨씬 더 빠릅니다.\n\n```js\nUser.where(email: 'example@gmail.com').exists?\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# update_all 대 update\n\n업데이트의 오버헤드: 개별 레코드에 대해 업데이트 메서드를 사용하면 여러 개의 데이터베이스 쿼리가 발생합니다.\n\n```js\nusers.each { |user| user.update(active: true) }\n```\n\nupdate_all의 효율성: update_all 메서드는 조건과 일치하는 모든 레코드를 업데이트하는 데 단일 쿼리를 수행하여 성능을 크게 향상시킵니다. 단, 여기에 주의해야 할 점은 해당 열이 인덱싱되어 있는지 확인하기 위해 신중히 WHERE 절을 사용하여 넓은 범위를 설정해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nUser.where(active: false).update_all(active: true)\n```\n\n# includes vs joins vs preload\n\n## Eager Loading Associations\n\n- N+1 쿼리 문제: 조인을 사용하면 각 관련 레코드가 개별적으로 쿼리될 수 있는 N+1 쿼리 문제가 발생할 수 있습니다.\n- User.joins(:posts)는 여기서 posts 테이블을 로드하지 않습니다. 포스트를 가진 사용자만을로드합니다. 포스트는 .each를 수행하고 사용자의 포스트를 가져올 때 로드됩니다. 데이터베이스에 다시 쿼리를 실행하게 됩니다. 이것이 고전적인 n +1 쿼리 문제입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 비효율적\nUser.joins(:posts).each { |user| user.posts.each { |post| puts post.title } }\n```\n\ninclude의 효율성: include 메서드는 관련 레코드를 최소한의 쿼리로 가져오는 것을 목적으로한다. include는 데이터를 가져오기 위해 preload와 eager_load 두 가지 방법을 사용합니다. preload는 기본 테이블과 연관 테이블을 가져오기 위해 두 개의 쿼리가 시작됩니다. eager_load는 왼쪽 조인을 사용하여 기본 및 보조 테이블 모두를 하나의 쿼리로 가져옵니다.\n\n```js\n# 효율적\nUser.includes(:posts).each { |user| user.posts.each { |post| puts post.title } }\n```\n\n# count vs size vs length\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 레코드 개수 세기\n\n- 길이의 오버헤드: 길이를 사용하는 것은 모든 레코드를 메모리로 로드하기 때문에 비효율적일 수 있습니다.\n\n```js\n# 비효율적\nUser.all.length\n```\n\n카운트의 효율성: count 메서드는 SELECT COUNT(\\*) 쿼리를 수행하여 대규모 데이터셋에 효율적입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nUser.count;\n```\n\n# find vs find_each:\n\n수천 개의 레코드를 처리할 때, find를 사용하면 처리를 시작하기 전에 모든 레코드를 로드해야하기 때문에 지나칠 정도로 비효율적입니다. 한 번에 10,000개의 레코드를 처리하는 경우 find를 사용할 때 약 500ms가 소요되고 많은 메모리가 사용되어 효율성이 떨어지는 것을 명확히 나타냅니다.\n\n```js\nUser.find(1..10000).each do |user|\n  # 일부 처리 작업\nend\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# find_each\n\n`find_each`은 내가 배고플 때 삼키는 만큼만 씹겠다고 하는 것과 비슷해요.\n\n```ruby\nUser.find_each(batch_size: 1000) do |user|\n  # 어떤 처리\nend\n```\n\n- 메모리 사용량: 감소\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# select vs pluck\n\n# Using select\n\n이 문은 사용자 테이블에서 특정 열 (id, name, email)을 선택하고 ActiveRecord 객체로로드합니다. 그런 다음 each 블록이 이러한 객체를 반복 처리합니다. 특히 그 객체 각각에서 무언가를 확인하려는 경우에 유용합니다.\n\n```js\nUser.select(:id, :name, :email).each { |user| ... }\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# pluck 사용하기\n\n이 문은 데이터베이스에서 지정된 열만 직접 검색합니다. 반환값은 값 배열(또는 다수의 열을 pluck하는 경우 값 배열의 배열)이며, Active Record 객체가 아닙니다. 이는 메모리에 덜 영향을 미칩니다. 다만, 결과는 active record 테이블에 대해 아무것도 모르는 값 배열일 뿐입니다.\n\n```js\nUser.pluck(:id, :name, :email)\n```\n\n# where vs find_by:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## where를 사용하기\n\nwhere는 Rails에서 강력한 쿼리 메서드로, 여러 레코드를 반환할 수 있습니다. 여러 결과를 처리해야 하는 애플리케이션 로직에서 이상적입니다. where로 여러 레코드를 가져 올 때, where 절에 전달된 필드가 인덱싱되어 있지 않은 경우 전체 테이블 스캔을 수행합니다. 인덱스를 사용하면 검색 범위가 제한되어 index scan을 수행합니다. 일부 상황에서는 이 메서드를 사용해야 할 수도 있지만, 최종적으로 .first를 수행한다면 이상적인 방법이 아닙니다.\n\n```js\nUser.where(name: 'John').first\n```\n\nfind_by 사용하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n특정 기준과 일치하는 첫 번째 레코드만 필요할 때는 find_by를 사용하는 것이 더 빠릅니다. 일치하는 항목을 찾자마자 쿼리가 중단되어 시간과 자원을 절약합니다. 필터 열이 인덱싱되어 있는 경우 런타임이 더 향상됩니다.\n\n```js\nUser.find_by(name: 'John')\n```\n\n# delete_all vs destroy_all\n\n# delete_all\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ndelete_all은 데이터베이스에 직접 레코드를 로드하지 않고 빠른 삭제를 위한 메서드입니다. 빠르지만 콜백을 건너뜁니다. 빠르지만 결정적이며 콜백이 없습니다. 콜백을 실행하지 않으면 외래 키 참조가 있는 레코드에서 오류가 발생할 수 있습니다.\n\n```js\nUser.where(active: false).delete_all\n```\n\ndestroy_all\n\n콜백을 실행하면서 레코드를 삭제하려면 destroy_all이 필요합니다. 데이터 무결성을 유지하지만 성능에 비용이 발생합니다. 더 많은 시간이 소요되지만 체계적이며 필요한 콜백을 실행합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nUser.where(active: false).destroy_all\n```\n\n이 글이 도움이 되었으면 좋겠어요.\n\n즐거운 코딩하세요!\n","ogImage":{"url":"/assets/img/2024-06-22-OptionsforbetterperformanceinRails_0.png"},"coverImage":"/assets/img/2024-06-22-OptionsforbetterperformanceinRails_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003e소개: 동기부여\u003c/h1\u003e\n\u003cp\u003e소프트웨어 엔지니어링에서 효율성은 빠른 실행만이 아니라 리소스를 최대화하고 사용자 경험을 향상하는 해결책을 개발하는 것을 의미합니다. 우아함으로 유명한 Ruby에서는 메소드의 선택이 성능에 깊은 영향을 미칠 수 있습니다. 이 글은 일반적인 Ruby 및 Rails 메소드를 비교하여 메모리와 실행 시간 측면에서 어떤 것이 비교적 더 나은 성능을 제공하는지 살펴봅니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-OptionsforbetterperformanceinRails_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003eexists? vs present? vs any?:\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eActiveRecord에서 present? 또는 any?과 같은 메서드를 사용하면 레코드를 메모리로 로드하여 일치하는 레코드가 있는지 확인할 수 있습니다. 이는 특히 대규모 데이터셋의 경우 비효율적일 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eemail\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'example@gmail.com'\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003epresent\u003c/span\u003e?\n\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eemail\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'example@gmail.com'\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003eany\u003c/span\u003e?\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eexists?의 효율성: exists? 메서드는 데이터를로드하지 않고 레코드의 존재 여부 만을 확인하도록 최적화되어 있어 훨씬 더 빠릅니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eemail\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'example@gmail.com'\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003eexists\u003c/span\u003e?\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eupdate_all 대 update\u003c/h1\u003e\n\u003cp\u003e업데이트의 오버헤드: 개별 레코드에 대해 업데이트 메서드를 사용하면 여러 개의 데이터베이스 쿼리가 발생합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eusers.\u003cspan class=\"hljs-property\"\u003eeach\u003c/span\u003e { |user| user.\u003cspan class=\"hljs-title function_\"\u003eupdate\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eactive\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e) }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eupdate_all의 효율성: update_all 메서드는 조건과 일치하는 모든 레코드를 업데이트하는 데 단일 쿼리를 수행하여 성능을 크게 향상시킵니다. 단, 여기에 주의해야 할 점은 해당 열이 인덱싱되어 있는지 확인하기 위해 신중히 WHERE 절을 사용하여 넓은 범위를 설정해야 합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eactive\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eupdate_all\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eactive\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eincludes vs joins vs preload\u003c/h1\u003e\n\u003ch2\u003eEager Loading Associations\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eN+1 쿼리 문제: 조인을 사용하면 각 관련 레코드가 개별적으로 쿼리될 수 있는 N+1 쿼리 문제가 발생할 수 있습니다.\u003c/li\u003e\n\u003cli\u003eUser.joins(:posts)는 여기서 posts 테이블을 로드하지 않습니다. 포스트를 가진 사용자만을로드합니다. 포스트는 .each를 수행하고 사용자의 포스트를 가져올 때 로드됩니다. 데이터베이스에 다시 쿼리를 실행하게 됩니다. 이것이 고전적인 n +1 쿼리 문제입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 비효율적\n\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejoins\u003c/span\u003e(:posts).\u003cspan class=\"hljs-property\"\u003eeach\u003c/span\u003e { |user| user.\u003cspan class=\"hljs-property\"\u003eposts\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eeach\u003c/span\u003e { |post| puts post.\u003cspan class=\"hljs-property\"\u003etitle\u003c/span\u003e } }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003einclude의 효율성: include 메서드는 관련 레코드를 최소한의 쿼리로 가져오는 것을 목적으로한다. include는 데이터를 가져오기 위해 preload와 eager_load 두 가지 방법을 사용합니다. preload는 기본 테이블과 연관 테이블을 가져오기 위해 두 개의 쿼리가 시작됩니다. eager_load는 왼쪽 조인을 사용하여 기본 및 보조 테이블 모두를 하나의 쿼리로 가져옵니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 효율적\n\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eincludes\u003c/span\u003e(:posts).\u003cspan class=\"hljs-property\"\u003eeach\u003c/span\u003e { |user| user.\u003cspan class=\"hljs-property\"\u003eposts\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eeach\u003c/span\u003e { |post| puts post.\u003cspan class=\"hljs-property\"\u003etitle\u003c/span\u003e } }\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003ecount vs size vs length\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e레코드 개수 세기\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e길이의 오버헤드: 길이를 사용하는 것은 모든 레코드를 메모리로 로드하기 때문에 비효율적일 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 비효율적\n\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eall\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e카운트의 효율성: count 메서드는 SELECT COUNT(*) 쿼리를 수행하여 대규모 데이터셋에 효율적입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecount\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003efind vs find_each:\u003c/h1\u003e\n\u003cp\u003e수천 개의 레코드를 처리할 때, find를 사용하면 처리를 시작하기 전에 모든 레코드를 로드해야하기 때문에 지나칠 정도로 비효율적입니다. 한 번에 10,000개의 레코드를 처리하는 경우 find를 사용할 때 약 500ms가 소요되고 많은 메모리가 사용되어 효율성이 떨어지는 것을 명확히 나타냅니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.10000\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003eeach\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edo\u003c/span\u003e |user|\n  # 일부 처리 작업\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003efind_each\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003efind_each\u003c/code\u003e은 내가 배고플 때 삼키는 만큼만 씹겠다고 하는 것과 비슷해요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-ruby\"\u003e\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e.find_each(\u003cspan class=\"hljs-symbol\"\u003ebatch_size:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003edo\u003c/span\u003e |\u003cspan class=\"hljs-params\"\u003euser\u003c/span\u003e|\n  \u003cspan class=\"hljs-comment\"\u003e# 어떤 처리\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eend\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e메모리 사용량: 감소\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eselect vs pluck\u003c/h1\u003e\n\u003ch1\u003eUsing select\u003c/h1\u003e\n\u003cp\u003e이 문은 사용자 테이블에서 특정 열 (id, name, email)을 선택하고 ActiveRecord 객체로로드합니다. 그런 다음 each 블록이 이러한 객체를 반복 처리합니다. 특히 그 객체 각각에서 무언가를 확인하려는 경우에 유용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eselect\u003c/span\u003e(:id, :name, :email).\u003cspan class=\"hljs-property\"\u003eeach\u003c/span\u003e { |user| ... }\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003epluck 사용하기\u003c/h1\u003e\n\u003cp\u003e이 문은 데이터베이스에서 지정된 열만 직접 검색합니다. 반환값은 값 배열(또는 다수의 열을 pluck하는 경우 값 배열의 배열)이며, Active Record 객체가 아닙니다. 이는 메모리에 덜 영향을 미칩니다. 다만, 결과는 active record 테이블에 대해 아무것도 모르는 값 배열일 뿐입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epluck\u003c/span\u003e(:id, :name, :email)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003ewhere vs find_by:\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003ewhere를 사용하기\u003c/h2\u003e\n\u003cp\u003ewhere는 Rails에서 강력한 쿼리 메서드로, 여러 레코드를 반환할 수 있습니다. 여러 결과를 처리해야 하는 애플리케이션 로직에서 이상적입니다. where로 여러 레코드를 가져 올 때, where 절에 전달된 필드가 인덱싱되어 있지 않은 경우 전체 테이블 스캔을 수행합니다. 인덱스를 사용하면 검색 범위가 제한되어 index scan을 수행합니다. 일부 상황에서는 이 메서드를 사용해야 할 수도 있지만, 최종적으로 .first를 수행한다면 이상적인 방법이 아닙니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'John'\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003efirst\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efind_by 사용하기\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e특정 기준과 일치하는 첫 번째 레코드만 필요할 때는 find_by를 사용하는 것이 더 빠릅니다. 일치하는 항목을 찾자마자 쿼리가 중단되어 시간과 자원을 절약합니다. 필터 열이 인덱싱되어 있는 경우 런타임이 더 향상됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efind_by\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'John'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003edelete_all vs destroy_all\u003c/h1\u003e\n\u003ch1\u003edelete_all\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003edelete_all은 데이터베이스에 직접 레코드를 로드하지 않고 빠른 삭제를 위한 메서드입니다. 빠르지만 콜백을 건너뜁니다. 빠르지만 결정적이며 콜백이 없습니다. 콜백을 실행하지 않으면 외래 키 참조가 있는 레코드에서 오류가 발생할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eactive\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003edelete_all\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edestroy_all\u003c/p\u003e\n\u003cp\u003e콜백을 실행하면서 레코드를 삭제하려면 destroy_all이 필요합니다. 데이터 무결성을 유지하지만 성능에 비용이 발생합니다. 더 많은 시간이 소요되지만 체계적이며 필요한 콜백을 실행합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eactive\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003edestroy_all\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 글이 도움이 되었으면 좋겠어요.\u003c/p\u003e\n\u003cp\u003e즐거운 코딩하세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-OptionsforbetterperformanceinRails"},"buildId":"YUMR4jSyk_WlOHHc7UfOk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>