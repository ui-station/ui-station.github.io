<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Java 제네릭을 이용한 다형 함수 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-19-PolymorphicfunctionsusingJavagenerics" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Java 제네릭을 이용한 다형 함수 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Java 제네릭을 이용한 다형 함수 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-19-PolymorphicfunctionsusingJavagenerics" data-gatsby-head="true"/><meta name="twitter:title" content="Java 제네릭을 이용한 다형 함수 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 22:03" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/YUMR4jSyk_WlOHHc7UfOk/_buildManifest.js" defer=""></script><script src="/_next/static/YUMR4jSyk_WlOHHc7UfOk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Java 제네릭을 이용한 다형 함수</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Java 제네릭을 이용한 다형 함수" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">15<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-PolymorphicfunctionsusingJavagenerics&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>자바 함수형 프로그래밍 구축 요소</p>
<p><img src="/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_0.png" alt="이미지"></p>
<p>이 기사는 제네릭 유형과 함수형 인터페이스를 사용하여 자바에서 다형성 함수를 작성하는 주제를 탐구합니다. 이 기본 사항은 종종 주니어 엔지니어에 의해 고려되지 않는다. 대신 Java 8+ Stream API와 같은 더 심화된 주제로 즉시 진입하는 것을 선호합니다. 그러나 이것들은 자바에서 함수형 프로그래밍 개념을 배우고 적용하며 더 깨끗하고 재사용 가능하며 선언적인 코드를 작성하는 데 필수적인 구축 요소입니다.</p>
<p>기사 말미에서, 저는 모든 것을 매우 유용하고 실용적인 예제로 하나로 조합할 것입니다. 이 기사가 당신에게 매우 유용하고 실질적인 예제가 될 것이라고 기대합니다. 이 기사가 당신에게 단단한 기초를 제공하고 댓글 섹션이나 스스로 더 탐구하도록 격려할 것입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그러나 계속 읽기 전에 주의할 점은, 이 문서가 제네릭 및 함수형 인터페이스 개념 및 구문을 배우는 초보자용 완전한 자습서로 제공되는 것이 아니라는 것입니다. 이미 Java 공식 문서 및 다양한 자습서 웹사이트에 많은 이러한 자습서가 존재합니다. 우리는 기본 사항을 빠르게 살펴볼 것이며, 이 글의 주요 목적은 왜 그리고 어떻게 실제로 유용한지 깊게 이해하려는 것입니다.</p>
<h2>Java 제네릭의 목적</h2>
<p>그렇다면 Java 제네릭의 목적은 무엇이며, 언제 유용할까요?</p>
<p>가장 유혹적인 말은 "공통 부모를 공유하는 클래스가 있는 재사용 가능한 코드를 작성하기 위해서"라고 말하는 것입니다. — 또는 이와 같은 말입니다. 경우에 따라, 그리고 어느 정도로 그렇습니다. 하지만 이것이 정확히 무엇을 의미하는지는 무엇일까요? 아래 코드 조각을 살펴봅시다. 제네릭 유형을 사용하는 좋은 이유가 될까요?</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_1.png" alt="image"></p>
<p>답은: no입니다. 이 코드는 다음 코드 스니펫에서 강조하는 것처럼 Dog 추상화 자체로 쉽게 바꿀 수 있습니다. 이러한 경우에는 제네릭을 사용할 필요가 없습니다.</p>
<p><img src="/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_2.png" alt="image"></p>
<p>그렇다면, Java 제네릭이 언제 진정으로 유용한가요? 먼저, 클래스 제네릭 유형과 메서드 제네릭 유형 두 가지 유형의 일반 유형이 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>클래스 제네릭 타입은 특히 여러 클래스 API 메소드들 사이에서 타입 일관성을 유지하는 데 유용합니다. 첫 번째 예시로는 List 인터페이스가 add나 get과 같은 여러 메소드에서 동일한 클래스 제네릭 타입 E를 시그니처에 재사용하는 것이 있습니다.</p>
<p>메소드 제네릭 타입은 Java 언어의 설계 제한을 극복하는 데 도움을 줍니다. 클래스 제네릭 타입을 사용하는 클래스는 무변(invariant)이기 때문에(공변(covariant)이 아님) 메소드 제네릭 타입은 여러 메소드 매개변수 및/또는 반환 타입에 걸쳐 특정 타입을 강제하는 데 매우 유용합니다.</p>
<p>실무에서 무변이 무엇을 의미하는지 예를 들어 설명하자면, List<code>String</code>은 String이 Object의 하위 타입이지만 List<code>Object</code>의 하위 타입이 아니라는 것입니다. 리스트가 무변이라는 것에 주목할 만한 점은 Java에서 배열은 공변적(covariant)이기 때문에(String[]는 Object[]를 확장합니다) 이 특정 목적을 위해 제네릭 메소드 타입을 사용할 필요가 없다는 것입니다.</p>
<p>다음 코드 스니펫에서 Java의 공변성/무변성 관련하여 어떤 것이 허용되고, 어떤 것이 안 되는지 살펴볼 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_3.png">
<p>그래서 요약하면, Java 제네릭의 주요 목적은 개발자가 여러 가지 유형에서 재사용 가능한 코드를 작성하고 일관된 계약(클래스 수준 또는 메소드 수준)을 제공하는 동안 유연하게 작동하도록 하는 것입니다.</p>
<h2>제한된 제네릭 유형</h2>
<p>제네릭 유형은 상한, 하한 또는 명시적 바운드가 없을 수 있습니다(Object가 상한인 경우).</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>한계가 없는 제네릭 유형을 탐색해 봅시다. 이 유형들은 어떤 객체 유형이든 가능하게 합니다. 주로 여러 매개변수 및/또는 반환 유형에 동일한 유형을 적용하는 데 사용됩니다. 아래 코드 예제에서 볼 수 있듯이 다른 간단한 동작도 정의할 수 있습니다.</p>
<p><img src="/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_4.png" alt="이미지"></p>
<p>아마도 가장 흔한 제네릭 사용 사례 중 하나는 상위 경계 제네릭 유형을 사용하는 것입니다. 이것은 소개 섹션에서 언급한 "일반 부모" 상속 기반 예제입니다. 아래 예제에서 강조되어 있습니다.</p>
<p><img src="/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_5.png" alt="이미지"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>한 번 멈춰서 일반적인 유형이 우리에게 무엇을 하는지 두 가지 관점에서 이해해 봅시다: 호출자의 관점과 구현의 관점에서.</p>
<p>이 API를 사용하는 사용자로서, List<code>Dog</code>나 Dog 하위 유형(예: List<code>GermanSheppard</code>)을 사용하여 findDogByNameGeneric(...)을 호출할 수 있습니다.</p>
<p>메서드 구현 관점에서는 경계가 있는 일반 유형 <code>T extends Dog</code> 가 우리에게 강력한 보증을 제공하는데, 이는 우리가 받는 모든 목록이 요소가 부모 유형 Dog를 공유할 것이라는 것입니다. 이는 목록이 개발자에게 메서드 내에서 사용할 수 있는 요소를 생성할 수 있게 해줍니다(즉, 여기서는 Dog 및 특히 부모 인터페이스에서 정의된 getName()을 호출하는 경우).</p>
<p>상한이 있는 제네릭 유형 목록으로는 요소를 추가할 수 없습니다. 이것을 생각해 보면 이해할 수 있으며, 그 이유를 찾아보는 것은 시간을 들여서 한 번 곰곰히 생각할 가치가 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>[1초 후]</p>
<p>상한이 정의된 제네릭 타입 목록에 요소를 추가할 수 없는 이유는 메서드 구현 내에서 호출된 목록의 실제 타입을 알 수 없기 때문입니다. 아래 예시를 살펴봅시다.</p>
<p><img src="/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_6.png" alt="image"></p>
<p>만약 상한이 정의된 타입에 추가할 수 있다면, List<code>Double</code> 입력 매개변수를 사용해 addSomething을 이론적으로 호출할 수 있고, 메서드 내에서 Double 목록에 Integer(또한 Number를 확장한)을 추가할 수 있습니다. 컴파일 시에 메서드가 어떤 타입으로 호출될지 알 수 없기 때문에, 언어가 목록의 타입 무결성을 잠재적으로 위반하지 못하도록 우리를 방해하는 것은 바로 이것입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>만약 우리가 일반 형식 소비자에 요소를 전달하려면(컬렉션이어야만 하는 것은 아님), 상위 바운드를 만들기 위해 super 키워드를 사용해야 합니다. 아래의 또 다른 예제를 살펴보고, 이전처럼 API 관점과 구현 관점에서 super가 우리에게 무엇을 보장해주는지 생각해봅시다.</p>
<p><img src="/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_7.png" alt="image"></p>
<p>API 관점에서는 populateGermanSheppards 메서드의 두 번째 매개변수는 List<code>GermanSheppard</code> 또는 그 상위 형식인 List<code>Dog</code>일 수 있습니다. 이게 구현 관점에서 왜 도움이 되는지 생각해 보세요.</p>
<p>[또 다른 시간이 흘렀습니다]</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>populateGermanSheppards의 구현 내에서 두 번째 입력 매개변수가 List<code>GermanSheppard</code> 또는 List<code>Dog</code> 중 하나인 것을 알 수 있습니다. 따라서 해당 목록에 GermanSheppard를 추가해도 목록의 유형 무결성을 위반하지 않습니다. 왜냐하면 입력 매개변수 목록이 List<code>GermanSheppard</code>인 경우 GermanSheppard를 추가하는 것이 단순히 유효하며, List<code>Dog</code>인 경우 GermanSheppard는 Dog이므로 유형이 여전히 유효합니다. 더불어 부모 클래스에 대해서도 동일한 원리가 적용됩니다.</p>
<p>매번 바운드된 제네릭 유형을 생각할 필요가 없도록, 간단히 PECS라는 머릿글자를 기억하면 됩니다. PECS는 Producer-Extends Consumer-Super의 약자로, 제네릭 메소드를 사용하여 상위 바운드 유형을 가진 요소를 생성/생산하는 요소들을 생산자로 정의합니다.</p>
<p>소비자는 요소를 받아들일 수 있는 능력과 관련이 있습니다. 예를 들어 List의 add 메소드는 요소를 받아들일 수 있기 때문에 소비자이며, 목록의 제네릭 유형을 소비자-슈퍼로 제한할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>지금까지 우리가 논의한 것은 단순한 기본 구성 요소로, Java에서 일반적인 타입이 어떻게 실제로 작동하는지의 기본 설명입니다. 더 많은 내용이 있으며, 와일드카드 및 타입 이레이저에 대해 약간 읽어보고, 컬렉션을 중심으로하지 않는 더 많은 예시(예: Optional)를 살펴보면 일반 타입에 대해 더 익숙해질 수 있습니다.</p>
<p>그러나 순수 일반 타입을 강조하는 좋은 예제를 제공하기가 어려운데, 적어도 내게는 이러한 타입의 가장 크고 일반적으로 사용되는 장점은 함수형 인터페이스와 결합될 때입니다. 이에 대해 더 자세히 알아보겠습니다.</p>
<h1>함수형 인터페이스 기본 사항</h1>
<p>함수형 인터페이스는 재사용 가능한 코드를 작성할 때 우리가 가진 도구 중 하나입니다. 또한 좋은 개발자 경험을 제공하는 유연한 API를 구축하고 싶다면 바운드된 제네릭 타입을 사용하여 개선할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이론적으로 함수형 인터페이스는 오직 하나의 비디폴트 메소드만 가진 인터페이스를 말합니다(즉, 구현이 없는 메소드가 하나뿐인 경우). 이러한 인터페이스들은 Java 유형을 제공하고 람다 표현식이나 메소드 참조 같은 호출 가능한 코드 조각을 참조하는 데 사용됩니다. 이러한 참조를 다른 객체 유형처럼 사용할 수 있게 해줍니다. 함수를 참조할 수 있고, 호출하지 않고 다른 함수에 전달할 수 있습니다.</p>
<p>Java 8부터 Java JDK 내에 여러 유형의 함수형 인터페이스가 있습니다. 가장 기본적인 것은 Function<code>T, R</code>입니다. 이는 입력 T 집합을 가져와 R 집합의 결과를 출력하는 수학 함수와 동등합니다. 다만 여기서는 유형 인스턴스를 다루고 있을 뿐입니다. 함수형 프로그래밍에서는 이를 펑터라고도 부릅니다.</p>
<p>함수 외에도 다음과 같이 계속해서 사용되는 함수형 인터페이스 유형들이 있습니다(그들의 Bi[…]variant인 BiFunction<code>T, U, R</code>와 함께), 이미 알고 계신지 모르겠지만 익숙해지기를 권장드립니다:</p>
<ul>
<li>Predicate<code>T</code>: Function<code>T, Boolean</code>와 같은 역할을 합니다.</li>
<li>Consumer<code>T</code>: T형 인자를 가지고 void(아무것도)를 반환하는 함수를 나타냅니다.</li>
<li>Supplier<code>T</code>: 어떠한 인자도 받지 않고 T 유형 원소를 반환하는 함수를 나타냅니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다음은 많은 작업을 수행할 수 있는 메소드의 예시를 살펴봅니다. 원리적으로는 리스트의 요소를 반복하고 특정 조건에서 특정 작업을 수행합니다. 메소드 자체에서는 구체적인 내용은 정의되어 있지 않으며, 이는 꽤 추상적입니다.</p>
<p><img src="/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_8.png" alt="이미지"></p>
<p>추가로, 제 개인적인 의견으로는 함수형 인터페이스를 사용하여 지나치게 추상화된 일반적인 함수를 작성하는 것도 코드 재사용성을 위해 코드 가독성을 너무 희생하는 경우 반대 패턴으로 간주해야 한다고 생각합니다. 둘 사이에는 균형이 필요하며, 재사용 가능한 일반적인 메소드에서 구체적이고 정당화할 수 있는 문제를 해결하도록 노력해야 합니다.</p>
<p>조건부 요소 소비자(conditionalElementsConsumer) 메소드 시그니처가 어떻게 보일지 생각해 보세요. 일반적인 타입을 완화하고 한정적인(혹은 제한된) 일반적인 타입을 사용한다면 어떨까요?</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>[a second of thinking passes]</p>
<p>PECS 약자에 대해 간단히 생각해 보면, 느슨한 서명은 다음 예시와 같은 형태여야 합니다.</p>
<p><img src="/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_9.png" alt="이미지"></p>
<p>새 예시에서 이전의 제한된 제네릭 유형이 새로운 케이스를 지원하기에 충분히 유연하지 못했음을 알 수 있습니다. 이 간단한 기능 인터페이스를 사용해 개념을 설명하고 있지만, 실제 프로젝트에서는 타입이 일치하도록 바꿀 수 없는 서드파티 코드의 메서드 참조와 유사한 상황을 마주하게 될 수 있습니다. 경계를 통해 제네릭 유형을 느슨하게 처리하면 이를 해결하는 데 도움이 될 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 지점에서 또 다른 좋은 연습은 위의 예제를 생각하고 152번 라인에서 컴파일 되는 메소드 호출의 실제 T 유형을 파악해 보는 것입니다.</p>
<p>함수형 인터페이스의 기본을 더 깊이 들어가지는 않겠습니다. 다양한 다른 유형에 대해 이야기하는 많은 기사들과 람다 표현식, 메소드 참조에 대해 참조할 수 있는 함수형 인터페이스 유형도 있습니다.</p>
<p>그러나 이러한 기본 개념을 조합하여 실제 유용한 재사용 가능한 코드를 만들 수 있는 방법을 강조하는 데는 조금 더 나아갈 것입니다.</p>
<h1>고차 함수를 통한 데코레이터</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>고차 함수는 다른 함수를 매개변수로 받거나 함수를 반환하는 함수형 프로그래밍 개념을 나타냅니다.</p>
<p>이를 생각하면, 실제로 호출하지 않고 일반 함수를 래핑하는 데코레이터와 유사한 디자인 패턴을 이론적으로 정의할 수 있습니다.</p>
<p>많이 접하게 되는 예시 중 하나는 확인된 예외를 throw하는 함수를 처리하는 것입니다. 이는 특히 Stream API 메소드 호출 내에서 문제가 될 수 있습니다. Stream API 메소드는 예외를 throw하지 않는 함수형 인터페이스를 입력 매개변수로 사용하기 때문입니다. 물론 Vavr과 같은 라이브러리를 사용할 수도 있지만, 사용 사례가 제한적이고 종속성 목록을 작게 유지하고 싶다면 직접 래퍼/핸들러를 구축하는 것이 더 나은 옵션이 될 수 있습니다. 아래 예시에서 (인기 있는) 상황을 확인해보세요.</p>
<p><img src="/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_10.png" alt="이미지"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>먼저, 위의 코드에서 발생한 컴파일 오류는 map 메서드에서 예상되는 메서드 시그니처 (즉, Function<code>T, R</code>)와 제공된 함수가 String을 가져와 List<code>String</code>을 반환하거나 IO Exception을 던질 수 있는 함수임을 고려할 때 발생합니다 (이러한 의미로는 JDK에 기본적으로 해당 함수형 인터페이스가 없음).</p>
<p>이러한 유형의 불일치를 다루는 비제네릭하고 간단한 방법은 발생한 예외를 별도의 메서드로 분리하여 거기서 예외를 처리하는 것입니다. 이렇게 하면 사실상 Stream::map 메서드에 대해 Function<code>String, List</code>String`` 입력 매개변수로 변환될 것이며 이는 컴파일이 될 것입니다. 그러나 제네릭 및 함수 인터페이스를 통해 코드 재사용할 수 있는 큰 기회가 있다는 것을 다음 예제에서 확인할 수 있습니다.</p>
<p><img src="/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_11.png" alt="Example"></p>
<p>위의 코드 예제를 조금 설명해보겠습니다. 먼저, 제시된 3가지 옵션 중 어느 것을 사용하더라도 더 이상 컴파일 오류가 발생하지 않음을 관찰할 수 있습니다. 이제 map 메서드는 호출 시 예상대로 Function<code>Path, List</code>String``를 받는다고 볼 수 있는 mapSafeFunction을 수신하며, 또한 ExceptionalFunction 인터페이스를 정의할 때 코드가 완벽하게 컴파일되고 Files::readAllLines 메서드 참조가 어떤 컴파일 오류도 없이 허용됩니다. 즉, 이 문제는 예외 처리가 되지 않았던 것이 아니라 함수형 인터페이스 타입이 일치하지 않았기 때문임을 결론짓습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>수학 함수에 대해 생각해보면, 입력을 받아 출력을 제공하며 예외를 throw하지 않습니다. 마찬가지로 여기서는 예외를 throw하는 함수를 throw하지 않는 함수로 변환하려고 합니다. 그렇다면 예외가 발생했을 때 어떻게 해야 할까요?</p>
<p>이것은 완전히 개인적인 선택이었지만, 예외가 발생한 경우 결과가 없을 수도 있다는 사실을 나타내기 위해 생성된 함수가 Optional을 반환하도록 만들기를 원했습니다. 이것이 ExceptionalFunction<code>T, R</code>의 입력에 대한 반환 타입이 Function<code>T, Optional</code>R``로 되어 있는 이유입니다. 이전 Optional::map 작업이 flatmap 작업으로 변경되어 코드 전체에 매우 잘 맞는 점에 주목하면 좋습니다(Javadoc 여기를 참조하세요). 예외가 발생하면 Optional 체인이 빈 결과를 제공하며 코드는 전반적으로 매우 깨끗하고 순조롭게 따라갈 수 있습니다.</p>
<p>(부기적으로, 예외를 완전히 억제하거나 런타임 예외로 다시 던지거나 null을 반환하는 API 디자인 선택은 개발자 경험 관점에서 객관적으로 잘못된 접근법이라고 생각합니다. 주된 주장은 계약이 그냥 틀렸다는 것이며, 예기치 않은 동작이 API를 통해 추론될 수 없다는 점이며, 코드를 읽어야만 이해할 수 있다는 것입니다.)</p>
<p>mapSafeFunction의 구현은 Files::readAllLines 또는 예외를 throw하는 기타 함수에 적용할 수 있습니다. 이 메서드는 전체 프로젝트 전반에 걸쳐 매우 재사용 가능하며 해결하는 문제가 매우 인기가 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>메소드 mapSafeFunction의 구현은 특별하거나 복잡한 것은 없습니다. 우리는 예외 처리 함수를 가져와 try/catch 예외 처리 논리를 처리하고 원래 함수를 호출하는 함수를 반환합니다. 추가적으로 Consumer<code>Exception</code>은 예외 로깅이나 처리 논리를 다루기 위한 유연한 API를 제공합니다. 호출자가 slf4j를 사용하여 예외를 로깅하거나, 콘솔에 로깅하거나, 소비자 내에서 런타임 예외를 다시 던지는 것을 막는 것은 없습니다. 이 방법은 덜 번거롭고 명시적이지 않은 API에 기본값을 제공하기위해 의도적으로 오버로드되었습니다.</p>
<p>동일한 패턴에 대한 유사한 사용 사례는 트랜잭션 관리 일 수도 있습니다. 함수가 호출되기 전에 트랜잭션을 시작하고, 끝에서 커밋하거나 예외가 발생했을 경우 롤백하는 전반적인 개념은 동일합니다.</p>
<h1>결론</h1>
<p>함수형 프로그래밍(또는 단순히 Java Stream API)을 이해하려면 함수형 인터페이스를 이해해야 하며, 이는 다시 제네릭 유형에 의존합니다. 이러한 주제들은 서로 긴밀하게 연결되어 있으며, 개인적인 관찰에 따르면 후자는 종종 간과됩니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 기사의 개념들은 하나씩 쉽게 이해할 수 있지만 함께 사용하면 사용할 수 있는 코드가 매우 재사용 가능하다는 것을 알 수 있습니다, 특히 예외 기능 데코레이터의 예시에서 확인할 수 있습니다. 더 많은 응용 프로그램이 있으며, 이 중 한 가지가 제 개인적인 취향입니다.</p>
<p>이 기사가 유익했고 이러한 개념을 실험하고 일상 프로젝트에 적용해 보는 호기심을 자극했기를 바랍니다. 이러한 기본적인 자바 개념은 자바에서 함수형 프로그래밍 패턴을 배우는 데 필요한 기본 블록으로 기능하지만, 이에 대해 더 알아보도록 하겠습니다.</p>
<p>향후 자바 개념 설명, 프레임워크 및 기타 기술 관련 콘텐츠에 구독하고 좋아요를 눌러주시기 바랍니다!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Java 제네릭을 이용한 다형 함수","description":"","date":"2024-06-19 22:03","slug":"2024-06-19-PolymorphicfunctionsusingJavagenerics","content":"\n자바 함수형 프로그래밍 구축 요소\n\n![이미지](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_0.png)\n\n이 기사는 제네릭 유형과 함수형 인터페이스를 사용하여 자바에서 다형성 함수를 작성하는 주제를 탐구합니다. 이 기본 사항은 종종 주니어 엔지니어에 의해 고려되지 않는다. 대신 Java 8+ Stream API와 같은 더 심화된 주제로 즉시 진입하는 것을 선호합니다. 그러나 이것들은 자바에서 함수형 프로그래밍 개념을 배우고 적용하며 더 깨끗하고 재사용 가능하며 선언적인 코드를 작성하는 데 필수적인 구축 요소입니다.\n\n기사 말미에서, 저는 모든 것을 매우 유용하고 실용적인 예제로 하나로 조합할 것입니다. 이 기사가 당신에게 매우 유용하고 실질적인 예제가 될 것이라고 기대합니다. 이 기사가 당신에게 단단한 기초를 제공하고 댓글 섹션이나 스스로 더 탐구하도록 격려할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 계속 읽기 전에 주의할 점은, 이 문서가 제네릭 및 함수형 인터페이스 개념 및 구문을 배우는 초보자용 완전한 자습서로 제공되는 것이 아니라는 것입니다. 이미 Java 공식 문서 및 다양한 자습서 웹사이트에 많은 이러한 자습서가 존재합니다. 우리는 기본 사항을 빠르게 살펴볼 것이며, 이 글의 주요 목적은 왜 그리고 어떻게 실제로 유용한지 깊게 이해하려는 것입니다.\n\n## Java 제네릭의 목적\n\n그렇다면 Java 제네릭의 목적은 무엇이며, 언제 유용할까요?\n\n가장 유혹적인 말은 \"공통 부모를 공유하는 클래스가 있는 재사용 가능한 코드를 작성하기 위해서\"라고 말하는 것입니다. — 또는 이와 같은 말입니다. 경우에 따라, 그리고 어느 정도로 그렇습니다. 하지만 이것이 정확히 무엇을 의미하는지는 무엇일까요? 아래 코드 조각을 살펴봅시다. 제네릭 유형을 사용하는 좋은 이유가 될까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_1.png)\n\n답은: no입니다. 이 코드는 다음 코드 스니펫에서 강조하는 것처럼 Dog 추상화 자체로 쉽게 바꿀 수 있습니다. 이러한 경우에는 제네릭을 사용할 필요가 없습니다.\n\n![image](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_2.png)\n\n그렇다면, Java 제네릭이 언제 진정으로 유용한가요? 먼저, 클래스 제네릭 유형과 메서드 제네릭 유형 두 가지 유형의 일반 유형이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클래스 제네릭 타입은 특히 여러 클래스 API 메소드들 사이에서 타입 일관성을 유지하는 데 유용합니다. 첫 번째 예시로는 List 인터페이스가 add나 get과 같은 여러 메소드에서 동일한 클래스 제네릭 타입 E를 시그니처에 재사용하는 것이 있습니다.\n\n메소드 제네릭 타입은 Java 언어의 설계 제한을 극복하는 데 도움을 줍니다. 클래스 제네릭 타입을 사용하는 클래스는 무변(invariant)이기 때문에(공변(covariant)이 아님) 메소드 제네릭 타입은 여러 메소드 매개변수 및/또는 반환 타입에 걸쳐 특정 타입을 강제하는 데 매우 유용합니다.\n\n실무에서 무변이 무엇을 의미하는지 예를 들어 설명하자면, List`String`은 String이 Object의 하위 타입이지만 List`Object`의 하위 타입이 아니라는 것입니다. 리스트가 무변이라는 것에 주목할 만한 점은 Java에서 배열은 공변적(covariant)이기 때문에(String[]는 Object[]를 확장합니다) 이 특정 목적을 위해 제네릭 메소드 타입을 사용할 필요가 없다는 것입니다.\n\n다음 코드 스니펫에서 Java의 공변성/무변성 관련하여 어떤 것이 허용되고, 어떤 것이 안 되는지 살펴볼 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_3.png\" /\u003e\n\n그래서 요약하면, Java 제네릭의 주요 목적은 개발자가 여러 가지 유형에서 재사용 가능한 코드를 작성하고 일관된 계약(클래스 수준 또는 메소드 수준)을 제공하는 동안 유연하게 작동하도록 하는 것입니다.\n\n## 제한된 제네릭 유형\n\n제네릭 유형은 상한, 하한 또는 명시적 바운드가 없을 수 있습니다(Object가 상한인 경우).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한계가 없는 제네릭 유형을 탐색해 봅시다. 이 유형들은 어떤 객체 유형이든 가능하게 합니다. 주로 여러 매개변수 및/또는 반환 유형에 동일한 유형을 적용하는 데 사용됩니다. 아래 코드 예제에서 볼 수 있듯이 다른 간단한 동작도 정의할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_4.png)\n\n아마도 가장 흔한 제네릭 사용 사례 중 하나는 상위 경계 제네릭 유형을 사용하는 것입니다. 이것은 소개 섹션에서 언급한 \"일반 부모\" 상속 기반 예제입니다. 아래 예제에서 강조되어 있습니다.\n\n![이미지](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 번 멈춰서 일반적인 유형이 우리에게 무엇을 하는지 두 가지 관점에서 이해해 봅시다: 호출자의 관점과 구현의 관점에서.\n\n이 API를 사용하는 사용자로서, List`Dog`나 Dog 하위 유형(예: List`GermanSheppard`)을 사용하여 findDogByNameGeneric(...)을 호출할 수 있습니다.\n\n메서드 구현 관점에서는 경계가 있는 일반 유형 `T extends Dog` 가 우리에게 강력한 보증을 제공하는데, 이는 우리가 받는 모든 목록이 요소가 부모 유형 Dog를 공유할 것이라는 것입니다. 이는 목록이 개발자에게 메서드 내에서 사용할 수 있는 요소를 생성할 수 있게 해줍니다(즉, 여기서는 Dog 및 특히 부모 인터페이스에서 정의된 getName()을 호출하는 경우).\n\n상한이 있는 제네릭 유형 목록으로는 요소를 추가할 수 없습니다. 이것을 생각해 보면 이해할 수 있으며, 그 이유를 찾아보는 것은 시간을 들여서 한 번 곰곰히 생각할 가치가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n[1초 후]\n\n상한이 정의된 제네릭 타입 목록에 요소를 추가할 수 없는 이유는 메서드 구현 내에서 호출된 목록의 실제 타입을 알 수 없기 때문입니다. 아래 예시를 살펴봅시다.\n\n![image](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_6.png)\n\n만약 상한이 정의된 타입에 추가할 수 있다면, List`Double` 입력 매개변수를 사용해 addSomething을 이론적으로 호출할 수 있고, 메서드 내에서 Double 목록에 Integer(또한 Number를 확장한)을 추가할 수 있습니다. 컴파일 시에 메서드가 어떤 타입으로 호출될지 알 수 없기 때문에, 언어가 목록의 타입 무결성을 잠재적으로 위반하지 못하도록 우리를 방해하는 것은 바로 이것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 우리가 일반 형식 소비자에 요소를 전달하려면(컬렉션이어야만 하는 것은 아님), 상위 바운드를 만들기 위해 super 키워드를 사용해야 합니다. 아래의 또 다른 예제를 살펴보고, 이전처럼 API 관점과 구현 관점에서 super가 우리에게 무엇을 보장해주는지 생각해봅시다.\n\n![image](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_7.png)\n\nAPI 관점에서는 populateGermanSheppards 메서드의 두 번째 매개변수는 List`GermanSheppard` 또는 그 상위 형식인 List`Dog`일 수 있습니다. 이게 구현 관점에서 왜 도움이 되는지 생각해 보세요.\n\n[또 다른 시간이 흘렀습니다]\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\npopulateGermanSheppards의 구현 내에서 두 번째 입력 매개변수가 List`GermanSheppard` 또는 List`Dog` 중 하나인 것을 알 수 있습니다. 따라서 해당 목록에 GermanSheppard를 추가해도 목록의 유형 무결성을 위반하지 않습니다. 왜냐하면 입력 매개변수 목록이 List`GermanSheppard`인 경우 GermanSheppard를 추가하는 것이 단순히 유효하며, List`Dog`인 경우 GermanSheppard는 Dog이므로 유형이 여전히 유효합니다. 더불어 부모 클래스에 대해서도 동일한 원리가 적용됩니다.\n\n매번 바운드된 제네릭 유형을 생각할 필요가 없도록, 간단히 PECS라는 머릿글자를 기억하면 됩니다. PECS는 Producer-Extends Consumer-Super의 약자로, 제네릭 메소드를 사용하여 상위 바운드 유형을 가진 요소를 생성/생산하는 요소들을 생산자로 정의합니다.\n\n소비자는 요소를 받아들일 수 있는 능력과 관련이 있습니다. 예를 들어 List의 add 메소드는 요소를 받아들일 수 있기 때문에 소비자이며, 목록의 제네릭 유형을 소비자-슈퍼로 제한할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금까지 우리가 논의한 것은 단순한 기본 구성 요소로, Java에서 일반적인 타입이 어떻게 실제로 작동하는지의 기본 설명입니다. 더 많은 내용이 있으며, 와일드카드 및 타입 이레이저에 대해 약간 읽어보고, 컬렉션을 중심으로하지 않는 더 많은 예시(예: Optional)를 살펴보면 일반 타입에 대해 더 익숙해질 수 있습니다.\n\n그러나 순수 일반 타입을 강조하는 좋은 예제를 제공하기가 어려운데, 적어도 내게는 이러한 타입의 가장 크고 일반적으로 사용되는 장점은 함수형 인터페이스와 결합될 때입니다. 이에 대해 더 자세히 알아보겠습니다.\n\n# 함수형 인터페이스 기본 사항\n\n함수형 인터페이스는 재사용 가능한 코드를 작성할 때 우리가 가진 도구 중 하나입니다. 또한 좋은 개발자 경험을 제공하는 유연한 API를 구축하고 싶다면 바운드된 제네릭 타입을 사용하여 개선할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이론적으로 함수형 인터페이스는 오직 하나의 비디폴트 메소드만 가진 인터페이스를 말합니다(즉, 구현이 없는 메소드가 하나뿐인 경우). 이러한 인터페이스들은 Java 유형을 제공하고 람다 표현식이나 메소드 참조 같은 호출 가능한 코드 조각을 참조하는 데 사용됩니다. 이러한 참조를 다른 객체 유형처럼 사용할 수 있게 해줍니다. 함수를 참조할 수 있고, 호출하지 않고 다른 함수에 전달할 수 있습니다.\n\nJava 8부터 Java JDK 내에 여러 유형의 함수형 인터페이스가 있습니다. 가장 기본적인 것은 Function`T, R`입니다. 이는 입력 T 집합을 가져와 R 집합의 결과를 출력하는 수학 함수와 동등합니다. 다만 여기서는 유형 인스턴스를 다루고 있을 뿐입니다. 함수형 프로그래밍에서는 이를 펑터라고도 부릅니다.\n\n함수 외에도 다음과 같이 계속해서 사용되는 함수형 인터페이스 유형들이 있습니다(그들의 Bi[…]variant인 BiFunction`T, U, R`와 함께), 이미 알고 계신지 모르겠지만 익숙해지기를 권장드립니다:\n\n- Predicate`T`: Function`T, Boolean`와 같은 역할을 합니다.\n- Consumer`T`: T형 인자를 가지고 void(아무것도)를 반환하는 함수를 나타냅니다.\n- Supplier`T`: 어떠한 인자도 받지 않고 T 유형 원소를 반환하는 함수를 나타냅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 많은 작업을 수행할 수 있는 메소드의 예시를 살펴봅니다. 원리적으로는 리스트의 요소를 반복하고 특정 조건에서 특정 작업을 수행합니다. 메소드 자체에서는 구체적인 내용은 정의되어 있지 않으며, 이는 꽤 추상적입니다.\n\n![이미지](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_8.png)\n\n추가로, 제 개인적인 의견으로는 함수형 인터페이스를 사용하여 지나치게 추상화된 일반적인 함수를 작성하는 것도 코드 재사용성을 위해 코드 가독성을 너무 희생하는 경우 반대 패턴으로 간주해야 한다고 생각합니다. 둘 사이에는 균형이 필요하며, 재사용 가능한 일반적인 메소드에서 구체적이고 정당화할 수 있는 문제를 해결하도록 노력해야 합니다.\n\n조건부 요소 소비자(conditionalElementsConsumer) 메소드 시그니처가 어떻게 보일지 생각해 보세요. 일반적인 타입을 완화하고 한정적인(혹은 제한된) 일반적인 타입을 사용한다면 어떨까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n[a second of thinking passes]\n\nPECS 약자에 대해 간단히 생각해 보면, 느슨한 서명은 다음 예시와 같은 형태여야 합니다.\n\n![이미지](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_9.png)\n\n새 예시에서 이전의 제한된 제네릭 유형이 새로운 케이스를 지원하기에 충분히 유연하지 못했음을 알 수 있습니다. 이 간단한 기능 인터페이스를 사용해 개념을 설명하고 있지만, 실제 프로젝트에서는 타입이 일치하도록 바꿀 수 없는 서드파티 코드의 메서드 참조와 유사한 상황을 마주하게 될 수 있습니다. 경계를 통해 제네릭 유형을 느슨하게 처리하면 이를 해결하는 데 도움이 될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 지점에서 또 다른 좋은 연습은 위의 예제를 생각하고 152번 라인에서 컴파일 되는 메소드 호출의 실제 T 유형을 파악해 보는 것입니다.\n\n함수형 인터페이스의 기본을 더 깊이 들어가지는 않겠습니다. 다양한 다른 유형에 대해 이야기하는 많은 기사들과 람다 표현식, 메소드 참조에 대해 참조할 수 있는 함수형 인터페이스 유형도 있습니다.\n\n그러나 이러한 기본 개념을 조합하여 실제 유용한 재사용 가능한 코드를 만들 수 있는 방법을 강조하는 데는 조금 더 나아갈 것입니다.\n\n# 고차 함수를 통한 데코레이터\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n고차 함수는 다른 함수를 매개변수로 받거나 함수를 반환하는 함수형 프로그래밍 개념을 나타냅니다.\n\n이를 생각하면, 실제로 호출하지 않고 일반 함수를 래핑하는 데코레이터와 유사한 디자인 패턴을 이론적으로 정의할 수 있습니다.\n\n많이 접하게 되는 예시 중 하나는 확인된 예외를 throw하는 함수를 처리하는 것입니다. 이는 특히 Stream API 메소드 호출 내에서 문제가 될 수 있습니다. Stream API 메소드는 예외를 throw하지 않는 함수형 인터페이스를 입력 매개변수로 사용하기 때문입니다. 물론 Vavr과 같은 라이브러리를 사용할 수도 있지만, 사용 사례가 제한적이고 종속성 목록을 작게 유지하고 싶다면 직접 래퍼/핸들러를 구축하는 것이 더 나은 옵션이 될 수 있습니다. 아래 예시에서 (인기 있는) 상황을 확인해보세요.\n\n![이미지](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_10.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저, 위의 코드에서 발생한 컴파일 오류는 map 메서드에서 예상되는 메서드 시그니처 (즉, Function`T, R`)와 제공된 함수가 String을 가져와 List`String`을 반환하거나 IO Exception을 던질 수 있는 함수임을 고려할 때 발생합니다 (이러한 의미로는 JDK에 기본적으로 해당 함수형 인터페이스가 없음).\n\n이러한 유형의 불일치를 다루는 비제네릭하고 간단한 방법은 발생한 예외를 별도의 메서드로 분리하여 거기서 예외를 처리하는 것입니다. 이렇게 하면 사실상 Stream::map 메서드에 대해 Function`String, List`String`` 입력 매개변수로 변환될 것이며 이는 컴파일이 될 것입니다. 그러나 제네릭 및 함수 인터페이스를 통해 코드 재사용할 수 있는 큰 기회가 있다는 것을 다음 예제에서 확인할 수 있습니다.\n\n![Example](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_11.png)\n\n위의 코드 예제를 조금 설명해보겠습니다. 먼저, 제시된 3가지 옵션 중 어느 것을 사용하더라도 더 이상 컴파일 오류가 발생하지 않음을 관찰할 수 있습니다. 이제 map 메서드는 호출 시 예상대로 Function`Path, List`String``를 받는다고 볼 수 있는 mapSafeFunction을 수신하며, 또한 ExceptionalFunction 인터페이스를 정의할 때 코드가 완벽하게 컴파일되고 Files::readAllLines 메서드 참조가 어떤 컴파일 오류도 없이 허용됩니다. 즉, 이 문제는 예외 처리가 되지 않았던 것이 아니라 함수형 인터페이스 타입이 일치하지 않았기 때문임을 결론짓습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n수학 함수에 대해 생각해보면, 입력을 받아 출력을 제공하며 예외를 throw하지 않습니다. 마찬가지로 여기서는 예외를 throw하는 함수를 throw하지 않는 함수로 변환하려고 합니다. 그렇다면 예외가 발생했을 때 어떻게 해야 할까요?\n\n이것은 완전히 개인적인 선택이었지만, 예외가 발생한 경우 결과가 없을 수도 있다는 사실을 나타내기 위해 생성된 함수가 Optional을 반환하도록 만들기를 원했습니다. 이것이 ExceptionalFunction`T, R`의 입력에 대한 반환 타입이 Function`T, Optional`R``로 되어 있는 이유입니다. 이전 Optional::map 작업이 flatmap 작업으로 변경되어 코드 전체에 매우 잘 맞는 점에 주목하면 좋습니다(Javadoc 여기를 참조하세요). 예외가 발생하면 Optional 체인이 빈 결과를 제공하며 코드는 전반적으로 매우 깨끗하고 순조롭게 따라갈 수 있습니다.\n\n(부기적으로, 예외를 완전히 억제하거나 런타임 예외로 다시 던지거나 null을 반환하는 API 디자인 선택은 개발자 경험 관점에서 객관적으로 잘못된 접근법이라고 생각합니다. 주된 주장은 계약이 그냥 틀렸다는 것이며, 예기치 않은 동작이 API를 통해 추론될 수 없다는 점이며, 코드를 읽어야만 이해할 수 있다는 것입니다.)\n\nmapSafeFunction의 구현은 Files::readAllLines 또는 예외를 throw하는 기타 함수에 적용할 수 있습니다. 이 메서드는 전체 프로젝트 전반에 걸쳐 매우 재사용 가능하며 해결하는 문제가 매우 인기가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n메소드 mapSafeFunction의 구현은 특별하거나 복잡한 것은 없습니다. 우리는 예외 처리 함수를 가져와 try/catch 예외 처리 논리를 처리하고 원래 함수를 호출하는 함수를 반환합니다. 추가적으로 Consumer`Exception`은 예외 로깅이나 처리 논리를 다루기 위한 유연한 API를 제공합니다. 호출자가 slf4j를 사용하여 예외를 로깅하거나, 콘솔에 로깅하거나, 소비자 내에서 런타임 예외를 다시 던지는 것을 막는 것은 없습니다. 이 방법은 덜 번거롭고 명시적이지 않은 API에 기본값을 제공하기위해 의도적으로 오버로드되었습니다.\n\n동일한 패턴에 대한 유사한 사용 사례는 트랜잭션 관리 일 수도 있습니다. 함수가 호출되기 전에 트랜잭션을 시작하고, 끝에서 커밋하거나 예외가 발생했을 경우 롤백하는 전반적인 개념은 동일합니다.\n\n# 결론\n\n함수형 프로그래밍(또는 단순히 Java Stream API)을 이해하려면 함수형 인터페이스를 이해해야 하며, 이는 다시 제네릭 유형에 의존합니다. 이러한 주제들은 서로 긴밀하게 연결되어 있으며, 개인적인 관찰에 따르면 후자는 종종 간과됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사의 개념들은 하나씩 쉽게 이해할 수 있지만 함께 사용하면 사용할 수 있는 코드가 매우 재사용 가능하다는 것을 알 수 있습니다, 특히 예외 기능 데코레이터의 예시에서 확인할 수 있습니다. 더 많은 응용 프로그램이 있으며, 이 중 한 가지가 제 개인적인 취향입니다.\n\n이 기사가 유익했고 이러한 개념을 실험하고 일상 프로젝트에 적용해 보는 호기심을 자극했기를 바랍니다. 이러한 기본적인 자바 개념은 자바에서 함수형 프로그래밍 패턴을 배우는 데 필요한 기본 블록으로 기능하지만, 이에 대해 더 알아보도록 하겠습니다.\n\n향후 자바 개념 설명, 프레임워크 및 기타 기술 관련 콘텐츠에 구독하고 좋아요를 눌러주시기 바랍니다!\n","ogImage":{"url":"/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_0.png"},"coverImage":"/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_0.png","tag":["Tech"],"readingTime":15},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e자바 함수형 프로그래밍 구축 요소\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이 기사는 제네릭 유형과 함수형 인터페이스를 사용하여 자바에서 다형성 함수를 작성하는 주제를 탐구합니다. 이 기본 사항은 종종 주니어 엔지니어에 의해 고려되지 않는다. 대신 Java 8+ Stream API와 같은 더 심화된 주제로 즉시 진입하는 것을 선호합니다. 그러나 이것들은 자바에서 함수형 프로그래밍 개념을 배우고 적용하며 더 깨끗하고 재사용 가능하며 선언적인 코드를 작성하는 데 필수적인 구축 요소입니다.\u003c/p\u003e\n\u003cp\u003e기사 말미에서, 저는 모든 것을 매우 유용하고 실용적인 예제로 하나로 조합할 것입니다. 이 기사가 당신에게 매우 유용하고 실질적인 예제가 될 것이라고 기대합니다. 이 기사가 당신에게 단단한 기초를 제공하고 댓글 섹션이나 스스로 더 탐구하도록 격려할 것입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그러나 계속 읽기 전에 주의할 점은, 이 문서가 제네릭 및 함수형 인터페이스 개념 및 구문을 배우는 초보자용 완전한 자습서로 제공되는 것이 아니라는 것입니다. 이미 Java 공식 문서 및 다양한 자습서 웹사이트에 많은 이러한 자습서가 존재합니다. 우리는 기본 사항을 빠르게 살펴볼 것이며, 이 글의 주요 목적은 왜 그리고 어떻게 실제로 유용한지 깊게 이해하려는 것입니다.\u003c/p\u003e\n\u003ch2\u003eJava 제네릭의 목적\u003c/h2\u003e\n\u003cp\u003e그렇다면 Java 제네릭의 목적은 무엇이며, 언제 유용할까요?\u003c/p\u003e\n\u003cp\u003e가장 유혹적인 말은 \"공통 부모를 공유하는 클래스가 있는 재사용 가능한 코드를 작성하기 위해서\"라고 말하는 것입니다. — 또는 이와 같은 말입니다. 경우에 따라, 그리고 어느 정도로 그렇습니다. 하지만 이것이 정확히 무엇을 의미하는지는 무엇일까요? 아래 코드 조각을 살펴봅시다. 제네릭 유형을 사용하는 좋은 이유가 될까요?\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e답은: no입니다. 이 코드는 다음 코드 스니펫에서 강조하는 것처럼 Dog 추상화 자체로 쉽게 바꿀 수 있습니다. 이러한 경우에는 제네릭을 사용할 필요가 없습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_2.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e그렇다면, Java 제네릭이 언제 진정으로 유용한가요? 먼저, 클래스 제네릭 유형과 메서드 제네릭 유형 두 가지 유형의 일반 유형이 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e클래스 제네릭 타입은 특히 여러 클래스 API 메소드들 사이에서 타입 일관성을 유지하는 데 유용합니다. 첫 번째 예시로는 List 인터페이스가 add나 get과 같은 여러 메소드에서 동일한 클래스 제네릭 타입 E를 시그니처에 재사용하는 것이 있습니다.\u003c/p\u003e\n\u003cp\u003e메소드 제네릭 타입은 Java 언어의 설계 제한을 극복하는 데 도움을 줍니다. 클래스 제네릭 타입을 사용하는 클래스는 무변(invariant)이기 때문에(공변(covariant)이 아님) 메소드 제네릭 타입은 여러 메소드 매개변수 및/또는 반환 타입에 걸쳐 특정 타입을 강제하는 데 매우 유용합니다.\u003c/p\u003e\n\u003cp\u003e실무에서 무변이 무엇을 의미하는지 예를 들어 설명하자면, List\u003ccode\u003eString\u003c/code\u003e은 String이 Object의 하위 타입이지만 List\u003ccode\u003eObject\u003c/code\u003e의 하위 타입이 아니라는 것입니다. 리스트가 무변이라는 것에 주목할 만한 점은 Java에서 배열은 공변적(covariant)이기 때문에(String[]는 Object[]를 확장합니다) 이 특정 목적을 위해 제네릭 메소드 타입을 사용할 필요가 없다는 것입니다.\u003c/p\u003e\n\u003cp\u003e다음 코드 스니펫에서 Java의 공변성/무변성 관련하여 어떤 것이 허용되고, 어떤 것이 안 되는지 살펴볼 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_3.png\"\u003e\n\u003cp\u003e그래서 요약하면, Java 제네릭의 주요 목적은 개발자가 여러 가지 유형에서 재사용 가능한 코드를 작성하고 일관된 계약(클래스 수준 또는 메소드 수준)을 제공하는 동안 유연하게 작동하도록 하는 것입니다.\u003c/p\u003e\n\u003ch2\u003e제한된 제네릭 유형\u003c/h2\u003e\n\u003cp\u003e제네릭 유형은 상한, 하한 또는 명시적 바운드가 없을 수 있습니다(Object가 상한인 경우).\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e한계가 없는 제네릭 유형을 탐색해 봅시다. 이 유형들은 어떤 객체 유형이든 가능하게 합니다. 주로 여러 매개변수 및/또는 반환 유형에 동일한 유형을 적용하는 데 사용됩니다. 아래 코드 예제에서 볼 수 있듯이 다른 간단한 동작도 정의할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e아마도 가장 흔한 제네릭 사용 사례 중 하나는 상위 경계 제네릭 유형을 사용하는 것입니다. 이것은 소개 섹션에서 언급한 \"일반 부모\" 상속 기반 예제입니다. 아래 예제에서 강조되어 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e한 번 멈춰서 일반적인 유형이 우리에게 무엇을 하는지 두 가지 관점에서 이해해 봅시다: 호출자의 관점과 구현의 관점에서.\u003c/p\u003e\n\u003cp\u003e이 API를 사용하는 사용자로서, List\u003ccode\u003eDog\u003c/code\u003e나 Dog 하위 유형(예: List\u003ccode\u003eGermanSheppard\u003c/code\u003e)을 사용하여 findDogByNameGeneric(...)을 호출할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e메서드 구현 관점에서는 경계가 있는 일반 유형 \u003ccode\u003eT extends Dog\u003c/code\u003e 가 우리에게 강력한 보증을 제공하는데, 이는 우리가 받는 모든 목록이 요소가 부모 유형 Dog를 공유할 것이라는 것입니다. 이는 목록이 개발자에게 메서드 내에서 사용할 수 있는 요소를 생성할 수 있게 해줍니다(즉, 여기서는 Dog 및 특히 부모 인터페이스에서 정의된 getName()을 호출하는 경우).\u003c/p\u003e\n\u003cp\u003e상한이 있는 제네릭 유형 목록으로는 요소를 추가할 수 없습니다. 이것을 생각해 보면 이해할 수 있으며, 그 이유를 찾아보는 것은 시간을 들여서 한 번 곰곰히 생각할 가치가 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e[1초 후]\u003c/p\u003e\n\u003cp\u003e상한이 정의된 제네릭 타입 목록에 요소를 추가할 수 없는 이유는 메서드 구현 내에서 호출된 목록의 실제 타입을 알 수 없기 때문입니다. 아래 예시를 살펴봅시다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_6.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e만약 상한이 정의된 타입에 추가할 수 있다면, List\u003ccode\u003eDouble\u003c/code\u003e 입력 매개변수를 사용해 addSomething을 이론적으로 호출할 수 있고, 메서드 내에서 Double 목록에 Integer(또한 Number를 확장한)을 추가할 수 있습니다. 컴파일 시에 메서드가 어떤 타입으로 호출될지 알 수 없기 때문에, 언어가 목록의 타입 무결성을 잠재적으로 위반하지 못하도록 우리를 방해하는 것은 바로 이것입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e만약 우리가 일반 형식 소비자에 요소를 전달하려면(컬렉션이어야만 하는 것은 아님), 상위 바운드를 만들기 위해 super 키워드를 사용해야 합니다. 아래의 또 다른 예제를 살펴보고, 이전처럼 API 관점과 구현 관점에서 super가 우리에게 무엇을 보장해주는지 생각해봅시다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_7.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eAPI 관점에서는 populateGermanSheppards 메서드의 두 번째 매개변수는 List\u003ccode\u003eGermanSheppard\u003c/code\u003e 또는 그 상위 형식인 List\u003ccode\u003eDog\u003c/code\u003e일 수 있습니다. 이게 구현 관점에서 왜 도움이 되는지 생각해 보세요.\u003c/p\u003e\n\u003cp\u003e[또 다른 시간이 흘렀습니다]\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003epopulateGermanSheppards의 구현 내에서 두 번째 입력 매개변수가 List\u003ccode\u003eGermanSheppard\u003c/code\u003e 또는 List\u003ccode\u003eDog\u003c/code\u003e 중 하나인 것을 알 수 있습니다. 따라서 해당 목록에 GermanSheppard를 추가해도 목록의 유형 무결성을 위반하지 않습니다. 왜냐하면 입력 매개변수 목록이 List\u003ccode\u003eGermanSheppard\u003c/code\u003e인 경우 GermanSheppard를 추가하는 것이 단순히 유효하며, List\u003ccode\u003eDog\u003c/code\u003e인 경우 GermanSheppard는 Dog이므로 유형이 여전히 유효합니다. 더불어 부모 클래스에 대해서도 동일한 원리가 적용됩니다.\u003c/p\u003e\n\u003cp\u003e매번 바운드된 제네릭 유형을 생각할 필요가 없도록, 간단히 PECS라는 머릿글자를 기억하면 됩니다. PECS는 Producer-Extends Consumer-Super의 약자로, 제네릭 메소드를 사용하여 상위 바운드 유형을 가진 요소를 생성/생산하는 요소들을 생산자로 정의합니다.\u003c/p\u003e\n\u003cp\u003e소비자는 요소를 받아들일 수 있는 능력과 관련이 있습니다. 예를 들어 List의 add 메소드는 요소를 받아들일 수 있기 때문에 소비자이며, 목록의 제네릭 유형을 소비자-슈퍼로 제한할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e지금까지 우리가 논의한 것은 단순한 기본 구성 요소로, Java에서 일반적인 타입이 어떻게 실제로 작동하는지의 기본 설명입니다. 더 많은 내용이 있으며, 와일드카드 및 타입 이레이저에 대해 약간 읽어보고, 컬렉션을 중심으로하지 않는 더 많은 예시(예: Optional)를 살펴보면 일반 타입에 대해 더 익숙해질 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그러나 순수 일반 타입을 강조하는 좋은 예제를 제공하기가 어려운데, 적어도 내게는 이러한 타입의 가장 크고 일반적으로 사용되는 장점은 함수형 인터페이스와 결합될 때입니다. 이에 대해 더 자세히 알아보겠습니다.\u003c/p\u003e\n\u003ch1\u003e함수형 인터페이스 기본 사항\u003c/h1\u003e\n\u003cp\u003e함수형 인터페이스는 재사용 가능한 코드를 작성할 때 우리가 가진 도구 중 하나입니다. 또한 좋은 개발자 경험을 제공하는 유연한 API를 구축하고 싶다면 바운드된 제네릭 타입을 사용하여 개선할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이론적으로 함수형 인터페이스는 오직 하나의 비디폴트 메소드만 가진 인터페이스를 말합니다(즉, 구현이 없는 메소드가 하나뿐인 경우). 이러한 인터페이스들은 Java 유형을 제공하고 람다 표현식이나 메소드 참조 같은 호출 가능한 코드 조각을 참조하는 데 사용됩니다. 이러한 참조를 다른 객체 유형처럼 사용할 수 있게 해줍니다. 함수를 참조할 수 있고, 호출하지 않고 다른 함수에 전달할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eJava 8부터 Java JDK 내에 여러 유형의 함수형 인터페이스가 있습니다. 가장 기본적인 것은 Function\u003ccode\u003eT, R\u003c/code\u003e입니다. 이는 입력 T 집합을 가져와 R 집합의 결과를 출력하는 수학 함수와 동등합니다. 다만 여기서는 유형 인스턴스를 다루고 있을 뿐입니다. 함수형 프로그래밍에서는 이를 펑터라고도 부릅니다.\u003c/p\u003e\n\u003cp\u003e함수 외에도 다음과 같이 계속해서 사용되는 함수형 인터페이스 유형들이 있습니다(그들의 Bi[…]variant인 BiFunction\u003ccode\u003eT, U, R\u003c/code\u003e와 함께), 이미 알고 계신지 모르겠지만 익숙해지기를 권장드립니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePredicate\u003ccode\u003eT\u003c/code\u003e: Function\u003ccode\u003eT, Boolean\u003c/code\u003e와 같은 역할을 합니다.\u003c/li\u003e\n\u003cli\u003eConsumer\u003ccode\u003eT\u003c/code\u003e: T형 인자를 가지고 void(아무것도)를 반환하는 함수를 나타냅니다.\u003c/li\u003e\n\u003cli\u003eSupplier\u003ccode\u003eT\u003c/code\u003e: 어떠한 인자도 받지 않고 T 유형 원소를 반환하는 함수를 나타냅니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다음은 많은 작업을 수행할 수 있는 메소드의 예시를 살펴봅니다. 원리적으로는 리스트의 요소를 반복하고 특정 조건에서 특정 작업을 수행합니다. 메소드 자체에서는 구체적인 내용은 정의되어 있지 않으며, 이는 꽤 추상적입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_8.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e추가로, 제 개인적인 의견으로는 함수형 인터페이스를 사용하여 지나치게 추상화된 일반적인 함수를 작성하는 것도 코드 재사용성을 위해 코드 가독성을 너무 희생하는 경우 반대 패턴으로 간주해야 한다고 생각합니다. 둘 사이에는 균형이 필요하며, 재사용 가능한 일반적인 메소드에서 구체적이고 정당화할 수 있는 문제를 해결하도록 노력해야 합니다.\u003c/p\u003e\n\u003cp\u003e조건부 요소 소비자(conditionalElementsConsumer) 메소드 시그니처가 어떻게 보일지 생각해 보세요. 일반적인 타입을 완화하고 한정적인(혹은 제한된) 일반적인 타입을 사용한다면 어떨까요?\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e[a second of thinking passes]\u003c/p\u003e\n\u003cp\u003ePECS 약자에 대해 간단히 생각해 보면, 느슨한 서명은 다음 예시와 같은 형태여야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_9.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e새 예시에서 이전의 제한된 제네릭 유형이 새로운 케이스를 지원하기에 충분히 유연하지 못했음을 알 수 있습니다. 이 간단한 기능 인터페이스를 사용해 개념을 설명하고 있지만, 실제 프로젝트에서는 타입이 일치하도록 바꿀 수 없는 서드파티 코드의 메서드 참조와 유사한 상황을 마주하게 될 수 있습니다. 경계를 통해 제네릭 유형을 느슨하게 처리하면 이를 해결하는 데 도움이 될 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 지점에서 또 다른 좋은 연습은 위의 예제를 생각하고 152번 라인에서 컴파일 되는 메소드 호출의 실제 T 유형을 파악해 보는 것입니다.\u003c/p\u003e\n\u003cp\u003e함수형 인터페이스의 기본을 더 깊이 들어가지는 않겠습니다. 다양한 다른 유형에 대해 이야기하는 많은 기사들과 람다 표현식, 메소드 참조에 대해 참조할 수 있는 함수형 인터페이스 유형도 있습니다.\u003c/p\u003e\n\u003cp\u003e그러나 이러한 기본 개념을 조합하여 실제 유용한 재사용 가능한 코드를 만들 수 있는 방법을 강조하는 데는 조금 더 나아갈 것입니다.\u003c/p\u003e\n\u003ch1\u003e고차 함수를 통한 데코레이터\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e고차 함수는 다른 함수를 매개변수로 받거나 함수를 반환하는 함수형 프로그래밍 개념을 나타냅니다.\u003c/p\u003e\n\u003cp\u003e이를 생각하면, 실제로 호출하지 않고 일반 함수를 래핑하는 데코레이터와 유사한 디자인 패턴을 이론적으로 정의할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e많이 접하게 되는 예시 중 하나는 확인된 예외를 throw하는 함수를 처리하는 것입니다. 이는 특히 Stream API 메소드 호출 내에서 문제가 될 수 있습니다. Stream API 메소드는 예외를 throw하지 않는 함수형 인터페이스를 입력 매개변수로 사용하기 때문입니다. 물론 Vavr과 같은 라이브러리를 사용할 수도 있지만, 사용 사례가 제한적이고 종속성 목록을 작게 유지하고 싶다면 직접 래퍼/핸들러를 구축하는 것이 더 나은 옵션이 될 수 있습니다. 아래 예시에서 (인기 있는) 상황을 확인해보세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_10.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e먼저, 위의 코드에서 발생한 컴파일 오류는 map 메서드에서 예상되는 메서드 시그니처 (즉, Function\u003ccode\u003eT, R\u003c/code\u003e)와 제공된 함수가 String을 가져와 List\u003ccode\u003eString\u003c/code\u003e을 반환하거나 IO Exception을 던질 수 있는 함수임을 고려할 때 발생합니다 (이러한 의미로는 JDK에 기본적으로 해당 함수형 인터페이스가 없음).\u003c/p\u003e\n\u003cp\u003e이러한 유형의 불일치를 다루는 비제네릭하고 간단한 방법은 발생한 예외를 별도의 메서드로 분리하여 거기서 예외를 처리하는 것입니다. 이렇게 하면 사실상 Stream::map 메서드에 대해 Function\u003ccode\u003eString, List\u003c/code\u003eString`` 입력 매개변수로 변환될 것이며 이는 컴파일이 될 것입니다. 그러나 제네릭 및 함수 인터페이스를 통해 코드 재사용할 수 있는 큰 기회가 있다는 것을 다음 예제에서 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_11.png\" alt=\"Example\"\u003e\u003c/p\u003e\n\u003cp\u003e위의 코드 예제를 조금 설명해보겠습니다. 먼저, 제시된 3가지 옵션 중 어느 것을 사용하더라도 더 이상 컴파일 오류가 발생하지 않음을 관찰할 수 있습니다. 이제 map 메서드는 호출 시 예상대로 Function\u003ccode\u003ePath, List\u003c/code\u003eString``를 받는다고 볼 수 있는 mapSafeFunction을 수신하며, 또한 ExceptionalFunction 인터페이스를 정의할 때 코드가 완벽하게 컴파일되고 Files::readAllLines 메서드 참조가 어떤 컴파일 오류도 없이 허용됩니다. 즉, 이 문제는 예외 처리가 되지 않았던 것이 아니라 함수형 인터페이스 타입이 일치하지 않았기 때문임을 결론짓습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e수학 함수에 대해 생각해보면, 입력을 받아 출력을 제공하며 예외를 throw하지 않습니다. 마찬가지로 여기서는 예외를 throw하는 함수를 throw하지 않는 함수로 변환하려고 합니다. 그렇다면 예외가 발생했을 때 어떻게 해야 할까요?\u003c/p\u003e\n\u003cp\u003e이것은 완전히 개인적인 선택이었지만, 예외가 발생한 경우 결과가 없을 수도 있다는 사실을 나타내기 위해 생성된 함수가 Optional을 반환하도록 만들기를 원했습니다. 이것이 ExceptionalFunction\u003ccode\u003eT, R\u003c/code\u003e의 입력에 대한 반환 타입이 Function\u003ccode\u003eT, Optional\u003c/code\u003eR``로 되어 있는 이유입니다. 이전 Optional::map 작업이 flatmap 작업으로 변경되어 코드 전체에 매우 잘 맞는 점에 주목하면 좋습니다(Javadoc 여기를 참조하세요). 예외가 발생하면 Optional 체인이 빈 결과를 제공하며 코드는 전반적으로 매우 깨끗하고 순조롭게 따라갈 수 있습니다.\u003c/p\u003e\n\u003cp\u003e(부기적으로, 예외를 완전히 억제하거나 런타임 예외로 다시 던지거나 null을 반환하는 API 디자인 선택은 개발자 경험 관점에서 객관적으로 잘못된 접근법이라고 생각합니다. 주된 주장은 계약이 그냥 틀렸다는 것이며, 예기치 않은 동작이 API를 통해 추론될 수 없다는 점이며, 코드를 읽어야만 이해할 수 있다는 것입니다.)\u003c/p\u003e\n\u003cp\u003emapSafeFunction의 구현은 Files::readAllLines 또는 예외를 throw하는 기타 함수에 적용할 수 있습니다. 이 메서드는 전체 프로젝트 전반에 걸쳐 매우 재사용 가능하며 해결하는 문제가 매우 인기가 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e메소드 mapSafeFunction의 구현은 특별하거나 복잡한 것은 없습니다. 우리는 예외 처리 함수를 가져와 try/catch 예외 처리 논리를 처리하고 원래 함수를 호출하는 함수를 반환합니다. 추가적으로 Consumer\u003ccode\u003eException\u003c/code\u003e은 예외 로깅이나 처리 논리를 다루기 위한 유연한 API를 제공합니다. 호출자가 slf4j를 사용하여 예외를 로깅하거나, 콘솔에 로깅하거나, 소비자 내에서 런타임 예외를 다시 던지는 것을 막는 것은 없습니다. 이 방법은 덜 번거롭고 명시적이지 않은 API에 기본값을 제공하기위해 의도적으로 오버로드되었습니다.\u003c/p\u003e\n\u003cp\u003e동일한 패턴에 대한 유사한 사용 사례는 트랜잭션 관리 일 수도 있습니다. 함수가 호출되기 전에 트랜잭션을 시작하고, 끝에서 커밋하거나 예외가 발생했을 경우 롤백하는 전반적인 개념은 동일합니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e함수형 프로그래밍(또는 단순히 Java Stream API)을 이해하려면 함수형 인터페이스를 이해해야 하며, 이는 다시 제네릭 유형에 의존합니다. 이러한 주제들은 서로 긴밀하게 연결되어 있으며, 개인적인 관찰에 따르면 후자는 종종 간과됩니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 기사의 개념들은 하나씩 쉽게 이해할 수 있지만 함께 사용하면 사용할 수 있는 코드가 매우 재사용 가능하다는 것을 알 수 있습니다, 특히 예외 기능 데코레이터의 예시에서 확인할 수 있습니다. 더 많은 응용 프로그램이 있으며, 이 중 한 가지가 제 개인적인 취향입니다.\u003c/p\u003e\n\u003cp\u003e이 기사가 유익했고 이러한 개념을 실험하고 일상 프로젝트에 적용해 보는 호기심을 자극했기를 바랍니다. 이러한 기본적인 자바 개념은 자바에서 함수형 프로그래밍 패턴을 배우는 데 필요한 기본 블록으로 기능하지만, 이에 대해 더 알아보도록 하겠습니다.\u003c/p\u003e\n\u003cp\u003e향후 자바 개념 설명, 프레임워크 및 기타 기술 관련 콘텐츠에 구독하고 좋아요를 눌러주시기 바랍니다!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-PolymorphicfunctionsusingJavagenerics"},"buildId":"YUMR4jSyk_WlOHHc7UfOk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>