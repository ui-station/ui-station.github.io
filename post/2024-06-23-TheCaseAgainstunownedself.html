<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Unowned self 개념의 문제점 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-23-TheCaseAgainstunownedself" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Unowned self 개념의 문제점 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Unowned self 개념의 문제점 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-TheCaseAgainstunownedself_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-23-TheCaseAgainstunownedself" data-gatsby-head="true"/><meta name="twitter:title" content="Unowned self 개념의 문제점 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-TheCaseAgainstunownedself_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 23:36" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/YUMR4jSyk_WlOHHc7UfOk/_buildManifest.js" defer=""></script><script src="/_next/static/YUMR4jSyk_WlOHHc7UfOk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Unowned self 개념의 문제점</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Unowned self 개념의 문제점" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-TheCaseAgainstunownedself&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-23-TheCaseAgainstunownedself_0.png" alt="2024-06-23-TheCaseAgainstunownedself_0.png"></p>
<p>클래스, 클로저 또는 액터를 사용할 때마다 Swift는 힙(heap)에 정보를 저장합니다. 전달하는 변수는 실제로 메모리의 주소(즉, 참조)를 가리키는 포인터입니다.</p>
<p>옛날에는 Mac과 iOS 개발자들이 이 메모리를 수동으로 관리해야 했습니다. heap에 메모리 블록을 만들기 위해 alloc()을 사용하고 다른 참조를 추가하기 위해 retain()을 사용하며 메모리를 해제하기 위해 release()를 사용합니다.</p>
<p>2011년, Apple은 ARC(자동 참조 카운트)를 소개했으며, 이를 통해 컴파일러가 이러한 보일러플레이트 메모리 관리 코드를 자동으로 작성하도록 하여, 축적된 개발 시간을 절약했습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>ARC는 다양한 종류의 참조 개념을 소개했습니다.</p>
<h2>강한 참조</h2>
<p>이것은 기본 참조입니다. 포인터가 사용 중일 때 가리키는 메모리를 유지합니다.</p>
<p>강한 참조를 만드는 동안 힙 객체의 참조 카운트(또는 refCount)가 증가하고, refCount가 0이 되면 객체가 할당 해제되어 힙에 있는 메모리가 해제됩니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>약한 참조</h2>
<p>약한 참조는 힙 객체들이 서로를 가리키면서 유지주기 문제 없이 회피할 수 있게 해줍니다. 이를 통해 개발자들은 클로저와 델리게이트에서 클래스에 대한 참조를 생성하지만 불필요하게 객체들을 유지할 필요가 없어집니다.</p>
<p>약한 참조는 refCount가 증가하지 않으면서 메모리의 힙 객체를 가리킵니다. 만약 refCount가 제로가 되면 객체는 해제되고 약한 참조는 nil이 됩니다— 이는 클로저에서 메모리 누수를 방지합니다.</p>
<p>이 작동방식을 다루기 위해 약한 참조는 항상 optional로 래핑되어 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-swift"><span class="hljs-comment">// StoreViewModel.swift</span>

<span class="hljs-keyword">func</span> <span class="hljs-title function_">loadStorefront</span>() {
    api.fetchInventory() { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] inventory <span class="hljs-keyword">in</span>
        <span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.inventory <span class="hljs-operator">=</span> inventory
    }
}
</code></pre>
<p>이 예에서 인벤토리는 네트워크를 통해 가져오며, 데이터가 도착하면 클로저 콜백이 실행됩니다. self는 약한 참조로 캡처되어 StoreViewModel의 속성이 클로저에서 업데이트될 수 있음을 의미합니다. 사용자가 화면을 나가면 뷰 모델의 강한 참조 수가 0이 되면 런타임이 뷰 모델을 해제할 수 있으므로, 콜백을 기다리는 동안 메모리에 유지되지 않고 인벤토리가 반환될 때 아무 일도 일어나지 않습니다.</p>
<h2>Unowned references</h2>
<p>리테인 사이클을 방지하기 위해 Swift에서 세 번째 종류의 참조인 unowned가 소개되었습니다. 이는 약한 참조와 유사하게 동작하지만 참조 대상 객체의 메모리가 항상 해당 객체를 참조하는 unowned 포인터보다 오래 존속할 것으로 가정합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-swift"><span class="hljs-comment">// StoreSingleton.swift</span>

<span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> sharedInstance <span class="hljs-operator">=</span> <span class="hljs-type">StoreSingleton</span>()

<span class="hljs-keyword">private</span> <span class="hljs-keyword">init</span>() {}

<span class="hljs-keyword">func</span> <span class="hljs-title function_">configureStorefront</span>() {
    api.fetchInventory() { [<span class="hljs-keyword">unowned</span> <span class="hljs-keyword">self</span>] inventory <span class="hljs-keyword">in</span>
        <span class="hljs-keyword">self</span>.inventory <span class="hljs-operator">=</span> inventory
    }
}
</code></pre>
<p>여기에서 우리는 "진정한 싱글톤" (private init으로)을 가지고 있기 때문에 객체의 수명이 클로저보다 더 오래 지속된다는 것을 확신할 수 있습니다. 클로저 캡처 목록의 [unowned self]는 리테인 사이클이 생성되는 것을 방지합니다 (그러나 싱글톤의 경우 리테인 사이클에 대해 걱정할 필요가 실제로 없습니다).</p>
<p>클로저는 약간 더 간단하며, unowned는 약한 참조와 비교하여 몇 가지 성능 이점을 제공합니다:</p>
<ul>
<li>옵셔널 체이닝이나 언래핑 작업을 사용할 필요가 없습니다.</li>
<li>unowned 참조는 힙 객체에 사이드 테이블을 만들지 않기 때문에 더 적은 메타데이터를 저장합니다.</li>
<li>약한 참조가 가리키는 메모리에 액세스하는 경우 포인터 간의 추가 점프 또는 간접 레이어가 하나 더 필요합니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>성능이 좋다고 해도 이에는 한 가지 제약 사항이 있습니다: 만약 수명을 잘못 지정하고 클로저나 프로퍼티가 weak 참조보다 더 오래 존속된다면, 앱이 크래시할 수 있습니다.</h1>
<h2>unowned는 가치가 있을까요?</h2>
<p>당연히, 크래시는 상당히 나쁩니다. 그리고 Knuth가 종종 오인용된 것처럼 이른 최적화는 우리가 분명히 조심해야 할 유혹입니다. 그래서 성능을 약간 더 얻기 위해 unowned 참조를 마구 사용해서는 안 됩니다.</p>
<p>제 블로그를 읽고 있다면, 아마 Swift에 대해 알고 있는 분일 것입니다. 하지만 당신의 팀원들이 모두 그렇다고 확신할 수 있을까요?</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>금요일 오후 5시에 수행하는 모든 코드 리뷰가 'unowned' 키워드를 발견할 때마다 개체 소멸로 이어지는 많은 가지 코드 경로를 이해하는 데 신중하다는 것을 확신하실 수 있나요?</p>
<p>궁극적으로, 'unowned'는 프로그래밍 문제가 아니라 인간 문제입니다.</p>
<h1>약한 참조의 성능 비용</h1>
<p>우리는 'unowned'의 위험을 이해합니다. 약한 참조와 비교했을 때 이점에 대해 이야기해봅시다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>성능에 관한 이야기예요.</p>
<p>약한 참조를 옵셔널 언래핑하는 데 포함된 소수의 CPU 명령이 중요하다고 가정하지 않겠어요. 옵셔널은 사실 열거형이라는 비밀을 알고 계세요? 이 값 형식은 스택에 존재하죠. 이를 조작하는 오버헤드는 무시할 수준이에요. 왜냐하면 이들은 힙에 대한 쓰레드 안전한 잠긴 접근이 필요하지 않거든요.</p>
<p>메모리에 대해 이야기해볼까요? 힙 객체를 약한 참조하는 것은 처음에 사이드 테이블을 만듭니다. 이는 힙 객체의 메모리 레이아웃 외부에 저장된 가벼운 메타데이터입니다. 사이드 테이블에는 힙 객체로의 포인터, 약한 참조 카운트; 그리고 정수 오버플로된 강한 참조 및 unowned 참조의 refCounts가 포함돼 있어요. unowned 참조 자체에는 사이드 테이블이 필요하지 않아요.</p>
<p>이게 작은 비트들의 소수라는 느낌이 드시나요? 그렇게 생각하시면 맞아요. 추가 메모리량이 극히 소량이죠. 사실상 런타임은 약한 참조를 미리 nil 처리하려고 deinit에 추가 작업이 필요하지 않아요. 약한 참조가 폐기될 때까지 가벼운 사이드 테이블이 메모리에 남아 있어 힙 객체의 라이프사이클 상태를 체크해 nil 또는 객체를 반환합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>여기에는 약간의 오버헤드가 있습니다. 약한 참조는 이 쪽 테이블을 가리키고, 다시 이를 통해 실제 힙 객체를 가리킵니다. 이 간접 참조 때문에 약한 참조에 약간의 오버헤드가 추가되고, 비싼 CPU 캐시 미스가 발생할 위험이 있습니다.</p>
<p>한편, 언올드 참조는 메모리의 힙 객체를 직접 가리킵니다. 간접 참조가 줄어듦에 따라 덜한 오버헤드가 발생하지만, 런타임은 여전히 힙 객체의 라이프사이클 상태를 확인해야 합니다. 따라서 객체를 반환해야 하는지, 아니면 swift_abortRetainUnowned로 크래시를 발생시켜야 하는지 알 수 있습니다.</p>
<h1>언올드를 사용하는 것이 합당한 경우</h1>
<p>Swift 소스를 살펴보며 약한 참조와 언올드 참조의 구현을 이해하면, 언올드를 사용하는 이점이 적고, 치명적인 오류를 발생시킬 위험 때문에 이 성능 이점이 가치가 없는 경우가 많다는 것이 분명해집니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그러나, 컴퓨터 과학에서 모든 것은 트레이드오프에 관한 것이며, 이런 경우에는 트레이드오프가 합리적인 경우가 있습니다.</p>
<ul>
<li>참조(reference)가 많고 실행 시간 성능이 중요한 병목 현상이 되는 경우, 예를 들어 많은 화면 객체를 포함하는 게임 엔진을 개발하는 개발자가 있는 경우.</li>
<li>참조(reference)의 수가 많고 메모리가 극도로 제한적해서 수 바이트를 저장하는 것이 관련이 있는 경우 — 예를 들어 코드 일부를 최적화하여 L1 CPU 캐시에 맞출 수 있는 경우.</li>
<li>다른 기여자에 의존하지 않는 인디 개발자가, 무엇을 하는 지 정확히 알고 있으며, 프로덕션에서의 충돌 비용을 감당할 준비가 되어 있는 경우.</li>
</ul>
<p>그러나 하나의 클로저 콜백에서 [unowned self]를 사용하는 것이 몇 개의 시계 주기와 최악의 경우 몇 나노초의 캐시 미스를 위해 꽤 좋지 않은 트레이드오프라는 점에 동의해 주셨으면 합니다.</p>
<h1>결론</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>ARC에서 잠재 쓰레기 참조 문제를 방지하는 데 기여하는 비소유 참조(unowned references)는 런타임 성능 향상의 조각을 제공하지만 잘못 사용하면 충돌 위험이 따릅니다.</p>
<p>매우 병목 상태인 시스템에 수많은 참조가 있는 경우 등 일부 상황에서는 사용할 만한 가치가 있지만, 단일 클로저 캡처 목록에 [unowned self]를 사용하는 것은 그중 하나가 아닙니다.</p>
<p>[weak self]를 계속 사용하고 unowned는 예외적인 경우로 취급해 주세요. 이는 잘못 사용하면 예외를 받아들일 수 있는 경우라는 의미입니다.</p>
<p>간단히 말해, 코드에서 unowned를 사용할 만큼 자신감이 있다면, 그냥 unowned(unsafe)를 사용하세요. 약간 더 성능적으로 우세합니다*.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Unowned self 개념의 문제점","description":"","date":"2024-06-23 23:36","slug":"2024-06-23-TheCaseAgainstunownedself","content":"\n![2024-06-23-TheCaseAgainstunownedself_0.png](/assets/img/2024-06-23-TheCaseAgainstunownedself_0.png)\n\n클래스, 클로저 또는 액터를 사용할 때마다 Swift는 힙(heap)에 정보를 저장합니다. 전달하는 변수는 실제로 메모리의 주소(즉, 참조)를 가리키는 포인터입니다.\n\n옛날에는 Mac과 iOS 개발자들이 이 메모리를 수동으로 관리해야 했습니다. heap에 메모리 블록을 만들기 위해 alloc()을 사용하고 다른 참조를 추가하기 위해 retain()을 사용하며 메모리를 해제하기 위해 release()를 사용합니다.\n\n2011년, Apple은 ARC(자동 참조 카운트)를 소개했으며, 이를 통해 컴파일러가 이러한 보일러플레이트 메모리 관리 코드를 자동으로 작성하도록 하여, 축적된 개발 시간을 절약했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nARC는 다양한 종류의 참조 개념을 소개했습니다.\n\n## 강한 참조\n\n이것은 기본 참조입니다. 포인터가 사용 중일 때 가리키는 메모리를 유지합니다.\n\n강한 참조를 만드는 동안 힙 객체의 참조 카운트(또는 refCount)가 증가하고, refCount가 0이 되면 객체가 할당 해제되어 힙에 있는 메모리가 해제됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 약한 참조\n\n약한 참조는 힙 객체들이 서로를 가리키면서 유지주기 문제 없이 회피할 수 있게 해줍니다. 이를 통해 개발자들은 클로저와 델리게이트에서 클래스에 대한 참조를 생성하지만 불필요하게 객체들을 유지할 필요가 없어집니다.\n\n약한 참조는 refCount가 증가하지 않으면서 메모리의 힙 객체를 가리킵니다. 만약 refCount가 제로가 되면 객체는 해제되고 약한 참조는 nil이 됩니다— 이는 클로저에서 메모리 누수를 방지합니다.\n\n이 작동방식을 다루기 위해 약한 참조는 항상 optional로 래핑되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\n// StoreViewModel.swift\n\nfunc loadStorefront() {\n    api.fetchInventory() { [weak self] inventory in\n        self?.inventory = inventory\n    }\n}\n```\n\n이 예에서 인벤토리는 네트워크를 통해 가져오며, 데이터가 도착하면 클로저 콜백이 실행됩니다. self는 약한 참조로 캡처되어 StoreViewModel의 속성이 클로저에서 업데이트될 수 있음을 의미합니다. 사용자가 화면을 나가면 뷰 모델의 강한 참조 수가 0이 되면 런타임이 뷰 모델을 해제할 수 있으므로, 콜백을 기다리는 동안 메모리에 유지되지 않고 인벤토리가 반환될 때 아무 일도 일어나지 않습니다.\n\n## Unowned references\n\n리테인 사이클을 방지하기 위해 Swift에서 세 번째 종류의 참조인 unowned가 소개되었습니다. 이는 약한 참조와 유사하게 동작하지만 참조 대상 객체의 메모리가 항상 해당 객체를 참조하는 unowned 포인터보다 오래 존속할 것으로 가정합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\n// StoreSingleton.swift\n\nstatic let sharedInstance = StoreSingleton()\n\nprivate init() {}\n\nfunc configureStorefront() {\n    api.fetchInventory() { [unowned self] inventory in\n        self.inventory = inventory\n    }\n}\n```\n\n여기에서 우리는 \"진정한 싱글톤\" (private init으로)을 가지고 있기 때문에 객체의 수명이 클로저보다 더 오래 지속된다는 것을 확신할 수 있습니다. 클로저 캡처 목록의 [unowned self]는 리테인 사이클이 생성되는 것을 방지합니다 (그러나 싱글톤의 경우 리테인 사이클에 대해 걱정할 필요가 실제로 없습니다).\n\n클로저는 약간 더 간단하며, unowned는 약한 참조와 비교하여 몇 가지 성능 이점을 제공합니다:\n\n- 옵셔널 체이닝이나 언래핑 작업을 사용할 필요가 없습니다.\n- unowned 참조는 힙 객체에 사이드 테이블을 만들지 않기 때문에 더 적은 메타데이터를 저장합니다.\n- 약한 참조가 가리키는 메모리에 액세스하는 경우 포인터 간의 추가 점프 또는 간접 레이어가 하나 더 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 성능이 좋다고 해도 이에는 한 가지 제약 사항이 있습니다: 만약 수명을 잘못 지정하고 클로저나 프로퍼티가 weak 참조보다 더 오래 존속된다면, 앱이 크래시할 수 있습니다.\n\n## unowned는 가치가 있을까요?\n\n당연히, 크래시는 상당히 나쁩니다. 그리고 Knuth가 종종 오인용된 것처럼 이른 최적화는 우리가 분명히 조심해야 할 유혹입니다. 그래서 성능을 약간 더 얻기 위해 unowned 참조를 마구 사용해서는 안 됩니다.\n\n제 블로그를 읽고 있다면, 아마 Swift에 대해 알고 있는 분일 것입니다. 하지만 당신의 팀원들이 모두 그렇다고 확신할 수 있을까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n금요일 오후 5시에 수행하는 모든 코드 리뷰가 'unowned' 키워드를 발견할 때마다 개체 소멸로 이어지는 많은 가지 코드 경로를 이해하는 데 신중하다는 것을 확신하실 수 있나요?\n\n궁극적으로, 'unowned'는 프로그래밍 문제가 아니라 인간 문제입니다.\n\n# 약한 참조의 성능 비용\n\n우리는 'unowned'의 위험을 이해합니다. 약한 참조와 비교했을 때 이점에 대해 이야기해봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n성능에 관한 이야기예요.\n\n약한 참조를 옵셔널 언래핑하는 데 포함된 소수의 CPU 명령이 중요하다고 가정하지 않겠어요. 옵셔널은 사실 열거형이라는 비밀을 알고 계세요? 이 값 형식은 스택에 존재하죠. 이를 조작하는 오버헤드는 무시할 수준이에요. 왜냐하면 이들은 힙에 대한 쓰레드 안전한 잠긴 접근이 필요하지 않거든요.\n\n메모리에 대해 이야기해볼까요? 힙 객체를 약한 참조하는 것은 처음에 사이드 테이블을 만듭니다. 이는 힙 객체의 메모리 레이아웃 외부에 저장된 가벼운 메타데이터입니다. 사이드 테이블에는 힙 객체로의 포인터, 약한 참조 카운트; 그리고 정수 오버플로된 강한 참조 및 unowned 참조의 refCounts가 포함돼 있어요. unowned 참조 자체에는 사이드 테이블이 필요하지 않아요.\n\n이게 작은 비트들의 소수라는 느낌이 드시나요? 그렇게 생각하시면 맞아요. 추가 메모리량이 극히 소량이죠. 사실상 런타임은 약한 참조를 미리 nil 처리하려고 deinit에 추가 작업이 필요하지 않아요. 약한 참조가 폐기될 때까지 가벼운 사이드 테이블이 메모리에 남아 있어 힙 객체의 라이프사이클 상태를 체크해 nil 또는 객체를 반환합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기에는 약간의 오버헤드가 있습니다. 약한 참조는 이 쪽 테이블을 가리키고, 다시 이를 통해 실제 힙 객체를 가리킵니다. 이 간접 참조 때문에 약한 참조에 약간의 오버헤드가 추가되고, 비싼 CPU 캐시 미스가 발생할 위험이 있습니다.\n\n한편, 언올드 참조는 메모리의 힙 객체를 직접 가리킵니다. 간접 참조가 줄어듦에 따라 덜한 오버헤드가 발생하지만, 런타임은 여전히 힙 객체의 라이프사이클 상태를 확인해야 합니다. 따라서 객체를 반환해야 하는지, 아니면 swift_abortRetainUnowned로 크래시를 발생시켜야 하는지 알 수 있습니다.\n\n# 언올드를 사용하는 것이 합당한 경우\n\nSwift 소스를 살펴보며 약한 참조와 언올드 참조의 구현을 이해하면, 언올드를 사용하는 이점이 적고, 치명적인 오류를 발생시킬 위험 때문에 이 성능 이점이 가치가 없는 경우가 많다는 것이 분명해집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나, 컴퓨터 과학에서 모든 것은 트레이드오프에 관한 것이며, 이런 경우에는 트레이드오프가 합리적인 경우가 있습니다.\n\n- 참조(reference)가 많고 실행 시간 성능이 중요한 병목 현상이 되는 경우, 예를 들어 많은 화면 객체를 포함하는 게임 엔진을 개발하는 개발자가 있는 경우.\n- 참조(reference)의 수가 많고 메모리가 극도로 제한적해서 수 바이트를 저장하는 것이 관련이 있는 경우 — 예를 들어 코드 일부를 최적화하여 L1 CPU 캐시에 맞출 수 있는 경우.\n- 다른 기여자에 의존하지 않는 인디 개발자가, 무엇을 하는 지 정확히 알고 있으며, 프로덕션에서의 충돌 비용을 감당할 준비가 되어 있는 경우.\n\n그러나 하나의 클로저 콜백에서 [unowned self]를 사용하는 것이 몇 개의 시계 주기와 최악의 경우 몇 나노초의 캐시 미스를 위해 꽤 좋지 않은 트레이드오프라는 점에 동의해 주셨으면 합니다.\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nARC에서 잠재 쓰레기 참조 문제를 방지하는 데 기여하는 비소유 참조(unowned references)는 런타임 성능 향상의 조각을 제공하지만 잘못 사용하면 충돌 위험이 따릅니다.\n\n매우 병목 상태인 시스템에 수많은 참조가 있는 경우 등 일부 상황에서는 사용할 만한 가치가 있지만, 단일 클로저 캡처 목록에 [unowned self]를 사용하는 것은 그중 하나가 아닙니다.\n\n[weak self]를 계속 사용하고 unowned는 예외적인 경우로 취급해 주세요. 이는 잘못 사용하면 예외를 받아들일 수 있는 경우라는 의미입니다.\n\n간단히 말해, 코드에서 unowned를 사용할 만큼 자신감이 있다면, 그냥 unowned(unsafe)를 사용하세요. 약간 더 성능적으로 우세합니다\\*.\n","ogImage":{"url":"/assets/img/2024-06-23-TheCaseAgainstunownedself_0.png"},"coverImage":"/assets/img/2024-06-23-TheCaseAgainstunownedself_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-TheCaseAgainstunownedself_0.png\" alt=\"2024-06-23-TheCaseAgainstunownedself_0.png\"\u003e\u003c/p\u003e\n\u003cp\u003e클래스, 클로저 또는 액터를 사용할 때마다 Swift는 힙(heap)에 정보를 저장합니다. 전달하는 변수는 실제로 메모리의 주소(즉, 참조)를 가리키는 포인터입니다.\u003c/p\u003e\n\u003cp\u003e옛날에는 Mac과 iOS 개발자들이 이 메모리를 수동으로 관리해야 했습니다. heap에 메모리 블록을 만들기 위해 alloc()을 사용하고 다른 참조를 추가하기 위해 retain()을 사용하며 메모리를 해제하기 위해 release()를 사용합니다.\u003c/p\u003e\n\u003cp\u003e2011년, Apple은 ARC(자동 참조 카운트)를 소개했으며, 이를 통해 컴파일러가 이러한 보일러플레이트 메모리 관리 코드를 자동으로 작성하도록 하여, 축적된 개발 시간을 절약했습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eARC는 다양한 종류의 참조 개념을 소개했습니다.\u003c/p\u003e\n\u003ch2\u003e강한 참조\u003c/h2\u003e\n\u003cp\u003e이것은 기본 참조입니다. 포인터가 사용 중일 때 가리키는 메모리를 유지합니다.\u003c/p\u003e\n\u003cp\u003e강한 참조를 만드는 동안 힙 객체의 참조 카운트(또는 refCount)가 증가하고, refCount가 0이 되면 객체가 할당 해제되어 힙에 있는 메모리가 해제됩니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e약한 참조\u003c/h2\u003e\n\u003cp\u003e약한 참조는 힙 객체들이 서로를 가리키면서 유지주기 문제 없이 회피할 수 있게 해줍니다. 이를 통해 개발자들은 클로저와 델리게이트에서 클래스에 대한 참조를 생성하지만 불필요하게 객체들을 유지할 필요가 없어집니다.\u003c/p\u003e\n\u003cp\u003e약한 참조는 refCount가 증가하지 않으면서 메모리의 힙 객체를 가리킵니다. 만약 refCount가 제로가 되면 객체는 해제되고 약한 참조는 nil이 됩니다— 이는 클로저에서 메모리 누수를 방지합니다.\u003c/p\u003e\n\u003cp\u003e이 작동방식을 다루기 위해 약한 참조는 항상 optional로 래핑되어 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-comment\"\u003e// StoreViewModel.swift\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eloadStorefront\u003c/span\u003e() {\n    api.fetchInventory() { [\u003cspan class=\"hljs-keyword\"\u003eweak\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e] inventory \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e?\u003c/span\u003e.inventory \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e inventory\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예에서 인벤토리는 네트워크를 통해 가져오며, 데이터가 도착하면 클로저 콜백이 실행됩니다. self는 약한 참조로 캡처되어 StoreViewModel의 속성이 클로저에서 업데이트될 수 있음을 의미합니다. 사용자가 화면을 나가면 뷰 모델의 강한 참조 수가 0이 되면 런타임이 뷰 모델을 해제할 수 있으므로, 콜백을 기다리는 동안 메모리에 유지되지 않고 인벤토리가 반환될 때 아무 일도 일어나지 않습니다.\u003c/p\u003e\n\u003ch2\u003eUnowned references\u003c/h2\u003e\n\u003cp\u003e리테인 사이클을 방지하기 위해 Swift에서 세 번째 종류의 참조인 unowned가 소개되었습니다. 이는 약한 참조와 유사하게 동작하지만 참조 대상 객체의 메모리가 항상 해당 객체를 참조하는 unowned 포인터보다 오래 존속할 것으로 가정합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-comment\"\u003e// StoreSingleton.swift\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e sharedInstance \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eStoreSingleton\u003c/span\u003e()\n\n\u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003einit\u003c/span\u003e() {}\n\n\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003econfigureStorefront\u003c/span\u003e() {\n    api.fetchInventory() { [\u003cspan class=\"hljs-keyword\"\u003eunowned\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e] inventory \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.inventory \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e inventory\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기에서 우리는 \"진정한 싱글톤\" (private init으로)을 가지고 있기 때문에 객체의 수명이 클로저보다 더 오래 지속된다는 것을 확신할 수 있습니다. 클로저 캡처 목록의 [unowned self]는 리테인 사이클이 생성되는 것을 방지합니다 (그러나 싱글톤의 경우 리테인 사이클에 대해 걱정할 필요가 실제로 없습니다).\u003c/p\u003e\n\u003cp\u003e클로저는 약간 더 간단하며, unowned는 약한 참조와 비교하여 몇 가지 성능 이점을 제공합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e옵셔널 체이닝이나 언래핑 작업을 사용할 필요가 없습니다.\u003c/li\u003e\n\u003cli\u003eunowned 참조는 힙 객체에 사이드 테이블을 만들지 않기 때문에 더 적은 메타데이터를 저장합니다.\u003c/li\u003e\n\u003cli\u003e약한 참조가 가리키는 메모리에 액세스하는 경우 포인터 간의 추가 점프 또는 간접 레이어가 하나 더 필요합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e성능이 좋다고 해도 이에는 한 가지 제약 사항이 있습니다: 만약 수명을 잘못 지정하고 클로저나 프로퍼티가 weak 참조보다 더 오래 존속된다면, 앱이 크래시할 수 있습니다.\u003c/h1\u003e\n\u003ch2\u003eunowned는 가치가 있을까요?\u003c/h2\u003e\n\u003cp\u003e당연히, 크래시는 상당히 나쁩니다. 그리고 Knuth가 종종 오인용된 것처럼 이른 최적화는 우리가 분명히 조심해야 할 유혹입니다. 그래서 성능을 약간 더 얻기 위해 unowned 참조를 마구 사용해서는 안 됩니다.\u003c/p\u003e\n\u003cp\u003e제 블로그를 읽고 있다면, 아마 Swift에 대해 알고 있는 분일 것입니다. 하지만 당신의 팀원들이 모두 그렇다고 확신할 수 있을까요?\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e금요일 오후 5시에 수행하는 모든 코드 리뷰가 'unowned' 키워드를 발견할 때마다 개체 소멸로 이어지는 많은 가지 코드 경로를 이해하는 데 신중하다는 것을 확신하실 수 있나요?\u003c/p\u003e\n\u003cp\u003e궁극적으로, 'unowned'는 프로그래밍 문제가 아니라 인간 문제입니다.\u003c/p\u003e\n\u003ch1\u003e약한 참조의 성능 비용\u003c/h1\u003e\n\u003cp\u003e우리는 'unowned'의 위험을 이해합니다. 약한 참조와 비교했을 때 이점에 대해 이야기해봅시다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e성능에 관한 이야기예요.\u003c/p\u003e\n\u003cp\u003e약한 참조를 옵셔널 언래핑하는 데 포함된 소수의 CPU 명령이 중요하다고 가정하지 않겠어요. 옵셔널은 사실 열거형이라는 비밀을 알고 계세요? 이 값 형식은 스택에 존재하죠. 이를 조작하는 오버헤드는 무시할 수준이에요. 왜냐하면 이들은 힙에 대한 쓰레드 안전한 잠긴 접근이 필요하지 않거든요.\u003c/p\u003e\n\u003cp\u003e메모리에 대해 이야기해볼까요? 힙 객체를 약한 참조하는 것은 처음에 사이드 테이블을 만듭니다. 이는 힙 객체의 메모리 레이아웃 외부에 저장된 가벼운 메타데이터입니다. 사이드 테이블에는 힙 객체로의 포인터, 약한 참조 카운트; 그리고 정수 오버플로된 강한 참조 및 unowned 참조의 refCounts가 포함돼 있어요. unowned 참조 자체에는 사이드 테이블이 필요하지 않아요.\u003c/p\u003e\n\u003cp\u003e이게 작은 비트들의 소수라는 느낌이 드시나요? 그렇게 생각하시면 맞아요. 추가 메모리량이 극히 소량이죠. 사실상 런타임은 약한 참조를 미리 nil 처리하려고 deinit에 추가 작업이 필요하지 않아요. 약한 참조가 폐기될 때까지 가벼운 사이드 테이블이 메모리에 남아 있어 힙 객체의 라이프사이클 상태를 체크해 nil 또는 객체를 반환합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e여기에는 약간의 오버헤드가 있습니다. 약한 참조는 이 쪽 테이블을 가리키고, 다시 이를 통해 실제 힙 객체를 가리킵니다. 이 간접 참조 때문에 약한 참조에 약간의 오버헤드가 추가되고, 비싼 CPU 캐시 미스가 발생할 위험이 있습니다.\u003c/p\u003e\n\u003cp\u003e한편, 언올드 참조는 메모리의 힙 객체를 직접 가리킵니다. 간접 참조가 줄어듦에 따라 덜한 오버헤드가 발생하지만, 런타임은 여전히 힙 객체의 라이프사이클 상태를 확인해야 합니다. 따라서 객체를 반환해야 하는지, 아니면 swift_abortRetainUnowned로 크래시를 발생시켜야 하는지 알 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e언올드를 사용하는 것이 합당한 경우\u003c/h1\u003e\n\u003cp\u003eSwift 소스를 살펴보며 약한 참조와 언올드 참조의 구현을 이해하면, 언올드를 사용하는 이점이 적고, 치명적인 오류를 발생시킬 위험 때문에 이 성능 이점이 가치가 없는 경우가 많다는 것이 분명해집니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그러나, 컴퓨터 과학에서 모든 것은 트레이드오프에 관한 것이며, 이런 경우에는 트레이드오프가 합리적인 경우가 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e참조(reference)가 많고 실행 시간 성능이 중요한 병목 현상이 되는 경우, 예를 들어 많은 화면 객체를 포함하는 게임 엔진을 개발하는 개발자가 있는 경우.\u003c/li\u003e\n\u003cli\u003e참조(reference)의 수가 많고 메모리가 극도로 제한적해서 수 바이트를 저장하는 것이 관련이 있는 경우 — 예를 들어 코드 일부를 최적화하여 L1 CPU 캐시에 맞출 수 있는 경우.\u003c/li\u003e\n\u003cli\u003e다른 기여자에 의존하지 않는 인디 개발자가, 무엇을 하는 지 정확히 알고 있으며, 프로덕션에서의 충돌 비용을 감당할 준비가 되어 있는 경우.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그러나 하나의 클로저 콜백에서 [unowned self]를 사용하는 것이 몇 개의 시계 주기와 최악의 경우 몇 나노초의 캐시 미스를 위해 꽤 좋지 않은 트레이드오프라는 점에 동의해 주셨으면 합니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eARC에서 잠재 쓰레기 참조 문제를 방지하는 데 기여하는 비소유 참조(unowned references)는 런타임 성능 향상의 조각을 제공하지만 잘못 사용하면 충돌 위험이 따릅니다.\u003c/p\u003e\n\u003cp\u003e매우 병목 상태인 시스템에 수많은 참조가 있는 경우 등 일부 상황에서는 사용할 만한 가치가 있지만, 단일 클로저 캡처 목록에 [unowned self]를 사용하는 것은 그중 하나가 아닙니다.\u003c/p\u003e\n\u003cp\u003e[weak self]를 계속 사용하고 unowned는 예외적인 경우로 취급해 주세요. 이는 잘못 사용하면 예외를 받아들일 수 있는 경우라는 의미입니다.\u003c/p\u003e\n\u003cp\u003e간단히 말해, 코드에서 unowned를 사용할 만큼 자신감이 있다면, 그냥 unowned(unsafe)를 사용하세요. 약간 더 성능적으로 우세합니다*.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-TheCaseAgainstunownedself"},"buildId":"YUMR4jSyk_WlOHHc7UfOk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>