<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Kotlin 코루틴 핵심요소 알아야 할 모든 것 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Kotlin 코루틴 핵심요소 알아야 할 모든 것 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Kotlin 코루틴 핵심요소 알아야 할 모든 것 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow" data-gatsby-head="true"/><meta name="twitter:title" content="Kotlin 코루틴 핵심요소 알아야 할 모든 것 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-18 15:32" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_buildManifest.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Kotlin 코루틴 핵심요소 알아야 할 모든 것</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Kotlin 코루틴 핵심요소 알아야 할 모든 것" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 18, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow_0.png">
<p>안녕하세요! 이 글은 코루틴 시리즈에서 두 번째 글입니다. 코루틴을 완전히 이해하기 위해 확인해볼 수 있는 다음 글 목록입니다.</p>
<ul>
<li>코루틴, 무엇인가, 어떻게 사용하며 왜 사용하는가?</li>
<li>코루틴 핵심 요소(이 글).</li>
<li>코루틴 내부 동작 방식.</li>
</ul>
<p>이미 코루틴이 무엇이고 어디에 어떻게 사용하는지 알고 있다고 가정하고 있습니다. 아직 익숙하지 않다면 이 글을 읽어보세요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우선, 잘 알려진 Coroutine 빌더를 사용하여 우리의 코루틴을 만들어 보겠습니다:</p>
<h1>Launch:</h1>
<p>launch 코루틴 빌더는 결과를 반환하지 않는 새로운 코루틴을 시작하는 데 사용됩니다. 이는 실행 후 바로 잊을 수 있는 작업에 사용되며, 긴 실행 함수를 호출하고 반환 값을 신경 쓰지 않아도 되는 경우에 사용됩니다.</p>
<pre><code class="hljs language-js">fun <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">println</span>(<span class="hljs-string">"시작"</span>)

    <span class="hljs-comment">// 코루틴 실행</span>
    <span class="hljs-title class_">GlobalScope</span>.<span class="hljs-property">launch</span> {
        <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>) <span class="hljs-comment">// 일부 백그라운드 작업 시뮬레이션</span>
        <span class="hljs-title function_">println</span>(<span class="hljs-string">"코루틴이 완료되었습니다"</span>)
    }

    <span class="hljs-title function_">println</span>(<span class="hljs-string">"끝"</span>)
}

<span class="hljs-comment">//시작</span>
<span class="hljs-comment">//끝</span>
<span class="hljs-comment">//...</span>
<span class="hljs-comment">//코루틴이 완료되었습니다</span>
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>비동기:</h1>
<p>비동기 코루틴 빌더(async)는 Deferred 값을 반환하는 코루틴을 시작하는 데 사용됩니다. 우리는 지연된 값에 대해 중단 함수 await를 호출하여 기다리고 결과를 가져올 수 있습니다.</p>
<pre><code class="hljs language-js">fun <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">println</span>(<span class="hljs-string">"시작"</span>)

    val deferredResult = <span class="hljs-title class_">GlobalScope</span>.<span class="hljs-property">async</span> {
        <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>) <span class="hljs-comment">// 일부 백그라운드 작업 시뮬레이션</span>
        <span class="hljs-string">"코루틴 완료"</span>
    }

    <span class="hljs-comment">// 그 동안 다른 작업 수행</span>

    <span class="hljs-comment">// 지연된 값에서 결과를 검색</span>
    runBlocking {
        val result = deferredResult.<span class="hljs-title function_">await</span>() <span class="hljs-comment">// await는 중단 함수입니다</span>
        <span class="hljs-title function_">println</span>(result)
    }

    <span class="hljs-title function_">println</span>(<span class="hljs-string">"끝"</span>)
}
<span class="hljs-comment">//시작</span>
<span class="hljs-comment">//코루틴 완료</span>
<span class="hljs-comment">//끝</span>
</code></pre>
<h1>CoroutineScope:</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이것을 코루틴의 어머니로 생각해보세요. CoroutineScope는 생성 중인 모든 코루틴을 추적하며, 마치 어머니가 자녀를 돌보는 것과 같습니다.</p>
<p>진행 중인 작업(실행 중인 코루틴)은 언제든지 scope.cancel()을 호출하여 취소할 수 있습니다.</p>
<p>특정 계층의 앱에서 코루틴의 수명주기를 시작하고 제어하고 싶을 때마다 CoroutineScope를 생성해야 합니다. 안드로이드에서는 viewModelScope, lifecycleScope 또는 전체 애플리케이션 수명주기를 위한 GlobalScope가 있습니다.</p>
<p>CoroutineScope를 생성할 때는 생성자의 매개변수로 CoroutineContext를 사용합니다. 다음 코드로 새로운 scope 및 코루틴을 생성할 수 있습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// Job과 Dispatcher는 CoroutineContext로 결합되어 CoroutineContext에 대해 곧 논의할 것입니다.</span>
<span class="hljs-keyword">val</span> scope = CoroutineScope(Job() + Dispatchers.Main)
<span class="hljs-keyword">val</span> job = scope.launch {
    <span class="hljs-comment">// 새로운 코루틴</span>
}
</code></pre>
<h2>Job:</h2>
<p>코루틴 내에서 Job 인스턴스는 코루틴 자체를 나타냅니다. Job은 코루틴에 대한 핸들입니다. launch 또는 async로 생성하는 각 코루틴에 대해 고유하게 식별되고 라이프사이클을 관리하는 Job 인스턴스가 반환됩니다.</p>
<p>Job은 일련의 상태를 거칠 수 있습니다: New, Active, Completing, Completed, Cancelling 및 Cancelled. 우리는 상태 자체에는 액세스할 수 없지만, Job의 속성에 액세스할 수 있습니다: isActive, isCancelled 및 isCompleted.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>작업/Coroutine의 상태:</p>
<p><img src="/assets/img/2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow_1.png" alt="Job/Coroutine States"></p>
<p>작업 유형:</p>
<ul>
<li>Job: 단일 coroutine을 나타내며 시작, 대기 및 취소와 같은 라이프사이클을 제어할 수 있습니다. 간단한 비동기 작업에 사용할 수 있습니다.</li>
<li>DeferredJob: 타입 T의 결과를 생성하는 coroutine을 나타내며 await 함수를 사용하여 결과를 대기할 수 있는 방법을 제공합니다. Deferred는 작업을 병행 및 비동기적으로 수행하고 결과를 얻어야 할 때 사용됩니다.</li>
<li>SupervisorJob: 자식 coroutines을 위한 부모 작업으로 사용되는 작업 유형입니다. 일반 작업과 달리 자식 coroutine의 실패 또는 취소가 부모 및 다른 자식에게 전파되지 않습니다. 작업 트리의 특정 가지에서 실패를 격리하고 싶을 때 유용합니다.</li>
<li>CompletableJob: 명시적으로 complete() 함수를 사용하여 완료할 수 있는 작업 유형입니다. 사용자 정의 구현이나 작업의 라이프사이클을 처리하는 사용자 정의 방법을 만들고 싶을 때 자주 사용됩니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>CoroutineContext:</h1>
<p>CoroutineContext은 코루틴 실행의 컨텍스트를 나타내는 인터페이스입니다. 코루틴의 동작을 정의하는 요소 집합을 제공합니다. 이 컨텍스트는 코루틴 실행을 관리하는 데 중요하며 동시성, 스레드 풀링 및 스케줄링을 처리합니다.</p>
<p>구성 요소는 다음과 같습니다:</p>
<ul>
<li>Job — 코루틴의 수명을 제어합니다.</li>
<li>CoroutineDispatcher — 작업을 적절한 스레드로 보냅니다.</li>
<li>CoroutineName — 코루틴의 이름으로 디버깅에 유용합니다.</li>
<li>CoroutineExceptionHandler — 처리되지 않은 예외를 처리합니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Coroutine은 새 작업 및 부모로부터 상속된 다른 것들의 CoroutineContext입니다.</p>
<p>CoroutineScope는 코루틴을 생성할 수 있고 코루틴 내에서 더 많은 코루틴을 생성할 수 있기 때문에 암시적인 작업 계층이 생성됩니다. 다음 코드 스니펫에서는 CoroutineScope를 사용하여 새 코루틴을 생성하는 것 외에도 코루틴 내에서 더 많은 코루틴을 생성하는 방법을 살펴보십시오:</p>
<pre><code class="hljs language-js">val scope = <span class="hljs-title class_">CoroutineScope</span>(<span class="hljs-title class_">Job</span>() + <span class="hljs-title class_">Dispatchers</span>.<span class="hljs-property">Main</span>)
val job = scope.<span class="hljs-property">launch</span> {
    <span class="hljs-comment">// CoroutineScope를 부모로 가지는 새 코루틴</span>
    val result = <span class="hljs-keyword">async</span> {
        <span class="hljs-comment">// launch에 의해 시작된 코루틴을 부모로 가지는 새 코루틴</span>
    }.<span class="hljs-title function_">await</span>()
}
</code></pre>
<p>해당 계층의 루트는 일반적으로 CoroutineScope입니다. 이 계층 구조를 다음과 같이 시각화할 수 있습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow_2.png" alt="Kotlin Coroutine Essentials"></p>
<p>코루틴은 작업 계층 구조에서 실행됩니다. 부모는 CoroutineScope 또는 다른 코루틴이 될 수 있습니다.</p>
<h1>부모 CoroutineContext:</h1>
<p>작업 계층 구조에서 각 코루틴은 CoroutineScope 또는 다른 코루틴이 될 수 있는 부모를 가지고 있습니다. 그러나 코루틴의 결과 CoroutineContext는 부모의 CoroutineContext와 다를 수 있습니다. 왜냐하면 이 공식에 따라 계산되기 때문입니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위와 같이 표현됩니다:</p>
<ul>
<li>일부 요소는 기본 값을 가집니다: Dispatchers.Default는 CoroutineDispatcher의 기본값이며, "coroutine"은 CoroutineName의 기본값입니다.</li>
<li>상속된 CoroutineContext는 해당 Coroutine을 생성한 coroutine의 CoroutineContext입니다.</li>
<li>Coroutine 빌더에 전달된 인수는 상속된 컨텍스트의 해당 요소들보다 우선합니다. (아래 예시 참조)</li>
</ul>
<p>참고: CoroutineContext는 + 연산자를 사용하여 결합할 수 있습니다. CoroutineContext는 요소의 집합이므로, + 연산자 오른쪽 요소들이 왼쪽 요소를 재정의하여 새로운 CoroutineContext가 생성됩니다.</p>
<p>예시: (Dispatchers.Main, "name") + (Dispatchers.IO) = (Dispatchers.IO, "name")</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow_3.png" alt="Coroutine Context"></p>
<p>이 CoroutineScope에서 시작된 모든 코루틴은 CoroutineContext에 적어도 이러한 요소가 있을 것입니다. CoroutineName은 기본 값에서 가져오므로 회색으로 표시됩니다.</p>
<p>새 코루틴의 부모 CoroutineContext를 알았으니, 그 코루틴의 실제 CoroutineContext는 다음과 같습니다:</p>
<p>위 이미지에 표시된 CoroutineScope를 사용하여 위와 같이 새 코루틴을 생성하면:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> job = scope.launch(Dispatchers.IO) {
    <span class="hljs-comment">// new coroutine</span>
}
</code></pre>
<p>그 코루틴의 부모 CoroutineContext 및 실제 CoroutineContext는 무엇입니까? 아래 이미지로 해답을 확인하세요!</p>
<p><img src="/assets/img/2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow_4.png" alt="해답 이미지"></p>
<p>CoroutineContext 안의 Job과 부모 컨텍스트는 항상 동일한 인스턴스가 아니며, 새로운 Coroutine이 항상 새로운 Job 인스턴스를 가져오게 됩니다. (새로운 Job은 녹색이고 부모 Job은 빨강색입니다.)</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><code>Dispatchers.IO</code>가 스코프의 <code>CoroutineDispatcher</code>를 덮어씌워서, 결과적으로 부모 CoroutineContext에는 Dispatchers.IO가 포함되어 있습니다.</p>
<p>코루틴과 관련된 중요한 개념들을 이해하셨기를 바라며, 앞으로는 이를 효율적으로 활용하여 멋진 애플리케이션을 만드시기 바랍니다. 앞으로 제공될 흥미로운 콘텐츠를 기대해 주세요. 함께 해주셔서 감사합니다!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Kotlin 코루틴 핵심요소 알아야 할 모든 것","description":"","date":"2024-05-18 15:32","slug":"2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow","content":"\n\u003cimg src=\"/assets/img/2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow_0.png\" /\u003e\n\n안녕하세요! 이 글은 코루틴 시리즈에서 두 번째 글입니다. 코루틴을 완전히 이해하기 위해 확인해볼 수 있는 다음 글 목록입니다.\n\n- 코루틴, 무엇인가, 어떻게 사용하며 왜 사용하는가?\n- 코루틴 핵심 요소(이 글).\n- 코루틴 내부 동작 방식.\n\n이미 코루틴이 무엇이고 어디에 어떻게 사용하는지 알고 있다고 가정하고 있습니다. 아직 익숙하지 않다면 이 글을 읽어보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우선, 잘 알려진 Coroutine 빌더를 사용하여 우리의 코루틴을 만들어 보겠습니다:\n\n# Launch:\n\nlaunch 코루틴 빌더는 결과를 반환하지 않는 새로운 코루틴을 시작하는 데 사용됩니다. 이는 실행 후 바로 잊을 수 있는 작업에 사용되며, 긴 실행 함수를 호출하고 반환 값을 신경 쓰지 않아도 되는 경우에 사용됩니다.\n\n```js\nfun main() {\n    println(\"시작\")\n\n    // 코루틴 실행\n    GlobalScope.launch {\n        delay(1000) // 일부 백그라운드 작업 시뮬레이션\n        println(\"코루틴이 완료되었습니다\")\n    }\n\n    println(\"끝\")\n}\n\n//시작\n//끝\n//...\n//코루틴이 완료되었습니다\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 비동기:\n\n비동기 코루틴 빌더(async)는 Deferred 값을 반환하는 코루틴을 시작하는 데 사용됩니다. 우리는 지연된 값에 대해 중단 함수 await를 호출하여 기다리고 결과를 가져올 수 있습니다.\n\n```js\nfun main() {\n    println(\"시작\")\n\n    val deferredResult = GlobalScope.async {\n        delay(1000) // 일부 백그라운드 작업 시뮬레이션\n        \"코루틴 완료\"\n    }\n\n    // 그 동안 다른 작업 수행\n\n    // 지연된 값에서 결과를 검색\n    runBlocking {\n        val result = deferredResult.await() // await는 중단 함수입니다\n        println(result)\n    }\n\n    println(\"끝\")\n}\n//시작\n//코루틴 완료\n//끝\n```\n\n# CoroutineScope:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것을 코루틴의 어머니로 생각해보세요. CoroutineScope는 생성 중인 모든 코루틴을 추적하며, 마치 어머니가 자녀를 돌보는 것과 같습니다.\n\n진행 중인 작업(실행 중인 코루틴)은 언제든지 scope.cancel()을 호출하여 취소할 수 있습니다.\n\n특정 계층의 앱에서 코루틴의 수명주기를 시작하고 제어하고 싶을 때마다 CoroutineScope를 생성해야 합니다. 안드로이드에서는 viewModelScope, lifecycleScope 또는 전체 애플리케이션 수명주기를 위한 GlobalScope가 있습니다.\n\nCoroutineScope를 생성할 때는 생성자의 매개변수로 CoroutineContext를 사용합니다. 다음 코드로 새로운 scope 및 코루틴을 생성할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n// Job과 Dispatcher는 CoroutineContext로 결합되어 CoroutineContext에 대해 곧 논의할 것입니다.\nval scope = CoroutineScope(Job() + Dispatchers.Main)\nval job = scope.launch {\n    // 새로운 코루틴\n}\n```\n\n## Job:\n\n코루틴 내에서 Job 인스턴스는 코루틴 자체를 나타냅니다. Job은 코루틴에 대한 핸들입니다. launch 또는 async로 생성하는 각 코루틴에 대해 고유하게 식별되고 라이프사이클을 관리하는 Job 인스턴스가 반환됩니다.\n\nJob은 일련의 상태를 거칠 수 있습니다: New, Active, Completing, Completed, Cancelling 및 Cancelled. 우리는 상태 자체에는 액세스할 수 없지만, Job의 속성에 액세스할 수 있습니다: isActive, isCancelled 및 isCompleted.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n작업/Coroutine의 상태:\n\n![Job/Coroutine States](/assets/img/2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow_1.png)\n\n작업 유형:\n\n- Job: 단일 coroutine을 나타내며 시작, 대기 및 취소와 같은 라이프사이클을 제어할 수 있습니다. 간단한 비동기 작업에 사용할 수 있습니다.\n- DeferredJob: 타입 T의 결과를 생성하는 coroutine을 나타내며 await 함수를 사용하여 결과를 대기할 수 있는 방법을 제공합니다. Deferred는 작업을 병행 및 비동기적으로 수행하고 결과를 얻어야 할 때 사용됩니다.\n- SupervisorJob: 자식 coroutines을 위한 부모 작업으로 사용되는 작업 유형입니다. 일반 작업과 달리 자식 coroutine의 실패 또는 취소가 부모 및 다른 자식에게 전파되지 않습니다. 작업 트리의 특정 가지에서 실패를 격리하고 싶을 때 유용합니다.\n- CompletableJob: 명시적으로 complete() 함수를 사용하여 완료할 수 있는 작업 유형입니다. 사용자 정의 구현이나 작업의 라이프사이클을 처리하는 사용자 정의 방법을 만들고 싶을 때 자주 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# CoroutineContext:\n\nCoroutineContext은 코루틴 실행의 컨텍스트를 나타내는 인터페이스입니다. 코루틴의 동작을 정의하는 요소 집합을 제공합니다. 이 컨텍스트는 코루틴 실행을 관리하는 데 중요하며 동시성, 스레드 풀링 및 스케줄링을 처리합니다.\n\n구성 요소는 다음과 같습니다:\n\n- Job — 코루틴의 수명을 제어합니다.\n- CoroutineDispatcher — 작업을 적절한 스레드로 보냅니다.\n- CoroutineName — 코루틴의 이름으로 디버깅에 유용합니다.\n- CoroutineExceptionHandler — 처리되지 않은 예외를 처리합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCoroutine은 새 작업 및 부모로부터 상속된 다른 것들의 CoroutineContext입니다.\n\nCoroutineScope는 코루틴을 생성할 수 있고 코루틴 내에서 더 많은 코루틴을 생성할 수 있기 때문에 암시적인 작업 계층이 생성됩니다. 다음 코드 스니펫에서는 CoroutineScope를 사용하여 새 코루틴을 생성하는 것 외에도 코루틴 내에서 더 많은 코루틴을 생성하는 방법을 살펴보십시오:\n\n```js\nval scope = CoroutineScope(Job() + Dispatchers.Main)\nval job = scope.launch {\n    // CoroutineScope를 부모로 가지는 새 코루틴\n    val result = async {\n        // launch에 의해 시작된 코루틴을 부모로 가지는 새 코루틴\n    }.await()\n}\n```\n\n해당 계층의 루트는 일반적으로 CoroutineScope입니다. 이 계층 구조를 다음과 같이 시각화할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Kotlin Coroutine Essentials](/assets/img/2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow_2.png)\n\n코루틴은 작업 계층 구조에서 실행됩니다. 부모는 CoroutineScope 또는 다른 코루틴이 될 수 있습니다.\n\n# 부모 CoroutineContext:\n\n작업 계층 구조에서 각 코루틴은 CoroutineScope 또는 다른 코루틴이 될 수 있는 부모를 가지고 있습니다. 그러나 코루틴의 결과 CoroutineContext는 부모의 CoroutineContext와 다를 수 있습니다. 왜냐하면 이 공식에 따라 계산되기 때문입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위와 같이 표현됩니다:\n\n- 일부 요소는 기본 값을 가집니다: Dispatchers.Default는 CoroutineDispatcher의 기본값이며, \"coroutine\"은 CoroutineName의 기본값입니다.\n- 상속된 CoroutineContext는 해당 Coroutine을 생성한 coroutine의 CoroutineContext입니다.\n- Coroutine 빌더에 전달된 인수는 상속된 컨텍스트의 해당 요소들보다 우선합니다. (아래 예시 참조)\n\n참고: CoroutineContext는 + 연산자를 사용하여 결합할 수 있습니다. CoroutineContext는 요소의 집합이므로, + 연산자 오른쪽 요소들이 왼쪽 요소를 재정의하여 새로운 CoroutineContext가 생성됩니다.\n\n예시: (Dispatchers.Main, \"name\") + (Dispatchers.IO) = (Dispatchers.IO, \"name\")\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Coroutine Context](/assets/img/2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow_3.png)\n\n이 CoroutineScope에서 시작된 모든 코루틴은 CoroutineContext에 적어도 이러한 요소가 있을 것입니다. CoroutineName은 기본 값에서 가져오므로 회색으로 표시됩니다.\n\n새 코루틴의 부모 CoroutineContext를 알았으니, 그 코루틴의 실제 CoroutineContext는 다음과 같습니다:\n\n위 이미지에 표시된 CoroutineScope를 사용하여 위와 같이 새 코루틴을 생성하면:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nval job = scope.launch(Dispatchers.IO) {\n    // new coroutine\n}\n```\n\n그 코루틴의 부모 CoroutineContext 및 실제 CoroutineContext는 무엇입니까? 아래 이미지로 해답을 확인하세요!\n\n![해답 이미지](/assets/img/2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow_4.png)\n\nCoroutineContext 안의 Job과 부모 컨텍스트는 항상 동일한 인스턴스가 아니며, 새로운 Coroutine이 항상 새로운 Job 인스턴스를 가져오게 됩니다. (새로운 Job은 녹색이고 부모 Job은 빨강색입니다.)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`Dispatchers.IO`가 스코프의 `CoroutineDispatcher`를 덮어씌워서, 결과적으로 부모 CoroutineContext에는 Dispatchers.IO가 포함되어 있습니다.\n\n코루틴과 관련된 중요한 개념들을 이해하셨기를 바라며, 앞으로는 이를 효율적으로 활용하여 멋진 애플리케이션을 만드시기 바랍니다. 앞으로 제공될 흥미로운 콘텐츠를 기대해 주세요. 함께 해주셔서 감사합니다!\n","ogImage":{"url":"/assets/img/2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow_0.png"},"coverImage":"/assets/img/2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow_0.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow_0.png\"\u003e\n\u003cp\u003e안녕하세요! 이 글은 코루틴 시리즈에서 두 번째 글입니다. 코루틴을 완전히 이해하기 위해 확인해볼 수 있는 다음 글 목록입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e코루틴, 무엇인가, 어떻게 사용하며 왜 사용하는가?\u003c/li\u003e\n\u003cli\u003e코루틴 핵심 요소(이 글).\u003c/li\u003e\n\u003cli\u003e코루틴 내부 동작 방식.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이미 코루틴이 무엇이고 어디에 어떻게 사용하는지 알고 있다고 가정하고 있습니다. 아직 익숙하지 않다면 이 글을 읽어보세요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우선, 잘 알려진 Coroutine 빌더를 사용하여 우리의 코루틴을 만들어 보겠습니다:\u003c/p\u003e\n\u003ch1\u003eLaunch:\u003c/h1\u003e\n\u003cp\u003elaunch 코루틴 빌더는 결과를 반환하지 않는 새로운 코루틴을 시작하는 데 사용됩니다. 이는 실행 후 바로 잊을 수 있는 작업에 사용되며, 긴 실행 함수를 호출하고 반환 값을 신경 쓰지 않아도 되는 경우에 사용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efun \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"시작\"\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-comment\"\u003e// 코루틴 실행\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eGlobalScope\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elaunch\u003c/span\u003e {\n        \u003cspan class=\"hljs-title function_\"\u003edelay\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// 일부 백그라운드 작업 시뮬레이션\u003c/span\u003e\n        \u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"코루틴이 완료되었습니다\"\u003c/span\u003e)\n    }\n\n    \u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"끝\"\u003c/span\u003e)\n}\n\n\u003cspan class=\"hljs-comment\"\u003e//시작\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//끝\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//...\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//코루틴이 완료되었습니다\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e비동기:\u003c/h1\u003e\n\u003cp\u003e비동기 코루틴 빌더(async)는 Deferred 값을 반환하는 코루틴을 시작하는 데 사용됩니다. 우리는 지연된 값에 대해 중단 함수 await를 호출하여 기다리고 결과를 가져올 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efun \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"시작\"\u003c/span\u003e)\n\n    val deferredResult = \u003cspan class=\"hljs-title class_\"\u003eGlobalScope\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003easync\u003c/span\u003e {\n        \u003cspan class=\"hljs-title function_\"\u003edelay\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// 일부 백그라운드 작업 시뮬레이션\u003c/span\u003e\n        \u003cspan class=\"hljs-string\"\u003e\"코루틴 완료\"\u003c/span\u003e\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// 그 동안 다른 작업 수행\u003c/span\u003e\n\n    \u003cspan class=\"hljs-comment\"\u003e// 지연된 값에서 결과를 검색\u003c/span\u003e\n    runBlocking {\n        val result = deferredResult.\u003cspan class=\"hljs-title function_\"\u003eawait\u003c/span\u003e() \u003cspan class=\"hljs-comment\"\u003e// await는 중단 함수입니다\u003c/span\u003e\n        \u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(result)\n    }\n\n    \u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"끝\"\u003c/span\u003e)\n}\n\u003cspan class=\"hljs-comment\"\u003e//시작\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//코루틴 완료\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//끝\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eCoroutineScope:\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이것을 코루틴의 어머니로 생각해보세요. CoroutineScope는 생성 중인 모든 코루틴을 추적하며, 마치 어머니가 자녀를 돌보는 것과 같습니다.\u003c/p\u003e\n\u003cp\u003e진행 중인 작업(실행 중인 코루틴)은 언제든지 scope.cancel()을 호출하여 취소할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e특정 계층의 앱에서 코루틴의 수명주기를 시작하고 제어하고 싶을 때마다 CoroutineScope를 생성해야 합니다. 안드로이드에서는 viewModelScope, lifecycleScope 또는 전체 애플리케이션 수명주기를 위한 GlobalScope가 있습니다.\u003c/p\u003e\n\u003cp\u003eCoroutineScope를 생성할 때는 생성자의 매개변수로 CoroutineContext를 사용합니다. 다음 코드로 새로운 scope 및 코루틴을 생성할 수 있습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Job과 Dispatcher는 CoroutineContext로 결합되어 CoroutineContext에 대해 곧 논의할 것입니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e scope = CoroutineScope(Job() + Dispatchers.Main)\n\u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e job = scope.launch {\n    \u003cspan class=\"hljs-comment\"\u003e// 새로운 코루틴\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eJob:\u003c/h2\u003e\n\u003cp\u003e코루틴 내에서 Job 인스턴스는 코루틴 자체를 나타냅니다. Job은 코루틴에 대한 핸들입니다. launch 또는 async로 생성하는 각 코루틴에 대해 고유하게 식별되고 라이프사이클을 관리하는 Job 인스턴스가 반환됩니다.\u003c/p\u003e\n\u003cp\u003eJob은 일련의 상태를 거칠 수 있습니다: New, Active, Completing, Completed, Cancelling 및 Cancelled. 우리는 상태 자체에는 액세스할 수 없지만, Job의 속성에 액세스할 수 있습니다: isActive, isCancelled 및 isCompleted.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e작업/Coroutine의 상태:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow_1.png\" alt=\"Job/Coroutine States\"\u003e\u003c/p\u003e\n\u003cp\u003e작업 유형:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eJob: 단일 coroutine을 나타내며 시작, 대기 및 취소와 같은 라이프사이클을 제어할 수 있습니다. 간단한 비동기 작업에 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003eDeferredJob: 타입 T의 결과를 생성하는 coroutine을 나타내며 await 함수를 사용하여 결과를 대기할 수 있는 방법을 제공합니다. Deferred는 작업을 병행 및 비동기적으로 수행하고 결과를 얻어야 할 때 사용됩니다.\u003c/li\u003e\n\u003cli\u003eSupervisorJob: 자식 coroutines을 위한 부모 작업으로 사용되는 작업 유형입니다. 일반 작업과 달리 자식 coroutine의 실패 또는 취소가 부모 및 다른 자식에게 전파되지 않습니다. 작업 트리의 특정 가지에서 실패를 격리하고 싶을 때 유용합니다.\u003c/li\u003e\n\u003cli\u003eCompletableJob: 명시적으로 complete() 함수를 사용하여 완료할 수 있는 작업 유형입니다. 사용자 정의 구현이나 작업의 라이프사이클을 처리하는 사용자 정의 방법을 만들고 싶을 때 자주 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eCoroutineContext:\u003c/h1\u003e\n\u003cp\u003eCoroutineContext은 코루틴 실행의 컨텍스트를 나타내는 인터페이스입니다. 코루틴의 동작을 정의하는 요소 집합을 제공합니다. 이 컨텍스트는 코루틴 실행을 관리하는 데 중요하며 동시성, 스레드 풀링 및 스케줄링을 처리합니다.\u003c/p\u003e\n\u003cp\u003e구성 요소는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eJob — 코루틴의 수명을 제어합니다.\u003c/li\u003e\n\u003cli\u003eCoroutineDispatcher — 작업을 적절한 스레드로 보냅니다.\u003c/li\u003e\n\u003cli\u003eCoroutineName — 코루틴의 이름으로 디버깅에 유용합니다.\u003c/li\u003e\n\u003cli\u003eCoroutineExceptionHandler — 처리되지 않은 예외를 처리합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eCoroutine은 새 작업 및 부모로부터 상속된 다른 것들의 CoroutineContext입니다.\u003c/p\u003e\n\u003cp\u003eCoroutineScope는 코루틴을 생성할 수 있고 코루틴 내에서 더 많은 코루틴을 생성할 수 있기 때문에 암시적인 작업 계층이 생성됩니다. 다음 코드 스니펫에서는 CoroutineScope를 사용하여 새 코루틴을 생성하는 것 외에도 코루틴 내에서 더 많은 코루틴을 생성하는 방법을 살펴보십시오:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eval scope = \u003cspan class=\"hljs-title class_\"\u003eCoroutineScope\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eJob\u003c/span\u003e() + \u003cspan class=\"hljs-title class_\"\u003eDispatchers\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eMain\u003c/span\u003e)\nval job = scope.\u003cspan class=\"hljs-property\"\u003elaunch\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// CoroutineScope를 부모로 가지는 새 코루틴\u003c/span\u003e\n    val result = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// launch에 의해 시작된 코루틴을 부모로 가지는 새 코루틴\u003c/span\u003e\n    }.\u003cspan class=\"hljs-title function_\"\u003eawait\u003c/span\u003e()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e해당 계층의 루트는 일반적으로 CoroutineScope입니다. 이 계층 구조를 다음과 같이 시각화할 수 있습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow_2.png\" alt=\"Kotlin Coroutine Essentials\"\u003e\u003c/p\u003e\n\u003cp\u003e코루틴은 작업 계층 구조에서 실행됩니다. 부모는 CoroutineScope 또는 다른 코루틴이 될 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e부모 CoroutineContext:\u003c/h1\u003e\n\u003cp\u003e작업 계층 구조에서 각 코루틴은 CoroutineScope 또는 다른 코루틴이 될 수 있는 부모를 가지고 있습니다. 그러나 코루틴의 결과 CoroutineContext는 부모의 CoroutineContext와 다를 수 있습니다. 왜냐하면 이 공식에 따라 계산되기 때문입니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위와 같이 표현됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e일부 요소는 기본 값을 가집니다: Dispatchers.Default는 CoroutineDispatcher의 기본값이며, \"coroutine\"은 CoroutineName의 기본값입니다.\u003c/li\u003e\n\u003cli\u003e상속된 CoroutineContext는 해당 Coroutine을 생성한 coroutine의 CoroutineContext입니다.\u003c/li\u003e\n\u003cli\u003eCoroutine 빌더에 전달된 인수는 상속된 컨텍스트의 해당 요소들보다 우선합니다. (아래 예시 참조)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e참고: CoroutineContext는 + 연산자를 사용하여 결합할 수 있습니다. CoroutineContext는 요소의 집합이므로, + 연산자 오른쪽 요소들이 왼쪽 요소를 재정의하여 새로운 CoroutineContext가 생성됩니다.\u003c/p\u003e\n\u003cp\u003e예시: (Dispatchers.Main, \"name\") + (Dispatchers.IO) = (Dispatchers.IO, \"name\")\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow_3.png\" alt=\"Coroutine Context\"\u003e\u003c/p\u003e\n\u003cp\u003e이 CoroutineScope에서 시작된 모든 코루틴은 CoroutineContext에 적어도 이러한 요소가 있을 것입니다. CoroutineName은 기본 값에서 가져오므로 회색으로 표시됩니다.\u003c/p\u003e\n\u003cp\u003e새 코루틴의 부모 CoroutineContext를 알았으니, 그 코루틴의 실제 CoroutineContext는 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e위 이미지에 표시된 CoroutineScope를 사용하여 위와 같이 새 코루틴을 생성하면:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e job = scope.launch(Dispatchers.IO) {\n    \u003cspan class=\"hljs-comment\"\u003e// new coroutine\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그 코루틴의 부모 CoroutineContext 및 실제 CoroutineContext는 무엇입니까? 아래 이미지로 해답을 확인하세요!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow_4.png\" alt=\"해답 이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eCoroutineContext 안의 Job과 부모 컨텍스트는 항상 동일한 인스턴스가 아니며, 새로운 Coroutine이 항상 새로운 Job 인스턴스를 가져오게 됩니다. (새로운 Job은 녹색이고 부모 Job은 빨강색입니다.)\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003ccode\u003eDispatchers.IO\u003c/code\u003e가 스코프의 \u003ccode\u003eCoroutineDispatcher\u003c/code\u003e를 덮어씌워서, 결과적으로 부모 CoroutineContext에는 Dispatchers.IO가 포함되어 있습니다.\u003c/p\u003e\n\u003cp\u003e코루틴과 관련된 중요한 개념들을 이해하셨기를 바라며, 앞으로는 이를 효율적으로 활용하여 멋진 애플리케이션을 만드시기 바랍니다. 앞으로 제공될 흥미로운 콘텐츠를 기대해 주세요. 함께 해주셔서 감사합니다!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-18-KotlinCoroutineEssentialsEverythingyouneedtoknow"},"buildId":"wfHLuDA3kTGBYfaM5IGXk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>