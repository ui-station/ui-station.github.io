<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Jetpack Compose 안드로이드에서 사용자 지정 PDF 뷰어 만들기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Jetpack Compose 안드로이드에서 사용자 지정 PDF 뷰어 만들기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Jetpack Compose 안드로이드에서 사용자 지정 PDF 뷰어 만들기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid" data-gatsby-head="true"/><meta name="twitter:title" content="Jetpack Compose 안드로이드에서 사용자 지정 PDF 뷰어 만들기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 13:43" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_buildManifest.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Jetpack Compose 안드로이드에서 사용자 지정 PDF 뷰어 만들기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Jetpack Compose 안드로이드에서 사용자 지정 PDF 뷰어 만들기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">10<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png" alt="PDFViewer"></p>
<p>PDF는 우리가 매일 사용하는 가장 일반적인 파일 형식 중 하나입니다. 그러나 Jetpack Compose에서 공식 PDF 뷰어가 아직 없습니다. 그렇다면 왜 만들지 않을까요?</p>
<h2>어떻게 가능한가요?</h2>
<p>우리의 계획 개요를 살펴봅시다:</p>
<p></p>
<ul>
<li>PDF 파일이 있는 원격 URL 또는 전화 저장소가 있습니다.</li>
<li>하나씩 페이지를 보여줄 수 있습니다.</li>
<li>페이지는 확대 및 이동할 수 있어야 합니다.</li>
<li>서버 PDF를 로컬 캐시/저장소에 다운로드하고 저장해야 합니다.</li>
<li>PDF를 '페이지'를 나타내는 '비트맵' 목록으로 변환할 수 있습니다.</li>
<li>그런 다음 간단히, 비트맵을 지원하는 이미지 컴포저블을 사용하여 세로로 페이지를 하나씩 모두 표시할 것입니다.</li>
</ul>
<h2>단계 1: PDF 다운로드 및 저장</h2>
<p>이 시점에서 PDF의 URL만 있습니다. 이를 다운로드하는 기능을 만들어 보겠습니다.</p>
<p>먼저 AndroidManifest.xml에 다음 권한을 추가하세요.</p>
<p></p>
<pre><code class="hljs language-java">&#x3C;uses-permission android:name=<span class="hljs-string">"android.permission.INTERNET"</span> />
&#x3C;uses-permission android:name=<span class="hljs-string">"android.permission.ACCESS_NETWORK_STATE"</span> />
</code></pre>
<p>우리는 HttpURLConnection 객체를 사용하여 연결을 설정하고 InputStream을 가져올 것입니다.</p>
<pre><code class="hljs language-java"><span class="hljs-type">val</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> URL(url).openConnection() as HttpURLConnection
connection.connect()
</code></pre>
<p>위의 코드들이 작동하여 PDF 파일을 가져올 것입니다. 작업이 완료되었고 필요한 Input stream을 얻었는지 확인해보세요.</p>
<p></p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">if</span> (connection.responseCode != HttpURLConnection.HTTP_OK) {
    connection.disconnect()
    <span class="hljs-keyword">return</span><span class="hljs-symbol">@withContext</span> <span class="hljs-literal">null</span>
}

<span class="hljs-keyword">val</span> inputStream = connection.inputStream
</code></pre>
<p>작업이 끝나면 꼭 연결을 끊어 주세요.</p>
<pre><code class="hljs language-kotlin">connection.disconnect()
</code></pre>
<p>이제 다운로드 부분이 완료되었으니 사용자의 로컬 스토리지에 저장해주세요.</p>
<p></p>
<pre><code class="hljs language-kotlin">file = File.createTempFile(fileName, <span class="hljs-string">".pdf"</span>)
<span class="hljs-keyword">val</span> outputStream = FileOutputStream(file)
inputStream.copyTo(outputStream)
outputStream.close()
</code></pre>
<p>변경 후 전체 함수는 다음과 같습니다:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">downloadAndGetFile</span><span class="hljs-params">(url: <span class="hljs-type">String</span>, fileName: <span class="hljs-type">String</span>)</span></span>: File? {
    <span class="hljs-keyword">if</span> (isFileExist(fileName)) <span class="hljs-keyword">return</span> File(fileName) <span class="hljs-comment">// 이 줄은 중복 파일 생성을 피하기 위해 중요합니다.</span>
    <span class="hljs-keyword">var</span> connection: HttpURLConnection? = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">var</span> file: File? = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">try</span> {
        withContext(Dispatchers.IO) {
            connection = URL(url).openConnection() <span class="hljs-keyword">as</span> HttpURLConnection
            connection!!.connect()

            <span class="hljs-keyword">if</span> (connection!!.responseCode != HttpURLConnection.HTTP_OK) {
                <span class="hljs-keyword">return</span><span class="hljs-symbol">@withContext</span> <span class="hljs-literal">null</span>
            }

            <span class="hljs-keyword">val</span> inputStream = connection!!.inputStream
            file = File.createTempFile(fileName, <span class="hljs-string">".pdf"</span>)
            <span class="hljs-keyword">val</span> outputStream = FileOutputStream(file)
            inputStream.copyTo(outputStream)
            outputStream.close()
        }
    } <span class="hljs-keyword">catch</span> (e: IOException) {
        <span class="hljs-comment">// UI에 응답을 전송합니다.</span>
    } <span class="hljs-keyword">finally</span> {
        connection?.disconnect()
    }
    <span class="hljs-keyword">return</span> file
}
</code></pre>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isFileExist</span><span class="hljs-params">(path: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">val</span> file = File(path)
    <span class="hljs-keyword">return</span> file.exists()
}
</code></pre>
<p></p>
<h2>단계 2: 파일 객체를 List<code>Bitmap</code>으로 변환합니다.</h2>
<p>이 변환에는 PdfRenderer 클래스를 사용할 것입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">PdfRenderer</span> renderer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PdfRenderer</span>(<span class="hljs-title class_">ParcelFileDescriptor</span>.<span class="hljs-title function_">open</span>(file, <span class="hljs-title class_">ParcelFileDescriptor</span>.<span class="hljs-property">MODE_READ_ONLY</span>));
</code></pre>
<p>하지만 이것을 직접 사용하는 것은 Jetpack Compose에서 좋지 않고 많은 RAM을 소비할 수 있습니다.</p>
<p></p>
<p>그럼 다음과 같이 사용할 것입니다:</p>
<pre><code class="hljs language-js">val rendererScope = <span class="hljs-title function_">rememberCoroutineScope</span>()
val mutex = remember { <span class="hljs-title class_">Mutex</span>() }
val renderer by produceState&#x3C;<span class="hljs-title class_">PdfRenderer</span>?>(<span class="hljs-literal">null</span>, file) {
    rendererScope.<span class="hljs-title function_">launch</span>(<span class="hljs-params">Dispatchers.IO</span>) {
        val input = <span class="hljs-title class_">ParcelFileDescriptor</span>.<span class="hljs-title function_">open</span>(file, <span class="hljs-title class_">ParcelFileDescriptor</span>.<span class="hljs-property">MODE_READ_ONLY</span>)
        value = <span class="hljs-title class_">PdfRenderer</span>(input)
    }
    awaitDispose {
        val currentRenderer = value
        rendererScope.<span class="hljs-title function_">launch</span>(<span class="hljs-params">Dispatchers.IO</span>) {
            mutex.<span class="hljs-property">withLock</span> {
                currentRenderer?.<span class="hljs-title function_">close</span>()
            }
        }
    }
}
</code></pre>
<p>이제 우리가 만든 "PDFRenderer" 객체인 "renderer"를 사용하여 모든 페이지를 가져와 비트맵 객체에 렌더링할 것입니다.</p>
<pre><code class="hljs language-js">renderer?.<span class="hljs-property">let</span> {
    it.<span class="hljs-title function_">openPage</span>(index).<span class="hljs-property">use</span> { page ->
        page.<span class="hljs-title function_">render</span>(destinationBitmap, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-title class_">PdfRenderer</span>.<span class="hljs-property">Page</span>.<span class="hljs-property">RENDER_MODE_FOR_DISPLAY</span>)
    }
}
</code></pre>
<p></p>
<p>이제 모든 페이지에 대한 비트맵을 가져올 수 있습니다. UI에서 모든 페이지에 표시할 시간입니다.</p>
<h2>단계 3: UI에 목록<code>비트맵</code> 표시 + 줌 및 이동 기능 추가:</h2>
<p>PDFViewer Composable의 전체 코드가 필요하면 이를 참조하십시오:</p>
<p>여기서 설명이 시작됩니다:</p>
<p></p>
<ul>
<li>BoxWithConstraints를 사용하는 이유는 페이지의 높이와 너비를 정의하고 줌 및 이동을 위해 화면의 높이와 너비가 필요하기 때문입니다.</li>
</ul>
<pre><code class="hljs language-js">            val width = <span class="hljs-title function_">with</span>(<span class="hljs-params">LocalDensity.current</span>) { maxWidth.<span class="hljs-title function_">toPx</span>() }.<span class="hljs-title function_">toInt</span>()
            val height = (width * <span class="hljs-title function_">sqrt</span>(2f)).<span class="hljs-title function_">toInt</span>()
            val pageCount by <span class="hljs-title function_">remember</span>(<span class="hljs-params">renderer</span>) { derivedStateOf { renderer?.<span class="hljs-property">pageCount</span> ?: <span class="hljs-number">0</span> } }<span class="hljs-comment">//Used ahead</span>

            <span class="hljs-keyword">var</span> scale by rememberSaveable {
                <span class="hljs-title function_">mutableFloatStateOf</span>(1f)
            }
            <span class="hljs-keyword">var</span> offset by remember {
                <span class="hljs-title function_">mutableStateOf</span>(<span class="hljs-title class_">Offset</span>.<span class="hljs-property">Zero</span>)
            }
            val state = <span class="hljs-comment">//Used for Zoom and Move</span>
                rememberTransformableState { zoomChange, panChange, rotationChange ->
                    scale = (scale * zoomChange).<span class="hljs-title function_">coerceIn</span>(1f, 5f)

                    val extraWidth = (scale - <span class="hljs-number">1</span>) * constraints.<span class="hljs-property">maxWidth</span>
                    val extraHeight = (scale - <span class="hljs-number">1</span>) * constraints.<span class="hljs-property">maxHeight</span>

                    val maxX = extraWidth / <span class="hljs-number">2</span>
                    val maxY = extraHeight / <span class="hljs-number">2</span>

                    offset = <span class="hljs-title class_">Offset</span>(
                        x = (offset.<span class="hljs-property">x</span> + scale * panChange.<span class="hljs-property">x</span>).<span class="hljs-title function_">coerceIn</span>(-maxX, maxX),
                        y = (offset.<span class="hljs-property">y</span> + scale * panChange.<span class="hljs-property">y</span>).<span class="hljs-title function_">coerceIn</span>(-maxY, maxY),
                    )
                }
</code></pre>
<p>Zoom 구현을 자세히 이해하려면 이 비디오를 시청하세요.</p>
<ol start="2">
<li>이 상태를 LazyColumn과 함께 간단히 사용하고 있습니다:</li>
</ol>
<p></p>
<pre><code class="hljs language-kotlin">            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .graphicsLayer {
                        scaleX = scale
                        scaleY = scale
                        translationX = offset.x
                        translationX = offset.y
                    }
                    .transformable(state)
</code></pre>
<ol start="3">
<li>호출할 때 이미 PDF 파일을 다운로드하고 저장했습니다.</li>
</ol>
<pre><code class="hljs language-kotlin">LaunchedEffect(key1 = <span class="hljs-built_in">Unit</span>) {
        file = async { downloadAndGetFile(url, fileName) }.await()
    }
</code></pre>
<ol start="4">
<li>"cacheKey"로부터 Bitmap 객체를 만들어야 합니다. 이미지도 캐시에 저장될 것입니다.</li>
</ol>
<p></p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> cacheKey = MemoryCache.Key(<span class="hljs-string">"<span class="hljs-subst">${file!!.name}</span>-<span class="hljs-variable">$index</span>"</span>)
<span class="hljs-keyword">val</span> cacheValue: Bitmap? = imageLoader.memoryCache?.<span class="hljs-keyword">get</span>(cacheKey)?.bitmap
<span class="hljs-keyword">var</span> bitmap: Bitmap? <span class="hljs-keyword">by</span> remember { mutableStateOf(cacheValue) }
</code></pre>
<ol start="5">
<li>이후에는 각 페이지의 비트맵을 가져와 Coil ImageRequest 객체로 표시합니다.</li>
</ol>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> request = ImageRequest.Builder(context)
    .size(width, height)
    .memoryCacheKey(cacheKey)
    .<span class="hljs-keyword">data</span>(bitmap)
    .build()

Image(
    modifier = Modifier
        .background(Color.Transparent)
        .border(<span class="hljs-number">1.</span>dp, MaterialTheme.colors.background)
<span class="hljs-comment">//        .aspectRatio(1f / sqrt(2f))</span>
        .fillMaxSize(),
    contentScale = ContentScale.Fit,
    painter = rememberAsyncImagePainter(request),
    contentDescription = <span class="hljs-string">"Page <span class="hljs-subst">${index + <span class="hljs-number">1</span>}</span> of <span class="hljs-variable">$pageCount</span>"</span>
)
</code></pre>
<p>나머지 부분은 상당히 직관적이고 이해하기 쉽습니다.</p>
<p></p>
<p>여기서 새로운 것을 배웠다면, 좋다면 팔로우 버튼을 눌러 주세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Jetpack Compose 안드로이드에서 사용자 지정 PDF 뷰어 만들기","description":"","date":"2024-06-19 13:43","slug":"2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid","content":"\n![PDFViewer](/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png)\n\nPDF는 우리가 매일 사용하는 가장 일반적인 파일 형식 중 하나입니다. 그러나 Jetpack Compose에서 공식 PDF 뷰어가 아직 없습니다. 그렇다면 왜 만들지 않을까요?\n\n## 어떻게 가능한가요?\n\n우리의 계획 개요를 살펴봅시다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- PDF 파일이 있는 원격 URL 또는 전화 저장소가 있습니다.\n- 하나씩 페이지를 보여줄 수 있습니다.\n- 페이지는 확대 및 이동할 수 있어야 합니다.\n- 서버 PDF를 로컬 캐시/저장소에 다운로드하고 저장해야 합니다.\n- PDF를 '페이지'를 나타내는 '비트맵' 목록으로 변환할 수 있습니다.\n- 그런 다음 간단히, 비트맵을 지원하는 이미지 컴포저블을 사용하여 세로로 페이지를 하나씩 모두 표시할 것입니다.\n\n## 단계 1: PDF 다운로드 및 저장\n\n이 시점에서 PDF의 URL만 있습니다. 이를 다운로드하는 기능을 만들어 보겠습니다.\n\n먼저 AndroidManifest.xml에 다음 권한을 추가하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\n\u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e\n\u003cuses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /\u003e\n```\n\n우리는 HttpURLConnection 객체를 사용하여 연결을 설정하고 InputStream을 가져올 것입니다.\n\n```java\nval connection = URL(url).openConnection() as HttpURLConnection\nconnection.connect()\n```\n\n위의 코드들이 작동하여 PDF 파일을 가져올 것입니다. 작업이 완료되었고 필요한 Input stream을 얻었는지 확인해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nif (connection.responseCode != HttpURLConnection.HTTP_OK) {\n    connection.disconnect()\n    return@withContext null\n}\n\nval inputStream = connection.inputStream\n```\n\n작업이 끝나면 꼭 연결을 끊어 주세요.\n\n```kotlin\nconnection.disconnect()\n```\n\n이제 다운로드 부분이 완료되었으니 사용자의 로컬 스토리지에 저장해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nfile = File.createTempFile(fileName, \".pdf\")\nval outputStream = FileOutputStream(file)\ninputStream.copyTo(outputStream)\noutputStream.close()\n```\n\n변경 후 전체 함수는 다음과 같습니다:\n\n```kotlin\nsuspend fun downloadAndGetFile(url: String, fileName: String): File? {\n    if (isFileExist(fileName)) return File(fileName) // 이 줄은 중복 파일 생성을 피하기 위해 중요합니다.\n    var connection: HttpURLConnection? = null\n    var file: File? = null\n    try {\n        withContext(Dispatchers.IO) {\n            connection = URL(url).openConnection() as HttpURLConnection\n            connection!!.connect()\n\n            if (connection!!.responseCode != HttpURLConnection.HTTP_OK) {\n                return@withContext null\n            }\n\n            val inputStream = connection!!.inputStream\n            file = File.createTempFile(fileName, \".pdf\")\n            val outputStream = FileOutputStream(file)\n            inputStream.copyTo(outputStream)\n            outputStream.close()\n        }\n    } catch (e: IOException) {\n        // UI에 응답을 전송합니다.\n    } finally {\n        connection?.disconnect()\n    }\n    return file\n}\n```\n\n```kotlin\nfun isFileExist(path: String): Boolean {\n    val file = File(path)\n    return file.exists()\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 2: 파일 객체를 List`Bitmap`으로 변환합니다.\n\n이 변환에는 PdfRenderer 클래스를 사용할 것입니다:\n\n```js\nPdfRenderer renderer = new PdfRenderer(ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY));\n```\n\n하지만 이것을 직접 사용하는 것은 Jetpack Compose에서 좋지 않고 많은 RAM을 소비할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼 다음과 같이 사용할 것입니다:\n\n```js\nval rendererScope = rememberCoroutineScope()\nval mutex = remember { Mutex() }\nval renderer by produceState\u003cPdfRenderer?\u003e(null, file) {\n    rendererScope.launch(Dispatchers.IO) {\n        val input = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY)\n        value = PdfRenderer(input)\n    }\n    awaitDispose {\n        val currentRenderer = value\n        rendererScope.launch(Dispatchers.IO) {\n            mutex.withLock {\n                currentRenderer?.close()\n            }\n        }\n    }\n}\n```\n\n이제 우리가 만든 \"PDFRenderer\" 객체인 \"renderer\"를 사용하여 모든 페이지를 가져와 비트맵 객체에 렌더링할 것입니다.\n\n```js\nrenderer?.let {\n    it.openPage(index).use { page -\u003e\n        page.render(destinationBitmap, null, null, PdfRenderer.Page.RENDER_MODE_FOR_DISPLAY)\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 모든 페이지에 대한 비트맵을 가져올 수 있습니다. UI에서 모든 페이지에 표시할 시간입니다.\n\n## 단계 3: UI에 목록`비트맵` 표시 + 줌 및 이동 기능 추가:\n\nPDFViewer Composable의 전체 코드가 필요하면 이를 참조하십시오:\n\n여기서 설명이 시작됩니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- BoxWithConstraints를 사용하는 이유는 페이지의 높이와 너비를 정의하고 줌 및 이동을 위해 화면의 높이와 너비가 필요하기 때문입니다.\n\n```js\n            val width = with(LocalDensity.current) { maxWidth.toPx() }.toInt()\n            val height = (width * sqrt(2f)).toInt()\n            val pageCount by remember(renderer) { derivedStateOf { renderer?.pageCount ?: 0 } }//Used ahead\n\n            var scale by rememberSaveable {\n                mutableFloatStateOf(1f)\n            }\n            var offset by remember {\n                mutableStateOf(Offset.Zero)\n            }\n            val state = //Used for Zoom and Move\n                rememberTransformableState { zoomChange, panChange, rotationChange -\u003e\n                    scale = (scale * zoomChange).coerceIn(1f, 5f)\n\n                    val extraWidth = (scale - 1) * constraints.maxWidth\n                    val extraHeight = (scale - 1) * constraints.maxHeight\n\n                    val maxX = extraWidth / 2\n                    val maxY = extraHeight / 2\n\n                    offset = Offset(\n                        x = (offset.x + scale * panChange.x).coerceIn(-maxX, maxX),\n                        y = (offset.y + scale * panChange.y).coerceIn(-maxY, maxY),\n                    )\n                }\n```\n\nZoom 구현을 자세히 이해하려면 이 비디오를 시청하세요.\n\n2. 이 상태를 LazyColumn과 함께 간단히 사용하고 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n            LazyColumn(\n                modifier = Modifier\n                    .fillMaxSize()\n                    .graphicsLayer {\n                        scaleX = scale\n                        scaleY = scale\n                        translationX = offset.x\n                        translationX = offset.y\n                    }\n                    .transformable(state)\n```\n\n3. 호출할 때 이미 PDF 파일을 다운로드하고 저장했습니다.\n\n```kotlin\nLaunchedEffect(key1 = Unit) {\n        file = async { downloadAndGetFile(url, fileName) }.await()\n    }\n```\n\n4. \"cacheKey\"로부터 Bitmap 객체를 만들어야 합니다. 이미지도 캐시에 저장될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nval cacheKey = MemoryCache.Key(\"${file!!.name}-$index\")\nval cacheValue: Bitmap? = imageLoader.memoryCache?.get(cacheKey)?.bitmap\nvar bitmap: Bitmap? by remember { mutableStateOf(cacheValue) }\n```\n\n5. 이후에는 각 페이지의 비트맵을 가져와 Coil ImageRequest 객체로 표시합니다.\n\n```kotlin\nval request = ImageRequest.Builder(context)\n    .size(width, height)\n    .memoryCacheKey(cacheKey)\n    .data(bitmap)\n    .build()\n\nImage(\n    modifier = Modifier\n        .background(Color.Transparent)\n        .border(1.dp, MaterialTheme.colors.background)\n//        .aspectRatio(1f / sqrt(2f))\n        .fillMaxSize(),\n    contentScale = ContentScale.Fit,\n    painter = rememberAsyncImagePainter(request),\n    contentDescription = \"Page ${index + 1} of $pageCount\"\n)\n```\n\n나머지 부분은 상당히 직관적이고 이해하기 쉽습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 새로운 것을 배웠다면, 좋다면 팔로우 버튼을 눌러 주세요.\n","ogImage":{"url":"/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png"},"coverImage":"/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png","tag":["Tech"],"readingTime":10},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png\" alt=\"PDFViewer\"\u003e\u003c/p\u003e\n\u003cp\u003ePDF는 우리가 매일 사용하는 가장 일반적인 파일 형식 중 하나입니다. 그러나 Jetpack Compose에서 공식 PDF 뷰어가 아직 없습니다. 그렇다면 왜 만들지 않을까요?\u003c/p\u003e\n\u003ch2\u003e어떻게 가능한가요?\u003c/h2\u003e\n\u003cp\u003e우리의 계획 개요를 살펴봅시다:\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePDF 파일이 있는 원격 URL 또는 전화 저장소가 있습니다.\u003c/li\u003e\n\u003cli\u003e하나씩 페이지를 보여줄 수 있습니다.\u003c/li\u003e\n\u003cli\u003e페이지는 확대 및 이동할 수 있어야 합니다.\u003c/li\u003e\n\u003cli\u003e서버 PDF를 로컬 캐시/저장소에 다운로드하고 저장해야 합니다.\u003c/li\u003e\n\u003cli\u003ePDF를 '페이지'를 나타내는 '비트맵' 목록으로 변환할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e그런 다음 간단히, 비트맵을 지원하는 이미지 컴포저블을 사용하여 세로로 페이지를 하나씩 모두 표시할 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e단계 1: PDF 다운로드 및 저장\u003c/h2\u003e\n\u003cp\u003e이 시점에서 PDF의 URL만 있습니다. 이를 다운로드하는 기능을 만들어 보겠습니다.\u003c/p\u003e\n\u003cp\u003e먼저 AndroidManifest.xml에 다음 권한을 추가하세요.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u0026#x3C;uses-permission android:name=\u003cspan class=\"hljs-string\"\u003e\"android.permission.INTERNET\"\u003c/span\u003e /\u003e\n\u0026#x3C;uses-permission android:name=\u003cspan class=\"hljs-string\"\u003e\"android.permission.ACCESS_NETWORK_STATE\"\u003c/span\u003e /\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 HttpURLConnection 객체를 사용하여 연결을 설정하고 InputStream을 가져올 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-type\"\u003eval\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003econnection\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e URL(url).openConnection() as HttpURLConnection\nconnection.connect()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 코드들이 작동하여 PDF 파일을 가져올 것입니다. 작업이 완료되었고 필요한 Input stream을 얻었는지 확인해보세요.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (connection.responseCode != HttpURLConnection.HTTP_OK) {\n    connection.disconnect()\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\u003cspan class=\"hljs-symbol\"\u003e@withContext\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e inputStream = connection.inputStream\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e작업이 끝나면 꼭 연결을 끊어 주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003econnection.disconnect()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 다운로드 부분이 완료되었으니 사용자의 로컬 스토리지에 저장해주세요.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003efile = File.createTempFile(fileName, \u003cspan class=\"hljs-string\"\u003e\".pdf\"\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e outputStream = FileOutputStream(file)\ninputStream.copyTo(outputStream)\noutputStream.close()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e변경 후 전체 함수는 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-keyword\"\u003esuspend\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003edownloadAndGetFile\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(url: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e, fileName: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e: File? {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isFileExist(fileName)) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e File(fileName) \u003cspan class=\"hljs-comment\"\u003e// 이 줄은 중복 파일 생성을 피하기 위해 중요합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e connection: HttpURLConnection? = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e file: File? = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n        withContext(Dispatchers.IO) {\n            connection = URL(url).openConnection() \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e HttpURLConnection\n            connection!!.connect()\n\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (connection!!.responseCode != HttpURLConnection.HTTP_OK) {\n                \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\u003cspan class=\"hljs-symbol\"\u003e@withContext\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n            }\n\n            \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e inputStream = connection!!.inputStream\n            file = File.createTempFile(fileName, \u003cspan class=\"hljs-string\"\u003e\".pdf\"\u003c/span\u003e)\n            \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e outputStream = FileOutputStream(file)\n            inputStream.copyTo(outputStream)\n            outputStream.close()\n        }\n    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (e: IOException) {\n        \u003cspan class=\"hljs-comment\"\u003e// UI에 응답을 전송합니다.\u003c/span\u003e\n    } \u003cspan class=\"hljs-keyword\"\u003efinally\u003c/span\u003e {\n        connection?.disconnect()\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e file\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eisFileExist\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(path: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eBoolean\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e file = File(path)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e file.exists()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e단계 2: 파일 객체를 List\u003ccode\u003eBitmap\u003c/code\u003e으로 변환합니다.\u003c/h2\u003e\n\u003cp\u003e이 변환에는 PdfRenderer 클래스를 사용할 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003ePdfRenderer\u003c/span\u003e renderer = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePdfRenderer\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eParcelFileDescriptor\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(file, \u003cspan class=\"hljs-title class_\"\u003eParcelFileDescriptor\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eMODE_READ_ONLY\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e하지만 이것을 직접 사용하는 것은 Jetpack Compose에서 좋지 않고 많은 RAM을 소비할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e그럼 다음과 같이 사용할 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eval rendererScope = \u003cspan class=\"hljs-title function_\"\u003erememberCoroutineScope\u003c/span\u003e()\nval mutex = remember { \u003cspan class=\"hljs-title class_\"\u003eMutex\u003c/span\u003e() }\nval renderer by produceState\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003ePdfRenderer\u003c/span\u003e?\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, file) {\n    rendererScope.\u003cspan class=\"hljs-title function_\"\u003elaunch\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eDispatchers.IO\u003c/span\u003e) {\n        val input = \u003cspan class=\"hljs-title class_\"\u003eParcelFileDescriptor\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(file, \u003cspan class=\"hljs-title class_\"\u003eParcelFileDescriptor\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eMODE_READ_ONLY\u003c/span\u003e)\n        value = \u003cspan class=\"hljs-title class_\"\u003ePdfRenderer\u003c/span\u003e(input)\n    }\n    awaitDispose {\n        val currentRenderer = value\n        rendererScope.\u003cspan class=\"hljs-title function_\"\u003elaunch\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eDispatchers.IO\u003c/span\u003e) {\n            mutex.\u003cspan class=\"hljs-property\"\u003ewithLock\u003c/span\u003e {\n                currentRenderer?.\u003cspan class=\"hljs-title function_\"\u003eclose\u003c/span\u003e()\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 우리가 만든 \"PDFRenderer\" 객체인 \"renderer\"를 사용하여 모든 페이지를 가져와 비트맵 객체에 렌더링할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003erenderer?.\u003cspan class=\"hljs-property\"\u003elet\u003c/span\u003e {\n    it.\u003cspan class=\"hljs-title function_\"\u003eopenPage\u003c/span\u003e(index).\u003cspan class=\"hljs-property\"\u003euse\u003c/span\u003e { page -\u003e\n        page.\u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(destinationBitmap, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003ePdfRenderer\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePage\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eRENDER_MODE_FOR_DISPLAY\u003c/span\u003e)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e이제 모든 페이지에 대한 비트맵을 가져올 수 있습니다. UI에서 모든 페이지에 표시할 시간입니다.\u003c/p\u003e\n\u003ch2\u003e단계 3: UI에 목록\u003ccode\u003e비트맵\u003c/code\u003e 표시 + 줌 및 이동 기능 추가:\u003c/h2\u003e\n\u003cp\u003ePDFViewer Composable의 전체 코드가 필요하면 이를 참조하십시오:\u003c/p\u003e\n\u003cp\u003e여기서 설명이 시작됩니다:\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBoxWithConstraints를 사용하는 이유는 페이지의 높이와 너비를 정의하고 줌 및 이동을 위해 화면의 높이와 너비가 필요하기 때문입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e            val width = \u003cspan class=\"hljs-title function_\"\u003ewith\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eLocalDensity.current\u003c/span\u003e) { maxWidth.\u003cspan class=\"hljs-title function_\"\u003etoPx\u003c/span\u003e() }.\u003cspan class=\"hljs-title function_\"\u003etoInt\u003c/span\u003e()\n            val height = (width * \u003cspan class=\"hljs-title function_\"\u003esqrt\u003c/span\u003e(2f)).\u003cspan class=\"hljs-title function_\"\u003etoInt\u003c/span\u003e()\n            val pageCount by \u003cspan class=\"hljs-title function_\"\u003eremember\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erenderer\u003c/span\u003e) { derivedStateOf { renderer?.\u003cspan class=\"hljs-property\"\u003epageCount\u003c/span\u003e ?: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e } }\u003cspan class=\"hljs-comment\"\u003e//Used ahead\u003c/span\u003e\n\n            \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e scale by rememberSaveable {\n                \u003cspan class=\"hljs-title function_\"\u003emutableFloatStateOf\u003c/span\u003e(1f)\n            }\n            \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e offset by remember {\n                \u003cspan class=\"hljs-title function_\"\u003emutableStateOf\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eOffset\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eZero\u003c/span\u003e)\n            }\n            val state = \u003cspan class=\"hljs-comment\"\u003e//Used for Zoom and Move\u003c/span\u003e\n                rememberTransformableState { zoomChange, panChange, rotationChange -\u003e\n                    scale = (scale * zoomChange).\u003cspan class=\"hljs-title function_\"\u003ecoerceIn\u003c/span\u003e(1f, 5f)\n\n                    val extraWidth = (scale - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) * constraints.\u003cspan class=\"hljs-property\"\u003emaxWidth\u003c/span\u003e\n                    val extraHeight = (scale - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) * constraints.\u003cspan class=\"hljs-property\"\u003emaxHeight\u003c/span\u003e\n\n                    val maxX = extraWidth / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n                    val maxY = extraHeight / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n\n                    offset = \u003cspan class=\"hljs-title class_\"\u003eOffset\u003c/span\u003e(\n                        x = (offset.\u003cspan class=\"hljs-property\"\u003ex\u003c/span\u003e + scale * panChange.\u003cspan class=\"hljs-property\"\u003ex\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ecoerceIn\u003c/span\u003e(-maxX, maxX),\n                        y = (offset.\u003cspan class=\"hljs-property\"\u003ey\u003c/span\u003e + scale * panChange.\u003cspan class=\"hljs-property\"\u003ey\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ecoerceIn\u003c/span\u003e(-maxY, maxY),\n                    )\n                }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eZoom 구현을 자세히 이해하려면 이 비디오를 시청하세요.\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e이 상태를 LazyColumn과 함께 간단히 사용하고 있습니다:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e            LazyColumn(\n                modifier = Modifier\n                    .fillMaxSize()\n                    .graphicsLayer {\n                        scaleX = scale\n                        scaleY = scale\n                        translationX = offset.x\n                        translationX = offset.y\n                    }\n                    .transformable(state)\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e호출할 때 이미 PDF 파일을 다운로드하고 저장했습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003eLaunchedEffect(key1 = \u003cspan class=\"hljs-built_in\"\u003eUnit\u003c/span\u003e) {\n        file = async { downloadAndGetFile(url, fileName) }.await()\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e\"cacheKey\"로부터 Bitmap 객체를 만들어야 합니다. 이미지도 캐시에 저장될 것입니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e cacheKey = MemoryCache.Key(\u003cspan class=\"hljs-string\"\u003e\"\u003cspan class=\"hljs-subst\"\u003e${file!!.name}\u003c/span\u003e-\u003cspan class=\"hljs-variable\"\u003e$index\u003c/span\u003e\"\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e cacheValue: Bitmap? = imageLoader.memoryCache?.\u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e(cacheKey)?.bitmap\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e bitmap: Bitmap? \u003cspan class=\"hljs-keyword\"\u003eby\u003c/span\u003e remember { mutableStateOf(cacheValue) }\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e이후에는 각 페이지의 비트맵을 가져와 Coil ImageRequest 객체로 표시합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e request = ImageRequest.Builder(context)\n    .size(width, height)\n    .memoryCacheKey(cacheKey)\n    .\u003cspan class=\"hljs-keyword\"\u003edata\u003c/span\u003e(bitmap)\n    .build()\n\nImage(\n    modifier = Modifier\n        .background(Color.Transparent)\n        .border(\u003cspan class=\"hljs-number\"\u003e1.\u003c/span\u003edp, MaterialTheme.colors.background)\n\u003cspan class=\"hljs-comment\"\u003e//        .aspectRatio(1f / sqrt(2f))\u003c/span\u003e\n        .fillMaxSize(),\n    contentScale = ContentScale.Fit,\n    painter = rememberAsyncImagePainter(request),\n    contentDescription = \u003cspan class=\"hljs-string\"\u003e\"Page \u003cspan class=\"hljs-subst\"\u003e${index + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e}\u003c/span\u003e of \u003cspan class=\"hljs-variable\"\u003e$pageCount\u003c/span\u003e\"\u003c/span\u003e\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e나머지 부분은 상당히 직관적이고 이해하기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e여기서 새로운 것을 배웠다면, 좋다면 팔로우 버튼을 눌러 주세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid"},"buildId":"bb_yO9GbCvdfc_n71SfUf","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>