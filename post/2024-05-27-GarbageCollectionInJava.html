<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>자바에서의 가비지 컬렉션 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-27-GarbageCollectionInJava" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="자바에서의 가비지 컬렉션 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="자바에서의 가비지 컬렉션 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-27-GarbageCollectionInJava_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-27-GarbageCollectionInJava" data-gatsby-head="true"/><meta name="twitter:title" content="자바에서의 가비지 컬렉션 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-27-GarbageCollectionInJava_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-27 15:48" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_buildManifest.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">자바에서의 가비지 컬렉션</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="자바에서의 가비지 컬렉션" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 27, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-27-GarbageCollectionInJava&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>자바에서 쓰레기 수거가 이뤄지는 방식에 대한 기본적인 설명</h2>
<p><img src="/assets/img/2024-05-27-GarbageCollectionInJava_0.png" alt="이미지"></p>
<h1>가비지 컬렉션이란?</h1>
<p>변수를 선언하는 것은 프로그래머로서 생활의 일부입니다. 변수를 사용하는 것은 코드의 재사용성을 향상시키는 것뿐만 아니라 코드의 가독성을 크게 향상시키고, 이는 결국 코드의 유지보수성을 높이는 데 큰 도움이 됩니다. 또한 선언된 변수가 일정 공간을 차지하고 특정 범위와 연결되어 있다는 것은 비밀이 아닙니다. 최적화된 메모리 관리를 위해 JVM이 이러한 객체들이 더 이상 필요하지 않을 때 제거하거나 파괴하는 것이 합리적입니다. 이렇게 "원치 않는" 변수들을 제거하는 프로세스를 가비지 컬렉션이라고 합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>자바에서의 가비지 컬렉션</h2>
<p>C, C++와 같은 언어에서는 가비지 컬렉션을 애플리케이션 개발자의 책임으로 간주됩니다. 이러한 언어에서는 쓰레기를 수동으로 처리하는 명시적 도구가 있습니다. 반면에 Java에서는 JVM이 가비지 컬렉션을 자동으로 처리합니다. JVM은 힙 메모리에서 언제 어디서 GC를 트리거할지 결정하는 일련의 프로세스를 거칩니다. 자바 개발자로서, 가비지 컬렉션의 기본 원리와 힙 메모리의 섹션을 이해하는 것이 매우 중요합니다. 이는 우리가 메모리를 효율적으로 사용하는 자바 애플리케이션을 개발하는 데 큰 도움이 될 것입니다.</p>
<h2>가비지 컬렉션에 포함된 단계</h2>
<p>자바 가비지 컬렉션은 일반적으로 2단계로 수행됩니다. 마크 단계와 스윕 단계입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>마크 단계: 마크 단계에서는 객체를 참조될 수 있는지 여부에 따라 두 가지 방식으로 분류합니다. 참조된 객체는 여전히 사용 중이며 범위에서 벗어나지 않은 객체입니다. 참조되지 않은 객체는 응용 프로그램에서 더 이상 필요하지 않은 객체입니다. 참조되지 않는 객체는 가비지 수집을 위해 "표시"됩니다.</p>
<p>스윕 단계: 스윕 단계에서는 "표시"된 객체가 삭제되거나 지워집니다. 게다가 때로는 힙(heap)에서 메모리 압축(Mark-compact 알고리즘)이라고 하는 작업도 초기화됩니다. 이 과정을 통해 남아 있는 객체가 연속된 메모리에 남아 있도록 메모리가 다시 할당됩니다. 이 과정을 통해 JVM이 새로 생성된 객체에 순차적으로 메모리를 할당할 수 있습니다. 메모리 압축 프로세스의 세부 내용은 이 글의 범위를 벗어나므로 생략하겠습니다.</p>
<p>효율적인 가비지 수집을 유지하기 위해 JVM이 따르는 일부 가비지 수집 전략이 있습니다. 가장 흔한 전략은 세대별 가비지 수집 전략입니다.</p>
<h2>세대별 가비지 수집 전략</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>여기서는 일반적으로 사용되는 가장 흔한 가비지 컬렉션 형태인 세대별 가비지 컬렉션 전략을 탐구해 볼 거에요. 세대별 가비지 컬렉션은 주로 2가지 주된 이유로 선호됩니다.</p>
<ul>
<li>메모리에 할당된 객체가 더 많아질수록 표시, 정리, 그리고 압축 과정이 굉장히 비효율적해집니다. 이는 표시, 정리, 그리고 압축하는 데 소요되는 시간을 증가시키고 극도로 큰 GC 시간을 야기할 수 있습니다.</li>
<li>분석 결과 자바 애플리케이션의 대부분 객체가 수명이 짧다는 것을 입증하였습니다.</li>
</ul>
<p>위에서 언급된 이유들 때문에, GC 프로세스를 더 효율적으로 만들기 위해 자바의 힙 메모리는 세그먼트 또는 세대로 분할됩니다.</p>
<p><img src="/assets/img/2024-05-27-GarbageCollectionInJava_1.png" alt="가비지컬렉션"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>젊은 세대:</p>
<p>젊은 세대는 세 지역으로 나뉩니다. 에덴 공간, 생존자 공간 제로(S0) 및 생존자 공간 원(S1). 우리는 응용 프로그램 부팅 시 가비지 컬렉션 프로세스를 논의해 보겠습니다.</p>
<p>처음에는 생성된 모든 객체가 에덴 공간에 채워집니다. 생존자 공간(S0 및 S1)은 모두 비어 있을 것입니다. 에덴 공간이 가득 차면 소규모 가비지 컬렉션 주기가 트리거됩니다. 에덴 공간의 모든 참조되지 않은 객체가 삭제되고 모든 참조된 객체가 S0로 이동됩니다. 이것이 gc(0)입니다. 이어지는 가비지 컬렉션 주기에서 에덴 공간 및 S0 공간의 모든 참조된 객체가 S1로 이동됩니다. 이후 모든 참조되지 않은 객체가 삭제됩니다. gc(1) 이후의 객체 할당은 다음과 같이 보일 것입니다.</p>
<p><img src="/assets/img/2024-05-27-GarbageCollectionInJava_2.png" alt="image"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위 이미지에서 볼 수 있듯이 모든 GC 주기마다 객체의 나이가 1씩 증가합니다. 나이가 특정 임계값에 도달하면 객체들은 힙 메모리의 다음 섹션으로 이동됩니다. 또한 모든 마이너 GC는 Stop the world 이벤트입니다. 이는 응용 프로그램 스레드가 GC가 완료될 때까지 중지된다는 것을 의미합니다. 일반적으로 마이너 GC는 메이저 GC와 비교했을 때 소요 시간이 더 적습니다.</p>
<p>늙은 세대</p>
<p>결국 객체의 연령이 특정 임계값에 도달하면 젊은 세대에서늙은 세대로 이동됩니다. 언젠가는 오래된 세대도 채워집니다. 오래된 세대가 가득 차고 정리되어야 할 때 메이저 GC가 트리거됩니다.</p>
<p>메이저 GC와 마이너 GC의 차이점</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Minor GC와 Major GC의 주요 차이 중 하나는 Minor GC와 Major GC가 완료되는 데 걸리는 시간입니다. Major GC는 Minor GC와 마찬가지로 멈춤 현상(stop the world) 이벤트이지만 Major GC를 완료하는 데 걸리는 시간은 모든 활성 객체를 포함하기 때문에 Minor GC보다 훨씬 많이 소요됩니다. Major GC를 완료하는 데 필요한 시간은 주요 GC 공간이 증가할수록 선형적으로 증가하며 공간이 많을수록 메모리 압축에 더 많은 시간이 소요됩니다. 이는 응답 시간을 우선시하는 응용 프로그램에서 주요 GC의 빈도를 낮게 유지해야 한다는 것을 의미합니다. 또한 주요 GC의 멈춤 현상 이벤트의 길이는 사용 중인 GC 유형에 따라 달라집니다.</p>
<p><strong>Full GC</strong></p>
<p>자바 가비지 컬렉션에서 Full GC란 young generation과 old generation GC가 모두 트리거되는 경우입니다. full garbage collection은 Minor GC나 Major GC보다 훨씬 더 많은 시간이 소요됩니다. Full GC가 발생하는 이유는 여러 가지가 있을 수 있습니다. 그 중 몇 가지 이유는 다음과 같습니다:</p>
<ul>
<li>Heap 공간이 가득 차는 경우: 모든 Java 힙 메모리가 고갈되기 전에 Full GC가 발생할 수 있습니다. 이는 일련의 영역을 연속으로 찾아야 하는 필요로 인해 발생할 수 있습니다.</li>
<li>영역 크기 변경: 메모리 수요에 따라 영역 크기(영구 또는 올드)가 변경되면 일반적으로 Full GC에 의해 영역 변경 크기가 시작됩니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>Metaspace</h2>
<p>힙 메모리의 일부였고 전체 가비지 수집에 포함되었던 추가 메모리 세그먼트가 있습니다. 이 메모리 세그먼트를 영구 세대(Permanent generation)라고 했습니다. Java 8에서 영구 세대는 Metaspace로 변경되었으며 힙 메모리에서 분리되었습니다. Metaspace의 주요 이유는 클래스 메타데이터를 저장하는 것입니다. 클래스가 더 많은 공간을로드하고 메타데이터를 저장해야 할 경우 Metaspace는 자동으로 증가하는 기능을 갖추고 있습니다.</p>
<p>Java 가비지 컬렉션을 이해하는 것은 자바 애플리케이션을 보다 효율적으로 만들기 위해 매우 중요하며 시스템에서 잠재적인 메모리 누수를 해결하고 문제 해결하는 데 도움이 됩니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"자바에서의 가비지 컬렉션","description":"","date":"2024-05-27 15:48","slug":"2024-05-27-GarbageCollectionInJava","content":"\n## 자바에서 쓰레기 수거가 이뤄지는 방식에 대한 기본적인 설명\n\n![이미지](/assets/img/2024-05-27-GarbageCollectionInJava_0.png)\n\n# 가비지 컬렉션이란?\n\n변수를 선언하는 것은 프로그래머로서 생활의 일부입니다. 변수를 사용하는 것은 코드의 재사용성을 향상시키는 것뿐만 아니라 코드의 가독성을 크게 향상시키고, 이는 결국 코드의 유지보수성을 높이는 데 큰 도움이 됩니다. 또한 선언된 변수가 일정 공간을 차지하고 특정 범위와 연결되어 있다는 것은 비밀이 아닙니다. 최적화된 메모리 관리를 위해 JVM이 이러한 객체들이 더 이상 필요하지 않을 때 제거하거나 파괴하는 것이 합리적입니다. 이렇게 \"원치 않는\" 변수들을 제거하는 프로세스를 가비지 컬렉션이라고 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 자바에서의 가비지 컬렉션\n\nC, C++와 같은 언어에서는 가비지 컬렉션을 애플리케이션 개발자의 책임으로 간주됩니다. 이러한 언어에서는 쓰레기를 수동으로 처리하는 명시적 도구가 있습니다. 반면에 Java에서는 JVM이 가비지 컬렉션을 자동으로 처리합니다. JVM은 힙 메모리에서 언제 어디서 GC를 트리거할지 결정하는 일련의 프로세스를 거칩니다. 자바 개발자로서, 가비지 컬렉션의 기본 원리와 힙 메모리의 섹션을 이해하는 것이 매우 중요합니다. 이는 우리가 메모리를 효율적으로 사용하는 자바 애플리케이션을 개발하는 데 큰 도움이 될 것입니다.\n\n## 가비지 컬렉션에 포함된 단계\n\n자바 가비지 컬렉션은 일반적으로 2단계로 수행됩니다. 마크 단계와 스윕 단계입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마크 단계: 마크 단계에서는 객체를 참조될 수 있는지 여부에 따라 두 가지 방식으로 분류합니다. 참조된 객체는 여전히 사용 중이며 범위에서 벗어나지 않은 객체입니다. 참조되지 않은 객체는 응용 프로그램에서 더 이상 필요하지 않은 객체입니다. 참조되지 않는 객체는 가비지 수집을 위해 \"표시\"됩니다.\n\n스윕 단계: 스윕 단계에서는 \"표시\"된 객체가 삭제되거나 지워집니다. 게다가 때로는 힙(heap)에서 메모리 압축(Mark-compact 알고리즘)이라고 하는 작업도 초기화됩니다. 이 과정을 통해 남아 있는 객체가 연속된 메모리에 남아 있도록 메모리가 다시 할당됩니다. 이 과정을 통해 JVM이 새로 생성된 객체에 순차적으로 메모리를 할당할 수 있습니다. 메모리 압축 프로세스의 세부 내용은 이 글의 범위를 벗어나므로 생략하겠습니다.\n\n효율적인 가비지 수집을 유지하기 위해 JVM이 따르는 일부 가비지 수집 전략이 있습니다. 가장 흔한 전략은 세대별 가비지 수집 전략입니다.\n\n## 세대별 가비지 수집 전략\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서는 일반적으로 사용되는 가장 흔한 가비지 컬렉션 형태인 세대별 가비지 컬렉션 전략을 탐구해 볼 거에요. 세대별 가비지 컬렉션은 주로 2가지 주된 이유로 선호됩니다.\n\n- 메모리에 할당된 객체가 더 많아질수록 표시, 정리, 그리고 압축 과정이 굉장히 비효율적해집니다. 이는 표시, 정리, 그리고 압축하는 데 소요되는 시간을 증가시키고 극도로 큰 GC 시간을 야기할 수 있습니다.\n- 분석 결과 자바 애플리케이션의 대부분 객체가 수명이 짧다는 것을 입증하였습니다.\n\n위에서 언급된 이유들 때문에, GC 프로세스를 더 효율적으로 만들기 위해 자바의 힙 메모리는 세그먼트 또는 세대로 분할됩니다.\n\n![가비지컬렉션](/assets/img/2024-05-27-GarbageCollectionInJava_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n젊은 세대:\n\n젊은 세대는 세 지역으로 나뉩니다. 에덴 공간, 생존자 공간 제로(S0) 및 생존자 공간 원(S1). 우리는 응용 프로그램 부팅 시 가비지 컬렉션 프로세스를 논의해 보겠습니다.\n\n처음에는 생성된 모든 객체가 에덴 공간에 채워집니다. 생존자 공간(S0 및 S1)은 모두 비어 있을 것입니다. 에덴 공간이 가득 차면 소규모 가비지 컬렉션 주기가 트리거됩니다. 에덴 공간의 모든 참조되지 않은 객체가 삭제되고 모든 참조된 객체가 S0로 이동됩니다. 이것이 gc(0)입니다. 이어지는 가비지 컬렉션 주기에서 에덴 공간 및 S0 공간의 모든 참조된 객체가 S1로 이동됩니다. 이후 모든 참조되지 않은 객체가 삭제됩니다. gc(1) 이후의 객체 할당은 다음과 같이 보일 것입니다.\n\n![image](/assets/img/2024-05-27-GarbageCollectionInJava_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 이미지에서 볼 수 있듯이 모든 GC 주기마다 객체의 나이가 1씩 증가합니다. 나이가 특정 임계값에 도달하면 객체들은 힙 메모리의 다음 섹션으로 이동됩니다. 또한 모든 마이너 GC는 Stop the world 이벤트입니다. 이는 응용 프로그램 스레드가 GC가 완료될 때까지 중지된다는 것을 의미합니다. 일반적으로 마이너 GC는 메이저 GC와 비교했을 때 소요 시간이 더 적습니다.\n\n늙은 세대\n\n결국 객체의 연령이 특정 임계값에 도달하면 젊은 세대에서늙은 세대로 이동됩니다. 언젠가는 오래된 세대도 채워집니다. 오래된 세대가 가득 차고 정리되어야 할 때 메이저 GC가 트리거됩니다.\n\n메이저 GC와 마이너 GC의 차이점\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMinor GC와 Major GC의 주요 차이 중 하나는 Minor GC와 Major GC가 완료되는 데 걸리는 시간입니다. Major GC는 Minor GC와 마찬가지로 멈춤 현상(stop the world) 이벤트이지만 Major GC를 완료하는 데 걸리는 시간은 모든 활성 객체를 포함하기 때문에 Minor GC보다 훨씬 많이 소요됩니다. Major GC를 완료하는 데 필요한 시간은 주요 GC 공간이 증가할수록 선형적으로 증가하며 공간이 많을수록 메모리 압축에 더 많은 시간이 소요됩니다. 이는 응답 시간을 우선시하는 응용 프로그램에서 주요 GC의 빈도를 낮게 유지해야 한다는 것을 의미합니다. 또한 주요 GC의 멈춤 현상 이벤트의 길이는 사용 중인 GC 유형에 따라 달라집니다.\n\n**Full GC**\n\n자바 가비지 컬렉션에서 Full GC란 young generation과 old generation GC가 모두 트리거되는 경우입니다. full garbage collection은 Minor GC나 Major GC보다 훨씬 더 많은 시간이 소요됩니다. Full GC가 발생하는 이유는 여러 가지가 있을 수 있습니다. 그 중 몇 가지 이유는 다음과 같습니다:\n\n- Heap 공간이 가득 차는 경우: 모든 Java 힙 메모리가 고갈되기 전에 Full GC가 발생할 수 있습니다. 이는 일련의 영역을 연속으로 찾아야 하는 필요로 인해 발생할 수 있습니다.\n- 영역 크기 변경: 메모리 수요에 따라 영역 크기(영구 또는 올드)가 변경되면 일반적으로 Full GC에 의해 영역 변경 크기가 시작됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Metaspace\n\n힙 메모리의 일부였고 전체 가비지 수집에 포함되었던 추가 메모리 세그먼트가 있습니다. 이 메모리 세그먼트를 영구 세대(Permanent generation)라고 했습니다. Java 8에서 영구 세대는 Metaspace로 변경되었으며 힙 메모리에서 분리되었습니다. Metaspace의 주요 이유는 클래스 메타데이터를 저장하는 것입니다. 클래스가 더 많은 공간을로드하고 메타데이터를 저장해야 할 경우 Metaspace는 자동으로 증가하는 기능을 갖추고 있습니다.\n\nJava 가비지 컬렉션을 이해하는 것은 자바 애플리케이션을 보다 효율적으로 만들기 위해 매우 중요하며 시스템에서 잠재적인 메모리 누수를 해결하고 문제 해결하는 데 도움이 됩니다.\n","ogImage":{"url":"/assets/img/2024-05-27-GarbageCollectionInJava_0.png"},"coverImage":"/assets/img/2024-05-27-GarbageCollectionInJava_0.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e자바에서 쓰레기 수거가 이뤄지는 방식에 대한 기본적인 설명\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-GarbageCollectionInJava_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e가비지 컬렉션이란?\u003c/h1\u003e\n\u003cp\u003e변수를 선언하는 것은 프로그래머로서 생활의 일부입니다. 변수를 사용하는 것은 코드의 재사용성을 향상시키는 것뿐만 아니라 코드의 가독성을 크게 향상시키고, 이는 결국 코드의 유지보수성을 높이는 데 큰 도움이 됩니다. 또한 선언된 변수가 일정 공간을 차지하고 특정 범위와 연결되어 있다는 것은 비밀이 아닙니다. 최적화된 메모리 관리를 위해 JVM이 이러한 객체들이 더 이상 필요하지 않을 때 제거하거나 파괴하는 것이 합리적입니다. 이렇게 \"원치 않는\" 변수들을 제거하는 프로세스를 가비지 컬렉션이라고 합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e자바에서의 가비지 컬렉션\u003c/h2\u003e\n\u003cp\u003eC, C++와 같은 언어에서는 가비지 컬렉션을 애플리케이션 개발자의 책임으로 간주됩니다. 이러한 언어에서는 쓰레기를 수동으로 처리하는 명시적 도구가 있습니다. 반면에 Java에서는 JVM이 가비지 컬렉션을 자동으로 처리합니다. JVM은 힙 메모리에서 언제 어디서 GC를 트리거할지 결정하는 일련의 프로세스를 거칩니다. 자바 개발자로서, 가비지 컬렉션의 기본 원리와 힙 메모리의 섹션을 이해하는 것이 매우 중요합니다. 이는 우리가 메모리를 효율적으로 사용하는 자바 애플리케이션을 개발하는 데 큰 도움이 될 것입니다.\u003c/p\u003e\n\u003ch2\u003e가비지 컬렉션에 포함된 단계\u003c/h2\u003e\n\u003cp\u003e자바 가비지 컬렉션은 일반적으로 2단계로 수행됩니다. 마크 단계와 스윕 단계입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e마크 단계: 마크 단계에서는 객체를 참조될 수 있는지 여부에 따라 두 가지 방식으로 분류합니다. 참조된 객체는 여전히 사용 중이며 범위에서 벗어나지 않은 객체입니다. 참조되지 않은 객체는 응용 프로그램에서 더 이상 필요하지 않은 객체입니다. 참조되지 않는 객체는 가비지 수집을 위해 \"표시\"됩니다.\u003c/p\u003e\n\u003cp\u003e스윕 단계: 스윕 단계에서는 \"표시\"된 객체가 삭제되거나 지워집니다. 게다가 때로는 힙(heap)에서 메모리 압축(Mark-compact 알고리즘)이라고 하는 작업도 초기화됩니다. 이 과정을 통해 남아 있는 객체가 연속된 메모리에 남아 있도록 메모리가 다시 할당됩니다. 이 과정을 통해 JVM이 새로 생성된 객체에 순차적으로 메모리를 할당할 수 있습니다. 메모리 압축 프로세스의 세부 내용은 이 글의 범위를 벗어나므로 생략하겠습니다.\u003c/p\u003e\n\u003cp\u003e효율적인 가비지 수집을 유지하기 위해 JVM이 따르는 일부 가비지 수집 전략이 있습니다. 가장 흔한 전략은 세대별 가비지 수집 전략입니다.\u003c/p\u003e\n\u003ch2\u003e세대별 가비지 수집 전략\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e여기서는 일반적으로 사용되는 가장 흔한 가비지 컬렉션 형태인 세대별 가비지 컬렉션 전략을 탐구해 볼 거에요. 세대별 가비지 컬렉션은 주로 2가지 주된 이유로 선호됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e메모리에 할당된 객체가 더 많아질수록 표시, 정리, 그리고 압축 과정이 굉장히 비효율적해집니다. 이는 표시, 정리, 그리고 압축하는 데 소요되는 시간을 증가시키고 극도로 큰 GC 시간을 야기할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e분석 결과 자바 애플리케이션의 대부분 객체가 수명이 짧다는 것을 입증하였습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위에서 언급된 이유들 때문에, GC 프로세스를 더 효율적으로 만들기 위해 자바의 힙 메모리는 세그먼트 또는 세대로 분할됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-GarbageCollectionInJava_1.png\" alt=\"가비지컬렉션\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e젊은 세대:\u003c/p\u003e\n\u003cp\u003e젊은 세대는 세 지역으로 나뉩니다. 에덴 공간, 생존자 공간 제로(S0) 및 생존자 공간 원(S1). 우리는 응용 프로그램 부팅 시 가비지 컬렉션 프로세스를 논의해 보겠습니다.\u003c/p\u003e\n\u003cp\u003e처음에는 생성된 모든 객체가 에덴 공간에 채워집니다. 생존자 공간(S0 및 S1)은 모두 비어 있을 것입니다. 에덴 공간이 가득 차면 소규모 가비지 컬렉션 주기가 트리거됩니다. 에덴 공간의 모든 참조되지 않은 객체가 삭제되고 모든 참조된 객체가 S0로 이동됩니다. 이것이 gc(0)입니다. 이어지는 가비지 컬렉션 주기에서 에덴 공간 및 S0 공간의 모든 참조된 객체가 S1로 이동됩니다. 이후 모든 참조되지 않은 객체가 삭제됩니다. gc(1) 이후의 객체 할당은 다음과 같이 보일 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-GarbageCollectionInJava_2.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위 이미지에서 볼 수 있듯이 모든 GC 주기마다 객체의 나이가 1씩 증가합니다. 나이가 특정 임계값에 도달하면 객체들은 힙 메모리의 다음 섹션으로 이동됩니다. 또한 모든 마이너 GC는 Stop the world 이벤트입니다. 이는 응용 프로그램 스레드가 GC가 완료될 때까지 중지된다는 것을 의미합니다. 일반적으로 마이너 GC는 메이저 GC와 비교했을 때 소요 시간이 더 적습니다.\u003c/p\u003e\n\u003cp\u003e늙은 세대\u003c/p\u003e\n\u003cp\u003e결국 객체의 연령이 특정 임계값에 도달하면 젊은 세대에서늙은 세대로 이동됩니다. 언젠가는 오래된 세대도 채워집니다. 오래된 세대가 가득 차고 정리되어야 할 때 메이저 GC가 트리거됩니다.\u003c/p\u003e\n\u003cp\u003e메이저 GC와 마이너 GC의 차이점\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eMinor GC와 Major GC의 주요 차이 중 하나는 Minor GC와 Major GC가 완료되는 데 걸리는 시간입니다. Major GC는 Minor GC와 마찬가지로 멈춤 현상(stop the world) 이벤트이지만 Major GC를 완료하는 데 걸리는 시간은 모든 활성 객체를 포함하기 때문에 Minor GC보다 훨씬 많이 소요됩니다. Major GC를 완료하는 데 필요한 시간은 주요 GC 공간이 증가할수록 선형적으로 증가하며 공간이 많을수록 메모리 압축에 더 많은 시간이 소요됩니다. 이는 응답 시간을 우선시하는 응용 프로그램에서 주요 GC의 빈도를 낮게 유지해야 한다는 것을 의미합니다. 또한 주요 GC의 멈춤 현상 이벤트의 길이는 사용 중인 GC 유형에 따라 달라집니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFull GC\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e자바 가비지 컬렉션에서 Full GC란 young generation과 old generation GC가 모두 트리거되는 경우입니다. full garbage collection은 Minor GC나 Major GC보다 훨씬 더 많은 시간이 소요됩니다. Full GC가 발생하는 이유는 여러 가지가 있을 수 있습니다. 그 중 몇 가지 이유는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHeap 공간이 가득 차는 경우: 모든 Java 힙 메모리가 고갈되기 전에 Full GC가 발생할 수 있습니다. 이는 일련의 영역을 연속으로 찾아야 하는 필요로 인해 발생할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e영역 크기 변경: 메모리 수요에 따라 영역 크기(영구 또는 올드)가 변경되면 일반적으로 Full GC에 의해 영역 변경 크기가 시작됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003eMetaspace\u003c/h2\u003e\n\u003cp\u003e힙 메모리의 일부였고 전체 가비지 수집에 포함되었던 추가 메모리 세그먼트가 있습니다. 이 메모리 세그먼트를 영구 세대(Permanent generation)라고 했습니다. Java 8에서 영구 세대는 Metaspace로 변경되었으며 힙 메모리에서 분리되었습니다. Metaspace의 주요 이유는 클래스 메타데이터를 저장하는 것입니다. 클래스가 더 많은 공간을로드하고 메타데이터를 저장해야 할 경우 Metaspace는 자동으로 증가하는 기능을 갖추고 있습니다.\u003c/p\u003e\n\u003cp\u003eJava 가비지 컬렉션을 이해하는 것은 자바 애플리케이션을 보다 효율적으로 만들기 위해 매우 중요하며 시스템에서 잠재적인 메모리 누수를 해결하고 문제 해결하는 데 도움이 됩니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-27-GarbageCollectionInJava"},"buildId":"wOkGEDZCvEs3S_XaNsdwr","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>