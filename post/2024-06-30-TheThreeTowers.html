<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>세 개의 타워 뭐가 다른가 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-30-TheThreeTowers" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="세 개의 타워 뭐가 다른가 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="세 개의 타워 뭐가 다른가 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-30-TheThreeTowers_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-30-TheThreeTowers" data-gatsby-head="true"/><meta name="twitter:title" content="세 개의 타워 뭐가 다른가 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-30-TheThreeTowers_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-30 21:55" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_buildManifest.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">세 개의 타워 뭐가 다른가</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="세 개의 타워 뭐가 다른가" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 30, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-30-TheThreeTowers&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-30-TheThreeTowers_0.png" alt="이미지"></p>
<p>하노이 탑은 프로그래밍에서 고전이자 도전적인 문제입니다. 이 문제의 해결책을 찾는 것은 어렵지 않지만, 해결책 뒤에 숨겨진 직관을 이해하는 데는 약간의 시간이 걸립니다. 이 문제를 살펴보고 이 문제의 직관을 이해하고 어떻게 코드로 작성할지 알아봅시다.</p>
<h1>기원</h1>
<p>하노이 탑 문제는 1883년 프랑스 수학자 에두아르 루카가 발명했습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>루카스는 이 문제를 더 넓은 대중에게 호소하기 위해 함께 이야기도 추가했습니다. 전설에 따르면 수세기동안 하인두 사원에서 사제들이 세 기둥 사이에서 금판을 옮겨다 놓았다고 합니다. 그들은 하노이의 탑 규칙을 따라야 합니다. 하루에 한 디스크씩만 움직일 수 있습니다. 이 퍼즐을 완성하면 세상이 끝날 것이라고 전해집니다.</p>
<h1>문제 설명</h1>
<p>세 개의 타워(기둥)가 있습니다. 하나의 타워에는 크기가 증가하는 n개의 디스크가 있고, 다른 두 타워는 비어 있습니다. 모든 디스크를 한 타워에서 다른 타워로 옮겨야 합니다.</p>
<p>두 가지 규칙이 있습니다. 더 큰 디스크를 작은 디스크 위에 놓을 수 없으며 한 번에 한 개의 디스크만 이동시킬 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>직관</h1>
<p>엣지 케이스를 살펴보죠. 즉, 우리가 디스크가 하나뿐인 경우의 처리 방법은 무엇일까요?</p>
<p>이 경우의 답은 꽤 간단합니다. 필요한 기둥으로 그냥 이동하면 됩니다.</p>
<img src="/assets/img/2024-06-30-TheThreeTowers_1.png">
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 2개의 디스크를 이동해 봅시다.</p>
<p>작은 디스크를 큰 디스크 위에 놓을 수 없기 때문에 먼저 작은 디스크를 중간으로 옮겨야 합니다.</p>
<p><img src="/assets/img/2024-06-30-TheThreeTowers_2.png" alt="이미지"></p>
<p>그런 다음 큰 디스크를 끝으로 옮기게 될 거에요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-06-30-TheThreeTowers_3.png" alt="이미지"></p>
<p>작은 디스크를 마지막 위치로 이동시키면 됩니다.</p>
<p><img src="/assets/img/2024-06-30-TheThreeTowers_4.png" alt="이미지"></p>
<p>문제가 해결되었습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 우리가 가장 중요한 테스트 케이스, 즉 3개의 디스크에 대한 것을 시도해 봅시다. 이것을 주의 깊게 이해하려고 노력해주세요.</p>
<p><img src="/assets/img/2024-06-30-TheThreeTowers_5.png" alt="이미지"></p>
<p>하나의 해결책은 백트래킹을 시도하여 가능성을 찾는 것입니다(수도 퍼즐과 같이). 그러나 더 나은 접근 방식은 문제를 분해하는 것입니다.</p>
<p>가장 큰 디스크를 무시해 봅시다. 우리는 한 막대에서 다른 막대로 두 개의 디스크를 옮기는 방법을 알고 있습니다. 그러나 만약 그들을 직접 최종 막대로 옮긴다면(2개 디스크 문제에서처럼) 가장 큰 디스크를 어떻게 옮길 것인가요?</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-06-30-TheThreeTowers_6.png" alt="image1"></p>
<p>이 방법은 문제가 발생할 수 있으므로 상단의 두 디스크를 중간 막대로 이동해 보겠습니다. 그렇게 하면 가장 큰 디스크를 마지막 막대로 바로 이동할 수 있습니다.</p>
<p><img src="/assets/img/2024-06-30-TheThreeTowers_7.png" alt="image2"></p>
<p>이제 동일한 방법을 따라서 (2개의 디스크를 이동할 때 사용한 것과 같은 방법으로) 두 개의 작은 디스크를 더 큰 디스크 위로 이동할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-06-30-TheThreeTowers_8.png" alt="이미지"></p>
<p>패턴을 보셨나요?</p>
<p>n개의 디스크를 시도해보세요.</p>
<p><img src="/assets/img/2024-06-30-TheThreeTowers_9.png" alt="이미지"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>3개의 디스크가 있는 문제와 비교해보세요. 먼저, 작은 디스크를 가운데로 옮깁니다.</p>
<p><img src="/assets/img/2024-06-30-TheThreeTowers_10.png" alt="image"></p>
<p>그런 다음 가장 큰 디스크를 최종 막대로 옮길 수 있습니다.</p>
<p><img src="/assets/img/2024-06-30-TheThreeTowers_11.png" alt="image"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 첫 번째 단계를 반복하고 n-1 개의 디스크를 더 큰 디스크 위로 이동해야 합니다.</p>
<p><img src="/assets/img/2024-06-30-TheThreeTowers_12.png" alt="image"></p>
<p>따라서 우리의 문제는 해결되었습니다!</p>
<h1>재귀 논리</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 주요 부분으로 넘어갑시다. 재귀 논리를 이해하는 방법은 무엇인가요?</p>
<ul>
<li>먼저 n-1개의 디스크를 보조 막대로 이동</li>
<li>n번째 디스크를 최종 막대로 이동</li>
<li>n-1개의 디스크를 최종 막대로 이동</li>
<li>만약 n = 1이면, 바로 최종 막대로 이동시킵니다</li>
</ul>
<h1>소스 코드</h1>
<p>이제 솔루션을 코딩해봅시다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> towerOfHanoi = <span class="hljs-keyword">function</span>(<span class="hljs-params">n, start, auxiliary, end</span>){}
</code></pre>
<p>먼저 우리는 에지 케이스를 작성할 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> towerOfHanoi = <span class="hljs-keyword">function</span>(<span class="hljs-params">n, start, auxiliary, end</span>) {
  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`디스크 1을 <span class="hljs-subst">${start}</span>에서 <span class="hljs-subst">${end}</span>로 옮깁니다`</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }
}
</code></pre>
<p>우리는 코드가 n-1에 대해 작동할 것으로 가정하고, n-1을 보조로 옮깁니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> towerOfHanoi = <span class="hljs-keyword">function</span>(<span class="hljs-params">n, start, auxiliary, end</span>) {
  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`디스크 1을 <span class="hljs-subst">${start}</span>에서 <span class="hljs-subst">${end}</span>로 이동합니다`</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }
  <span class="hljs-title function_">towerOfHanoi</span>(n - <span class="hljs-number">1</span>, start, end, auxiliary);
}
</code></pre>
<p>그리고 가장 큰 디스크를 끝으로 이동합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> towerOfHanoi = <span class="hljs-keyword">function</span>(<span class="hljs-params">n, start, auxiliary, end</span>) {
  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`디스크 1을 <span class="hljs-subst">${start}</span>에서 <span class="hljs-subst">${end}</span>로 이동합니다`</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }
  <span class="hljs-title function_">towerOfHanoi</span>(n - <span class="hljs-number">1</span>, start, end, auxiliary);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`디스크 <span class="hljs-subst">${n}</span>을 <span class="hljs-subst">${start}</span>에서 <span class="hljs-subst">${end}</span>로 이동합니다`</span>);
}
</code></pre>
<p>마지막으로, 보조 기둥에 있는 n-1을 끝으로 옮깁니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> towerOfHanoi = <span class="hljs-keyword">function</span>(<span class="hljs-params">n, start, auxiliary, end</span>) {
  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`move the disk 1 from <span class="hljs-subst">${start}</span> to <span class="hljs-subst">${end}</span>`</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }
  <span class="hljs-title function_">towerOfHanoi</span>(n - <span class="hljs-number">1</span>, start, end, auxiliary);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`move the disk <span class="hljs-subst">${n}</span> from <span class="hljs-subst">${start}</span> to <span class="hljs-subst">${end}</span>`</span>);
  <span class="hljs-title function_">towerOfHanoi</span>(n - <span class="hljs-number">1</span>, auxiliary, start, end);
}
</code></pre>
<p>이제 우리의 코드가 완성되었습니다!!!</p>
<h1>시간 복잡도</h1>
<p>이 알고리즘의 시간 복잡도를 찾아봅시다</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>가정해볼게요. n개의 디스크가 있다고 가정해봅시다. 시간은 T(n)이라고 부르겠습니다.</p>
<p>따라서, T(n) = 2(T(n-1)) +1</p>
<p>= T(n) = 2(2(T(n-2)) + 1) +1</p>
<p>= T(n)= 2²T(n-2) + 2 + 1</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>=T(n)= 2³T(n-3) + 2² + 2 + 1</p>
<p>= T(n) = (2^k) *T(n-k) +(2^k) +2^(k-1) + …. + 2² + 1</p>
<p>( T(1) = 1 and T(0) = 0)</p>
<p>= T(n) = 2⁰ + 2¹ + 2² + …. + 2^(n-1)</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이것은 등비 수열이기 때문에 합계를 구할 수 있습니다.</p>
<p><code>T(n) = (2^n) -1</code></p>
<p>따라서, 시간복잡도는 O((2^n)-1) 입니다.</p>
<h1>공간 복잡도</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>재귀를 사용할 때 함수가 다른 함수를 호출하면 외부 함수가 재귀 호출 스택에 저장됩니다.</p>
<p>함수는 1에 도달할 때까지 계속 호출되므로,</p>
<p>SC = O(N)</p>
<p>이 글이 마음에 들었기를 바랍니다. 불일치나 의문 사항이 있으면 언제든지 연락 주세요. 즐거운 학습되세요!!!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"세 개의 타워 뭐가 다른가","description":"","date":"2024-06-30 21:55","slug":"2024-06-30-TheThreeTowers","content":"\n\n![이미지](/assets/img/2024-06-30-TheThreeTowers_0.png)\n\n하노이 탑은 프로그래밍에서 고전이자 도전적인 문제입니다. 이 문제의 해결책을 찾는 것은 어렵지 않지만, 해결책 뒤에 숨겨진 직관을 이해하는 데는 약간의 시간이 걸립니다. 이 문제를 살펴보고 이 문제의 직관을 이해하고 어떻게 코드로 작성할지 알아봅시다.\n\n# 기원\n\n하노이 탑 문제는 1883년 프랑스 수학자 에두아르 루카가 발명했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n루카스는 이 문제를 더 넓은 대중에게 호소하기 위해 함께 이야기도 추가했습니다. 전설에 따르면 수세기동안 하인두 사원에서 사제들이 세 기둥 사이에서 금판을 옮겨다 놓았다고 합니다. 그들은 하노이의 탑 규칙을 따라야 합니다. 하루에 한 디스크씩만 움직일 수 있습니다. 이 퍼즐을 완성하면 세상이 끝날 것이라고 전해집니다.\n\n# 문제 설명\n\n세 개의 타워(기둥)가 있습니다. 하나의 타워에는 크기가 증가하는 n개의 디스크가 있고, 다른 두 타워는 비어 있습니다. 모든 디스크를 한 타워에서 다른 타워로 옮겨야 합니다.\n\n두 가지 규칙이 있습니다. 더 큰 디스크를 작은 디스크 위에 놓을 수 없으며 한 번에 한 개의 디스크만 이동시킬 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 직관\n\n엣지 케이스를 살펴보죠. 즉, 우리가 디스크가 하나뿐인 경우의 처리 방법은 무엇일까요?\n\n이 경우의 답은 꽤 간단합니다. 필요한 기둥으로 그냥 이동하면 됩니다.\n\n\u003cimg src=\"/assets/img/2024-06-30-TheThreeTowers_1.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 2개의 디스크를 이동해 봅시다.\n\n작은 디스크를 큰 디스크 위에 놓을 수 없기 때문에 먼저 작은 디스크를 중간으로 옮겨야 합니다.\n\n![이미지](/assets/img/2024-06-30-TheThreeTowers_2.png)\n\n그런 다음 큰 디스크를 끝으로 옮기게 될 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/assets/img/2024-06-30-TheThreeTowers_3.png)\n\n작은 디스크를 마지막 위치로 이동시키면 됩니다.\n\n![이미지](/assets/img/2024-06-30-TheThreeTowers_4.png)\n\n문제가 해결되었습니다.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 우리가 가장 중요한 테스트 케이스, 즉 3개의 디스크에 대한 것을 시도해 봅시다. 이것을 주의 깊게 이해하려고 노력해주세요.\n\n![이미지](/assets/img/2024-06-30-TheThreeTowers_5.png)\n\n하나의 해결책은 백트래킹을 시도하여 가능성을 찾는 것입니다(수도 퍼즐과 같이). 그러나 더 나은 접근 방식은 문제를 분해하는 것입니다.\n\n가장 큰 디스크를 무시해 봅시다. 우리는 한 막대에서 다른 막대로 두 개의 디스크를 옮기는 방법을 알고 있습니다. 그러나 만약 그들을 직접 최종 막대로 옮긴다면(2개 디스크 문제에서처럼) 가장 큰 디스크를 어떻게 옮길 것인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image1](/assets/img/2024-06-30-TheThreeTowers_6.png)\n\n이 방법은 문제가 발생할 수 있으므로 상단의 두 디스크를 중간 막대로 이동해 보겠습니다. 그렇게 하면 가장 큰 디스크를 마지막 막대로 바로 이동할 수 있습니다.\n\n![image2](/assets/img/2024-06-30-TheThreeTowers_7.png)\n\n이제 동일한 방법을 따라서 (2개의 디스크를 이동할 때 사용한 것과 같은 방법으로) 두 개의 작은 디스크를 더 큰 디스크 위로 이동할 수 있습니다.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/assets/img/2024-06-30-TheThreeTowers_8.png)\n\n패턴을 보셨나요?\n\nn개의 디스크를 시도해보세요.\n\n![이미지](/assets/img/2024-06-30-TheThreeTowers_9.png)\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3개의 디스크가 있는 문제와 비교해보세요. 먼저, 작은 디스크를 가운데로 옮깁니다.\n\n![image](/assets/img/2024-06-30-TheThreeTowers_10.png)\n\n그런 다음 가장 큰 디스크를 최종 막대로 옮길 수 있습니다.\n\n![image](/assets/img/2024-06-30-TheThreeTowers_11.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 첫 번째 단계를 반복하고 n-1 개의 디스크를 더 큰 디스크 위로 이동해야 합니다.\n\n![image](/assets/img/2024-06-30-TheThreeTowers_12.png)\n\n따라서 우리의 문제는 해결되었습니다!\n\n# 재귀 논리\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 주요 부분으로 넘어갑시다. 재귀 논리를 이해하는 방법은 무엇인가요?\n\n- 먼저 n-1개의 디스크를 보조 막대로 이동\n- n번째 디스크를 최종 막대로 이동\n- n-1개의 디스크를 최종 막대로 이동\n- 만약 n = 1이면, 바로 최종 막대로 이동시킵니다\n\n# 소스 코드\n\n이제 솔루션을 코딩해봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nvar towerOfHanoi = function(n, start, auxiliary, end){}\n```\n\n먼저 우리는 에지 케이스를 작성할 것입니다.\n\n```js\nvar towerOfHanoi = function(n, start, auxiliary, end) {\n  if (n == 1) {\n    console.log(`디스크 1을 ${start}에서 ${end}로 옮깁니다`);\n    return 0;\n  }\n}\n```\n\n우리는 코드가 n-1에 대해 작동할 것으로 가정하고, n-1을 보조로 옮깁니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nvar towerOfHanoi = function(n, start, auxiliary, end) {\n  if (n == 1) {\n    console.log(`디스크 1을 ${start}에서 ${end}로 이동합니다`);\n    return 0;\n  }\n  towerOfHanoi(n - 1, start, end, auxiliary);\n}\n```\n\n그리고 가장 큰 디스크를 끝으로 이동합니다.\n\n```js\nvar towerOfHanoi = function(n, start, auxiliary, end) {\n  if (n == 1) {\n    console.log(`디스크 1을 ${start}에서 ${end}로 이동합니다`);\n    return 0;\n  }\n  towerOfHanoi(n - 1, start, end, auxiliary);\n  console.log(`디스크 ${n}을 ${start}에서 ${end}로 이동합니다`);\n}\n```\n\n마지막으로, 보조 기둥에 있는 n-1을 끝으로 옮깁니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nvar towerOfHanoi = function(n, start, auxiliary, end) {\n  if (n == 1) {\n    console.log(`move the disk 1 from ${start} to ${end}`);\n    return 0;\n  }\n  towerOfHanoi(n - 1, start, end, auxiliary);\n  console.log(`move the disk ${n} from ${start} to ${end}`);\n  towerOfHanoi(n - 1, auxiliary, start, end);\n}\n```\n\n이제 우리의 코드가 완성되었습니다!!!\n\n# 시간 복잡도\n\n이 알고리즘의 시간 복잡도를 찾아봅시다\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가정해볼게요. n개의 디스크가 있다고 가정해봅시다. 시간은 T(n)이라고 부르겠습니다.\n\n따라서, T(n) = 2(T(n-1)) +1\n\n= T(n) = 2(2(T(n-2)) + 1) +1\n\n= T(n)= 2²T(n-2) + 2 + 1\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n=T(n)= 2³T(n-3) + 2² + 2 + 1\n\n= T(n) = (2^k) *T(n-k) +(2^k) +2^(k-1) + …. + 2² + 1\n\n( T(1) = 1 and T(0) = 0)\n\n= T(n) = 2⁰ + 2¹ + 2² + …. + 2^(n-1)\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 등비 수열이기 때문에 합계를 구할 수 있습니다.\n\n` T(n) = (2^n) -1 `\n\n따라서, 시간복잡도는 O((2^n)-1) 입니다.\n\n# 공간 복잡도\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n재귀를 사용할 때 함수가 다른 함수를 호출하면 외부 함수가 재귀 호출 스택에 저장됩니다.\n\n함수는 1에 도달할 때까지 계속 호출되므로,\n\nSC = O(N)\n\n이 글이 마음에 들었기를 바랍니다. 불일치나 의문 사항이 있으면 언제든지 연락 주세요. 즐거운 학습되세요!!!","ogImage":{"url":"/assets/img/2024-06-30-TheThreeTowers_0.png"},"coverImage":"/assets/img/2024-06-30-TheThreeTowers_0.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-TheThreeTowers_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e하노이 탑은 프로그래밍에서 고전이자 도전적인 문제입니다. 이 문제의 해결책을 찾는 것은 어렵지 않지만, 해결책 뒤에 숨겨진 직관을 이해하는 데는 약간의 시간이 걸립니다. 이 문제를 살펴보고 이 문제의 직관을 이해하고 어떻게 코드로 작성할지 알아봅시다.\u003c/p\u003e\n\u003ch1\u003e기원\u003c/h1\u003e\n\u003cp\u003e하노이 탑 문제는 1883년 프랑스 수학자 에두아르 루카가 발명했습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e루카스는 이 문제를 더 넓은 대중에게 호소하기 위해 함께 이야기도 추가했습니다. 전설에 따르면 수세기동안 하인두 사원에서 사제들이 세 기둥 사이에서 금판을 옮겨다 놓았다고 합니다. 그들은 하노이의 탑 규칙을 따라야 합니다. 하루에 한 디스크씩만 움직일 수 있습니다. 이 퍼즐을 완성하면 세상이 끝날 것이라고 전해집니다.\u003c/p\u003e\n\u003ch1\u003e문제 설명\u003c/h1\u003e\n\u003cp\u003e세 개의 타워(기둥)가 있습니다. 하나의 타워에는 크기가 증가하는 n개의 디스크가 있고, 다른 두 타워는 비어 있습니다. 모든 디스크를 한 타워에서 다른 타워로 옮겨야 합니다.\u003c/p\u003e\n\u003cp\u003e두 가지 규칙이 있습니다. 더 큰 디스크를 작은 디스크 위에 놓을 수 없으며 한 번에 한 개의 디스크만 이동시킬 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e직관\u003c/h1\u003e\n\u003cp\u003e엣지 케이스를 살펴보죠. 즉, 우리가 디스크가 하나뿐인 경우의 처리 방법은 무엇일까요?\u003c/p\u003e\n\u003cp\u003e이 경우의 답은 꽤 간단합니다. 필요한 기둥으로 그냥 이동하면 됩니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-30-TheThreeTowers_1.png\"\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 2개의 디스크를 이동해 봅시다.\u003c/p\u003e\n\u003cp\u003e작은 디스크를 큰 디스크 위에 놓을 수 없기 때문에 먼저 작은 디스크를 중간으로 옮겨야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-TheThreeTowers_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e그런 다음 큰 디스크를 끝으로 옮기게 될 거에요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-TheThreeTowers_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e작은 디스크를 마지막 위치로 이동시키면 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-TheThreeTowers_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e문제가 해결되었습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 우리가 가장 중요한 테스트 케이스, 즉 3개의 디스크에 대한 것을 시도해 봅시다. 이것을 주의 깊게 이해하려고 노력해주세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-TheThreeTowers_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e하나의 해결책은 백트래킹을 시도하여 가능성을 찾는 것입니다(수도 퍼즐과 같이). 그러나 더 나은 접근 방식은 문제를 분해하는 것입니다.\u003c/p\u003e\n\u003cp\u003e가장 큰 디스크를 무시해 봅시다. 우리는 한 막대에서 다른 막대로 두 개의 디스크를 옮기는 방법을 알고 있습니다. 그러나 만약 그들을 직접 최종 막대로 옮긴다면(2개 디스크 문제에서처럼) 가장 큰 디스크를 어떻게 옮길 것인가요?\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-TheThreeTowers_6.png\" alt=\"image1\"\u003e\u003c/p\u003e\n\u003cp\u003e이 방법은 문제가 발생할 수 있으므로 상단의 두 디스크를 중간 막대로 이동해 보겠습니다. 그렇게 하면 가장 큰 디스크를 마지막 막대로 바로 이동할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-TheThreeTowers_7.png\" alt=\"image2\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 동일한 방법을 따라서 (2개의 디스크를 이동할 때 사용한 것과 같은 방법으로) 두 개의 작은 디스크를 더 큰 디스크 위로 이동할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-TheThreeTowers_8.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e패턴을 보셨나요?\u003c/p\u003e\n\u003cp\u003en개의 디스크를 시도해보세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-TheThreeTowers_9.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e3개의 디스크가 있는 문제와 비교해보세요. 먼저, 작은 디스크를 가운데로 옮깁니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-TheThreeTowers_10.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e그런 다음 가장 큰 디스크를 최종 막대로 옮길 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-TheThreeTowers_11.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 첫 번째 단계를 반복하고 n-1 개의 디스크를 더 큰 디스크 위로 이동해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-TheThreeTowers_12.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e따라서 우리의 문제는 해결되었습니다!\u003c/p\u003e\n\u003ch1\u003e재귀 논리\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 주요 부분으로 넘어갑시다. 재귀 논리를 이해하는 방법은 무엇인가요?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e먼저 n-1개의 디스크를 보조 막대로 이동\u003c/li\u003e\n\u003cli\u003en번째 디스크를 최종 막대로 이동\u003c/li\u003e\n\u003cli\u003en-1개의 디스크를 최종 막대로 이동\u003c/li\u003e\n\u003cli\u003e만약 n = 1이면, 바로 최종 막대로 이동시킵니다\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e소스 코드\u003c/h1\u003e\n\u003cp\u003e이제 솔루션을 코딩해봅시다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e towerOfHanoi = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003en, start, auxiliary, end\u003c/span\u003e){}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e먼저 우리는 에지 케이스를 작성할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e towerOfHanoi = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003en, start, auxiliary, end\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (n == \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`디스크 1을 \u003cspan class=\"hljs-subst\"\u003e${start}\u003c/span\u003e에서 \u003cspan class=\"hljs-subst\"\u003e${end}\u003c/span\u003e로 옮깁니다`\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 코드가 n-1에 대해 작동할 것으로 가정하고, n-1을 보조로 옮깁니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e towerOfHanoi = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003en, start, auxiliary, end\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (n == \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`디스크 1을 \u003cspan class=\"hljs-subst\"\u003e${start}\u003c/span\u003e에서 \u003cspan class=\"hljs-subst\"\u003e${end}\u003c/span\u003e로 이동합니다`\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-title function_\"\u003etowerOfHanoi\u003c/span\u003e(n - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, start, end, auxiliary);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 가장 큰 디스크를 끝으로 이동합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e towerOfHanoi = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003en, start, auxiliary, end\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (n == \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`디스크 1을 \u003cspan class=\"hljs-subst\"\u003e${start}\u003c/span\u003e에서 \u003cspan class=\"hljs-subst\"\u003e${end}\u003c/span\u003e로 이동합니다`\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-title function_\"\u003etowerOfHanoi\u003c/span\u003e(n - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, start, end, auxiliary);\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`디스크 \u003cspan class=\"hljs-subst\"\u003e${n}\u003c/span\u003e을 \u003cspan class=\"hljs-subst\"\u003e${start}\u003c/span\u003e에서 \u003cspan class=\"hljs-subst\"\u003e${end}\u003c/span\u003e로 이동합니다`\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막으로, 보조 기둥에 있는 n-1을 끝으로 옮깁니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e towerOfHanoi = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003en, start, auxiliary, end\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (n == \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`move the disk 1 from \u003cspan class=\"hljs-subst\"\u003e${start}\u003c/span\u003e to \u003cspan class=\"hljs-subst\"\u003e${end}\u003c/span\u003e`\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-title function_\"\u003etowerOfHanoi\u003c/span\u003e(n - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, start, end, auxiliary);\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`move the disk \u003cspan class=\"hljs-subst\"\u003e${n}\u003c/span\u003e from \u003cspan class=\"hljs-subst\"\u003e${start}\u003c/span\u003e to \u003cspan class=\"hljs-subst\"\u003e${end}\u003c/span\u003e`\u003c/span\u003e);\n  \u003cspan class=\"hljs-title function_\"\u003etowerOfHanoi\u003c/span\u003e(n - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, auxiliary, start, end);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 우리의 코드가 완성되었습니다!!!\u003c/p\u003e\n\u003ch1\u003e시간 복잡도\u003c/h1\u003e\n\u003cp\u003e이 알고리즘의 시간 복잡도를 찾아봅시다\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e가정해볼게요. n개의 디스크가 있다고 가정해봅시다. 시간은 T(n)이라고 부르겠습니다.\u003c/p\u003e\n\u003cp\u003e따라서, T(n) = 2(T(n-1)) +1\u003c/p\u003e\n\u003cp\u003e= T(n) = 2(2(T(n-2)) + 1) +1\u003c/p\u003e\n\u003cp\u003e= T(n)= 2²T(n-2) + 2 + 1\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e=T(n)= 2³T(n-3) + 2² + 2 + 1\u003c/p\u003e\n\u003cp\u003e= T(n) = (2^k) *T(n-k) +(2^k) +2^(k-1) + …. + 2² + 1\u003c/p\u003e\n\u003cp\u003e( T(1) = 1 and T(0) = 0)\u003c/p\u003e\n\u003cp\u003e= T(n) = 2⁰ + 2¹ + 2² + …. + 2^(n-1)\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이것은 등비 수열이기 때문에 합계를 구할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eT(n) = (2^n) -1\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e따라서, 시간복잡도는 O((2^n)-1) 입니다.\u003c/p\u003e\n\u003ch1\u003e공간 복잡도\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e재귀를 사용할 때 함수가 다른 함수를 호출하면 외부 함수가 재귀 호출 스택에 저장됩니다.\u003c/p\u003e\n\u003cp\u003e함수는 1에 도달할 때까지 계속 호출되므로,\u003c/p\u003e\n\u003cp\u003eSC = O(N)\u003c/p\u003e\n\u003cp\u003e이 글이 마음에 들었기를 바랍니다. 불일치나 의문 사항이 있으면 언제든지 연락 주세요. 즐거운 학습되세요!!!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-30-TheThreeTowers"},"buildId":"wOkGEDZCvEs3S_XaNsdwr","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>