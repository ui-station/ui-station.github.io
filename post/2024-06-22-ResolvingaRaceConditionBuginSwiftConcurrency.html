<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Swift 비동기 처리에서 경합 상태 버그 해결 방법  | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Swift 비동기 처리에서 경합 상태 버그 해결 방법  | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Swift 비동기 처리에서 경합 상태 버그 해결 방법  | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency" data-gatsby-head="true"/><meta name="twitter:title" content="Swift 비동기 처리에서 경합 상태 버그 해결 방법  | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 23:11" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_buildManifest.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Swift 비동기 처리에서 경합 상태 버그 해결 방법 </h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Swift 비동기 처리에서 경합 상태 버그 해결 방법 " loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_0.png">
<p>iOS 캘린더 스케줄러에는 '기본 캘린더' 기능이 있어요. Apple 캘린더와 같은 외부 캘린더와 통합한 후에, 이 설정은 이벤트를 추가할 때 가장 자주 사용하는 캘린더가 기본적으로 선택되도록 합니다. 이 기능은 사용자가 정의한 '기본 캘린더'를 연결된 캘린더에서 이벤트 스케줄링 시에 에디터의 '캘린더 선택' 섹션에서 자동으로 선택되도록 설정합니다.</p>
<img src="/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_1.png">
<h1>💡 경합 조건으로 인한 문제 해결하기</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그러나 때로는 다른 닠린더가 선택된 경우도 있었습니다. 항상 그런 것은 아니었고, 대부분의 경우 정상적으로 작동했습니다. 제가 이 문제를 디버그하는 방법을 잘 모르겠었는데, 가끔 발생하는 문제라서 더욱 더 어려웠습니다. 가끔씩 발생하더라도, 이 기능이 제대로 작동하지 않으면 사용자가 잘못된 링크된 달력에 이벤트를 알지 못하게 추가할 수 있어 나중에 불필요한 수정을 유발할 수 있습니다.</p>
<p>최근에 이 문제를 해결할 실마리를 찾았습니다. Xcode 16 베타 버전의 새 기능에 대한 호기심으로 설치한 후 보게 된 경고 메시지 덕분이었습니다. 이 경고는 이전 버전의 Xcode에서는 나타나지 않았고, 스위프트 6의 보다 엄격한 Actor Isolation 규칙으로 인해 발생했습니다. 이 규칙은 동시성 모델을 더 안전하게 만들기 위한 것입니다.</p>
<p><img src="/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_2.png" alt="Image"></p>
<p>스위프트에서 Actor는 동시성 모델로, 내부 함수와 속성을 동시 액세스로부터 보호합니다. Actors는 수행하는 작업을 직렬화하여 각 작업이 순차적으로 실행되도록 합니다. 이를 통해 경합 조건 및 데이터 경주와 같은 동시성 문제를 방지할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>경주 조건은 시스템의 동작이 실행 순서에 따라 달라질 수 있는 다중 스레드 프로그래밍에서 중요한 개념입니다. 다시 말해, 경주 조건은 두 개 이상의 작업이 병렬로 실행되고 결과가 실행 순서나 시간에 따라 변경될 수 있는 경우 발생합니다. 경주 조건이 발생하면 프로그램이 예측할 수 없이 동작하거나 예상치 못한 결과를 내놓을 수 있습니다.</p>
<p>데이터 경주는 두 개 이상의 스레드가 동시에 동일한 메모리 위치에 액세스하고, 그 중 적어도 하나가 쓰기 작업을 수행하는 경우 발생합니다. 이는 메모리 일관성을 파괴하고 예측할 수 없는 프로그램 동작으로 이어질 수 있습니다. Swift의 Actor는 이러한 문제를 방지하기 위해 상태를 안전하게 격리합니다.</p>
<p>제 코드에서는 메인 Actor 콘텍스트에서 Actor로 격리된 ekRepository의 eventStore 속성에 액세스하려고 시도했으며, 이로 인해 Swift 6에서 컴파일 오류가 발생했습니다. 코드의 문제가 요약된 부분은 다음과 같습니다:</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">import</span> EventKit

<span class="hljs-keyword">actor</span> <span class="hljs-title class_">EKRepository</span> {
    <span class="hljs-keyword">let</span> eventStore: <span class="hljs-type">EKEventStore</span>

    <span class="hljs-keyword">init</span>() {
        <span class="hljs-keyword">self</span>.eventStore <span class="hljs-operator">=</span> <span class="hljs-type">EKEventStore</span>()
    }
}

<span class="hljs-meta">@MainActor</span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EKInteractor</span>: <span class="hljs-title class_">ObservableObject</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> ekRepository: <span class="hljs-type">EKRepository</span>

    <span class="hljs-keyword">var</span> eventStore: <span class="hljs-type">EKEventStore</span> {
        <span class="hljs-comment">/// 🔥 Actor-isolated property 'eventStore' can not be referenced from the main actor;</span>
        <span class="hljs-comment">/// 🔥 this is an error in the Swift 6 language mode.</span>
        ekRepository.eventStore
    }

    <span class="hljs-keyword">init</span>(<span class="hljs-params">ekRepository</span>: <span class="hljs-type">EKRepository</span>) {
        <span class="hljs-keyword">self</span>.ekRepository <span class="hljs-operator">=</span> ekRepository
    }
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>저는 이 코드를 처음 작성할 때 'eventStore'가 'EKRepository' 내에서만 액세스되도록 보장하는 것이 목표였습니다. 처음에는 EKInteractor가 속성으로 eventStore를 정의하지 않았습니다. 그러나 EKEventEditViewController와 같은 Apple에서 제공하는 UI에 EKEventStore를 매개변수로 전달해야 하는 상황이 많았습니다. 그 결과, EKInteractor는 eventStore을 노출하기 시작했습니다.</p>
<p>하지만, EKInteractor가 Actor Isolation을 무시하고 ekRepository의 eventStore에 액세스하고 있다면, 이는 경합 조건과 예기치 않은 문제를 초래할 수 있습니다.</p>
<p>이를 해결하기 위해 코드를 리팩토링하여 Actor Isolation을 준수하도록 만들어 경합 조건을 피했습니다. 리팩토링된 코드는 다음과 같습니다:</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">actor</span> <span class="hljs-title class_">EKRepository</span> {
    <span class="hljs-comment">/// 💡 'getEventStore()' 메서드를 사용하여 eventStore에 대한 액세스 캡슐화</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> eventStore: <span class="hljs-type">EKEventStore</span>

    <span class="hljs-keyword">init</span>() {
        <span class="hljs-keyword">self</span>.eventStore <span class="hljs-operator">=</span> <span class="hljs-type">EKEventStore</span>()
    }
}

<span class="hljs-keyword">extension</span> <span class="hljs-title class_">EKRepository</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getEventStore</span>() -> <span class="hljs-type">EKEventStore</span> {
        <span class="hljs-keyword">return</span> eventStore
    }
}

<span class="hljs-meta">@MainActor</span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EKInteractor</span>: <span class="hljs-title class_">ObservableObject</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> ekRepository: <span class="hljs-type">EKRepository</span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> cachedEventStore: <span class="hljs-type">EKEventStore</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>

    <span class="hljs-comment">/// 💡 Actor Isolation을 준수하면서 eventStore에 비동기적으로 액세스하고 캐시합니다.</span>
    <span class="hljs-comment">/// 우선 캐시된 eventStore이 있는지 확인하고,</span>
    <span class="hljs-comment">/// 그렇지 않으면 EKRepository의 getEventStore 메서드를 비동기적으로 호출하여 eventStore을 가져와 캐시합니다.</span>
    <span class="hljs-keyword">var</span> eventStore: <span class="hljs-type">EKEventStore</span> {
        <span class="hljs-keyword">get</span> <span class="hljs-keyword">async</span> {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> eventStore <span class="hljs-operator">=</span> cachedEventStore {
                <span class="hljs-keyword">return</span> eventStore
            }

            <span class="hljs-keyword">let</span> store <span class="hljs-operator">=</span> <span class="hljs-keyword">await</span> ekRepository.getEventStore()
            cachedEventStore <span class="hljs-operator">=</span> store
            <span class="hljs-keyword">return</span> store
        }
    }

    <span class="hljs-keyword">init</span>(<span class="hljs-params">ekRepository</span>: <span class="hljs-type">EKRepository</span>) {
        <span class="hljs-keyword">self</span>.ekRepository <span class="hljs-operator">=</span> ekRepository

        <span class="hljs-comment">/// 💡 시작할 때 eventStore을 비동기적으로 가져와 캐싱하여 이후 액세스 성능을 향상시킵니다.</span>
        initEventStore(ekRepository: ekRepository)
    }
}

<span class="hljs-keyword">extension</span> <span class="hljs-title class_">EKInteractor</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">initEventStore</span>(<span class="hljs-params">ekRepository</span>: <span class="hljs-type">EKRepository</span>) {
        <span class="hljs-comment">/// 💡 [Task] 이 메서드는 eventStore을 비동기적으로 가져와 캐시하지만,</span>
        <span class="hljs-comment">/// 이 프로세스가 완료되기 전에 후속 작업이 진행될 수 있습니다.</span>
        <span class="hljs-type">Task</span> {
            <span class="hljs-keyword">self</span>.cachedEventStore <span class="hljs-operator">=</span> <span class="hljs-keyword">await</span> ekRepository.getEventStore()
        }
    }
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>또한, 'Default Calendar'를 설정하는 부분에서 레이스 컨디션에 민감한 코드를 발견했어요. 아래 코드에서는 newEKEvent의 캘린더(타입은 EKCalendar)가 Task 블록 내에서 비동기로 설정되어 있습니다. 이 비동기 작업은 getNewEKEvent 함수가 newEKEvent 객체를 반환한 뒤에 실행될 수 있습니다. 이는 반환된 newEKEvent 객체를 다른 곳에서 사용하려고 할 때 캘린더 속성이 아직 설정되지 않을 수 있다는 의미입니다. 이러한 상황은 '실행 순서(execution order)'에 따라 예측할 수 없는 동작을 유발할 수 있으며, 이는 해결하고자 했던 간헐적 버그와 일치합니다.</p>
<pre><code class="hljs language-js">private func <span class="hljs-title function_">getNewEKEvent</span>(<span class="hljs-attr">ekInteractor</span>: <span class="hljs-title class_">EKInteractor</span>, <span class="hljs-attr">selectedDate</span>: <span class="hljs-title class_">Date</span>) -> <span class="hljs-title class_">EKEvent</span> {
    <span class="hljs-keyword">let</span> newEKEvent = <span class="hljs-title class_">EKEvent</span>(<span class="hljs-attr">eventStore</span>: ekInteractor.<span class="hljs-property">eventStore</span>)

    <span class="hljs-comment">// 🔥 문제: 이 Task 블록은 비동기로 실행되므로, 함수가 newEKEvent를 반환한 후에 실행될 수 있습니다.</span>
    <span class="hljs-title class_">Task</span> {
        <span class="hljs-comment">// 🔥 문제: 비동기 작업이 newEKEvent 반환 후에 완료된 경우, 캘린더 속성이 아직 설정되지 않을 수 있습니다.</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> defaultEKCalendarToAdd = <span class="hljs-keyword">await</span> ekInteractor.<span class="hljs-title function_">getDefaultEKCalendarToAdd</span>(<span class="hljs-params"></span>) {
            newEKEvent.<span class="hljs-property">calendar</span> = defaultEKCalendarToAdd
        }
    }

    <span class="hljs-comment">// 🔥 문제: 함수가 비동기 작업이 완료되기 전에 newEKEvent를 반환하므로, 데이터 레이스와 레이스 컨디션이 발생할 수 있습니다.</span>
    <span class="hljs-keyword">return</span> newEKEvent
}
</code></pre>
<p>요약하면, 위의 코드는 '레이스 컨디션'의 대상이 될 수 있으며, 비동기 작업이 완료되기 전에 객체가 반환됩니다. 이 문제는 아래에 표시된 대로 코드를 재구성하여 해결할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/// 💡 비동기 작업을 수행할 수 있도록 getNewEKEvent 함수를 async로 선언하여,</span>
<span class="hljs-comment">/// 모든 비동기 작업이 완료된 후에만 newEKEvent가 반환되도록 함.</span>
<span class="hljs-comment">/// ---> 레이스 컨디션과 데이터 레이스 방지</span>
private func <span class="hljs-title function_">getNewEKEvent</span>(<span class="hljs-attr">ekInteractor</span>: <span class="hljs-title class_">EKInteractor</span>, <span class="hljs-attr">selectedDate</span>: <span class="hljs-title class_">Date</span>) <span class="hljs-keyword">async</span> -> <span class="hljs-title class_">EKEvent</span> {
    <span class="hljs-comment">/// 💡 eventStore를 비동기로 가져오기 위해 await 사용</span>
    <span class="hljs-keyword">let</span> newEKEvent = <span class="hljs-title class_">EKEvent</span>(<span class="hljs-attr">eventStore</span>: <span class="hljs-keyword">await</span> ekInteractor.<span class="hljs-property">eventStore</span>)

    <span class="hljs-comment">/// 💡 defaultEKCalendarToAdd를 비동기로 가져와 newEKEvent의 캘린더 속성에 설정</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> defaultEKCalendarToAdd = <span class="hljs-keyword">await</span> ekInteractor.<span class="hljs-title function_">getDefaultEKCalendarToAdd</span>(<span class="hljs-params"></span>) {
        newEKEvent.<span class="hljs-property">calendar</span> = defaultEKCalendarToAdd
    }

    <span class="hljs-comment">/// 💡 모든 비동기 작업이 완료된 후에 newEKEvent 반환</span>
    <span class="hljs-keyword">return</span> newEKEvent
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>결론</h1>
<p>이 문제를 해결하면서 Swift 동시성에 대한 이해가 깊어졌습니다. 안전한 동시 코드 작성의 기초를 확립할 수 있어 기쁩니다. 무엇보다도, Scheduler 앱의 다음 업데이트에서 사용자에게 흠잡을 데 없는 '기본 캘린더' 기능을 제공할 수 있어 기쁩니다.</p>
<p>'Reminders'부터 '기본 캘린더'까지 모든 것을 신속하게 통합하세요.
다양한 위젯.
Scheduler: iPhone, iPad 및 Mac용 캘린더 앱.</p>
<h1>참고문헌</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>Swift 프로그래밍 언어 — 동시성:
<a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/concurrency/" rel="nofollow" target="_blank">https://docs.swift.org/swift-book/documentation/the-swift-programming-language/concurrency/</a></li>
<li>Apple 개발자 문서 — Swift 동시성:
<a href="https://developer.apple.com/documentation/swift/concurrency" rel="nofollow" target="_blank">https://developer.apple.com/documentation/swift/concurrency</a></li>
<li>Apple 개발자 문서 — EKEventStore:
<a href="https://developer.apple.com/documentation/eventkit/ekeventstore" rel="nofollow" target="_blank">https://developer.apple.com/documentation/eventkit/ekeventstore</a></li>
<li>경합 조건 이해와 해결:
<a href="https://en.wikipedia.org/wiki/Race_condition" rel="nofollow" target="_blank">https://en.wikipedia.org/wiki/Race_condition</a></li>
<li>Apple 개발자 문서 — Task:
<a href="https://developer.apple.com/documentation/swift/task" rel="nofollow" target="_blank">https://developer.apple.com/documentation/swift/task</a></li>
</ul>
<p>이러한 자료들은 Swift 동시성, 액터 및 관련 주제에 대해 자세한 정보를 제공하여 경합 조건과 같은 문제를 이해하고 해결하는 데 도움이 됩니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Swift 비동기 처리에서 경합 상태 버그 해결 방법 ","description":"","date":"2024-06-22 23:11","slug":"2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency","content":"\n\u003cimg src=\"/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_0.png\" /\u003e\n\niOS 캘린더 스케줄러에는 '기본 캘린더' 기능이 있어요. Apple 캘린더와 같은 외부 캘린더와 통합한 후에, 이 설정은 이벤트를 추가할 때 가장 자주 사용하는 캘린더가 기본적으로 선택되도록 합니다. 이 기능은 사용자가 정의한 '기본 캘린더'를 연결된 캘린더에서 이벤트 스케줄링 시에 에디터의 '캘린더 선택' 섹션에서 자동으로 선택되도록 설정합니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_1.png\" /\u003e\n\n# 💡 경합 조건으로 인한 문제 해결하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 때로는 다른 닠린더가 선택된 경우도 있었습니다. 항상 그런 것은 아니었고, 대부분의 경우 정상적으로 작동했습니다. 제가 이 문제를 디버그하는 방법을 잘 모르겠었는데, 가끔 발생하는 문제라서 더욱 더 어려웠습니다. 가끔씩 발생하더라도, 이 기능이 제대로 작동하지 않으면 사용자가 잘못된 링크된 달력에 이벤트를 알지 못하게 추가할 수 있어 나중에 불필요한 수정을 유발할 수 있습니다.\n\n최근에 이 문제를 해결할 실마리를 찾았습니다. Xcode 16 베타 버전의 새 기능에 대한 호기심으로 설치한 후 보게 된 경고 메시지 덕분이었습니다. 이 경고는 이전 버전의 Xcode에서는 나타나지 않았고, 스위프트 6의 보다 엄격한 Actor Isolation 규칙으로 인해 발생했습니다. 이 규칙은 동시성 모델을 더 안전하게 만들기 위한 것입니다.\n\n![Image](/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_2.png)\n\n스위프트에서 Actor는 동시성 모델로, 내부 함수와 속성을 동시 액세스로부터 보호합니다. Actors는 수행하는 작업을 직렬화하여 각 작업이 순차적으로 실행되도록 합니다. 이를 통해 경합 조건 및 데이터 경주와 같은 동시성 문제를 방지할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n경주 조건은 시스템의 동작이 실행 순서에 따라 달라질 수 있는 다중 스레드 프로그래밍에서 중요한 개념입니다. 다시 말해, 경주 조건은 두 개 이상의 작업이 병렬로 실행되고 결과가 실행 순서나 시간에 따라 변경될 수 있는 경우 발생합니다. 경주 조건이 발생하면 프로그램이 예측할 수 없이 동작하거나 예상치 못한 결과를 내놓을 수 있습니다.\n\n데이터 경주는 두 개 이상의 스레드가 동시에 동일한 메모리 위치에 액세스하고, 그 중 적어도 하나가 쓰기 작업을 수행하는 경우 발생합니다. 이는 메모리 일관성을 파괴하고 예측할 수 없는 프로그램 동작으로 이어질 수 있습니다. Swift의 Actor는 이러한 문제를 방지하기 위해 상태를 안전하게 격리합니다.\n\n제 코드에서는 메인 Actor 콘텍스트에서 Actor로 격리된 ekRepository의 eventStore 속성에 액세스하려고 시도했으며, 이로 인해 Swift 6에서 컴파일 오류가 발생했습니다. 코드의 문제가 요약된 부분은 다음과 같습니다:\n\n```swift\nimport EventKit\n\nactor EKRepository {\n    let eventStore: EKEventStore\n\n    init() {\n        self.eventStore = EKEventStore()\n    }\n}\n\n@MainActor\nfinal class EKInteractor: ObservableObject {\n    private let ekRepository: EKRepository\n\n    var eventStore: EKEventStore {\n        /// 🔥 Actor-isolated property 'eventStore' can not be referenced from the main actor;\n        /// 🔥 this is an error in the Swift 6 language mode.\n        ekRepository.eventStore\n    }\n\n    init(ekRepository: EKRepository) {\n        self.ekRepository = ekRepository\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 이 코드를 처음 작성할 때 'eventStore'가 'EKRepository' 내에서만 액세스되도록 보장하는 것이 목표였습니다. 처음에는 EKInteractor가 속성으로 eventStore를 정의하지 않았습니다. 그러나 EKEventEditViewController와 같은 Apple에서 제공하는 UI에 EKEventStore를 매개변수로 전달해야 하는 상황이 많았습니다. 그 결과, EKInteractor는 eventStore을 노출하기 시작했습니다.\n\n하지만, EKInteractor가 Actor Isolation을 무시하고 ekRepository의 eventStore에 액세스하고 있다면, 이는 경합 조건과 예기치 않은 문제를 초래할 수 있습니다.\n\n이를 해결하기 위해 코드를 리팩토링하여 Actor Isolation을 준수하도록 만들어 경합 조건을 피했습니다. 리팩토링된 코드는 다음과 같습니다:\n\n```swift\nactor EKRepository {\n    /// 💡 'getEventStore()' 메서드를 사용하여 eventStore에 대한 액세스 캡슐화\n    private let eventStore: EKEventStore\n\n    init() {\n        self.eventStore = EKEventStore()\n    }\n}\n\nextension EKRepository {\n    func getEventStore() -\u003e EKEventStore {\n        return eventStore\n    }\n}\n\n@MainActor\nfinal class EKInteractor: ObservableObject {\n    private let ekRepository: EKRepository\n\n    private var cachedEventStore: EKEventStore? = nil\n\n    /// 💡 Actor Isolation을 준수하면서 eventStore에 비동기적으로 액세스하고 캐시합니다.\n    /// 우선 캐시된 eventStore이 있는지 확인하고,\n    /// 그렇지 않으면 EKRepository의 getEventStore 메서드를 비동기적으로 호출하여 eventStore을 가져와 캐시합니다.\n    var eventStore: EKEventStore {\n        get async {\n            if let eventStore = cachedEventStore {\n                return eventStore\n            }\n\n            let store = await ekRepository.getEventStore()\n            cachedEventStore = store\n            return store\n        }\n    }\n\n    init(ekRepository: EKRepository) {\n        self.ekRepository = ekRepository\n\n        /// 💡 시작할 때 eventStore을 비동기적으로 가져와 캐싱하여 이후 액세스 성능을 향상시킵니다.\n        initEventStore(ekRepository: ekRepository)\n    }\n}\n\nextension EKInteractor {\n    private func initEventStore(ekRepository: EKRepository) {\n        /// 💡 [Task] 이 메서드는 eventStore을 비동기적으로 가져와 캐시하지만,\n        /// 이 프로세스가 완료되기 전에 후속 작업이 진행될 수 있습니다.\n        Task {\n            self.cachedEventStore = await ekRepository.getEventStore()\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n또한, 'Default Calendar'를 설정하는 부분에서 레이스 컨디션에 민감한 코드를 발견했어요. 아래 코드에서는 newEKEvent의 캘린더(타입은 EKCalendar)가 Task 블록 내에서 비동기로 설정되어 있습니다. 이 비동기 작업은 getNewEKEvent 함수가 newEKEvent 객체를 반환한 뒤에 실행될 수 있습니다. 이는 반환된 newEKEvent 객체를 다른 곳에서 사용하려고 할 때 캘린더 속성이 아직 설정되지 않을 수 있다는 의미입니다. 이러한 상황은 '실행 순서(execution order)'에 따라 예측할 수 없는 동작을 유발할 수 있으며, 이는 해결하고자 했던 간헐적 버그와 일치합니다.\n\n```js\nprivate func getNewEKEvent(ekInteractor: EKInteractor, selectedDate: Date) -\u003e EKEvent {\n    let newEKEvent = EKEvent(eventStore: ekInteractor.eventStore)\n\n    // 🔥 문제: 이 Task 블록은 비동기로 실행되므로, 함수가 newEKEvent를 반환한 후에 실행될 수 있습니다.\n    Task {\n        // 🔥 문제: 비동기 작업이 newEKEvent 반환 후에 완료된 경우, 캘린더 속성이 아직 설정되지 않을 수 있습니다.\n        if let defaultEKCalendarToAdd = await ekInteractor.getDefaultEKCalendarToAdd() {\n            newEKEvent.calendar = defaultEKCalendarToAdd\n        }\n    }\n\n    // 🔥 문제: 함수가 비동기 작업이 완료되기 전에 newEKEvent를 반환하므로, 데이터 레이스와 레이스 컨디션이 발생할 수 있습니다.\n    return newEKEvent\n}\n```\n\n요약하면, 위의 코드는 '레이스 컨디션'의 대상이 될 수 있으며, 비동기 작업이 완료되기 전에 객체가 반환됩니다. 이 문제는 아래에 표시된 대로 코드를 재구성하여 해결할 수 있습니다.\n\n```js\n/// 💡 비동기 작업을 수행할 수 있도록 getNewEKEvent 함수를 async로 선언하여,\n/// 모든 비동기 작업이 완료된 후에만 newEKEvent가 반환되도록 함.\n/// ---\u003e 레이스 컨디션과 데이터 레이스 방지\nprivate func getNewEKEvent(ekInteractor: EKInteractor, selectedDate: Date) async -\u003e EKEvent {\n    /// 💡 eventStore를 비동기로 가져오기 위해 await 사용\n    let newEKEvent = EKEvent(eventStore: await ekInteractor.eventStore)\n\n    /// 💡 defaultEKCalendarToAdd를 비동기로 가져와 newEKEvent의 캘린더 속성에 설정\n    if let defaultEKCalendarToAdd = await ekInteractor.getDefaultEKCalendarToAdd() {\n        newEKEvent.calendar = defaultEKCalendarToAdd\n    }\n\n    /// 💡 모든 비동기 작업이 완료된 후에 newEKEvent 반환\n    return newEKEvent\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n이 문제를 해결하면서 Swift 동시성에 대한 이해가 깊어졌습니다. 안전한 동시 코드 작성의 기초를 확립할 수 있어 기쁩니다. 무엇보다도, Scheduler 앱의 다음 업데이트에서 사용자에게 흠잡을 데 없는 '기본 캘린더' 기능을 제공할 수 있어 기쁩니다.\n\n'Reminders'부터 '기본 캘린더'까지 모든 것을 신속하게 통합하세요.\n다양한 위젯.\nScheduler: iPhone, iPad 및 Mac용 캘린더 앱.\n\n# 참고문헌\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Swift 프로그래밍 언어 — 동시성:\n  https://docs.swift.org/swift-book/documentation/the-swift-programming-language/concurrency/\n- Apple 개발자 문서 — Swift 동시성:\n  https://developer.apple.com/documentation/swift/concurrency\n- Apple 개발자 문서 — EKEventStore:\n  https://developer.apple.com/documentation/eventkit/ekeventstore\n- 경합 조건 이해와 해결:\n  https://en.wikipedia.org/wiki/Race_condition\n- Apple 개발자 문서 — Task:\n  https://developer.apple.com/documentation/swift/task\n\n이러한 자료들은 Swift 동시성, 액터 및 관련 주제에 대해 자세한 정보를 제공하여 경합 조건과 같은 문제를 이해하고 해결하는 데 도움이 됩니다.\n","ogImage":{"url":"/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_0.png"},"coverImage":"/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_0.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_0.png\"\u003e\n\u003cp\u003eiOS 캘린더 스케줄러에는 '기본 캘린더' 기능이 있어요. Apple 캘린더와 같은 외부 캘린더와 통합한 후에, 이 설정은 이벤트를 추가할 때 가장 자주 사용하는 캘린더가 기본적으로 선택되도록 합니다. 이 기능은 사용자가 정의한 '기본 캘린더'를 연결된 캘린더에서 이벤트 스케줄링 시에 에디터의 '캘린더 선택' 섹션에서 자동으로 선택되도록 설정합니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_1.png\"\u003e\n\u003ch1\u003e💡 경합 조건으로 인한 문제 해결하기\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그러나 때로는 다른 닠린더가 선택된 경우도 있었습니다. 항상 그런 것은 아니었고, 대부분의 경우 정상적으로 작동했습니다. 제가 이 문제를 디버그하는 방법을 잘 모르겠었는데, 가끔 발생하는 문제라서 더욱 더 어려웠습니다. 가끔씩 발생하더라도, 이 기능이 제대로 작동하지 않으면 사용자가 잘못된 링크된 달력에 이벤트를 알지 못하게 추가할 수 있어 나중에 불필요한 수정을 유발할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e최근에 이 문제를 해결할 실마리를 찾았습니다. Xcode 16 베타 버전의 새 기능에 대한 호기심으로 설치한 후 보게 된 경고 메시지 덕분이었습니다. 이 경고는 이전 버전의 Xcode에서는 나타나지 않았고, 스위프트 6의 보다 엄격한 Actor Isolation 규칙으로 인해 발생했습니다. 이 규칙은 동시성 모델을 더 안전하게 만들기 위한 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_2.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e스위프트에서 Actor는 동시성 모델로, 내부 함수와 속성을 동시 액세스로부터 보호합니다. Actors는 수행하는 작업을 직렬화하여 각 작업이 순차적으로 실행되도록 합니다. 이를 통해 경합 조건 및 데이터 경주와 같은 동시성 문제를 방지할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e경주 조건은 시스템의 동작이 실행 순서에 따라 달라질 수 있는 다중 스레드 프로그래밍에서 중요한 개념입니다. 다시 말해, 경주 조건은 두 개 이상의 작업이 병렬로 실행되고 결과가 실행 순서나 시간에 따라 변경될 수 있는 경우 발생합니다. 경주 조건이 발생하면 프로그램이 예측할 수 없이 동작하거나 예상치 못한 결과를 내놓을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e데이터 경주는 두 개 이상의 스레드가 동시에 동일한 메모리 위치에 액세스하고, 그 중 적어도 하나가 쓰기 작업을 수행하는 경우 발생합니다. 이는 메모리 일관성을 파괴하고 예측할 수 없는 프로그램 동작으로 이어질 수 있습니다. Swift의 Actor는 이러한 문제를 방지하기 위해 상태를 안전하게 격리합니다.\u003c/p\u003e\n\u003cp\u003e제 코드에서는 메인 Actor 콘텍스트에서 Actor로 격리된 ekRepository의 eventStore 속성에 액세스하려고 시도했으며, 이로 인해 Swift 6에서 컴파일 오류가 발생했습니다. 코드의 문제가 요약된 부분은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e EventKit\n\n\u003cspan class=\"hljs-keyword\"\u003eactor\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEKRepository\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e eventStore: \u003cspan class=\"hljs-type\"\u003eEKEventStore\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003einit\u003c/span\u003e() {\n        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.eventStore \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eEKEventStore\u003c/span\u003e()\n    }\n}\n\n\u003cspan class=\"hljs-meta\"\u003e@MainActor\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEKInteractor\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eObservableObject\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e ekRepository: \u003cspan class=\"hljs-type\"\u003eEKRepository\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e eventStore: \u003cspan class=\"hljs-type\"\u003eEKEventStore\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e/// 🔥 Actor-isolated property 'eventStore' can not be referenced from the main actor;\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e/// 🔥 this is an error in the Swift 6 language mode.\u003c/span\u003e\n        ekRepository.eventStore\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003einit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eekRepository\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eEKRepository\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.ekRepository \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e ekRepository\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e저는 이 코드를 처음 작성할 때 'eventStore'가 'EKRepository' 내에서만 액세스되도록 보장하는 것이 목표였습니다. 처음에는 EKInteractor가 속성으로 eventStore를 정의하지 않았습니다. 그러나 EKEventEditViewController와 같은 Apple에서 제공하는 UI에 EKEventStore를 매개변수로 전달해야 하는 상황이 많았습니다. 그 결과, EKInteractor는 eventStore을 노출하기 시작했습니다.\u003c/p\u003e\n\u003cp\u003e하지만, EKInteractor가 Actor Isolation을 무시하고 ekRepository의 eventStore에 액세스하고 있다면, 이는 경합 조건과 예기치 않은 문제를 초래할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이를 해결하기 위해 코드를 리팩토링하여 Actor Isolation을 준수하도록 만들어 경합 조건을 피했습니다. 리팩토링된 코드는 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003eactor\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEKRepository\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e/// 💡 'getEventStore()' 메서드를 사용하여 eventStore에 대한 액세스 캡슐화\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e eventStore: \u003cspan class=\"hljs-type\"\u003eEKEventStore\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003einit\u003c/span\u003e() {\n        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.eventStore \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eEKEventStore\u003c/span\u003e()\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eextension\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEKRepository\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetEventStore\u003c/span\u003e() -\u003e \u003cspan class=\"hljs-type\"\u003eEKEventStore\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e eventStore\n    }\n}\n\n\u003cspan class=\"hljs-meta\"\u003e@MainActor\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEKInteractor\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eObservableObject\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e ekRepository: \u003cspan class=\"hljs-type\"\u003eEKRepository\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e cachedEventStore: \u003cspan class=\"hljs-type\"\u003eEKEventStore\u003c/span\u003e? \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e\n\n    \u003cspan class=\"hljs-comment\"\u003e/// 💡 Actor Isolation을 준수하면서 eventStore에 비동기적으로 액세스하고 캐시합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e/// 우선 캐시된 eventStore이 있는지 확인하고,\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e/// 그렇지 않으면 EKRepository의 getEventStore 메서드를 비동기적으로 호출하여 eventStore을 가져와 캐시합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e eventStore: \u003cspan class=\"hljs-type\"\u003eEKEventStore\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e eventStore \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e cachedEventStore {\n                \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e eventStore\n            }\n\n            \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e store \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e ekRepository.getEventStore()\n            cachedEventStore \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e store\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e store\n        }\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003einit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eekRepository\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eEKRepository\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.ekRepository \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e ekRepository\n\n        \u003cspan class=\"hljs-comment\"\u003e/// 💡 시작할 때 eventStore을 비동기적으로 가져와 캐싱하여 이후 액세스 성능을 향상시킵니다.\u003c/span\u003e\n        initEventStore(ekRepository: ekRepository)\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eextension\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEKInteractor\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003einitEventStore\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eekRepository\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eEKRepository\u003c/span\u003e) {\n        \u003cspan class=\"hljs-comment\"\u003e/// 💡 [Task] 이 메서드는 eventStore을 비동기적으로 가져와 캐시하지만,\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e/// 이 프로세스가 완료되기 전에 후속 작업이 진행될 수 있습니다.\u003c/span\u003e\n        \u003cspan class=\"hljs-type\"\u003eTask\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.cachedEventStore \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e ekRepository.getEventStore()\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e또한, 'Default Calendar'를 설정하는 부분에서 레이스 컨디션에 민감한 코드를 발견했어요. 아래 코드에서는 newEKEvent의 캘린더(타입은 EKCalendar)가 Task 블록 내에서 비동기로 설정되어 있습니다. 이 비동기 작업은 getNewEKEvent 함수가 newEKEvent 객체를 반환한 뒤에 실행될 수 있습니다. 이는 반환된 newEKEvent 객체를 다른 곳에서 사용하려고 할 때 캘린더 속성이 아직 설정되지 않을 수 있다는 의미입니다. 이러한 상황은 '실행 순서(execution order)'에 따라 예측할 수 없는 동작을 유발할 수 있으며, 이는 해결하고자 했던 간헐적 버그와 일치합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eprivate func \u003cspan class=\"hljs-title function_\"\u003egetNewEKEvent\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eekInteractor\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eEKInteractor\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eselectedDate\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-title class_\"\u003eEKEvent\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e newEKEvent = \u003cspan class=\"hljs-title class_\"\u003eEKEvent\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eeventStore\u003c/span\u003e: ekInteractor.\u003cspan class=\"hljs-property\"\u003eeventStore\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-comment\"\u003e// 🔥 문제: 이 Task 블록은 비동기로 실행되므로, 함수가 newEKEvent를 반환한 후에 실행될 수 있습니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eTask\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// 🔥 문제: 비동기 작업이 newEKEvent 반환 후에 완료된 경우, 캘린더 속성이 아직 설정되지 않을 수 있습니다.\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e defaultEKCalendarToAdd = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e ekInteractor.\u003cspan class=\"hljs-title function_\"\u003egetDefaultEKCalendarToAdd\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n            newEKEvent.\u003cspan class=\"hljs-property\"\u003ecalendar\u003c/span\u003e = defaultEKCalendarToAdd\n        }\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// 🔥 문제: 함수가 비동기 작업이 완료되기 전에 newEKEvent를 반환하므로, 데이터 레이스와 레이스 컨디션이 발생할 수 있습니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e newEKEvent\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e요약하면, 위의 코드는 '레이스 컨디션'의 대상이 될 수 있으며, 비동기 작업이 완료되기 전에 객체가 반환됩니다. 이 문제는 아래에 표시된 대로 코드를 재구성하여 해결할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/// 💡 비동기 작업을 수행할 수 있도록 getNewEKEvent 함수를 async로 선언하여,\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e/// 모든 비동기 작업이 완료된 후에만 newEKEvent가 반환되도록 함.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e/// ---\u003e 레이스 컨디션과 데이터 레이스 방지\u003c/span\u003e\nprivate func \u003cspan class=\"hljs-title function_\"\u003egetNewEKEvent\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eekInteractor\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eEKInteractor\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eselectedDate\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e -\u003e \u003cspan class=\"hljs-title class_\"\u003eEKEvent\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e/// 💡 eventStore를 비동기로 가져오기 위해 await 사용\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e newEKEvent = \u003cspan class=\"hljs-title class_\"\u003eEKEvent\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eeventStore\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e ekInteractor.\u003cspan class=\"hljs-property\"\u003eeventStore\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-comment\"\u003e/// 💡 defaultEKCalendarToAdd를 비동기로 가져와 newEKEvent의 캘린더 속성에 설정\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e defaultEKCalendarToAdd = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e ekInteractor.\u003cspan class=\"hljs-title function_\"\u003egetDefaultEKCalendarToAdd\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        newEKEvent.\u003cspan class=\"hljs-property\"\u003ecalendar\u003c/span\u003e = defaultEKCalendarToAdd\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e/// 💡 모든 비동기 작업이 완료된 후에 newEKEvent 반환\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e newEKEvent\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 문제를 해결하면서 Swift 동시성에 대한 이해가 깊어졌습니다. 안전한 동시 코드 작성의 기초를 확립할 수 있어 기쁩니다. 무엇보다도, Scheduler 앱의 다음 업데이트에서 사용자에게 흠잡을 데 없는 '기본 캘린더' 기능을 제공할 수 있어 기쁩니다.\u003c/p\u003e\n\u003cp\u003e'Reminders'부터 '기본 캘린더'까지 모든 것을 신속하게 통합하세요.\n다양한 위젯.\nScheduler: iPhone, iPad 및 Mac용 캘린더 앱.\u003c/p\u003e\n\u003ch1\u003e참고문헌\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003eSwift 프로그래밍 언어 — 동시성:\n\u003ca href=\"https://docs.swift.org/swift-book/documentation/the-swift-programming-language/concurrency/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://docs.swift.org/swift-book/documentation/the-swift-programming-language/concurrency/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eApple 개발자 문서 — Swift 동시성:\n\u003ca href=\"https://developer.apple.com/documentation/swift/concurrency\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://developer.apple.com/documentation/swift/concurrency\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eApple 개발자 문서 — EKEventStore:\n\u003ca href=\"https://developer.apple.com/documentation/eventkit/ekeventstore\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://developer.apple.com/documentation/eventkit/ekeventstore\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e경합 조건 이해와 해결:\n\u003ca href=\"https://en.wikipedia.org/wiki/Race_condition\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://en.wikipedia.org/wiki/Race_condition\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eApple 개발자 문서 — Task:\n\u003ca href=\"https://developer.apple.com/documentation/swift/task\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://developer.apple.com/documentation/swift/task\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 자료들은 Swift 동시성, 액터 및 관련 주제에 대해 자세한 정보를 제공하여 경합 조건과 같은 문제를 이해하고 해결하는 데 도움이 됩니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency"},"buildId":"wfHLuDA3kTGBYfaM5IGXk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>