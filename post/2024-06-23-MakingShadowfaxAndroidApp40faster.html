<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Shadowfax 안드로이드 앱 40 더 빠르게 만드는 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-23-MakingShadowfaxAndroidApp40faster" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Shadowfax 안드로이드 앱 40 더 빠르게 만드는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Shadowfax 안드로이드 앱 40 더 빠르게 만드는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-23-MakingShadowfaxAndroidApp40faster" data-gatsby-head="true"/><meta name="twitter:title" content="Shadowfax 안드로이드 앱 40 더 빠르게 만드는 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 01:14" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_buildManifest.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Shadowfax 안드로이드 앱 40 더 빠르게 만드는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Shadowfax 안드로이드 앱 40 더 빠르게 만드는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-MakingShadowfaxAndroidApp40faster&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_0.png" alt="Image"></p>
<h1>1. 목표 설정</h1>
<p>모바일 앱 성능에는 모든 밀리초가 중요합니다. 앱이 빨리 로드될수록 사용자가 머물 가능성이 높아집니다.</p>
<p>매일 10만 명 이상의 DAU를 보유한 Shadowfax Rider 앱은 앱이 실행되는 데 약 3.5초가 걸리는 문제에 직면했습니다!</p>
<p>목표는 다음과 같이이 시간을 단축하는 것이었습니다:</p>
<ul>
<li>90 백분위에는 2 초</li>
<li>중간 사용자에 대해 800ms</li>
</ul>
<h2>2. 앱 시작 시간 측정</h2>
<p>Firebase에 따르면 앱 시작 시간은 런처에서 앱이 시작되어 첫 번째 액티비티의 <code>onResume()</code> 메서드가 호출 될 때까지의 지속 시간입니다. 이 기간은 다음과 같이 logcat에도 보고됩니다:</p>
<p>여기에서 더 많은 정보를 읽을 수 있습니다. Firebase에서 Startup 시간이 진실의 근원이었습니다.</p>
<p>만약 onResume이 호출된 후 어떤 시점에 앱이 완전히 로드된 것으로 간주한다면 (지도가 완전히 그려진 후와 같이), 해당 시점을 시스템 및 Firebase에 Activity.reportFullyDrawn()으로 보고할 수 있습니다.</p>
<p>만약 Perfetto를 사용하고 있다면, 나중에 그에 대해 자세히 설명하겠습니다.</p>
<h1>3. 자세히 들여다보기</h1>
<p>앱의 시작 시간을 기간별로 분해하기 위해 Firebase 성능 라이브러리의 @trace 어노테이션을 app 클래스의 onCreate() 함수, BaseActivity 및 MainActivity의 onCreate() &#x26; onStart()에 추가했어요. 기본적으로 모든 것을 최상위 수준에서 측정하므로 주요 원인을 파악하고 거기서부터 드릴다운합니다.</p>
<p><img src="/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_1.png" alt="이미지"></p>
<p>Main 및 Base 액티비티 이외에도 앱 클래스가 앱 시작 시간의 30%를 차지했기 때문에 2가지 작업을 수행했어요:</p>
<h1>3.1 라이브러리 및 콘텐츠 제공자 지연 로드 (-10% 시작 시간)</h1>
<p>애플리케이션 클래스는 일반적으로 많은 라이브러리를 초기화합니다. 필요하지 않은 라이브러리는 앱 시작 시 즉시 초기화하는 대신 백그라운드에서 초기화하도록 변경했습니다. Content Provider가 있다면 Startup 라이브러리를 사용하여 그것들을 나중에 로딩할 수도 있습니다.</p>
<p>다음은 몇 가지 SDK를 백그라운드 스레드에서 초기화하는 방법입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApp</span> : <span class="hljs-title class_">Application</span>() {
    @<span class="hljs-title class_">AddTrace</span>(name = <span class="hljs-string">"backgroundInitializationsTrace"</span>)
    private fun <span class="hljs-title function_">performBackgroundInitializations</span>(<span class="hljs-params"></span>) {
        runWithLooper {
            <span class="hljs-comment">// 메인 스레드에서 초기화가 필요하지 않은 SDK 초기화</span>
        }
    }
}

object <span class="hljs-title class_">MyUtils</span> {
    <span class="hljs-comment">// 백그라운드 스레드에서 초기화를 위한 유틸리티 함수</span>
    fun <span class="hljs-title function_">runWithLooper</span>(<span class="hljs-params">runnable: Runnable</span>) {
        val threadHandler = <span class="hljs-title class_">HandlerThread</span>(<span class="hljs-string">"Thread${System.currentTimeMillis()}"</span>)
        <span class="hljs-keyword">try</span> {
            threadHandler.<span class="hljs-title function_">start</span>()
            val handler = <span class="hljs-title class_">Handler</span>(threadHandler.<span class="hljs-property">looper</span>)
            handler.<span class="hljs-property">post</span> {
                runnable.<span class="hljs-title function_">run</span>()
            }
        } <span class="hljs-keyword">catch</span> (<span class="hljs-attr">e</span>: <span class="hljs-title class_">OutOfMemoryError</span>) {
            firebaseCrashlytics.<span class="hljs-title function_">recordException</span>(e)
            <span class="hljs-title function_">runWithinMainLooper</span>(runnable)
        }
    }
    <span class="hljs-comment">// 대체 방법</span>
    fun <span class="hljs-title function_">runWithinMainLooper</span>(<span class="hljs-params">mainThread: Runnable</span>) {
        val handler = <span class="hljs-title class_">Handler</span>(<span class="hljs-title class_">Looper</span>.<span class="hljs-title function_">getMainLooper</span>())
        handler.<span class="hljs-property">post</span> {
            mainThread.<span class="hljs-title function_">run</span>()
        }
    }
}
</code></pre>
<h1>3.2 베이스라인 프로필 (-7% 시작 시간)</h1>
<p>Google은 첫 번째 앱 시작 시간을 개선하기 위해 기본 프로필을 설정하는 것을 권장합니다. 전체 앱 시작 시간이 7% 향상되었음을 확인했습니다. 실제 결과는 다를 수 있지만 꼭 시도해 보세요.</p>
<p>그래서 우리는 좋은 시작을 했지만 더 심층적으로 파헤쳐야 했습니다.</p>
<h3>4. Perfetto 사용하기</h3>
<p>안드로이드 스튜디오에서 시스템 추적을 실행하여 각 함수의 수행 시간을 측정할 수 있으며, 그런 다음 앱을 실행하고 추적을 Perfetto 비주얼라이저에 로드할 수 있습니다.</p>
<p>Android Studio에 내장된 프로파일러를 사용할 수 있지만, Perfetto가 더 나은 탐색 및 세부 정보를 제공합니다.</p>
<p>시스템 추적 방법은 여기에 있지만 앱 실행 시간을 프로파일링하려면 앱을 보통 실행하지 마세요. 다음과 같이 해야 합니다:</p>
<ul>
<li>정확한 결과를 얻기 위해 앱의 릴리스 빌드 변형을 선택하세요. 디버그 빌드 대신</li>
<li>Android Studio의 실행 버튼 근처에 있는 3점 메뉴를 클릭하세요</li>
<li>그런 다음 "오버헤드 낮은 상태로 앱 프로파일링"을 선택하여 앱을 실행하세요</li>
<li>이제 앱이 완전히 로드될 때까지 대기한 후 녹화를 중지하세요</li>
<li>마지막으로 Profiler의 저장 아이콘을 사용하여 추적을 내보낸 다음 Perfetto Web UI로 가져오세요</li>
</ul>
<p>퍼페토에 추적 파일을 로드하면 화면에 수많은 색상이 나타나더라도 놀라지 마세요. 그 모든 것을 다룰 필요는 없습니다.</p>
<h1>4.1 퍼페토에서 시작 시간 지표 찾기</h1>
<p><img src="/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_3.png" alt="이미지"></p>
<p>“startup”을 검색하면 앱 시작 시간의 시각화를 볼 수 있습니다. 초록 막대를 클릭한 후 키보드에서 ‘M’을 누르세요. 이렇게 하면 그 막대의 시작과 끝을 표시할 수 있습니다. 지금은 이에만 집중하고 나머지는 그냥 잡음입니다.</p>
<h1>4.2 원인을 찾아보세요</h1>
<p>지금 시작 시간 막대 아래에 패키지 이름을 찾아 확장하세요. 그래프의 표시된 영역에만 집중하고 메인 스레드를 보세요. x축에 각 함수의 지속 시간이 나올 것이며, y축에 중첩된 막대가 있는 경우 중첩된 함수를 의미합니다.</p>
<p>먼저 수평으로 긴 막대부터 살펴보세요. 그 막대가 가장 많이 소요된 시간을 나타낼 것입니다. 예상보다 시간이 더 많이 소요된 함수가 어떤 것인지 확인하고 기록해보세요. 그런 다음 상위 4~5개의 주범을 최적화할 수 있을 것입니다.</p>
<p><img src="/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_4.png" alt="그래프"></p>
<p>프레임은 16밀리초 내에 렌더링되어야 60fps를 달성할 수 있어요</p>
<p>팁: WASD 키를 사용하여 이동하세요. perfetto UI에 대해 더 읽고 싶다면 여기를 확인해보세요. 문서는 약간 오래되었지만 핵심 원칙은 같아요.</p>
<h1>5. 토끼굴에 들어가다</h1>
<p>긴 지속 시간을 가진 함수들이 있을 수 있지만 결과물이 없을 수도 있어요.</p>
<p>저기요, 이 BaseActivity의 onResume() 메서드가 엄청 길어요. 하지만 이 그래프만으로는 무엇이 시간을 차지하는지 알 수 없어요.</p>
<p>마지막 부분에야 전체 시간의 1/4를 차지하는 중첩 함수가 보이네요.</p>
<p>그럼 이제 어떻게 해볼까요?</p>
<p><img src="/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_5.png" alt="이미지"></p>
<p>트레이싱을 더 추가해야 돼요. 자바 및 코틀린에서 사용 가능한 트레이싱 라이브러리로 쉽게 할 수 있어요. 자세한 내용은 여기를 참조할 수 있지만 코드 일부를 살펴봐요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  fun <span class="hljs-title function_">foo</span>(<span class="hljs-params">pika: <span class="hljs-built_in">String</span></span>) {
    <span class="hljs-title function_">trace</span>(<span class="hljs-params"><span class="hljs-string">"MyClass.foo"</span></span>) {
    <span class="hljs-comment">// 기존의 함수 로직이 여기에 있어요...</span>
    }
  }
}
</code></pre>
<p>이제 MyClass.foo가 Perfetto에 나타날 거예요. 따라서 디버그 중인 함수 내 모든 중첩 함수에 대한 트레이싱을 추가한 후 트레이스를 다시 기록하고 Perfetto에서 분석해보세요. 각 라이프사이클 함수에 대해 이 과정을 계속 반복하세요.</p>
<p><img src="/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_6.png" alt="이미지"></p>
<h1>6. 우리의 솔루션</h1>
<p>이 연습을 통해 매우 명확한 근본 원인과 목표를 얻었습니다. 이제 각 원인을 하나씩 해결할 때가 왔습니다. Perfetto와 SysTrace의 관측을 바탕으로 다음과 같은 다양한 최적화가 실행되었습니다:</p>
<h2>6.1. 홈 화면 레이아웃 최적화 (-15% 시작 시간)</h2>
<p>ConstraintLayout으로 뷰를 중첩하지 않고 hidden views 대신 viewstubs를 사용하여 최대 600ms까지 감소하였습니다. 이 접근 방식은 기본적으로 숨겨져 있고 사용자 상호작용 후에만 표시되는 뷰의 불필요한 측정 및 확장을 방지합니다. view stubs에 대해 더 알아보기.</p>
<p>200~300 밀리초가 걸리는 mapView가 onResume()이 호출된 후에 init으로 이동되었기 때문에 핵심 UI에서 주문 수와 상태를 표시한 후에 로드됩니다.</p>
<pre><code class="hljs language-js">private fun <span class="hljs-title class_">HomeFragment</span>.<span class="hljs-title function_">lazyLoadMap</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title class_">Handler</span>(<span class="hljs-title class_">Looper</span>.<span class="hljs-title function_">getMainLooper</span>()).<span class="hljs-property">post</span> {
    <span class="hljs-comment">// 이 Runnable은 메인 스레드가 HomeFrag를 확장한 후에만 실행됩니다.</span>
    <span class="hljs-title function_">initMap</span>()
  }
}
</code></pre>
<h1>6.2 MainActivity 최적화하기 (-5% 시작 시간)</h1>
<p>반복된 성능 테스트에서 LinearLayout이 Fragment에 대한 컨테이너로만 사용되는 MainActivity에서 ConstraintLayout보다 성능이 더 우수했습니다. 실제로 LinearLayout으로 변경하면 MainActivity가 특히 웜 스타트에서 2배 더 빨리 시작되었습니다.</p>
<h2>6.3 MainActivity SDK들의 지연 로딩(-10% 시간)</h2>
<p>퍼페토는 MainActivity에서 초기화되는 단일 3rd party SDK가 onCreate() 지속 시간의 70%를 차지하고 있다는 것을 보여주었습니다. 우리는 앱 시작 시 즉시 필요하지 않았기 때문에 백그라운드에서 이를 지연로딩하기 시작했습니다.</p>
<h2>7. 실제 성능 결과</h2>
<p>이러한 솔루션을 여러 릴리스를 통해 출시한 뒤, 시작 시간의 90분위가 3.5초에서 거의 2초 미만으로 점진적으로 개선되어, 놀라운 42%의 감소를 보았습니다.</p>
<p><img src="/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_7.png" alt="image"></p>
<p>더 많은 병목 현상을 찾고 앱 속도를 높이는 데 노력하고 있습니다. 이를 통해 파트너들이 더 생산적일 수 있도록 돕고 있습니다.</p>
<p>프레펫토를 사용하여 병목 현상을 발견하는 것은이 프로젝트에 있어 중요했으며, 각 문제를 해결함으로써 얼마나 많은 성능 향상을 이끌어낼 수 있는지를 알기에 자신감을 갖게 되었습니다.</p>
<p>앱 시작 시간을 개선하는 데 도움을 준 Burhan &#x26; Vishnu에게 감사드립니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Shadowfax 안드로이드 앱 40 더 빠르게 만드는 방법","description":"","date":"2024-06-23 01:14","slug":"2024-06-23-MakingShadowfaxAndroidApp40faster","content":"\n\n\n![Image](/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_0.png)\n\n# 1. 목표 설정\n\n모바일 앱 성능에는 모든 밀리초가 중요합니다. 앱이 빨리 로드될수록 사용자가 머물 가능성이 높아집니다.\n\n매일 10만 명 이상의 DAU를 보유한 Shadowfax Rider 앱은 앱이 실행되는 데 약 3.5초가 걸리는 문제에 직면했습니다!\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n목표는 다음과 같이이 시간을 단축하는 것이었습니다:\n\n- 90 백분위에는 2 초\n- 중간 사용자에 대해 800ms\n\n## 2. 앱 시작 시간 측정\n\nFirebase에 따르면 앱 시작 시간은 런처에서 앱이 시작되어 첫 번째 액티비티의 `onResume()` 메서드가 호출 될 때까지의 지속 시간입니다. 이 기간은 다음과 같이 logcat에도 보고됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에서 더 많은 정보를 읽을 수 있습니다. Firebase에서 Startup 시간이 진실의 근원이었습니다.\n\n만약 onResume이 호출된 후 어떤 시점에 앱이 완전히 로드된 것으로 간주한다면 (지도가 완전히 그려진 후와 같이), 해당 시점을 시스템 및 Firebase에 Activity.reportFullyDrawn()으로 보고할 수 있습니다.\n\n만약 Perfetto를 사용하고 있다면, 나중에 그에 대해 자세히 설명하겠습니다.\n\n# 3. 자세히 들여다보기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱의 시작 시간을 기간별로 분해하기 위해 Firebase 성능 라이브러리의 @trace 어노테이션을 app 클래스의 onCreate() 함수, BaseActivity 및 MainActivity의 onCreate() \u0026 onStart()에 추가했어요. 기본적으로 모든 것을 최상위 수준에서 측정하므로 주요 원인을 파악하고 거기서부터 드릴다운합니다.\n\n![이미지](/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_1.png)\n\nMain 및 Base 액티비티 이외에도 앱 클래스가 앱 시작 시간의 30%를 차지했기 때문에 2가지 작업을 수행했어요:\n\n# 3.1 라이브러리 및 콘텐츠 제공자 지연 로드 (-10% 시작 시간)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n애플리케이션 클래스는 일반적으로 많은 라이브러리를 초기화합니다. 필요하지 않은 라이브러리는 앱 시작 시 즉시 초기화하는 대신 백그라운드에서 초기화하도록 변경했습니다. Content Provider가 있다면 Startup 라이브러리를 사용하여 그것들을 나중에 로딩할 수도 있습니다.\n\n다음은 몇 가지 SDK를 백그라운드 스레드에서 초기화하는 방법입니다:\n\n```js\nclass MyApp : Application() {\n    @AddTrace(name = \"backgroundInitializationsTrace\")\n    private fun performBackgroundInitializations() {\n        runWithLooper {\n            // 메인 스레드에서 초기화가 필요하지 않은 SDK 초기화\n        }\n    }\n}\n\nobject MyUtils {\n    // 백그라운드 스레드에서 초기화를 위한 유틸리티 함수\n    fun runWithLooper(runnable: Runnable) {\n        val threadHandler = HandlerThread(\"Thread${System.currentTimeMillis()}\")\n        try {\n            threadHandler.start()\n            val handler = Handler(threadHandler.looper)\n            handler.post {\n                runnable.run()\n            }\n        } catch (e: OutOfMemoryError) {\n            firebaseCrashlytics.recordException(e)\n            runWithinMainLooper(runnable)\n        }\n    }\n    // 대체 방법\n    fun runWithinMainLooper(mainThread: Runnable) {\n        val handler = Handler(Looper.getMainLooper())\n        handler.post {\n            mainThread.run()\n        }\n    }\n}\n```\n\n# 3.2 베이스라인 프로필 (-7% 시작 시간)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGoogle은 첫 번째 앱 시작 시간을 개선하기 위해 기본 프로필을 설정하는 것을 권장합니다. 전체 앱 시작 시간이 7% 향상되었음을 확인했습니다. 실제 결과는 다를 수 있지만 꼭 시도해 보세요.\n\n그래서 우리는 좋은 시작을 했지만 더 심층적으로 파헤쳐야 했습니다.\n\n### 4. Perfetto 사용하기\n\n안드로이드 스튜디오에서 시스템 추적을 실행하여 각 함수의 수행 시간을 측정할 수 있으며, 그런 다음 앱을 실행하고 추적을 Perfetto 비주얼라이저에 로드할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAndroid Studio에 내장된 프로파일러를 사용할 수 있지만, Perfetto가 더 나은 탐색 및 세부 정보를 제공합니다.\n\n시스템 추적 방법은 여기에 있지만 앱 실행 시간을 프로파일링하려면 앱을 보통 실행하지 마세요. 다음과 같이 해야 합니다:\n\n- 정확한 결과를 얻기 위해 앱의 릴리스 빌드 변형을 선택하세요. 디버그 빌드 대신\n- Android Studio의 실행 버튼 근처에 있는 3점 메뉴를 클릭하세요\n- 그런 다음 \"오버헤드 낮은 상태로 앱 프로파일링\"을 선택하여 앱을 실행하세요\n- 이제 앱이 완전히 로드될 때까지 대기한 후 녹화를 중지하세요\n- 마지막으로 Profiler의 저장 아이콘을 사용하여 추적을 내보낸 다음 Perfetto Web UI로 가져오세요\n\n\u003cimg src=\"/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n퍼페토에 추적 파일을 로드하면 화면에 수많은 색상이 나타나더라도 놀라지 마세요. 그 모든 것을 다룰 필요는 없습니다.\n\n# 4.1 퍼페토에서 시작 시간 지표 찾기\n\n![이미지](/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_3.png)\n\n“startup”을 검색하면 앱 시작 시간의 시각화를 볼 수 있습니다. 초록 막대를 클릭한 후 키보드에서 ‘M’을 누르세요. 이렇게 하면 그 막대의 시작과 끝을 표시할 수 있습니다. 지금은 이에만 집중하고 나머지는 그냥 잡음입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4.2 원인을 찾아보세요\n\n지금 시작 시간 막대 아래에 패키지 이름을 찾아 확장하세요. 그래프의 표시된 영역에만 집중하고 메인 스레드를 보세요. x축에 각 함수의 지속 시간이 나올 것이며, y축에 중첩된 막대가 있는 경우 중첩된 함수를 의미합니다.\n\n먼저 수평으로 긴 막대부터 살펴보세요. 그 막대가 가장 많이 소요된 시간을 나타낼 것입니다. 예상보다 시간이 더 많이 소요된 함수가 어떤 것인지 확인하고 기록해보세요. 그런 다음 상위 4~5개의 주범을 최적화할 수 있을 것입니다.\n\n![그래프](/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프레임은 16밀리초 내에 렌더링되어야 60fps를 달성할 수 있어요\n\n팁: WASD 키를 사용하여 이동하세요. perfetto UI에 대해 더 읽고 싶다면 여기를 확인해보세요. 문서는 약간 오래되었지만 핵심 원칙은 같아요.\n\n# 5. 토끼굴에 들어가다\n\n긴 지속 시간을 가진 함수들이 있을 수 있지만 결과물이 없을 수도 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저기요, 이 BaseActivity의 onResume() 메서드가 엄청 길어요. 하지만 이 그래프만으로는 무엇이 시간을 차지하는지 알 수 없어요.\n\n마지막 부분에야 전체 시간의 1/4를 차지하는 중첩 함수가 보이네요.\n\n그럼 이제 어떻게 해볼까요?\n\n![이미지](/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n트레이싱을 더 추가해야 돼요. 자바 및 코틀린에서 사용 가능한 트레이싱 라이브러리로 쉽게 할 수 있어요. 자세한 내용은 여기를 참조할 수 있지만 코드 일부를 살펴봐요:\n\n```js\nclass MyClass {\n  fun foo(pika: String) {\n    trace(\"MyClass.foo\") {\n    // 기존의 함수 로직이 여기에 있어요...\n    }\n  }\n}\n```\n\n이제 MyClass.foo가 Perfetto에 나타날 거예요. 따라서 디버그 중인 함수 내 모든 중첩 함수에 대한 트레이싱을 추가한 후 트레이스를 다시 기록하고 Perfetto에서 분석해보세요. 각 라이프사이클 함수에 대해 이 과정을 계속 반복하세요.\n\n![이미지](/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 6. 우리의 솔루션\n\n이 연습을 통해 매우 명확한 근본 원인과 목표를 얻었습니다. 이제 각 원인을 하나씩 해결할 때가 왔습니다. Perfetto와 SysTrace의 관측을 바탕으로 다음과 같은 다양한 최적화가 실행되었습니다:\n\n## 6.1. 홈 화면 레이아웃 최적화 (-15% 시작 시간)\n\nConstraintLayout으로 뷰를 중첩하지 않고 hidden views 대신 viewstubs를 사용하여 최대 600ms까지 감소하였습니다. 이 접근 방식은 기본적으로 숨겨져 있고 사용자 상호작용 후에만 표시되는 뷰의 불필요한 측정 및 확장을 방지합니다. view stubs에 대해 더 알아보기.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n200~300 밀리초가 걸리는 mapView가 onResume()이 호출된 후에 init으로 이동되었기 때문에 핵심 UI에서 주문 수와 상태를 표시한 후에 로드됩니다.\n\n```js\nprivate fun HomeFragment.lazyLoadMap() {\n  Handler(Looper.getMainLooper()).post {\n    // 이 Runnable은 메인 스레드가 HomeFrag를 확장한 후에만 실행됩니다.\n    initMap()\n  }\n}\n```\n\n# 6.2 MainActivity 최적화하기 (-5% 시작 시간)\n\n반복된 성능 테스트에서 LinearLayout이 Fragment에 대한 컨테이너로만 사용되는 MainActivity에서 ConstraintLayout보다 성능이 더 우수했습니다. 실제로 LinearLayout으로 변경하면 MainActivity가 특히 웜 스타트에서 2배 더 빨리 시작되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 6.3 MainActivity SDK들의 지연 로딩(-10% 시간)\n\n퍼페토는 MainActivity에서 초기화되는 단일 3rd party SDK가 onCreate() 지속 시간의 70%를 차지하고 있다는 것을 보여주었습니다. 우리는 앱 시작 시 즉시 필요하지 않았기 때문에 백그라운드에서 이를 지연로딩하기 시작했습니다.\n\n## 7. 실제 성능 결과\n\n이러한 솔루션을 여러 릴리스를 통해 출시한 뒤, 시작 시간의 90분위가 3.5초에서 거의 2초 미만으로 점진적으로 개선되어, 놀라운 42%의 감소를 보았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_7.png)\n\n더 많은 병목 현상을 찾고 앱 속도를 높이는 데 노력하고 있습니다. 이를 통해 파트너들이 더 생산적일 수 있도록 돕고 있습니다.\n\n프레펫토를 사용하여 병목 현상을 발견하는 것은이 프로젝트에 있어 중요했으며, 각 문제를 해결함으로써 얼마나 많은 성능 향상을 이끌어낼 수 있는지를 알기에 자신감을 갖게 되었습니다.\n\n앱 시작 시간을 개선하는 데 도움을 준 Burhan \u0026 Vishnu에게 감사드립니다.","ogImage":{"url":"/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_0.png"},"coverImage":"/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_0.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003ch1\u003e1. 목표 설정\u003c/h1\u003e\n\u003cp\u003e모바일 앱 성능에는 모든 밀리초가 중요합니다. 앱이 빨리 로드될수록 사용자가 머물 가능성이 높아집니다.\u003c/p\u003e\n\u003cp\u003e매일 10만 명 이상의 DAU를 보유한 Shadowfax Rider 앱은 앱이 실행되는 데 약 3.5초가 걸리는 문제에 직면했습니다!\u003c/p\u003e\n\u003cp\u003e목표는 다음과 같이이 시간을 단축하는 것이었습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e90 백분위에는 2 초\u003c/li\u003e\n\u003cli\u003e중간 사용자에 대해 800ms\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e2. 앱 시작 시간 측정\u003c/h2\u003e\n\u003cp\u003eFirebase에 따르면 앱 시작 시간은 런처에서 앱이 시작되어 첫 번째 액티비티의 \u003ccode\u003eonResume()\u003c/code\u003e 메서드가 호출 될 때까지의 지속 시간입니다. 이 기간은 다음과 같이 logcat에도 보고됩니다:\u003c/p\u003e\n\u003cp\u003e여기에서 더 많은 정보를 읽을 수 있습니다. Firebase에서 Startup 시간이 진실의 근원이었습니다.\u003c/p\u003e\n\u003cp\u003e만약 onResume이 호출된 후 어떤 시점에 앱이 완전히 로드된 것으로 간주한다면 (지도가 완전히 그려진 후와 같이), 해당 시점을 시스템 및 Firebase에 Activity.reportFullyDrawn()으로 보고할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e만약 Perfetto를 사용하고 있다면, 나중에 그에 대해 자세히 설명하겠습니다.\u003c/p\u003e\n\u003ch1\u003e3. 자세히 들여다보기\u003c/h1\u003e\n\u003cp\u003e앱의 시작 시간을 기간별로 분해하기 위해 Firebase 성능 라이브러리의 @trace 어노테이션을 app 클래스의 onCreate() 함수, BaseActivity 및 MainActivity의 onCreate() \u0026#x26; onStart()에 추가했어요. 기본적으로 모든 것을 최상위 수준에서 측정하므로 주요 원인을 파악하고 거기서부터 드릴다운합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eMain 및 Base 액티비티 이외에도 앱 클래스가 앱 시작 시간의 30%를 차지했기 때문에 2가지 작업을 수행했어요:\u003c/p\u003e\n\u003ch1\u003e3.1 라이브러리 및 콘텐츠 제공자 지연 로드 (-10% 시작 시간)\u003c/h1\u003e\n\u003cp\u003e애플리케이션 클래스는 일반적으로 많은 라이브러리를 초기화합니다. 필요하지 않은 라이브러리는 앱 시작 시 즉시 초기화하는 대신 백그라운드에서 초기화하도록 변경했습니다. Content Provider가 있다면 Startup 라이브러리를 사용하여 그것들을 나중에 로딩할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e다음은 몇 가지 SDK를 백그라운드 스레드에서 초기화하는 방법입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyApp\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eApplication\u003c/span\u003e() {\n    @\u003cspan class=\"hljs-title class_\"\u003eAddTrace\u003c/span\u003e(name = \u003cspan class=\"hljs-string\"\u003e\"backgroundInitializationsTrace\"\u003c/span\u003e)\n    private fun \u003cspan class=\"hljs-title function_\"\u003eperformBackgroundInitializations\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        runWithLooper {\n            \u003cspan class=\"hljs-comment\"\u003e// 메인 스레드에서 초기화가 필요하지 않은 SDK 초기화\u003c/span\u003e\n        }\n    }\n}\n\nobject \u003cspan class=\"hljs-title class_\"\u003eMyUtils\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 백그라운드 스레드에서 초기화를 위한 유틸리티 함수\u003c/span\u003e\n    fun \u003cspan class=\"hljs-title function_\"\u003erunWithLooper\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erunnable: Runnable\u003c/span\u003e) {\n        val threadHandler = \u003cspan class=\"hljs-title class_\"\u003eHandlerThread\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Thread${System.currentTimeMillis()}\"\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n            threadHandler.\u003cspan class=\"hljs-title function_\"\u003estart\u003c/span\u003e()\n            val handler = \u003cspan class=\"hljs-title class_\"\u003eHandler\u003c/span\u003e(threadHandler.\u003cspan class=\"hljs-property\"\u003elooper\u003c/span\u003e)\n            handler.\u003cspan class=\"hljs-property\"\u003epost\u003c/span\u003e {\n                runnable.\u003cspan class=\"hljs-title function_\"\u003erun\u003c/span\u003e()\n            }\n        } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (\u003cspan class=\"hljs-attr\"\u003ee\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eOutOfMemoryError\u003c/span\u003e) {\n            firebaseCrashlytics.\u003cspan class=\"hljs-title function_\"\u003erecordException\u003c/span\u003e(e)\n            \u003cspan class=\"hljs-title function_\"\u003erunWithinMainLooper\u003c/span\u003e(runnable)\n        }\n    }\n    \u003cspan class=\"hljs-comment\"\u003e// 대체 방법\u003c/span\u003e\n    fun \u003cspan class=\"hljs-title function_\"\u003erunWithinMainLooper\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003emainThread: Runnable\u003c/span\u003e) {\n        val handler = \u003cspan class=\"hljs-title class_\"\u003eHandler\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eLooper\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetMainLooper\u003c/span\u003e())\n        handler.\u003cspan class=\"hljs-property\"\u003epost\u003c/span\u003e {\n            mainThread.\u003cspan class=\"hljs-title function_\"\u003erun\u003c/span\u003e()\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e3.2 베이스라인 프로필 (-7% 시작 시간)\u003c/h1\u003e\n\u003cp\u003eGoogle은 첫 번째 앱 시작 시간을 개선하기 위해 기본 프로필을 설정하는 것을 권장합니다. 전체 앱 시작 시간이 7% 향상되었음을 확인했습니다. 실제 결과는 다를 수 있지만 꼭 시도해 보세요.\u003c/p\u003e\n\u003cp\u003e그래서 우리는 좋은 시작을 했지만 더 심층적으로 파헤쳐야 했습니다.\u003c/p\u003e\n\u003ch3\u003e4. Perfetto 사용하기\u003c/h3\u003e\n\u003cp\u003e안드로이드 스튜디오에서 시스템 추적을 실행하여 각 함수의 수행 시간을 측정할 수 있으며, 그런 다음 앱을 실행하고 추적을 Perfetto 비주얼라이저에 로드할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eAndroid Studio에 내장된 프로파일러를 사용할 수 있지만, Perfetto가 더 나은 탐색 및 세부 정보를 제공합니다.\u003c/p\u003e\n\u003cp\u003e시스템 추적 방법은 여기에 있지만 앱 실행 시간을 프로파일링하려면 앱을 보통 실행하지 마세요. 다음과 같이 해야 합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e정확한 결과를 얻기 위해 앱의 릴리스 빌드 변형을 선택하세요. 디버그 빌드 대신\u003c/li\u003e\n\u003cli\u003eAndroid Studio의 실행 버튼 근처에 있는 3점 메뉴를 클릭하세요\u003c/li\u003e\n\u003cli\u003e그런 다음 \"오버헤드 낮은 상태로 앱 프로파일링\"을 선택하여 앱을 실행하세요\u003c/li\u003e\n\u003cli\u003e이제 앱이 완전히 로드될 때까지 대기한 후 녹화를 중지하세요\u003c/li\u003e\n\u003cli\u003e마지막으로 Profiler의 저장 아이콘을 사용하여 추적을 내보낸 다음 Perfetto Web UI로 가져오세요\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e퍼페토에 추적 파일을 로드하면 화면에 수많은 색상이 나타나더라도 놀라지 마세요. 그 모든 것을 다룰 필요는 없습니다.\u003c/p\u003e\n\u003ch1\u003e4.1 퍼페토에서 시작 시간 지표 찾기\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e“startup”을 검색하면 앱 시작 시간의 시각화를 볼 수 있습니다. 초록 막대를 클릭한 후 키보드에서 ‘M’을 누르세요. 이렇게 하면 그 막대의 시작과 끝을 표시할 수 있습니다. 지금은 이에만 집중하고 나머지는 그냥 잡음입니다.\u003c/p\u003e\n\u003ch1\u003e4.2 원인을 찾아보세요\u003c/h1\u003e\n\u003cp\u003e지금 시작 시간 막대 아래에 패키지 이름을 찾아 확장하세요. 그래프의 표시된 영역에만 집중하고 메인 스레드를 보세요. x축에 각 함수의 지속 시간이 나올 것이며, y축에 중첩된 막대가 있는 경우 중첩된 함수를 의미합니다.\u003c/p\u003e\n\u003cp\u003e먼저 수평으로 긴 막대부터 살펴보세요. 그 막대가 가장 많이 소요된 시간을 나타낼 것입니다. 예상보다 시간이 더 많이 소요된 함수가 어떤 것인지 확인하고 기록해보세요. 그런 다음 상위 4~5개의 주범을 최적화할 수 있을 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_4.png\" alt=\"그래프\"\u003e\u003c/p\u003e\n\u003cp\u003e프레임은 16밀리초 내에 렌더링되어야 60fps를 달성할 수 있어요\u003c/p\u003e\n\u003cp\u003e팁: WASD 키를 사용하여 이동하세요. perfetto UI에 대해 더 읽고 싶다면 여기를 확인해보세요. 문서는 약간 오래되었지만 핵심 원칙은 같아요.\u003c/p\u003e\n\u003ch1\u003e5. 토끼굴에 들어가다\u003c/h1\u003e\n\u003cp\u003e긴 지속 시간을 가진 함수들이 있을 수 있지만 결과물이 없을 수도 있어요.\u003c/p\u003e\n\u003cp\u003e저기요, 이 BaseActivity의 onResume() 메서드가 엄청 길어요. 하지만 이 그래프만으로는 무엇이 시간을 차지하는지 알 수 없어요.\u003c/p\u003e\n\u003cp\u003e마지막 부분에야 전체 시간의 1/4를 차지하는 중첩 함수가 보이네요.\u003c/p\u003e\n\u003cp\u003e그럼 이제 어떻게 해볼까요?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e트레이싱을 더 추가해야 돼요. 자바 및 코틀린에서 사용 가능한 트레이싱 라이브러리로 쉽게 할 수 있어요. 자세한 내용은 여기를 참조할 수 있지만 코드 일부를 살펴봐요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyClass\u003c/span\u003e {\n  fun \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003epika: \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003etrace\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"MyClass.foo\"\u003c/span\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 기존의 함수 로직이 여기에 있어요...\u003c/span\u003e\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 MyClass.foo가 Perfetto에 나타날 거예요. 따라서 디버그 중인 함수 내 모든 중첩 함수에 대한 트레이싱을 추가한 후 트레이스를 다시 기록하고 Perfetto에서 분석해보세요. 각 라이프사이클 함수에 대해 이 과정을 계속 반복하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e6. 우리의 솔루션\u003c/h1\u003e\n\u003cp\u003e이 연습을 통해 매우 명확한 근본 원인과 목표를 얻었습니다. 이제 각 원인을 하나씩 해결할 때가 왔습니다. Perfetto와 SysTrace의 관측을 바탕으로 다음과 같은 다양한 최적화가 실행되었습니다:\u003c/p\u003e\n\u003ch2\u003e6.1. 홈 화면 레이아웃 최적화 (-15% 시작 시간)\u003c/h2\u003e\n\u003cp\u003eConstraintLayout으로 뷰를 중첩하지 않고 hidden views 대신 viewstubs를 사용하여 최대 600ms까지 감소하였습니다. 이 접근 방식은 기본적으로 숨겨져 있고 사용자 상호작용 후에만 표시되는 뷰의 불필요한 측정 및 확장을 방지합니다. view stubs에 대해 더 알아보기.\u003c/p\u003e\n\u003cp\u003e200~300 밀리초가 걸리는 mapView가 onResume()이 호출된 후에 init으로 이동되었기 때문에 핵심 UI에서 주문 수와 상태를 표시한 후에 로드됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eprivate fun \u003cspan class=\"hljs-title class_\"\u003eHomeFragment\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elazyLoadMap\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title class_\"\u003eHandler\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eLooper\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetMainLooper\u003c/span\u003e()).\u003cspan class=\"hljs-property\"\u003epost\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 이 Runnable은 메인 스레드가 HomeFrag를 확장한 후에만 실행됩니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003einitMap\u003c/span\u003e()\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e6.2 MainActivity 최적화하기 (-5% 시작 시간)\u003c/h1\u003e\n\u003cp\u003e반복된 성능 테스트에서 LinearLayout이 Fragment에 대한 컨테이너로만 사용되는 MainActivity에서 ConstraintLayout보다 성능이 더 우수했습니다. 실제로 LinearLayout으로 변경하면 MainActivity가 특히 웜 스타트에서 2배 더 빨리 시작되었습니다.\u003c/p\u003e\n\u003ch2\u003e6.3 MainActivity SDK들의 지연 로딩(-10% 시간)\u003c/h2\u003e\n\u003cp\u003e퍼페토는 MainActivity에서 초기화되는 단일 3rd party SDK가 onCreate() 지속 시간의 70%를 차지하고 있다는 것을 보여주었습니다. 우리는 앱 시작 시 즉시 필요하지 않았기 때문에 백그라운드에서 이를 지연로딩하기 시작했습니다.\u003c/p\u003e\n\u003ch2\u003e7. 실제 성능 결과\u003c/h2\u003e\n\u003cp\u003e이러한 솔루션을 여러 릴리스를 통해 출시한 뒤, 시작 시간의 90분위가 3.5초에서 거의 2초 미만으로 점진적으로 개선되어, 놀라운 42%의 감소를 보았습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_7.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e더 많은 병목 현상을 찾고 앱 속도를 높이는 데 노력하고 있습니다. 이를 통해 파트너들이 더 생산적일 수 있도록 돕고 있습니다.\u003c/p\u003e\n\u003cp\u003e프레펫토를 사용하여 병목 현상을 발견하는 것은이 프로젝트에 있어 중요했으며, 각 문제를 해결함으로써 얼마나 많은 성능 향상을 이끌어낼 수 있는지를 알기에 자신감을 갖게 되었습니다.\u003c/p\u003e\n\u003cp\u003e앱 시작 시간을 개선하는 데 도움을 준 Burhan \u0026#x26; Vishnu에게 감사드립니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-MakingShadowfaxAndroidApp40faster"},"buildId":"o1YmnmSuZvAX2O4TI9r41","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>