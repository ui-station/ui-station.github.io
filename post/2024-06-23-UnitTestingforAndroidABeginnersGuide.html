<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>안드로이드 유닛 테스트 101 초보자를 위한 가이드 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-23-UnitTestingforAndroidABeginnersGuide" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="안드로이드 유닛 테스트 101 초보자를 위한 가이드 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="안드로이드 유닛 테스트 101 초보자를 위한 가이드 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-23-UnitTestingforAndroidABeginnersGuide" data-gatsby-head="true"/><meta name="twitter:title" content="안드로이드 유닛 테스트 101 초보자를 위한 가이드 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 20:57" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_buildManifest.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">안드로이드 유닛 테스트 101 초보자를 위한 가이드</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="안드로이드 유닛 테스트 101 초보자를 위한 가이드" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-UnitTestingforAndroidABeginnersGuide&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>유닛 테스트는 소프트웨어 개발의 중요한 단계입니다. 이것은 Test Driven Development (TDD)라고 불리는 개발 패러다임을 가져옵니다. 이러한 테스트는 일반적으로 애플리케이션의 비즈니스 로직을 테스트합니다.</p>
<h1>왜 우리는 유닛 테스트를 작성할까요?</h1>
<ul>
<li>우리는 실수를 할 수 있습니다.</li>
<li>우리의 코드가 작동되기를 원합니다.</li>
<li>더 빠르게 개발하고 더 많은 확신과 더 적은 회귀를 가지기를 원합니다.</li>
</ul>
<p>안드로이드 및 일반적으로 다양한 모바일 플랫폼에서 앱 테스트는 어려울 수 있습니다. 유닛 테스트를 구현하고 테스트 주도 개발(TDD)의 원칙을 따르는 것은 종종 직관에 어긋날 수 있습니다. 그럼에도 불구하고 테스트는 중요하며 당연하게 여기거나 무시해서는 안 됩니다.</p>
<p></p>
<p>한 번 유닛 테스트의 기본 사항으로 이동해 보죠. 안드로이드에서 유당 테스트라고 하면 떠오르는 몇 가지 기본 사항부터 시작해보겠습니다.</p>
<h1>패키지 구조</h1>
<p>새로운 안드로이드 프로젝트를 생성하면 기본적으로 다음 세 가지 소스 세트를 얻게 됩니다. 이들은 다음과 같습니다:</p>
<p><img src="/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_0.png" alt="Unit Testing for Android - A Beginner&#x27;s Guide"></p>
<p></p>
<ul>
<li>main: 앱 코드가 포함되어 있습니다.</li>
<li>androidTest: 인스트루먼티드 테스트로 알려진 테스트가 포함되어 있습니다.</li>
<li>test: 로컬 테스트로 알려진 테스트가 포함되어 있습니다.</li>
</ul>
<p>로컬 테스트와 인스트루먼티드 테스트의 차이점은 실행되는 방식에 있습니다.</p>
<h1>로컬 테스트 (test 소스 세트)</h1>
<p>이러한 테스트는 개발 컴퓨터의 JVM에서 로컬로 실행되며 에뮬레이터나 물리적 장치가 필요하지 않습니다. 이로 인해 실행 속도가 빠르지만, 신뢰성은 낮아 실제와 다르게 동작할 수 있습니다.</p>
<p></p>
<h1>Instrumented tests (androidTest source set)</h1>
<p>이러한 테스트는 실제 또는 에뮬레이션된 Android 장치에서 실행되므로 실제 세계에서 발생할 사항을 반영하지만 훨씬 느립니다.</p>
<h1>Test runner</h1>
<p>테스트 실행기는 테스트를 실행하는 JUnit 구성 요소입니다. 테스트 실행기가 없으면 테스트가 실행되지 않습니다. JUnit에서는 자동으로 제공되는 기본 테스트 실행기가 있습니다.</p>
<p></p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Android</span> <span class="hljs-title class_">Studio</span>를 사용하면 클래스를 테스트하는 테스트를 생성할 수 있는 도구를 제공합니다. 테스트할 클래스를 마우스 오른쪽 버튼으로 클릭하고 <span class="hljs-title class_">Generate</span> <span class="hljs-string">` Test를 선택하세요.

&#x3C;img src="/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_1.png" />

Test를 클릭한 후에는 Test 클래스를 생성할 수 있습니다.
</span></code></pre>
<p></p>
<p><img src="/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_2.png" alt="이미지"></p>
<p>테스트 클래스에서 사용하는 몇 가지 주석을 살펴봅시다.</p>
<ul>
<li>@Test: 이 주석은 메서드를 테스트 케이스로 표시하는 데 사용됩니다. @Test 주석은 Java 컴파일러에게 클래스를 컴파일할 때 메서드를 테스트 케이스로 실행하도록 알려줍니다.</li>
<li>@Before: 이 주석은 메서드를 설정 메서드로 표시하는 데 사용됩니다. @Before 주석은 Java 컴파일러에게 클래스의 각 테스트 케이스 전에 메서드를 실행하도록 알려줍니다. 각 테스트 케이스가 실행되기 전에 테스트 환경을 설정하는 데 유용합니다.</li>
<li>@After: 이 주석은 메서드를 소멸 메서드로 표시하는 데 사용됩니다. @After 주석은 Java 컴파일러에게 클래스의 각 테스트 케이스 후에 메서드를 실행하도록 알려줍니다. 각 테스트 케이스가 실행된 후 테스트 환경을 정리하는 데 유용합니다.</li>
<li>@Ignore: 이 주석은 메서드를 무시된 테스트 케이스로 표시하는 데 사용됩니다. @Ignore 주석은 Java 컴파일러에게 메서드를 테스트 케이스로 실행하지 말도록 알려줍니다. 아직 실행할 준비가 안 된 테스트 케이스를 일시적으로 무시하는 데 유용합니다.</li>
</ul>
<p>단언문은 테스트의 핵심입니다. 코드 문장으로, 코드나 앱이 예상대로 작동했는지 확인합니다. 이 경우, 단언문은 assertEquals(4, 2 + 2)로 4가 2 + 2와 같은지를 확인합니다.</p>
<p></p>
<h1>테스트 전략</h1>
<p>가독성이 좋은 테스트를 작성하는 몇 가지 다른 전략이 있습니다. 방금 작성한 테스트에서 이 두 가지 전략이 모두 보여집니다.</p>
<h2>주어진 상황, When, Then</h2>
<p>테스트의 구조를 생각하는 한 가지 방법은 주어진 상황, When, Then 테스트 니모닉을 따르는 것입니다. 이를 통해 테스트를 세 부분으로 나눌 수 있습니다:</p>
<p></p>
<ul>
<li>주어진: 테스트에 필요한 객체 및 앱 상태를 설정하십시오. 이 테스트에서 "주어진" 부분이 무엇인가요.</li>
<li>실행: 테스트 중인 객체에 대해 실제로 작업을 수행하십시오.</li>
<li>결과: 이 부분은 실제로 작업을 수행할 때 일어나는 일을 확인하는 곳으로, 테스트가 통과했는지 실패했는지 확인합니다. 보통 여러 assert 함수 호출이 포함됩니다.</li>
</ul>
<p>주의해 주실 점은 "준비, 실행, 확인" (AAA) 테스트 니모닉이 유사한 개념이라는 것입니다.</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Test</span>
fun <span class="hljs-title function_">getUserProfile_givenUserId_returnUser</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 주어진</span>
    val userId = <span class="hljs-number">1</span>
    val user = <span class="hljs-title class_">User</span>(userId,<span class="hljs-string">""</span>,<span class="hljs-string">"TestUser"</span>)
    <span class="hljs-comment">// 실행</span>
    <span class="hljs-title function_">doReturn</span>(<span class="hljs-title class_">Observable</span>.<span class="hljs-title function_">just</span>(user)).<span class="hljs-string">`when`</span>(webservice).<span class="hljs-title function_">getMyProfile</span>(userId)
    presenter.<span class="hljs-title function_">getUserProfile</span>(<span class="hljs-title function_">anyString</span>())
    <span class="hljs-comment">// 결과</span>
    <span class="hljs-title function_">verify</span>(profileView).<span class="hljs-title function_">render</span>(<span class="hljs-title class_">ProfileState</span>.<span class="hljs-title class_">DataState</span>(user))
}
</code></pre>
<h1>종속성 구성</h1>
<p></p>
<p>일반적으로 종속성을 추가할 때 구현을 사용합니다. 앱을 세계와 공유할 준비가 되면, 테스트 코드나 앱의 종속성을 APK의 크기를 부풀리지 않는 것이 가장 좋습니다. Gradle 구성을 사용하여 라이브러리가 주 코드 또는 테스트 코드에 포함되어야 하는지 지정할 수 있습니다.</p>
<p>가장 일반적인 구성은 다음과 같습니다:</p>
<ul>
<li>implementation—이 종속성은 테스트 소스 세트를 포함한 모든 소스 세트에서 사용할 수 있습니다.</li>
<li>testImplementation—이 종속성은 테스트 소스 세트에서만 사용할 수 있습니다.</li>
<li>androidTestImplementation—이 종속성은 androidTest 소스 세트에서만 사용할 수 있습니다.</li>
</ul>
<h1>테스트 더블들</h1>
<p></p>
<p>이 문제의 해결책은 리포지토리를 테스트할 때 실제 네트워킹 또는 데이터베이스 코드를 사용하지 말고 대신 테스트 더블을 사용해야 합니다. 테스트 더블은 테스트를 위해 특별히 작성된 클래스의 버전을 말합니다. 이것은 테스트에서 사용되는 클래스의 실제 버전을 대체하는 것을 목적으로 합니다. 이는 스턴트 배우가 위험한 액션을 대신하는 것처럼 테스트 더블이 스턴트에 특화된 배우인 것과 유사합니다.</p>
<p>다음은 일부 테스트 더블의 유형입니다:</p>
<h2>가짜(Fake)</h2>
<p>클래스의 "작동" 구현을 갖는 테스트 더블이지만 테스트에는 적합하지만 프로덕션에는 적합하지 않은 방식으로 구현되어 있습니다.</p>
<p></p>
<h2>목</h2>
<p>호출된 메소드를 추적하는 테스트 더블(Mock)입니다. 그런 다음 메소드가 올바르게 호출되었는지에 따라 테스트를 통과하거나 실패합니다. 객체를 모의(Mock)하면 해당 클래스의 빈 구현이 생성됩니다.</p>
<h1>네이밍 규칙</h1>
<p>테스트의 이름은 해당 테스트가 무엇을 하는지 이해하는 데 도움이 되어야 합니다. 네이밍 규칙은 다음과 같이 보여야 합니다:</p>
<p></p>
<p><strong>subjectUnderTest_actionOrInput_resultState</strong></p>
<ul>
<li>Subject under test is the method or class that is being tested (getUserProfile).</li>
<li>Next is the action or input (givenUserId).</li>
<li>Finally you have the expected result (returnUser).</li>
</ul>
<p><strong>Pro Tip</strong></p>
<p>When you have repeated setup code for multiple tests, you can use the @Before annotation to create a setup method and remove repeated code.</p>
<p></p>
<p>이 기사를 읽어 주셔서 감사합니다. 도움이 되었다면 아래 👏을 클릭해서 기사를 칭찬해주세요. 제게 매우 큰 의미가 됩니다. 댓글이나 트위터, 링크드인을 통해 연락 주시면 감사하겠습니다. 코딩 즐기시고 즐거운 시간 보내세요!</p>
<p>커피 사주세요 ☕</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"안드로이드 유닛 테스트 101 초보자를 위한 가이드","description":"","date":"2024-06-23 20:57","slug":"2024-06-23-UnitTestingforAndroidABeginnersGuide","content":"\n유닛 테스트는 소프트웨어 개발의 중요한 단계입니다. 이것은 Test Driven Development (TDD)라고 불리는 개발 패러다임을 가져옵니다. 이러한 테스트는 일반적으로 애플리케이션의 비즈니스 로직을 테스트합니다.\n\n# 왜 우리는 유닛 테스트를 작성할까요?\n\n- 우리는 실수를 할 수 있습니다.\n- 우리의 코드가 작동되기를 원합니다.\n- 더 빠르게 개발하고 더 많은 확신과 더 적은 회귀를 가지기를 원합니다.\n\n안드로이드 및 일반적으로 다양한 모바일 플랫폼에서 앱 테스트는 어려울 수 있습니다. 유닛 테스트를 구현하고 테스트 주도 개발(TDD)의 원칙을 따르는 것은 종종 직관에 어긋날 수 있습니다. 그럼에도 불구하고 테스트는 중요하며 당연하게 여기거나 무시해서는 안 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 번 유닛 테스트의 기본 사항으로 이동해 보죠. 안드로이드에서 유당 테스트라고 하면 떠오르는 몇 가지 기본 사항부터 시작해보겠습니다.\n\n# 패키지 구조\n\n새로운 안드로이드 프로젝트를 생성하면 기본적으로 다음 세 가지 소스 세트를 얻게 됩니다. 이들은 다음과 같습니다:\n\n![Unit Testing for Android - A Beginner's Guide](/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- main: 앱 코드가 포함되어 있습니다.\n- androidTest: 인스트루먼티드 테스트로 알려진 테스트가 포함되어 있습니다.\n- test: 로컬 테스트로 알려진 테스트가 포함되어 있습니다.\n\n로컬 테스트와 인스트루먼티드 테스트의 차이점은 실행되는 방식에 있습니다.\n\n# 로컬 테스트 (test 소스 세트)\n\n이러한 테스트는 개발 컴퓨터의 JVM에서 로컬로 실행되며 에뮬레이터나 물리적 장치가 필요하지 않습니다. 이로 인해 실행 속도가 빠르지만, 신뢰성은 낮아 실제와 다르게 동작할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Instrumented tests (androidTest source set)\n\n이러한 테스트는 실제 또는 에뮬레이션된 Android 장치에서 실행되므로 실제 세계에서 발생할 사항을 반영하지만 훨씬 느립니다.\n\n# Test runner\n\n테스트 실행기는 테스트를 실행하는 JUnit 구성 요소입니다. 테스트 실행기가 없으면 테스트가 실행되지 않습니다. JUnit에서는 자동으로 제공되는 기본 테스트 실행기가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nAndroid Studio를 사용하면 클래스를 테스트하는 테스트를 생성할 수 있는 도구를 제공합니다. 테스트할 클래스를 마우스 오른쪽 버튼으로 클릭하고 Generate ` Test를 선택하세요.\n\n\u003cimg src=\"/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_1.png\" /\u003e\n\nTest를 클릭한 후에는 Test 클래스를 생성할 수 있습니다.\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_2.png)\n\n테스트 클래스에서 사용하는 몇 가지 주석을 살펴봅시다.\n\n- @Test: 이 주석은 메서드를 테스트 케이스로 표시하는 데 사용됩니다. @Test 주석은 Java 컴파일러에게 클래스를 컴파일할 때 메서드를 테스트 케이스로 실행하도록 알려줍니다.\n- @Before: 이 주석은 메서드를 설정 메서드로 표시하는 데 사용됩니다. @Before 주석은 Java 컴파일러에게 클래스의 각 테스트 케이스 전에 메서드를 실행하도록 알려줍니다. 각 테스트 케이스가 실행되기 전에 테스트 환경을 설정하는 데 유용합니다.\n- @After: 이 주석은 메서드를 소멸 메서드로 표시하는 데 사용됩니다. @After 주석은 Java 컴파일러에게 클래스의 각 테스트 케이스 후에 메서드를 실행하도록 알려줍니다. 각 테스트 케이스가 실행된 후 테스트 환경을 정리하는 데 유용합니다.\n- @Ignore: 이 주석은 메서드를 무시된 테스트 케이스로 표시하는 데 사용됩니다. @Ignore 주석은 Java 컴파일러에게 메서드를 테스트 케이스로 실행하지 말도록 알려줍니다. 아직 실행할 준비가 안 된 테스트 케이스를 일시적으로 무시하는 데 유용합니다.\n\n단언문은 테스트의 핵심입니다. 코드 문장으로, 코드나 앱이 예상대로 작동했는지 확인합니다. 이 경우, 단언문은 assertEquals(4, 2 + 2)로 4가 2 + 2와 같은지를 확인합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 테스트 전략\n\n가독성이 좋은 테스트를 작성하는 몇 가지 다른 전략이 있습니다. 방금 작성한 테스트에서 이 두 가지 전략이 모두 보여집니다.\n\n## 주어진 상황, When, Then\n\n테스트의 구조를 생각하는 한 가지 방법은 주어진 상황, When, Then 테스트 니모닉을 따르는 것입니다. 이를 통해 테스트를 세 부분으로 나눌 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 주어진: 테스트에 필요한 객체 및 앱 상태를 설정하십시오. 이 테스트에서 \"주어진\" 부분이 무엇인가요.\n- 실행: 테스트 중인 객체에 대해 실제로 작업을 수행하십시오.\n- 결과: 이 부분은 실제로 작업을 수행할 때 일어나는 일을 확인하는 곳으로, 테스트가 통과했는지 실패했는지 확인합니다. 보통 여러 assert 함수 호출이 포함됩니다.\n\n주의해 주실 점은 \"준비, 실행, 확인\" (AAA) 테스트 니모닉이 유사한 개념이라는 것입니다.\n\n```js\n@Test\nfun getUserProfile_givenUserId_returnUser() {\n    // 주어진\n    val userId = 1\n    val user = User(userId,\"\",\"TestUser\")\n    // 실행\n    doReturn(Observable.just(user)).`when`(webservice).getMyProfile(userId)\n    presenter.getUserProfile(anyString())\n    // 결과\n    verify(profileView).render(ProfileState.DataState(user))\n}\n```\n\n# 종속성 구성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적으로 종속성을 추가할 때 구현을 사용합니다. 앱을 세계와 공유할 준비가 되면, 테스트 코드나 앱의 종속성을 APK의 크기를 부풀리지 않는 것이 가장 좋습니다. Gradle 구성을 사용하여 라이브러리가 주 코드 또는 테스트 코드에 포함되어야 하는지 지정할 수 있습니다.\n\n가장 일반적인 구성은 다음과 같습니다:\n\n- implementation—이 종속성은 테스트 소스 세트를 포함한 모든 소스 세트에서 사용할 수 있습니다.\n- testImplementation—이 종속성은 테스트 소스 세트에서만 사용할 수 있습니다.\n- androidTestImplementation—이 종속성은 androidTest 소스 세트에서만 사용할 수 있습니다.\n\n# 테스트 더블들\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 문제의 해결책은 리포지토리를 테스트할 때 실제 네트워킹 또는 데이터베이스 코드를 사용하지 말고 대신 테스트 더블을 사용해야 합니다. 테스트 더블은 테스트를 위해 특별히 작성된 클래스의 버전을 말합니다. 이것은 테스트에서 사용되는 클래스의 실제 버전을 대체하는 것을 목적으로 합니다. 이는 스턴트 배우가 위험한 액션을 대신하는 것처럼 테스트 더블이 스턴트에 특화된 배우인 것과 유사합니다.\n\n다음은 일부 테스트 더블의 유형입니다:\n\n## 가짜(Fake)\n\n클래스의 \"작동\" 구현을 갖는 테스트 더블이지만 테스트에는 적합하지만 프로덕션에는 적합하지 않은 방식으로 구현되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 목\n\n호출된 메소드를 추적하는 테스트 더블(Mock)입니다. 그런 다음 메소드가 올바르게 호출되었는지에 따라 테스트를 통과하거나 실패합니다. 객체를 모의(Mock)하면 해당 클래스의 빈 구현이 생성됩니다.\n\n# 네이밍 규칙\n\n테스트의 이름은 해당 테스트가 무엇을 하는지 이해하는 데 도움이 되어야 합니다. 네이밍 규칙은 다음과 같이 보여야 합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**subjectUnderTest_actionOrInput_resultState**\n\n- Subject under test is the method or class that is being tested (getUserProfile).\n- Next is the action or input (givenUserId).\n- Finally you have the expected result (returnUser).\n\n**Pro Tip**\n\nWhen you have repeated setup code for multiple tests, you can use the @Before annotation to create a setup method and remove repeated code.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사를 읽어 주셔서 감사합니다. 도움이 되었다면 아래 👏을 클릭해서 기사를 칭찬해주세요. 제게 매우 큰 의미가 됩니다. 댓글이나 트위터, 링크드인을 통해 연락 주시면 감사하겠습니다. 코딩 즐기시고 즐거운 시간 보내세요!\n\n커피 사주세요 ☕\n","ogImage":{"url":"/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_0.png"},"coverImage":"/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e유닛 테스트는 소프트웨어 개발의 중요한 단계입니다. 이것은 Test Driven Development (TDD)라고 불리는 개발 패러다임을 가져옵니다. 이러한 테스트는 일반적으로 애플리케이션의 비즈니스 로직을 테스트합니다.\u003c/p\u003e\n\u003ch1\u003e왜 우리는 유닛 테스트를 작성할까요?\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e우리는 실수를 할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e우리의 코드가 작동되기를 원합니다.\u003c/li\u003e\n\u003cli\u003e더 빠르게 개발하고 더 많은 확신과 더 적은 회귀를 가지기를 원합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e안드로이드 및 일반적으로 다양한 모바일 플랫폼에서 앱 테스트는 어려울 수 있습니다. 유닛 테스트를 구현하고 테스트 주도 개발(TDD)의 원칙을 따르는 것은 종종 직관에 어긋날 수 있습니다. 그럼에도 불구하고 테스트는 중요하며 당연하게 여기거나 무시해서는 안 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e한 번 유닛 테스트의 기본 사항으로 이동해 보죠. 안드로이드에서 유당 테스트라고 하면 떠오르는 몇 가지 기본 사항부터 시작해보겠습니다.\u003c/p\u003e\n\u003ch1\u003e패키지 구조\u003c/h1\u003e\n\u003cp\u003e새로운 안드로이드 프로젝트를 생성하면 기본적으로 다음 세 가지 소스 세트를 얻게 됩니다. 이들은 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_0.png\" alt=\"Unit Testing for Android - A Beginner\u0026#x27;s Guide\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emain: 앱 코드가 포함되어 있습니다.\u003c/li\u003e\n\u003cli\u003eandroidTest: 인스트루먼티드 테스트로 알려진 테스트가 포함되어 있습니다.\u003c/li\u003e\n\u003cli\u003etest: 로컬 테스트로 알려진 테스트가 포함되어 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e로컬 테스트와 인스트루먼티드 테스트의 차이점은 실행되는 방식에 있습니다.\u003c/p\u003e\n\u003ch1\u003e로컬 테스트 (test 소스 세트)\u003c/h1\u003e\n\u003cp\u003e이러한 테스트는 개발 컴퓨터의 JVM에서 로컬로 실행되며 에뮬레이터나 물리적 장치가 필요하지 않습니다. 이로 인해 실행 속도가 빠르지만, 신뢰성은 낮아 실제와 다르게 동작할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003eInstrumented tests (androidTest source set)\u003c/h1\u003e\n\u003cp\u003e이러한 테스트는 실제 또는 에뮬레이션된 Android 장치에서 실행되므로 실제 세계에서 발생할 사항을 반영하지만 훨씬 느립니다.\u003c/p\u003e\n\u003ch1\u003eTest runner\u003c/h1\u003e\n\u003cp\u003e테스트 실행기는 테스트를 실행하는 JUnit 구성 요소입니다. 테스트 실행기가 없으면 테스트가 실행되지 않습니다. JUnit에서는 자동으로 제공되는 기본 테스트 실행기가 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eAndroid\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStudio\u003c/span\u003e를 사용하면 클래스를 테스트하는 테스트를 생성할 수 있는 도구를 제공합니다. 테스트할 클래스를 마우스 오른쪽 버튼으로 클릭하고 \u003cspan class=\"hljs-title class_\"\u003eGenerate\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e` Test를 선택하세요.\n\n\u0026#x3C;img src=\"/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_1.png\" /\u003e\n\nTest를 클릭한 후에는 Test 클래스를 생성할 수 있습니다.\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e테스트 클래스에서 사용하는 몇 가지 주석을 살펴봅시다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e@Test: 이 주석은 메서드를 테스트 케이스로 표시하는 데 사용됩니다. @Test 주석은 Java 컴파일러에게 클래스를 컴파일할 때 메서드를 테스트 케이스로 실행하도록 알려줍니다.\u003c/li\u003e\n\u003cli\u003e@Before: 이 주석은 메서드를 설정 메서드로 표시하는 데 사용됩니다. @Before 주석은 Java 컴파일러에게 클래스의 각 테스트 케이스 전에 메서드를 실행하도록 알려줍니다. 각 테스트 케이스가 실행되기 전에 테스트 환경을 설정하는 데 유용합니다.\u003c/li\u003e\n\u003cli\u003e@After: 이 주석은 메서드를 소멸 메서드로 표시하는 데 사용됩니다. @After 주석은 Java 컴파일러에게 클래스의 각 테스트 케이스 후에 메서드를 실행하도록 알려줍니다. 각 테스트 케이스가 실행된 후 테스트 환경을 정리하는 데 유용합니다.\u003c/li\u003e\n\u003cli\u003e@Ignore: 이 주석은 메서드를 무시된 테스트 케이스로 표시하는 데 사용됩니다. @Ignore 주석은 Java 컴파일러에게 메서드를 테스트 케이스로 실행하지 말도록 알려줍니다. 아직 실행할 준비가 안 된 테스트 케이스를 일시적으로 무시하는 데 유용합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e단언문은 테스트의 핵심입니다. 코드 문장으로, 코드나 앱이 예상대로 작동했는지 확인합니다. 이 경우, 단언문은 assertEquals(4, 2 + 2)로 4가 2 + 2와 같은지를 확인합니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003e테스트 전략\u003c/h1\u003e\n\u003cp\u003e가독성이 좋은 테스트를 작성하는 몇 가지 다른 전략이 있습니다. 방금 작성한 테스트에서 이 두 가지 전략이 모두 보여집니다.\u003c/p\u003e\n\u003ch2\u003e주어진 상황, When, Then\u003c/h2\u003e\n\u003cp\u003e테스트의 구조를 생각하는 한 가지 방법은 주어진 상황, When, Then 테스트 니모닉을 따르는 것입니다. 이를 통해 테스트를 세 부분으로 나눌 수 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e주어진: 테스트에 필요한 객체 및 앱 상태를 설정하십시오. 이 테스트에서 \"주어진\" 부분이 무엇인가요.\u003c/li\u003e\n\u003cli\u003e실행: 테스트 중인 객체에 대해 실제로 작업을 수행하십시오.\u003c/li\u003e\n\u003cli\u003e결과: 이 부분은 실제로 작업을 수행할 때 일어나는 일을 확인하는 곳으로, 테스트가 통과했는지 실패했는지 확인합니다. 보통 여러 assert 함수 호출이 포함됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e주의해 주실 점은 \"준비, 실행, 확인\" (AAA) 테스트 니모닉이 유사한 개념이라는 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e\nfun \u003cspan class=\"hljs-title function_\"\u003egetUserProfile_givenUserId_returnUser\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 주어진\u003c/span\u003e\n    val userId = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n    val user = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(userId,\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"TestUser\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-comment\"\u003e// 실행\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003edoReturn\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejust\u003c/span\u003e(user)).\u003cspan class=\"hljs-string\"\u003e`when`\u003c/span\u003e(webservice).\u003cspan class=\"hljs-title function_\"\u003egetMyProfile\u003c/span\u003e(userId)\n    presenter.\u003cspan class=\"hljs-title function_\"\u003egetUserProfile\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eanyString\u003c/span\u003e())\n    \u003cspan class=\"hljs-comment\"\u003e// 결과\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003everify\u003c/span\u003e(profileView).\u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eProfileState\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eDataState\u003c/span\u003e(user))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e종속성 구성\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e일반적으로 종속성을 추가할 때 구현을 사용합니다. 앱을 세계와 공유할 준비가 되면, 테스트 코드나 앱의 종속성을 APK의 크기를 부풀리지 않는 것이 가장 좋습니다. Gradle 구성을 사용하여 라이브러리가 주 코드 또는 테스트 코드에 포함되어야 하는지 지정할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e가장 일반적인 구성은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eimplementation—이 종속성은 테스트 소스 세트를 포함한 모든 소스 세트에서 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003etestImplementation—이 종속성은 테스트 소스 세트에서만 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003eandroidTestImplementation—이 종속성은 androidTest 소스 세트에서만 사용할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e테스트 더블들\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e이 문제의 해결책은 리포지토리를 테스트할 때 실제 네트워킹 또는 데이터베이스 코드를 사용하지 말고 대신 테스트 더블을 사용해야 합니다. 테스트 더블은 테스트를 위해 특별히 작성된 클래스의 버전을 말합니다. 이것은 테스트에서 사용되는 클래스의 실제 버전을 대체하는 것을 목적으로 합니다. 이는 스턴트 배우가 위험한 액션을 대신하는 것처럼 테스트 더블이 스턴트에 특화된 배우인 것과 유사합니다.\u003c/p\u003e\n\u003cp\u003e다음은 일부 테스트 더블의 유형입니다:\u003c/p\u003e\n\u003ch2\u003e가짜(Fake)\u003c/h2\u003e\n\u003cp\u003e클래스의 \"작동\" 구현을 갖는 테스트 더블이지만 테스트에는 적합하지만 프로덕션에는 적합하지 않은 방식으로 구현되어 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e목\u003c/h2\u003e\n\u003cp\u003e호출된 메소드를 추적하는 테스트 더블(Mock)입니다. 그런 다음 메소드가 올바르게 호출되었는지에 따라 테스트를 통과하거나 실패합니다. 객체를 모의(Mock)하면 해당 클래스의 빈 구현이 생성됩니다.\u003c/p\u003e\n\u003ch1\u003e네이밍 규칙\u003c/h1\u003e\n\u003cp\u003e테스트의 이름은 해당 테스트가 무엇을 하는지 이해하는 데 도움이 되어야 합니다. 네이밍 규칙은 다음과 같이 보여야 합니다:\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003esubjectUnderTest_actionOrInput_resultState\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSubject under test is the method or class that is being tested (getUserProfile).\u003c/li\u003e\n\u003cli\u003eNext is the action or input (givenUserId).\u003c/li\u003e\n\u003cli\u003eFinally you have the expected result (returnUser).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003ePro Tip\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eWhen you have repeated setup code for multiple tests, you can use the @Before annotation to create a setup method and remove repeated code.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e이 기사를 읽어 주셔서 감사합니다. 도움이 되었다면 아래 👏을 클릭해서 기사를 칭찬해주세요. 제게 매우 큰 의미가 됩니다. 댓글이나 트위터, 링크드인을 통해 연락 주시면 감사하겠습니다. 코딩 즐기시고 즐거운 시간 보내세요!\u003c/p\u003e\n\u003cp\u003e커피 사주세요 ☕\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-UnitTestingforAndroidABeginnersGuide"},"buildId":"bb_yO9GbCvdfc_n71SfUf","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>