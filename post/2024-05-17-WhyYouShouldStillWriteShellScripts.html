<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>쉘 스크립트를 여전히 작성해야 하는 이유 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-17-WhyYouShouldStillWriteShellScripts" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="쉘 스크립트를 여전히 작성해야 하는 이유 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="쉘 스크립트를 여전히 작성해야 하는 이유 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-17-WhyYouShouldStillWriteShellScripts_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-17-WhyYouShouldStillWriteShellScripts" data-gatsby-head="true"/><meta name="twitter:title" content="쉘 스크립트를 여전히 작성해야 하는 이유 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-17-WhyYouShouldStillWriteShellScripts_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-17 18:51" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_buildManifest.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">쉘 스크립트를 여전히 작성해야 하는 이유</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="쉘 스크립트를 여전히 작성해야 하는 이유" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 17, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-17-WhyYouShouldStillWriteShellScripts&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>고전적 접근 방식에 대한 현대적인 사례.</p>
<p><img src="/assets/img/2024-05-17-WhyYouShouldStillWriteShellScripts_0.png" alt="이미지"></p>
<p>솔직히 말해서, grep -o <code>Response Code:.*</code> | cut -f 3 -d <code> </code> | sort | uniq -c | sort -h 3을 지켜보는 것은 고오급한 Kubernetes Operator를 사용하여 일어나는 것만큼 흥미롭지 않습니다. 많은 소프트웨어 전문가들, 시스템 관리자의 건강한 비율을 포함하여 긴 셸 스크립트를 보는 것은 공포와 혼란의 조합으로 인식합니다. 그러나 나는 현대 엔지니어가 갖춰야 할 유용한 기술 중 하나로 셸 스크립트를 편안하게 작성하고 한 줄 기반으로 만드는 능력을 주장합니다.</p>
<p>대학 시절에 스크립팅 수업을 들었습니다. 수업의 처음 몇 주는 Perl로 넘어가기 전에 셸의 기본 사항을 배우는 데 집중했습니다. 우스꽝스럽게도, 지금은 이 매우 같은 강의를 가르치지만 내용은 Perl에서 Python으로 변화했습니다. 불가피하게, 나의 학생들은 저와 같은 어려움을 겪습니다: 셸 구문은 난해하고 혼란스럽고 기억하기 어려운 것들입니다. 그것은 단순히 "오래된" 느낌이 들어서, 첫 번째 셸 스크립트를 작성하는 것은 어둠 속에서 헤매고 있는 것과 같은 느낌입니다.</p>
<p>시간이 흐르면서 저는 쉘을 매우 강력한 기능과 풍부한 역사를 가진 도구로 칭찬하게 되었습니다. 쉘 스크립트를 작성하는 방법을 배우는 것은 아마도 여러분이 익숙한 것과는 다르게 사용자 친화적이지 않을 수도 있습니다. 특히 Python이나 Go와 같은 언어에서 오신 경우에는 더 그렇습니다. 그러나 나는 모두가 쉘 스크립팅 능력을 키우는 데 시간을 쏟는 것이 매우 값진 일이라고 생각합니다.</p>
<p>아래에는 파일을 열 때 #!/bin/bash라는 구문을 보고 신경 쓰이는 경우 고려해 볼 다섯 가지 이유가 있습니다:</p>
<h2>Reason 1: Containers Demand It</h2>
<p>컨테이너는 현재 워크로드를 배포하는 표준 방식입니다. 동의하든 그렇지 않든, 쿠버네티스 열풍에 흔들리지 않았더라도 환경에서 컨테이너화된 워크로드를 배포 중인 가능성은 높습니다.</p>
<p>바이너리 엔트리포인트에 의존하는 컨테이너를 빌드할 수 있지만, 보통 컨테이너는 시작 스크립트를 실행합니다. 이는 실행 시간 구성을 제한하는 기회를 제공합니다. 고품질 쉘 스크립트를 작성하면 컨테이너 엔트리포인트의 품질을 향상시켜 컨테이너 이미지 사용자에게 강력한 실행 시간 구성을 제공할 수 있습니다. 이는 오류 확인부터 자격 증명 또는 구성 매개변수를 자동으로 생성하는 것과 같은 더 복잡한 구성까지 모두 포함됩니다.</p>
<p>게다가: 엔트리포인트 스크립트를 POSIX 쉘(#!/bin/sh)로만 제한하는 방법을 배우면 컨테이너 이미지에서 Bash를 제거하고 그 크기와 공격 표면을 줄일 수 있습니다.</p>
<h1>공식 MariaDB 컨테이너는 623줄의 도커 엔트리포인트 쉘 스크립트를 사용합니다.</h1>
<p>$ podman exec -it mariadb wc -l /usr/local/bin/docker-entrypoint.sh
623 /usr/local/bin/docker-entrypoint.sh</p>
<p>로그 및 추적 프로젝트는 대략 백만 개 정도가 있어요. 왜 그럴까요? 로깅은 도전적입니다, 특히 분산 마이크로서비스 세계에서요. 멋진 추적 도구와 로그 집계 서비스는 훌륭하지만 종종 명령줄에서 찾을 수 있는 그 유연성을 제공하지 못할 때가 많아요. 저는 파이프된 명령어 한 줄을 작성하는 것이 대부분의 로깅 시스템 UI를 헤매는 것보다 빠르다고 생각해요.</p>
<p>GUI를 버리지 않는 것을 추천하지 않아요. 오히려 그게 유용해요. 텍스트 데이터를 그래픽 인터페이스와 명령줄 모두에서 탐색하는 것이 유용하기 때문이죠. 내 전형적인 워크플로우는 로깅 UI(예: 키바나)를 사용하여 관심 있는 로그로 대략적으로 필터링한 다음 로그 메시지를 다운로드하여 쉽게 구문 분석하기 위해 셸 유틸리티를 사용하는 것입니다. 원하는 것을 더 잘 알게 되면 실제 쿼리가 있는 대시보드를 작성하게 될 거예요.</p>
<p>생산 문제를 디버깅할 때도 아마 당신은 당신의 서버나 쿠버네티스 클러스터에 앉아 있을 거예요. 장애 발생 시 분 단위가 중요할 때 몇 번의 키 입력으로 바로 이론을 테스트하는 것이 절대적으로 중요합니다. 문제가 심각해서 로그 수집 자체가 고장났을 수도 있고, 아니면 터미널과 로깅 도구 간의 컨텍스트 전환을 계속할 여유가 없을 수도 있어요. 그 어떤 경우에도, 단순한 한 줄짜리 명령어를 만들어 내는 데 익숙해서 다행할 것입니다.</p>
<p>배우는 곡선은 있지만, 쉘에서 사용 가능한 많은 유틸리티로 편안해지면 쉘 명령어를 사용하여 데이터를 "탐색"하는 것이 훨씬 쉽다는 것을 알게 되실 거예요. 필요한 데이터를 빠르게 반환하는 작은 스크립트 라이브러리를 점차적으로 구축할 수 있을 거예요. 제가 가장 좋아하는 것 중 하나는 제 Nginx 로그를 구문 분석하고 서버를 공격하는 상위 10개 IP 주소를 알려주는 간단한 Bash 한 줄짜리입니다.</p>
<pre><code class="hljs language-js">$ cut -f <span class="hljs-number">1</span> -d <span class="hljs-string">' '</span> /<span class="hljs-keyword">var</span>/log/nginx/access.<span class="hljs-property">log</span> | sort | uniq -c | sort -hr | head -n <span class="hljs-number">10</span>
     <span class="hljs-number">38</span> <span class="hljs-number">65.108</span><span class="hljs-number">.66</span><span class="hljs-number">.11</span>
     <span class="hljs-number">20</span> <span class="hljs-number">91.240</span><span class="hljs-number">.118</span><span class="hljs-number">.252</span>
     <span class="hljs-number">18</span> <span class="hljs-number">194.110</span><span class="hljs-number">.115</span><span class="hljs-number">.68</span>
     <span class="hljs-number">17</span> <span class="hljs-number">3.234</span><span class="hljs-number">.236</span><span class="hljs-number">.64</span>
     <span class="hljs-number">11</span> <span class="hljs-number">190.117</span><span class="hljs-number">.58</span><span class="hljs-number">.32</span>
     <span class="hljs-number">11</span> <span class="hljs-number">172.56</span><span class="hljs-number">.209</span><span class="hljs-number">.241</span>
     <span class="hljs-number">11</span> <span class="hljs-number">165.225</span><span class="hljs-number">.233</span><span class="hljs-number">.21</span>
     <span class="hljs-number">10</span> <span class="hljs-number">95.161</span><span class="hljs-number">.221</span><span class="hljs-number">.0</span>
     <span class="hljs-number">10</span> <span class="hljs-number">85.173</span><span class="hljs-number">.195</span><span class="hljs-number">.175</span>
     <span class="hljs-number">10</span> <span class="hljs-number">37.79</span><span class="hljs-number">.10</span><span class="hljs-number">.45</span>
</code></pre>
<h1>Reason 3: 어떤 (텍스트) 데이터 형식이든</h1>
<p>우리가 일상적으로 다루는 대부분의 데이터는 텍스트 형식입니다: 애플리케이션 데이터, 설정 파일, 로그 메시지 등등. 이러한 데이터나 로그 집계 플랫폼에서 이 데이터를 다루는 것은 데이터의 형식(또는 스키마)에 대해 신중한 고려를 요구합니다. 이는 장기적인 저장 및 검색을 위해 이상적인 선택입니다: 데이터 형식을 이해하는 것은 복잡한 데이터를 효율적으로 저장하고 쿼리하는 데 중요합니다.</p>
<p>하지만 당신은 아마도 데이터를 탐색하는 데 편의를 제공하는 방식으로 빠르고 쉽게 데이터를 다루고 싶어하는 상황에 직면해 본 적이 있을 것입니다. 아직 다루고 있는 데이터의 구조나 형식에 대해 이해하고 있지 않을 수도 있습니다. 이를 이해하려는 과정에 있을 수도 있고, 특정 데이터의 일부를 빠르게 쿼리하거나 변환하고 싶을 수도 있습니다.</p>
<p>쉘(shell)이 빛을 발하는 작업들이에요! 대부분의 쉘 도구들은 텍스트의 구조에 대해 크게 신경 쓰지 않고 원시 텍스트와 직접 작동합니다. 임의로 형식이 지정되지 않은 텍스트 파일에서 모두 dev를 prod로 변경하고 싶다면, 쉘이 도움이 될 거예요. JSON이나 YAML과 같은 구조화된 데이터 형식을 이미 사용하고 있다면, jq나 yq와 같은 도구를 사용해서 이러한 형식과 함께 작업할 수 있어요.</p>
<pre><code class="hljs language-js"># 개발용 구성 파일
$ cat /tmp/sample.<span class="hljs-property">json</span>
{
    <span class="hljs-string">"Environment"</span>: <span class="hljs-string">"dev"</span>,
    <span class="hljs-string">"Database"</span>: {
        <span class="hljs-string">"Host"</span>: <span class="hljs-string">"dev.example.com"</span>
    },
    <span class="hljs-string">"AppName"</span>: <span class="hljs-string">"iot-dev"</span>,
    <span class="hljs-string">"CacheShards"</span>: [
        <span class="hljs-string">"east1-cache-dev-1"</span>,
        <span class="hljs-string">"east1-cache-dev-2"</span>,
        <span class="hljs-string">"east1-cache-dev-3"</span>
    ]
}

# <span class="hljs-title class_">Sed</span>는 <span class="hljs-title class_">JSON</span>, <span class="hljs-variable constant_">YAML</span>, <span class="hljs-variable constant_">XML</span> 또는 다른 형식이든 상관하지 않아요.
# 텍스트이면 됩니다!
$ sed -s <span class="hljs-string">'s/dev/prod/g'</span> /tmp/sample.<span class="hljs-property">json</span>
{
    <span class="hljs-string">"Environment"</span>: <span class="hljs-string">"prod"</span>,
    <span class="hljs-string">"Database"</span>: {
        <span class="hljs-string">"Host"</span>: <span class="hljs-string">"prod.example.com"</span>
    },
    <span class="hljs-string">"AppName"</span>: <span class="hljs-string">"iot-prod"</span>,
    <span class="hljs-string">"CacheShards"</span>: [
        <span class="hljs-string">"east1-cache-prod-1"</span>,
        <span class="hljs-string">"east1-cache-prod-2"</span>,
        <span class="hljs-string">"east1-cache-prod-3"</span>
    ]
}
</code></pre>
<h1>이유 4: 자동화를 지지합니다</h1>
<p>자동화는 소프트웨어 엔지니어부터 운영 전문가에 이르기까지 모두의 책임이에요. 소프트웨어 분야에서 일하고 있다면 이미 자동화의 이점을 잘 알고 있고, 아마도 자동화된 몇 가지 프로세스를 진정으로 자랑스럽게 자동화했을 거예요.</p>
<p>셸 스크립트는 존재하는 자동화 방식 중 가장 일반적이고 간단하며 기본적인 유형 중 하나입니다. Ansible, Puppet, Chef, Kubernetes 및 기타 도구들이 나오기 전에는 셸만 있었습니다. 옛날의 시스템 관리자들은 사용자 관리부터 보안 감사까지 모든 것을 다루기 위해 스크립트를 작성했습니다. 이러한 프로세스를 자동화하기 위해 다른 도구를 배울 필요가 없었기 때문에 셸은 시스템과 상호 작용하는 유일한 방법이었죠.</p>
<p>이러한 형태의 자동화를 이해하는 것은 그저 향수에 젖은 연습을 하는 것 이상입니다. 종종 복잡한 프로세스를 자동화하기 위해서는 간단한 셸 스크립트만으로 충분할 수 있습니다. 게다가 많은 자동화 플랫폼들은 이미 강력한 셸 스크립트의 래퍼일 뿐입니다. 셸 스크립트를 작성하고 읽는 방법을 이해하는 것은 자동화 기초에 대한 더 나은 이해를 제공받게 되며, 복잡한 문제를 간단한 방식으로 해결하는 데 도움이 될 것입니다.</p>
<h1>이유 5: 모든 곳에서 존재하는 기술</h1>
<p>현대 컴퓨팅 세계의 현실은 대부분의 기업이 이종 컴퓨팅 워크로드를 실행한다는 것입니다: 가상 머신, 컨테이너, 물리적 호스트 등이 있습니다. 워크로드는 클라우드, 온프레미스 및 엣지에서 실행됩니다. 우수한 엔지니어들은 이러한 환경을 횡단하여 편안하게 작업할 수 있어서 자신을 다른 사람들과 구분지을 수 있습니다.</p>
<p>하지만 최신 데이터 처리 또는 로그 분석 도구가 없어서 간소화된 컨테이너 애플리케이션 문제 해결에 어려움이 있을 때는 어떻게 해야 할까요? 새로운 팀(또는 직장)으로 옮겨갔을 때 새 역할에서 사용하는 도구체인이 완전히 다를 경우에는 어떻게 해야 할까요?</p>
<p>기본적인 셸 스크립트 작성에 능숙하다면 걱정할 필요가 없습니다. 완전히 다른 환경의 원격 시스템에 로그인하여 로그 데이터를 캡처하거나 자동화된 결함 해결 기능을 동일하게 수행할 수 있습니다. 이런 셸 스크립트를 작성하여 산업 분야에서 계속 발전시키는 경력을 쌓을 수 있습니다. 셸은 시간에 걸쳐 검증되어왔으며, 업계에서의 시간 동안 그것이 성과를 거두는 것을 발견하게 될 것입니다.</p>
<h1>결론</h1>
<p>작은 셸 스크립트도구 상자를 구축하세요. 퇴사할 때 멋진 Kubernetes 오퍼레이터, 놀라운 Kibana 대시보드 또는 멋진 커맨드 라인 도구를 가져갈 수 없을 수도 있습니다. 또한 그것은 간단히 기억에서 재구성하기에 너무 복잡할 수도 있습니다. 그러나 다음 회사에서는 셸이 포함된 시스템이 있을 것이며, 그럼에도 불구하고 당신이 익숙하고 쉽게 어떤 작업이든 수행할 수 있다는 것을 확신할 수 있습니다.</p>
<p>확실하게 말씀드리자면: 쉘 스크립트 작성에는 제약과 도전이 있습니다. 하지만 그에 대한 논의는 다음에 하도록 하죠. 그래도 컨테이너 엔트리포인트를 파헤치는 과정에서 #!/bin/sh를 보게 된다고 두려워하지 마세요. 구문과 스타일에 익숙해지면, 강력한 쉘 스크립트가 소프트웨어 전문가로써 우리의 삶을 더 쉽게 만든다는 점을 감사히 여기게 될 거에요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"쉘 스크립트를 여전히 작성해야 하는 이유","description":"","date":"2024-05-17 18:51","slug":"2024-05-17-WhyYouShouldStillWriteShellScripts","content":"\n\n고전적 접근 방식에 대한 현대적인 사례.\n\n![이미지](/assets/img/2024-05-17-WhyYouShouldStillWriteShellScripts_0.png)\n\n솔직히 말해서, grep -o `Response Code:.*` | cut -f 3 -d ` ` | sort | uniq -c | sort -h 3을 지켜보는 것은 고오급한 Kubernetes Operator를 사용하여 일어나는 것만큼 흥미롭지 않습니다. 많은 소프트웨어 전문가들, 시스템 관리자의 건강한 비율을 포함하여 긴 셸 스크립트를 보는 것은 공포와 혼란의 조합으로 인식합니다. 그러나 나는 현대 엔지니어가 갖춰야 할 유용한 기술 중 하나로 셸 스크립트를 편안하게 작성하고 한 줄 기반으로 만드는 능력을 주장합니다.\n\n대학 시절에 스크립팅 수업을 들었습니다. 수업의 처음 몇 주는 Perl로 넘어가기 전에 셸의 기본 사항을 배우는 데 집중했습니다. 우스꽝스럽게도, 지금은 이 매우 같은 강의를 가르치지만 내용은 Perl에서 Python으로 변화했습니다. 불가피하게, 나의 학생들은 저와 같은 어려움을 겪습니다: 셸 구문은 난해하고 혼란스럽고 기억하기 어려운 것들입니다. 그것은 단순히 \"오래된\" 느낌이 들어서, 첫 번째 셸 스크립트를 작성하는 것은 어둠 속에서 헤매고 있는 것과 같은 느낌입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시간이 흐르면서 저는 쉘을 매우 강력한 기능과 풍부한 역사를 가진 도구로 칭찬하게 되었습니다. 쉘 스크립트를 작성하는 방법을 배우는 것은 아마도 여러분이 익숙한 것과는 다르게 사용자 친화적이지 않을 수도 있습니다. 특히 Python이나 Go와 같은 언어에서 오신 경우에는 더 그렇습니다. 그러나 나는 모두가 쉘 스크립팅 능력을 키우는 데 시간을 쏟는 것이 매우 값진 일이라고 생각합니다.\n\n아래에는 파일을 열 때 #!/bin/bash라는 구문을 보고 신경 쓰이는 경우 고려해 볼 다섯 가지 이유가 있습니다:\n\n## Reason 1: Containers Demand It\n\n컨테이너는 현재 워크로드를 배포하는 표준 방식입니다. 동의하든 그렇지 않든, 쿠버네티스 열풍에 흔들리지 않았더라도 환경에서 컨테이너화된 워크로드를 배포 중인 가능성은 높습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n바이너리 엔트리포인트에 의존하는 컨테이너를 빌드할 수 있지만, 보통 컨테이너는 시작 스크립트를 실행합니다. 이는 실행 시간 구성을 제한하는 기회를 제공합니다. 고품질 쉘 스크립트를 작성하면 컨테이너 엔트리포인트의 품질을 향상시켜 컨테이너 이미지 사용자에게 강력한 실행 시간 구성을 제공할 수 있습니다. 이는 오류 확인부터 자격 증명 또는 구성 매개변수를 자동으로 생성하는 것과 같은 더 복잡한 구성까지 모두 포함됩니다.\n\n게다가: 엔트리포인트 스크립트를 POSIX 쉘(#!/bin/sh)로만 제한하는 방법을 배우면 컨테이너 이미지에서 Bash를 제거하고 그 크기와 공격 표면을 줄일 수 있습니다.\n\n\n# 공식 MariaDB 컨테이너는 623줄의 도커 엔트리포인트 쉘 스크립트를 사용합니다.\n$ podman exec -it mariadb wc -l /usr/local/bin/docker-entrypoint.sh\n623 /usr/local/bin/docker-entrypoint.sh\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로그 및 추적 프로젝트는 대략 백만 개 정도가 있어요. 왜 그럴까요? 로깅은 도전적입니다, 특히 분산 마이크로서비스 세계에서요. 멋진 추적 도구와 로그 집계 서비스는 훌륭하지만 종종 명령줄에서 찾을 수 있는 그 유연성을 제공하지 못할 때가 많아요. 저는 파이프된 명령어 한 줄을 작성하는 것이 대부분의 로깅 시스템 UI를 헤매는 것보다 빠르다고 생각해요.\n\nGUI를 버리지 않는 것을 추천하지 않아요. 오히려 그게 유용해요. 텍스트 데이터를 그래픽 인터페이스와 명령줄 모두에서 탐색하는 것이 유용하기 때문이죠. 내 전형적인 워크플로우는 로깅 UI(예: 키바나)를 사용하여 관심 있는 로그로 대략적으로 필터링한 다음 로그 메시지를 다운로드하여 쉽게 구문 분석하기 위해 셸 유틸리티를 사용하는 것입니다. 원하는 것을 더 잘 알게 되면 실제 쿼리가 있는 대시보드를 작성하게 될 거예요.\n\n생산 문제를 디버깅할 때도 아마 당신은 당신의 서버나 쿠버네티스 클러스터에 앉아 있을 거예요. 장애 발생 시 분 단위가 중요할 때 몇 번의 키 입력으로 바로 이론을 테스트하는 것이 절대적으로 중요합니다. 문제가 심각해서 로그 수집 자체가 고장났을 수도 있고, 아니면 터미널과 로깅 도구 간의 컨텍스트 전환을 계속할 여유가 없을 수도 있어요. 그 어떤 경우에도, 단순한 한 줄짜리 명령어를 만들어 내는 데 익숙해서 다행할 것입니다.\n\n배우는 곡선은 있지만, 쉘에서 사용 가능한 많은 유틸리티로 편안해지면 쉘 명령어를 사용하여 데이터를 \"탐색\"하는 것이 훨씬 쉽다는 것을 알게 되실 거예요. 필요한 데이터를 빠르게 반환하는 작은 스크립트 라이브러리를 점차적으로 구축할 수 있을 거예요. 제가 가장 좋아하는 것 중 하나는 제 Nginx 로그를 구문 분석하고 서버를 공격하는 상위 10개 IP 주소를 알려주는 간단한 Bash 한 줄짜리입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\n$ cut -f 1 -d ' ' /var/log/nginx/access.log | sort | uniq -c | sort -hr | head -n 10\n     38 65.108.66.11\n     20 91.240.118.252\n     18 194.110.115.68\n     17 3.234.236.64\n     11 190.117.58.32\n     11 172.56.209.241\n     11 165.225.233.21\n     10 95.161.221.0\n     10 85.173.195.175\n     10 37.79.10.45\n```\n\n# Reason 3: 어떤 (텍스트) 데이터 형식이든\n\n우리가 일상적으로 다루는 대부분의 데이터는 텍스트 형식입니다: 애플리케이션 데이터, 설정 파일, 로그 메시지 등등. 이러한 데이터나 로그 집계 플랫폼에서 이 데이터를 다루는 것은 데이터의 형식(또는 스키마)에 대해 신중한 고려를 요구합니다. 이는 장기적인 저장 및 검색을 위해 이상적인 선택입니다: 데이터 형식을 이해하는 것은 복잡한 데이터를 효율적으로 저장하고 쿼리하는 데 중요합니다.\n\n하지만 당신은 아마도 데이터를 탐색하는 데 편의를 제공하는 방식으로 빠르고 쉽게 데이터를 다루고 싶어하는 상황에 직면해 본 적이 있을 것입니다. 아직 다루고 있는 데이터의 구조나 형식에 대해 이해하고 있지 않을 수도 있습니다. 이를 이해하려는 과정에 있을 수도 있고, 특정 데이터의 일부를 빠르게 쿼리하거나 변환하고 싶을 수도 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n쉘(shell)이 빛을 발하는 작업들이에요! 대부분의 쉘 도구들은 텍스트의 구조에 대해 크게 신경 쓰지 않고 원시 텍스트와 직접 작동합니다. 임의로 형식이 지정되지 않은 텍스트 파일에서 모두 dev를 prod로 변경하고 싶다면, 쉘이 도움이 될 거예요. JSON이나 YAML과 같은 구조화된 데이터 형식을 이미 사용하고 있다면, jq나 yq와 같은 도구를 사용해서 이러한 형식과 함께 작업할 수 있어요.\n\n```js\n# 개발용 구성 파일\n$ cat /tmp/sample.json\n{\n    \"Environment\": \"dev\",\n    \"Database\": {\n        \"Host\": \"dev.example.com\"\n    },\n    \"AppName\": \"iot-dev\",\n    \"CacheShards\": [\n        \"east1-cache-dev-1\",\n        \"east1-cache-dev-2\",\n        \"east1-cache-dev-3\"\n    ]\n}\n\n# Sed는 JSON, YAML, XML 또는 다른 형식이든 상관하지 않아요.\n# 텍스트이면 됩니다!\n$ sed -s 's/dev/prod/g' /tmp/sample.json\n{\n    \"Environment\": \"prod\",\n    \"Database\": {\n        \"Host\": \"prod.example.com\"\n    },\n    \"AppName\": \"iot-prod\",\n    \"CacheShards\": [\n        \"east1-cache-prod-1\",\n        \"east1-cache-prod-2\",\n        \"east1-cache-prod-3\"\n    ]\n}\n```\n\n# 이유 4: 자동화를 지지합니다\n\n자동화는 소프트웨어 엔지니어부터 운영 전문가에 이르기까지 모두의 책임이에요. 소프트웨어 분야에서 일하고 있다면 이미 자동화의 이점을 잘 알고 있고, 아마도 자동화된 몇 가지 프로세스를 진정으로 자랑스럽게 자동화했을 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n셸 스크립트는 존재하는 자동화 방식 중 가장 일반적이고 간단하며 기본적인 유형 중 하나입니다. Ansible, Puppet, Chef, Kubernetes 및 기타 도구들이 나오기 전에는 셸만 있었습니다. 옛날의 시스템 관리자들은 사용자 관리부터 보안 감사까지 모든 것을 다루기 위해 스크립트를 작성했습니다. 이러한 프로세스를 자동화하기 위해 다른 도구를 배울 필요가 없었기 때문에 셸은 시스템과 상호 작용하는 유일한 방법이었죠.\n\n이러한 형태의 자동화를 이해하는 것은 그저 향수에 젖은 연습을 하는 것 이상입니다. 종종 복잡한 프로세스를 자동화하기 위해서는 간단한 셸 스크립트만으로 충분할 수 있습니다. 게다가 많은 자동화 플랫폼들은 이미 강력한 셸 스크립트의 래퍼일 뿐입니다. 셸 스크립트를 작성하고 읽는 방법을 이해하는 것은 자동화 기초에 대한 더 나은 이해를 제공받게 되며, 복잡한 문제를 간단한 방식으로 해결하는 데 도움이 될 것입니다.\n\n# 이유 5: 모든 곳에서 존재하는 기술\n\n현대 컴퓨팅 세계의 현실은 대부분의 기업이 이종 컴퓨팅 워크로드를 실행한다는 것입니다: 가상 머신, 컨테이너, 물리적 호스트 등이 있습니다. 워크로드는 클라우드, 온프레미스 및 엣지에서 실행됩니다. 우수한 엔지니어들은 이러한 환경을 횡단하여 편안하게 작업할 수 있어서 자신을 다른 사람들과 구분지을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 최신 데이터 처리 또는 로그 분석 도구가 없어서 간소화된 컨테이너 애플리케이션 문제 해결에 어려움이 있을 때는 어떻게 해야 할까요? 새로운 팀(또는 직장)으로 옮겨갔을 때 새 역할에서 사용하는 도구체인이 완전히 다를 경우에는 어떻게 해야 할까요?\n\n기본적인 셸 스크립트 작성에 능숙하다면 걱정할 필요가 없습니다. 완전히 다른 환경의 원격 시스템에 로그인하여 로그 데이터를 캡처하거나 자동화된 결함 해결 기능을 동일하게 수행할 수 있습니다. 이런 셸 스크립트를 작성하여 산업 분야에서 계속 발전시키는 경력을 쌓을 수 있습니다. 셸은 시간에 걸쳐 검증되어왔으며, 업계에서의 시간 동안 그것이 성과를 거두는 것을 발견하게 될 것입니다.\n\n# 결론\n\n작은 셸 스크립트도구 상자를 구축하세요. 퇴사할 때 멋진 Kubernetes 오퍼레이터, 놀라운 Kibana 대시보드 또는 멋진 커맨드 라인 도구를 가져갈 수 없을 수도 있습니다. 또한 그것은 간단히 기억에서 재구성하기에 너무 복잡할 수도 있습니다. 그러나 다음 회사에서는 셸이 포함된 시스템이 있을 것이며, 그럼에도 불구하고 당신이 익숙하고 쉽게 어떤 작업이든 수행할 수 있다는 것을 확신할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n확실하게 말씀드리자면: 쉘 스크립트 작성에는 제약과 도전이 있습니다. 하지만 그에 대한 논의는 다음에 하도록 하죠. 그래도 컨테이너 엔트리포인트를 파헤치는 과정에서 #!/bin/sh를 보게 된다고 두려워하지 마세요. 구문과 스타일에 익숙해지면, 강력한 쉘 스크립트가 소프트웨어 전문가로써 우리의 삶을 더 쉽게 만든다는 점을 감사히 여기게 될 거에요.","ogImage":{"url":"/assets/img/2024-05-17-WhyYouShouldStillWriteShellScripts_0.png"},"coverImage":"/assets/img/2024-05-17-WhyYouShouldStillWriteShellScripts_0.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e고전적 접근 방식에 대한 현대적인 사례.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-WhyYouShouldStillWriteShellScripts_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e솔직히 말해서, grep -o \u003ccode\u003eResponse Code:.*\u003c/code\u003e | cut -f 3 -d \u003ccode\u003e \u003c/code\u003e | sort | uniq -c | sort -h 3을 지켜보는 것은 고오급한 Kubernetes Operator를 사용하여 일어나는 것만큼 흥미롭지 않습니다. 많은 소프트웨어 전문가들, 시스템 관리자의 건강한 비율을 포함하여 긴 셸 스크립트를 보는 것은 공포와 혼란의 조합으로 인식합니다. 그러나 나는 현대 엔지니어가 갖춰야 할 유용한 기술 중 하나로 셸 스크립트를 편안하게 작성하고 한 줄 기반으로 만드는 능력을 주장합니다.\u003c/p\u003e\n\u003cp\u003e대학 시절에 스크립팅 수업을 들었습니다. 수업의 처음 몇 주는 Perl로 넘어가기 전에 셸의 기본 사항을 배우는 데 집중했습니다. 우스꽝스럽게도, 지금은 이 매우 같은 강의를 가르치지만 내용은 Perl에서 Python으로 변화했습니다. 불가피하게, 나의 학생들은 저와 같은 어려움을 겪습니다: 셸 구문은 난해하고 혼란스럽고 기억하기 어려운 것들입니다. 그것은 단순히 \"오래된\" 느낌이 들어서, 첫 번째 셸 스크립트를 작성하는 것은 어둠 속에서 헤매고 있는 것과 같은 느낌입니다.\u003c/p\u003e\n\u003cp\u003e시간이 흐르면서 저는 쉘을 매우 강력한 기능과 풍부한 역사를 가진 도구로 칭찬하게 되었습니다. 쉘 스크립트를 작성하는 방법을 배우는 것은 아마도 여러분이 익숙한 것과는 다르게 사용자 친화적이지 않을 수도 있습니다. 특히 Python이나 Go와 같은 언어에서 오신 경우에는 더 그렇습니다. 그러나 나는 모두가 쉘 스크립팅 능력을 키우는 데 시간을 쏟는 것이 매우 값진 일이라고 생각합니다.\u003c/p\u003e\n\u003cp\u003e아래에는 파일을 열 때 #!/bin/bash라는 구문을 보고 신경 쓰이는 경우 고려해 볼 다섯 가지 이유가 있습니다:\u003c/p\u003e\n\u003ch2\u003eReason 1: Containers Demand It\u003c/h2\u003e\n\u003cp\u003e컨테이너는 현재 워크로드를 배포하는 표준 방식입니다. 동의하든 그렇지 않든, 쿠버네티스 열풍에 흔들리지 않았더라도 환경에서 컨테이너화된 워크로드를 배포 중인 가능성은 높습니다.\u003c/p\u003e\n\u003cp\u003e바이너리 엔트리포인트에 의존하는 컨테이너를 빌드할 수 있지만, 보통 컨테이너는 시작 스크립트를 실행합니다. 이는 실행 시간 구성을 제한하는 기회를 제공합니다. 고품질 쉘 스크립트를 작성하면 컨테이너 엔트리포인트의 품질을 향상시켜 컨테이너 이미지 사용자에게 강력한 실행 시간 구성을 제공할 수 있습니다. 이는 오류 확인부터 자격 증명 또는 구성 매개변수를 자동으로 생성하는 것과 같은 더 복잡한 구성까지 모두 포함됩니다.\u003c/p\u003e\n\u003cp\u003e게다가: 엔트리포인트 스크립트를 POSIX 쉘(#!/bin/sh)로만 제한하는 방법을 배우면 컨테이너 이미지에서 Bash를 제거하고 그 크기와 공격 표면을 줄일 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e공식 MariaDB 컨테이너는 623줄의 도커 엔트리포인트 쉘 스크립트를 사용합니다.\u003c/h1\u003e\n\u003cp\u003e$ podman exec -it mariadb wc -l /usr/local/bin/docker-entrypoint.sh\n623 /usr/local/bin/docker-entrypoint.sh\u003c/p\u003e\n\u003cp\u003e로그 및 추적 프로젝트는 대략 백만 개 정도가 있어요. 왜 그럴까요? 로깅은 도전적입니다, 특히 분산 마이크로서비스 세계에서요. 멋진 추적 도구와 로그 집계 서비스는 훌륭하지만 종종 명령줄에서 찾을 수 있는 그 유연성을 제공하지 못할 때가 많아요. 저는 파이프된 명령어 한 줄을 작성하는 것이 대부분의 로깅 시스템 UI를 헤매는 것보다 빠르다고 생각해요.\u003c/p\u003e\n\u003cp\u003eGUI를 버리지 않는 것을 추천하지 않아요. 오히려 그게 유용해요. 텍스트 데이터를 그래픽 인터페이스와 명령줄 모두에서 탐색하는 것이 유용하기 때문이죠. 내 전형적인 워크플로우는 로깅 UI(예: 키바나)를 사용하여 관심 있는 로그로 대략적으로 필터링한 다음 로그 메시지를 다운로드하여 쉽게 구문 분석하기 위해 셸 유틸리티를 사용하는 것입니다. 원하는 것을 더 잘 알게 되면 실제 쿼리가 있는 대시보드를 작성하게 될 거예요.\u003c/p\u003e\n\u003cp\u003e생산 문제를 디버깅할 때도 아마 당신은 당신의 서버나 쿠버네티스 클러스터에 앉아 있을 거예요. 장애 발생 시 분 단위가 중요할 때 몇 번의 키 입력으로 바로 이론을 테스트하는 것이 절대적으로 중요합니다. 문제가 심각해서 로그 수집 자체가 고장났을 수도 있고, 아니면 터미널과 로깅 도구 간의 컨텍스트 전환을 계속할 여유가 없을 수도 있어요. 그 어떤 경우에도, 단순한 한 줄짜리 명령어를 만들어 내는 데 익숙해서 다행할 것입니다.\u003c/p\u003e\n\u003cp\u003e배우는 곡선은 있지만, 쉘에서 사용 가능한 많은 유틸리티로 편안해지면 쉘 명령어를 사용하여 데이터를 \"탐색\"하는 것이 훨씬 쉽다는 것을 알게 되실 거예요. 필요한 데이터를 빠르게 반환하는 작은 스크립트 라이브러리를 점차적으로 구축할 수 있을 거예요. 제가 가장 좋아하는 것 중 하나는 제 Nginx 로그를 구문 분석하고 서버를 공격하는 상위 10개 IP 주소를 알려주는 간단한 Bash 한 줄짜리입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$ cut -f \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e -d \u003cspan class=\"hljs-string\"\u003e' '\u003c/span\u003e /\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e/log/nginx/access.\u003cspan class=\"hljs-property\"\u003elog\u003c/span\u003e | sort | uniq -c | sort -hr | head -n \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e\n     \u003cspan class=\"hljs-number\"\u003e38\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e65.108\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.66\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.11\u003c/span\u003e\n     \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e91.240\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.118\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.252\u003c/span\u003e\n     \u003cspan class=\"hljs-number\"\u003e18\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e194.110\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.115\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.68\u003c/span\u003e\n     \u003cspan class=\"hljs-number\"\u003e17\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3.234\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.236\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.64\u003c/span\u003e\n     \u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e190.117\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.58\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.32\u003c/span\u003e\n     \u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e172.56\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.209\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.241\u003c/span\u003e\n     \u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e165.225\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.233\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.21\u003c/span\u003e\n     \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e95.161\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.221\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e\n     \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e85.173\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.195\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.175\u003c/span\u003e\n     \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e37.79\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.10\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.45\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eReason 3: 어떤 (텍스트) 데이터 형식이든\u003c/h1\u003e\n\u003cp\u003e우리가 일상적으로 다루는 대부분의 데이터는 텍스트 형식입니다: 애플리케이션 데이터, 설정 파일, 로그 메시지 등등. 이러한 데이터나 로그 집계 플랫폼에서 이 데이터를 다루는 것은 데이터의 형식(또는 스키마)에 대해 신중한 고려를 요구합니다. 이는 장기적인 저장 및 검색을 위해 이상적인 선택입니다: 데이터 형식을 이해하는 것은 복잡한 데이터를 효율적으로 저장하고 쿼리하는 데 중요합니다.\u003c/p\u003e\n\u003cp\u003e하지만 당신은 아마도 데이터를 탐색하는 데 편의를 제공하는 방식으로 빠르고 쉽게 데이터를 다루고 싶어하는 상황에 직면해 본 적이 있을 것입니다. 아직 다루고 있는 데이터의 구조나 형식에 대해 이해하고 있지 않을 수도 있습니다. 이를 이해하려는 과정에 있을 수도 있고, 특정 데이터의 일부를 빠르게 쿼리하거나 변환하고 싶을 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e쉘(shell)이 빛을 발하는 작업들이에요! 대부분의 쉘 도구들은 텍스트의 구조에 대해 크게 신경 쓰지 않고 원시 텍스트와 직접 작동합니다. 임의로 형식이 지정되지 않은 텍스트 파일에서 모두 dev를 prod로 변경하고 싶다면, 쉘이 도움이 될 거예요. JSON이나 YAML과 같은 구조화된 데이터 형식을 이미 사용하고 있다면, jq나 yq와 같은 도구를 사용해서 이러한 형식과 함께 작업할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 개발용 구성 파일\n$ cat /tmp/sample.\u003cspan class=\"hljs-property\"\u003ejson\u003c/span\u003e\n{\n    \u003cspan class=\"hljs-string\"\u003e\"Environment\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"dev\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"Database\"\u003c/span\u003e: {\n        \u003cspan class=\"hljs-string\"\u003e\"Host\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"dev.example.com\"\u003c/span\u003e\n    },\n    \u003cspan class=\"hljs-string\"\u003e\"AppName\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"iot-dev\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"CacheShards\"\u003c/span\u003e: [\n        \u003cspan class=\"hljs-string\"\u003e\"east1-cache-dev-1\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"east1-cache-dev-2\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"east1-cache-dev-3\"\u003c/span\u003e\n    ]\n}\n\n# \u003cspan class=\"hljs-title class_\"\u003eSed\u003c/span\u003e는 \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eYAML\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eXML\u003c/span\u003e 또는 다른 형식이든 상관하지 않아요.\n# 텍스트이면 됩니다!\n$ sed -s \u003cspan class=\"hljs-string\"\u003e's/dev/prod/g'\u003c/span\u003e /tmp/sample.\u003cspan class=\"hljs-property\"\u003ejson\u003c/span\u003e\n{\n    \u003cspan class=\"hljs-string\"\u003e\"Environment\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"prod\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"Database\"\u003c/span\u003e: {\n        \u003cspan class=\"hljs-string\"\u003e\"Host\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"prod.example.com\"\u003c/span\u003e\n    },\n    \u003cspan class=\"hljs-string\"\u003e\"AppName\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"iot-prod\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"CacheShards\"\u003c/span\u003e: [\n        \u003cspan class=\"hljs-string\"\u003e\"east1-cache-prod-1\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"east1-cache-prod-2\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"east1-cache-prod-3\"\u003c/span\u003e\n    ]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e이유 4: 자동화를 지지합니다\u003c/h1\u003e\n\u003cp\u003e자동화는 소프트웨어 엔지니어부터 운영 전문가에 이르기까지 모두의 책임이에요. 소프트웨어 분야에서 일하고 있다면 이미 자동화의 이점을 잘 알고 있고, 아마도 자동화된 몇 가지 프로세스를 진정으로 자랑스럽게 자동화했을 거예요.\u003c/p\u003e\n\u003cp\u003e셸 스크립트는 존재하는 자동화 방식 중 가장 일반적이고 간단하며 기본적인 유형 중 하나입니다. Ansible, Puppet, Chef, Kubernetes 및 기타 도구들이 나오기 전에는 셸만 있었습니다. 옛날의 시스템 관리자들은 사용자 관리부터 보안 감사까지 모든 것을 다루기 위해 스크립트를 작성했습니다. 이러한 프로세스를 자동화하기 위해 다른 도구를 배울 필요가 없었기 때문에 셸은 시스템과 상호 작용하는 유일한 방법이었죠.\u003c/p\u003e\n\u003cp\u003e이러한 형태의 자동화를 이해하는 것은 그저 향수에 젖은 연습을 하는 것 이상입니다. 종종 복잡한 프로세스를 자동화하기 위해서는 간단한 셸 스크립트만으로 충분할 수 있습니다. 게다가 많은 자동화 플랫폼들은 이미 강력한 셸 스크립트의 래퍼일 뿐입니다. 셸 스크립트를 작성하고 읽는 방법을 이해하는 것은 자동화 기초에 대한 더 나은 이해를 제공받게 되며, 복잡한 문제를 간단한 방식으로 해결하는 데 도움이 될 것입니다.\u003c/p\u003e\n\u003ch1\u003e이유 5: 모든 곳에서 존재하는 기술\u003c/h1\u003e\n\u003cp\u003e현대 컴퓨팅 세계의 현실은 대부분의 기업이 이종 컴퓨팅 워크로드를 실행한다는 것입니다: 가상 머신, 컨테이너, 물리적 호스트 등이 있습니다. 워크로드는 클라우드, 온프레미스 및 엣지에서 실행됩니다. 우수한 엔지니어들은 이러한 환경을 횡단하여 편안하게 작업할 수 있어서 자신을 다른 사람들과 구분지을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e하지만 최신 데이터 처리 또는 로그 분석 도구가 없어서 간소화된 컨테이너 애플리케이션 문제 해결에 어려움이 있을 때는 어떻게 해야 할까요? 새로운 팀(또는 직장)으로 옮겨갔을 때 새 역할에서 사용하는 도구체인이 완전히 다를 경우에는 어떻게 해야 할까요?\u003c/p\u003e\n\u003cp\u003e기본적인 셸 스크립트 작성에 능숙하다면 걱정할 필요가 없습니다. 완전히 다른 환경의 원격 시스템에 로그인하여 로그 데이터를 캡처하거나 자동화된 결함 해결 기능을 동일하게 수행할 수 있습니다. 이런 셸 스크립트를 작성하여 산업 분야에서 계속 발전시키는 경력을 쌓을 수 있습니다. 셸은 시간에 걸쳐 검증되어왔으며, 업계에서의 시간 동안 그것이 성과를 거두는 것을 발견하게 될 것입니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e작은 셸 스크립트도구 상자를 구축하세요. 퇴사할 때 멋진 Kubernetes 오퍼레이터, 놀라운 Kibana 대시보드 또는 멋진 커맨드 라인 도구를 가져갈 수 없을 수도 있습니다. 또한 그것은 간단히 기억에서 재구성하기에 너무 복잡할 수도 있습니다. 그러나 다음 회사에서는 셸이 포함된 시스템이 있을 것이며, 그럼에도 불구하고 당신이 익숙하고 쉽게 어떤 작업이든 수행할 수 있다는 것을 확신할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e확실하게 말씀드리자면: 쉘 스크립트 작성에는 제약과 도전이 있습니다. 하지만 그에 대한 논의는 다음에 하도록 하죠. 그래도 컨테이너 엔트리포인트를 파헤치는 과정에서 #!/bin/sh를 보게 된다고 두려워하지 마세요. 구문과 스타일에 익숙해지면, 강력한 쉘 스크립트가 소프트웨어 전문가로써 우리의 삶을 더 쉽게 만든다는 점을 감사히 여기게 될 거에요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-17-WhyYouShouldStillWriteShellScripts"},"buildId":"o1YmnmSuZvAX2O4TI9r41","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>