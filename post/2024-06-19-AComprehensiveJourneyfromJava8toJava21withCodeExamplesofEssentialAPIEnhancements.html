<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>자바 8부터 자바 21까지의 포괄적인 여정 중요 API 개선 사항의 코드 예제 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="자바 8부터 자바 21까지의 포괄적인 여정 중요 API 개선 사항의 코드 예제 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="자바 8부터 자바 21까지의 포괄적인 여정 중요 API 개선 사항의 코드 예제 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements" data-gatsby-head="true"/><meta name="twitter:title" content="자바 8부터 자바 21까지의 포괄적인 여정 중요 API 개선 사항의 코드 예제 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 21:56" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_buildManifest.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">자바 8부터 자바 21까지의 포괄적인 여정 중요 API 개선 사항의 코드 예제</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="자바 8부터 자바 21까지의 포괄적인 여정 중요 API 개선 사항의 코드 예제" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">46<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>안녕하세요 친구들, 이 기사에서는 다양한 Java 버전에 대해 이야기하고 싶습니다. 나는 Java 8부터 Java 21까지의 각 버전에서 소개된 모든 중요한 기능과 API를 다루고, 좀 더 심도있는 통찰력을 얻기 위해 코딩 예제를 제시하려고 합니다.</h2>
<p>이는 Java 초보자뿐만 아니라 Java 8이나 Java 11과 같은 오래된 버전의 Java에서 작업하고 있는 Java 개발자들에게 도움이 될 것입니다. 자바 세계에서 무슨 일이 일어나고 있는지업데이트하고 싶어 하는 사람들에게 유용할 것입니다.</p>
<p>자 그럼 시작해봅시다,</p>
<p><img src="/assets/img/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements_0.png" alt="이미지"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>특징:</h2>
<p>람다 표현식:</p>
<ul>
<li>익명 함수 사용으로 함수형 프로그래밍 가능.</li>
<li>함수형 인터페이스 작성을 위한 간결한 구문.</li>
</ul>
<p>함수형 인터페이스:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>람다 표현식을 사용하는 데 도움이되는 단일 추상 메소드를 가진 인터페이스입니다.</li>
<li>@FunctionalInterface 어노테이션을 사용하여 해당 인터페이스를 표시합니다.</li>
</ul>
<p>스트림 API:</p>
<ul>
<li>요소 시퀀스를 처리하기 위해 Stream이라는 새로운 추상화를 소개합니다.</li>
<li>filter, map, reduce 등의 함수형 스타일 작업을 지원합니다.</li>
</ul>
<p>메소드 참조:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>람다 표현식에 대한 간편한 표기법을 제공합니다.</li>
<li>메서드나 생성자를 :: 연산자를 사용하여 참조할 수 있습니다.</li>
</ul>
<p>Optional 클래스:</p>
<ul>
<li>비어 있을 수도 있고 비어 있지 않은 값을 포함할 수 있는 컨테이너 객체입니다.</li>
<li>null 체크를 더 효과적으로 처리하고 NullPointerException을 방지하는 데 도움이 됩니다.</li>
</ul>
<p>새로운 날짜 및 시간 API:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>java.time 패키지는 날짜와 시간을 다루는 보다 포괄적이고 유연한 API를 소개했습니다.</li>
<li>이전의 java.util.Date 및 java.util.Calendar 클래스에서 발생한 다양한 문제를 해결합니다.</li>
</ul>
<p>기본 메소드:</p>
<ul>
<li>인터페이스에 메소드 구현을 허용합니다.</li>
<li>기존 구현을 망가뜨리지 않고 인터페이스를 발전시키는 데 도움이 됩니다.</li>
</ul>
<p>Nashorn JavaScript 엔진:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>이전 Rhino JavaScript 엔진을 대체합니다.</li>
<li>더 나은 성능을 제공하며 최신 JavaScript 표준과 더 호환됩니다.</li>
</ul>
<p>Parallel Streams:</p>
<ul>
<li>parallel() 메서드를 사용하여 스트림을 병렬 처리할 수 있습니다.</li>
<li>특정 유형의 작업에서 멀티코어 시스템에서 성능을 향상시킵니다.</li>
</ul>
<p>Collectors:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>일반적인 축소 작업을 위한 Collectors 클래스의 유틸리티 메서드 집합을 소개합니다. 예를들어 toList(), toSet(), joining() 등이 있습니다.</li>
</ul>
<p>java.util.function 패키지의 함수형 인터페이스:</p>
<ul>
<li>람다 표현식을 지원하기 위해 Predicate, Function, Consumer 및 Supplier와 같은 새로운 함수형 인터페이스가 추가되었습니다.</li>
</ul>
<h2>개선된 Process API:</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>자바 9은 원시 프로세스를 더 잘 제어할 수 있도록 Process API에 개선 사항을 도입했습니다. 새로운 ProcessHandle 클래스를 사용하면 개발자가 프로세스와 관련된 정보를 얻고 상호 작용할 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// ProcessHandle API를 사용하여 현재 프로세스에 대한 정보 가져오기</span>
public <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessHandleExample</span> {
    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) {
        <span class="hljs-title class_">ProcessHandle</span> currentProcess = <span class="hljs-title class_">ProcessHandle</span>.<span class="hljs-title function_">current</span>();
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"프로세스 ID: "</span> + currentProcess.<span class="hljs-title function_">pid</span>());
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"실행 중? "</span> + currentProcess.<span class="hljs-title function_">isAlive</span>());
    }
}
</code></pre>
<h2>컬렉션 팩토리 메서드:</h2>
<ul>
<li>자바 9에서는 컬렉션 인터페이스(List, Set, Map 등)에 새로운 정적 팩토리 메서드를 추가하여 이러한 컬렉션의 불변 인스턴스를 더 편리하게 생성할 수 있게 했습니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">List</span>;

public <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionFactoryMethodsExample</span> {
    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) {
        <span class="hljs-comment">// List.of() 팩토리 메서드를 사용하여 변경할 수 없는 목록 생성</span>
        <span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">String</span>> colors = <span class="hljs-title class_">List</span>.<span class="hljs-title function_">of</span>(<span class="hljs-string">"Red"</span>, <span class="hljs-string">"Green"</span>, <span class="hljs-string">"Blue"</span>);
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(colors);
    }
}
</code></pre>
<h2>향상된 스트림 API:</h2>
<ul>
<li>takeWhile, dropWhile, ofNullable과 같은 여러 새로운 메서드로 스트림 API가 향상되어 스트림 작업의 유연성과 기능성을 향상시켰습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Arrays</span>;
<span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">List</span>;
<span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">stream</span>.<span class="hljs-property">Collectors</span>;

public <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamAPIImprovementsExample</span> {
    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) {
        <span class="hljs-comment">// 예시 1: takeWhile</span>
        <span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">Integer</span>> numbers = <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">asList</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>);
        <span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">Integer</span>> lessThanFive = numbers.<span class="hljs-title function_">stream</span>()
                .<span class="hljs-title function_">takeWhile</span>(n -> n &#x3C; <span class="hljs-number">5</span>)
                .<span class="hljs-title function_">collect</span>(<span class="hljs-title class_">Collectors</span>.<span class="hljs-title function_">toList</span>());

        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"5보다 작은 숫자: "</span> + lessThanFive);

        <span class="hljs-comment">// 예시 2: dropWhile</span>
        <span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">Integer</span>> greaterThanThree = numbers.<span class="hljs-title function_">stream</span>()
                .<span class="hljs-title function_">dropWhile</span>(n -> n &#x3C;= <span class="hljs-number">3</span>)
                .<span class="hljs-title function_">collect</span>(<span class="hljs-title class_">Collectors</span>.<span class="hljs-title function_">toList</span>());

        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"3보다 큰 숫자: "</span> + greaterThanThree);

        <span class="hljs-comment">// 예시 3: ofNullable</span>

        <span class="hljs-comment">// 예시 3: ofNullable</span>
        <span class="hljs-title class_">String</span> value1 = <span class="hljs-string">"안녕"</span>;
        <span class="hljs-title class_">String</span> value2 = <span class="hljs-literal">null</span>;

        <span class="hljs-comment">// null이 아닌 값이 있는 예시</span>
        <span class="hljs-title class_">Stream</span>.<span class="hljs-title function_">ofNullable</span>(value1)
                .<span class="hljs-title function_">ifPresentOrElse</span>(v -> <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"ofNullable 예제 - null이 아닌 값: "</span> + v),
                        () -> <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"ofNullable 예제 - null 값"</span>));

        <span class="hljs-comment">// null 값이 있는 예시</span>
        <span class="hljs-title class_">Stream</span>.<span class="hljs-title function_">ofNullable</span>(value2)
                .<span class="hljs-title function_">ifPresentOrElse</span>(v -> <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"ofNullable 예제 - null이 아닌 값: "</span> + v),
                        () -> <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"ofNullable 예제 - null 값"</span>));

        <span class="hljs-comment">// null 안전한 스트림 예시</span>
        <span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">String</span>> names = <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">asList</span>(<span class="hljs-string">"Alice"</span>, <span class="hljs-string">"Bob"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"Charlie"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"David"</span>);
        <span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">String</span>> nonNullNames = names.<span class="hljs-title function_">stream</span>()
                .<span class="hljs-title function_">flatMap</span>(name -> <span class="hljs-title class_">StreamAPIImprovementsExample</span>.<span class="hljs-title function_">nullSafeStream</span>(name))
                .<span class="hljs-title function_">collect</span>(<span class="hljs-title class_">Collectors</span>.<span class="hljs-title function_">toList</span>());

        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"null이 아닌 이름: "</span> + nonNullNames);
    }

    <span class="hljs-comment">// 잠재적으로 null인 값을 스트림으로 만드는 헬퍼 메서드</span>
    private <span class="hljs-keyword">static</span> &#x3C;T> java.<span class="hljs-property">util</span>.<span class="hljs-property">stream</span>.<span class="hljs-property">Stream</span>&#x3C;T> <span class="hljs-title function_">nullSafeStream</span>(<span class="hljs-params">T value</span>) {
        <span class="hljs-keyword">return</span> value == <span class="hljs-literal">null</span> ? java.<span class="hljs-property">util</span>.<span class="hljs-property">stream</span>.<span class="hljs-property">Stream</span>.<span class="hljs-title function_">empty</span>() : java.<span class="hljs-property">util</span>.<span class="hljs-property">stream</span>.<span class="hljs-property">Stream</span>.<span class="hljs-title function_">of</span>(value);
    }
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 예제에서:</p>
<ul>
<li>takeWhile은 특정 조건이 충족될 때까지 스트림에서 요소를 가져오는 데 사용됩니다 (이 경우에는 5보다 작은 숫자).</li>
<li>dropWhile은 특정 조건이 충족될 때까지 스트림에서 요소를 삭제하는 데 사용됩니다 (이 경우에는 3 이하의 숫자).</li>
<li>ofNullable은 잠재적으로 null인 값을 사용하여 스트림을 생성하고 null 값을 필터링하여 null 이름을 제외합니다.</li>
</ul>
<h2>인터페이스의 비공개 메서드:</h2>
<ul>
<li>Java 9의 인터페이스는 비공개 메서드를 가질 수 있습니다. 이를 통해 공통 기능을 인터페이스 내에 캡슐화하여 외부 클래스에 노출하지 않고 사용할 수 있습니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-comment">// 프라이빗 메서드를 가진 인터페이스</span>
public interface <span class="hljs-title class_">PrivateMethodInterface</span> {
    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">publicMethod</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">// 퍼블릭 메서드에서 프라이빗 메서드 호출 가능</span>
        <span class="hljs-title function_">privateMethod</span>();
    }

    private <span class="hljs-keyword">void</span> <span class="hljs-title function_">privateMethod</span>(<span class="hljs-params"></span>) {
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"인터페이스 안의 프라이빗 메서드"</span>);
    }
}
</code></pre>
<p>HTTP/2 클라이언트:</p>
<ul>
<li>Java 9에서는 HTTP/2 및 WebSocket을 지원하는 새로운 가벼운 HTTP 클라이언트가 도입되었습니다. 이 클라이언트는 예전 HttpURLConnection API보다 효율적이고 유연하게 설계되었습니다.</li>
</ul>
<pre><code class="hljs language-java"><span class="hljs-keyword">import</span> java.net.URI;
<span class="hljs-keyword">import</span> java.net.http.HttpClient;
<span class="hljs-keyword">import</span> java.net.http.HttpRequest;
<span class="hljs-keyword">import</span> java.net.http.HttpResponse;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpClientExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">HttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> HttpClient.newHttpClient();
        <span class="hljs-type">HttpRequest</span> <span class="hljs-variable">httpRequest</span> <span class="hljs-operator">=</span> HttpRequest.newBuilder()
                .uri(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(<span class="hljs-string">"https://www.example.com"</span>))
                .GET()
                .build();

        HttpResponse&#x3C;String> response = httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString());
        System.out.println(<span class="hljs-string">"응답 코드: "</span> + response.statusCode());
        System.out.println(<span class="hljs-string">"응답 본문: "</span> + response.body());
    }
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>로컬 변수 타입 추론 (var):</p>
<ul>
<li>자바 10에서는 var 키워드를 사용하여 로컬 변수 타입 추론 기능을 도입했습니다. 이를 통해 개발자는 타입을 명시적으로 지정하지 않고 로컬 변수를 선언할 수 있으며, 할당된 값에 기반하여 컴파일러가 추론하도록 합니다.</li>
</ul>
<pre><code class="hljs language-js">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalVarInference</span> {

    <span class="hljs-comment">/**
     * 허용: 로컬 변수로만 사용
     * 허용되지 않음: 클래스 필드, 메소드 매개변수 등 다른 곳 (멤버 변수, 여타곳)
     * var 키워드 책임있게 사용하는 것이 좋습니다!
     *
     * 사용 사례:
     *  - 타입이 명확한 경우 (문자열, 정수)
     *  - 너무 긴, 복잡한 타입을 줄이기 위하여
     *
     * 사용하지 말아야 할 때:
     *      - 반환 값이 명확하지 않은 경우 (var data = service.getData();)
     */</span>

    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) {

        <span class="hljs-comment">// 허용되지만 장점이 별로 없음</span>
        <span class="hljs-keyword">var</span> b = <span class="hljs-string">"b"</span>;
        <span class="hljs-keyword">var</span> c = <span class="hljs-number">5</span>; <span class="hljs-comment">// int</span>
        <span class="hljs-keyword">var</span> d = <span class="hljs-number">5.0</span>; <span class="hljs-comment">// double</span>
        <span class="hljs-keyword">var</span> httpClient = <span class="hljs-title class_">HttpClient</span>.<span class="hljs-title function_">newHttpClient</span>();

        <span class="hljs-comment">// 추론할때 쉬운 경우 :)</span>
        <span class="hljs-keyword">var</span> list = <span class="hljs-title class_">List</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.0</span>, <span class="hljs-string">"3"</span>);

        <span class="hljs-comment">// 이름이 긴 타입일 때 장점이 더욱 분명해집니다</span>
        <span class="hljs-keyword">var</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-literal">null</span>);
        <span class="hljs-comment">// vs.</span>
        <span class="hljs-title class_">BufferedReader</span> reader2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-literal">null</span>);
    }
}
</code></pre>
<p>Optional API - 새로운 메소드가 도입되었습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OptionalApi</span> {

    <span class="hljs-comment">/**
     * 새로운 .orElseThrow() 메서드
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {

        Optional&#x3C;Flight> earliestFlight = FlightSchedule.getFlights()
                .stream()
                .filter(f -> <span class="hljs-string">"Boston"</span>.equals(f.from()))
                .filter(f -> <span class="hljs-string">"San Francisco"</span>.equals(f.to()))
                .min(comparing(Flight::date));

        earliestFlight.orElseThrow(FlightNotFoundException::<span class="hljs-keyword">new</span>);
    }
}
</code></pre>
<p>HTTP client</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpClientBasicExample</span> {

    <span class="hljs-comment">/**
     * 클라이언트 생성, GET 요청 보내기, 응답 정보 출력
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">HttpClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> HttpClient.newHttpClient();

        <span class="hljs-type">HttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span>
                HttpRequest.newBuilder(URI.create(<span class="hljs-string">"https://github.com/"</span>))
                        .GET()  <span class="hljs-comment">// 기본값, 생략 가능</span>
                        .build();

        HttpResponse&#x3C;String> response =
                client.send(request, HttpResponse.BodyHandlers.ofString());

        print(<span class="hljs-string">"상태 코드: "</span> + response.statusCode());

        print(response.headers().map());
    }
}
</code></pre>
<h2>새로운 파일 메서드:</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Java 11에서는 java.nio.file 패키지에 여러 가지 새로운 메서드가 추가되었는데, 파일 및 디렉토리 작업에 대한 추가 기능을 제공합니다. 주목할 만한 몇 가지 메서드는 다음과 같습니다:</p>
<ul>
<li>
<p>Files.readString(Path path) 및 Files.writeString(Path path, CharSequence content, OpenOption... options):</p>
</li>
<li>
<p>이러한 메서드를 사용하여 파일의 내용을 문자열로 읽고 쓰는 작업을 간단하게 처리할 수 있습니다. readString 메서드는 파일의 전체 내용을 문자열로 읽어오고, writeString 메서드는 문자열을 파일에 씁니다.</p>
</li>
</ul>
<ol start="2">
<li>Files.readAllLines(Path path) 및 Files.write(Path path, Iterable&#x3C;? extends CharSequence> lines, OpenOption... options):</li>
</ol>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>이러한 메서드는 파일 내용을 문자열 목록으로 읽고 쓰는 작업을 간단하게 해줍니다. readAllLines 메서드는 파일에서 모든 줄을 목록으로 읽고, write 메서드는 문자열 컬렉션을 파일에 쓰기 위한 메서드입니다.</li>
</ul>
<ol start="3">
<li>Files.newBufferedReader(Path path) 및 Files.newBufferedWriter(Path path, OpenOption... options):</li>
</ol>
<ul>
<li>이러한 메서드는 파일을 효율적으로 읽고 쓰기 위한 버퍼드 리더와 라이터를 생성합니다. 이들은 문자 스트림을 다루는 프로세스를 간단하게 합니다.</li>
</ul>
<ol start="4">
<li>files.mismatch(Path path1, Path path2):</li>
</ol>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>이 메서드는 두 파일의 내용을 비교하여 첫 번째 불일치하는 바이트의 위치를 반환합니다. 파일이 동일한 경우 -1을 반환합니다.</li>
</ul>
<pre><code class="hljs language-js">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewFilesMethods</span> {

    <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> filePath = <span class="hljs-title class_">System</span>.<span class="hljs-title function_">getProperty</span>(<span class="hljs-string">"user.dir"</span>) + <span class="hljs-string">"/src/main/resources/"</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> file_1 = filePath + <span class="hljs-string">"file_1.txt"</span>;

    <span class="hljs-comment">/**
     * Files.readString() and .writeString()
     */</span>
    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-title class_">String</span>[] args) throws <span class="hljs-title class_">IOException</span> {

        <span class="hljs-comment">// 파일 읽기가 이제 훨씬 쉬워졌습니다.</span>
        <span class="hljs-comment">// 대용량 파일과 사용하면 안됨</span>
        <span class="hljs-title class_">Path</span> path = <span class="hljs-title class_">Paths</span>.<span class="hljs-title function_">get</span>(file_1);
        <span class="hljs-title class_">String</span> content = <span class="hljs-title class_">Files</span>.<span class="hljs-title function_">readString</span>(path);
        <span class="hljs-title function_">print</span>(content);

        <span class="hljs-title class_">Path</span> newFile = <span class="hljs-title class_">Paths</span>.<span class="hljs-title function_">get</span>(filePath + <span class="hljs-string">"newFile.txt"</span>);
        <span class="hljs-keyword">if</span>(!<span class="hljs-title class_">Files</span>.<span class="hljs-title function_">exists</span>(newFile)) {
            <span class="hljs-title class_">Files</span>.<span class="hljs-title function_">writeString</span>(newFile, <span class="hljs-string">"some str"</span>, <span class="hljs-title class_">StandardOpenOption</span>.<span class="hljs-property">CREATE</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-title class_">Files</span>.<span class="hljs-title function_">writeString</span>(newFile, <span class="hljs-string">"some str"</span>, <span class="hljs-title class_">StandardOpenOption</span>.<span class="hljs-property">TRUNCATE_EXISTING</span>);
        }
    }
}
</code></pre>
<h2>콤팩트 숫자 포맷팅:</h2>
<p>Java 12에서 JEP 357의 일환으로 "콤팩트 숫자 포맷팅"이라는 새로운 기능이 소개되었습니다. 이 개선은 지역별 방식으로 대형 숫자를 더 간결하게 포맷하는 방법을 제공합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>java.text 패키지의 NumberFormat 클래스가 새로운 Style enum을 지원할 수 있도록 업데이트되었습니다. 이 Style에는 Style.SHORT 및 Style.LONG 상수가 포함되어 있습니다. 이러한 스타일은 특정 로케일에 기반해 큰 숫자를 간결한 형태로 포맷하는 데 사용할 수 있습니다.</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">import</span> java.text.NumberFormat;
<span class="hljs-keyword">import</span> java.util.Locale;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CompactNumberFormattingExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 컴팩트 스타일의 숫자 포매터 생성</span>
        <span class="hljs-type">NumberFormat</span> <span class="hljs-variable">compactFormatter</span> <span class="hljs-operator">=</span> NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);

        <span class="hljs-comment">// 큰 숫자 형식화</span>
        System.out.println(<span class="hljs-string">"Short Format: "</span> + compactFormatter.format(<span class="hljs-number">1000</span>));  <span class="hljs-comment">// 결과: 1K</span>
        System.out.println(<span class="hljs-string">"Short Format: "</span> + compactFormatter.format(<span class="hljs-number">1000000</span>));  <span class="hljs-comment">// 결과: 1M</span>

        <span class="hljs-comment">// 긴 형식의 컴팩트 스타일 숫자 포매터 생성</span>
        <span class="hljs-type">NumberFormat</span> <span class="hljs-variable">compactLongFormatter</span> <span class="hljs-operator">=</span> NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.LONG);

        <span class="hljs-comment">// 긴 스타일로 큰 숫자 형식화</span>
        System.out.println(<span class="hljs-string">"Long Format: "</span> + compactLongFormatter.format(<span class="hljs-number">10000000</span>));  <span class="hljs-comment">// 결과: 10 million</span>
        System.out.println(<span class="hljs-string">"Long Format: "</span> + compactLongFormatter.format(<span class="hljs-number">1000000000</span>));  <span class="hljs-comment">// 결과: 1 billion</span>
    }
}
</code></pre>
<h2>String::indent (JEP 326):</h2>
<ul>
<li>Java 12의 String 클래스에는 indent(int n)이라는 새로운 메서드가 도입되었습니다. 이 메서드는 문자열의 각 줄의 들여쓰기를 지정된 공백 수만큼 조정하는 데 사용됩니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-java"><span class="hljs-type">String</span> <span class="hljs-variable">indentedString</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Hello\nWorld"</span>.indent(<span class="hljs-number">3</span>);
<span class="hljs-comment">// indentedString이 이제 "   Hello\n   World"가 됩니다.</span>
</code></pre>
<p>java.util.Arrays에 추가된 새로운 메서드 (JEP 326):</p>
<ul>
<li>Java 12에서는 java.util.Arrays 클래스에 copyOfRange 및 Comparator를 사용하는 equals 변형 등을 포함한 여러 새로운 메서드가 추가되었습니다.</li>
</ul>
<p>java.util.stream.Collectors의 개선 사항 (JEP 325):</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>Java 12에서 도입된 Collectors 유틸리티 클래스에는 teeing과 같은 새로운 수집기가 추가되었는데, 이를 사용하면 두 개의 수집기를 결합하여 하나의 수집기로 만들 수 있습니다.</li>
</ul>
<h2>새로운 파일 메소드:</h2>
<pre><code class="hljs language-js">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewFilesMethod</span> {

    <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> filePath = <span class="hljs-title class_">System</span>.<span class="hljs-title function_">getProperty</span>(<span class="hljs-string">"user.dir"</span>) + <span class="hljs-string">"/src/main/resources/"</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> file_1 = filePath + <span class="hljs-string">"file_1.txt"</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> file_2 = filePath + <span class="hljs-string">"file_2.txt"</span>;

    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-title class_">String</span>[] args) throws <span class="hljs-title class_">IOException</span> {

        <span class="hljs-comment">// 두 파일의 내용에서 첫 번째 불일치하는 바이트의 위치를 찾아 반환합니다.</span>
        <span class="hljs-comment">// 불일치가 없는 경우 -1L을 반환합니다.</span>
        long result = <span class="hljs-title class_">Files</span>.<span class="hljs-title function_">mismatch</span>(<span class="hljs-title class_">Paths</span>.<span class="hljs-title function_">get</span>(file_1), <span class="hljs-title class_">Paths</span>.<span class="hljs-title function_">get</span>(file_2));

        <span class="hljs-title function_">print</span>(result);      <span class="hljs-comment">// -1</span>
    }
}
</code></pre>
<p>특별히 흥미로운 일은 없었습니다:</p>
<ul>
<li>ByteBuffer에 대한 API 업데이트</li>
<li>지역화 업데이트 (새로운 문자 및 이모지 지원)</li>
<li>GC 업데이트</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>“Switch Expressions” (SE) 대신 “Switch Statements” (SS):</h2>
<p>향상된 Switch 표현식:</p>
<ul>
<li>Java 12에서 미리보기 기능으로 소개되었으며 Java 13에서 최종화된 스위치 표현식은 개발자들이 switch 문을 표현식으로 사용할 수 있도록 해주어 더 간결하고 표현력 있는 구문을 제공합니다.</li>
</ul>
<pre><code class="hljs language-java"><span class="hljs-type">int</span> <span class="hljs-variable">dayOfWeek</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">dayType</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">switch</span> (dayOfWeek) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> -> <span class="hljs-string">"평일"</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>, <span class="hljs-number">7</span> -> <span class="hljs-string">"주말"</span>;
    <span class="hljs-keyword">default</span> -> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"유효하지 않은 요일: "</span> + dayOfWeek);
};
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>"수확" 문장:</p>
<ul>
<li>"수확" 문장은 스위치 표현식을 보완하기 위해 Java 14에서 소개되었습니다. 이를 사용하여 스위치 암에서 반환할 값을 지정할 수 있어, 명령형과 함수형 스타일을 융합하는 데 더 많은 유연성을 제공합니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-title class_">String</span> dayType = <span class="hljs-keyword">switch</span> (dayOfWeek) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> -> {
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"근무일"</span>);
        <span class="hljs-keyword">yield</span> <span class="hljs-string">"평일"</span>;
    }
    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>, <span class="hljs-number">7</span> -> {
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"주말"</span>);
        <span class="hljs-keyword">yield</span> <span class="hljs-string">"주말"</span>;
    }
    <span class="hljs-keyword">default</span> -> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"유효하지 않은 요일: "</span> + dayOfWeek);
};
</code></pre>
<p>또 다른 예시,</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-java"><span class="hljs-comment">/**
 * "스위치 표현식" (SE) 대신 "스위치 문" (SS)
 * (둘 다 사용할 수 있지만 SE가 SS보다 낫습니다)
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwitchExpressions</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {

        oldStyleWithBreak(FruitType.APPLE);

        withSwitchExpression(FruitType.PEAR);

        switchExpressionWithReturn(FruitType.KIWI);

        switchWithYield(FruitType.PINEAPPLE);
    }

    <span class="hljs-comment">// 예전 방식은 더 복잡하고 오류 발생 가능성이 높음 ("break;"을 잊으면 switch가 지나가버릴 수 있음)</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">oldStyleWithBreak</span><span class="hljs-params">(FruitType fruit)</span> {
        print(<span class="hljs-string">"==== break를 사용한 예전 방식 ===="</span>);
        <span class="hljs-keyword">switch</span> (fruit) {
            <span class="hljs-keyword">case</span> APPLE, PEAR:
                print(<span class="hljs-string">"보통 과일"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> PINEAPPLE, KIWI:
                print(<span class="hljs-string">"이국적인 과일"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:
                print(<span class="hljs-string">"정의되지 않은 과일"</span>);
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withSwitchExpression</span><span class="hljs-params">(FruitType fruit)</span> {
        print(<span class="hljs-string">"==== 스위치 표현식을 사용한 방식 ===="</span>);
        <span class="hljs-keyword">switch</span> (fruit) {
            <span class="hljs-keyword">case</span> APPLE, PEAR -> print(<span class="hljs-string">"보통 과일"</span>);
            <span class="hljs-keyword">case</span> PINEAPPLE -> print(<span class="hljs-string">"이국적인 과일"</span>);
            <span class="hljs-keyword">default</span> -> print(<span class="hljs-string">"정의되지 않은 과일"</span>);
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">switchExpressionWithReturn</span><span class="hljs-params">(FruitType fruit)</span> {
        print(<span class="hljs-string">"==== 반환 값이 있는 경우 ===="</span>);

        <span class="hljs-comment">// 직접 "return switch"을 사용할 수도 있음</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">switch</span> (fruit) {
            <span class="hljs-keyword">case</span> APPLE, PEAR -> <span class="hljs-string">"보통 과일"</span>;
            <span class="hljs-keyword">case</span> PINEAPPLE -> <span class="hljs-string">"이국적인 과일"</span>;
            <span class="hljs-keyword">default</span> -> <span class="hljs-string">"정의되지 않은 과일"</span>;
        };
        print(text);
    }

    <span class="hljs-comment">/**
     * "Yield"는 "return"과 비슷하지만 중요한 차이가 있음:
     * "yield"는 값을 반환하고 switch 문을 종료함. 실행은 특정 메서드 내에서 유지됨
     * "return"은 switch문 및 특정 메서드를 종료함
     */</span>
    <span class="hljs-comment">// https://stackoverflow.com/questions/58049131/what-does-the-new-keyword-yield-mean-in-java-13</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">switchWithYield</span><span class="hljs-params">(FruitType fruit)</span> {
        print(<span class="hljs-string">"==== yield를 사용한 경우 ===="</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">switch</span> (fruit) {
            <span class="hljs-keyword">case</span> APPLE, PEAR -> {
                print(<span class="hljs-string">"주어진 과일은: "</span> + fruit);
                <span class="hljs-keyword">yield</span> <span class="hljs-string">"보통 과일"</span>;
            }
            <span class="hljs-keyword">case</span> PINEAPPLE -> <span class="hljs-string">"이국적인 과일"</span>;
            <span class="hljs-keyword">default</span> -> <span class="hljs-string">"정의되지 않은 과일"</span>;
        };
        print(text);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">FruitType</span> {APPLE, PEAR, PINEAPPLE, KIWI}
}
</code></pre>
<h2>텍스트 블록</h2>
<p>텍스트 블록은 여러 줄에 걸친 문자열 리터럴을 나타내는 새로운 유형의 리터럴입니다. 여러 줄에 걸친 소스 코드의 문자열을 작성하고 유지하는 작업을 간단하게 만들면서 이스케이프 시퀀스를 피하려고 합니다.</p>
<p>텍스트 블록을 사용하지 않은 예시:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-title class_">String</span> html = <span class="hljs-string">""</span><span class="hljs-string">"
&#x3C;html>
    &#x3C;body>
        &#x3C;p>Hello, world&#x3C;/p>
    &#x3C;/body>
&#x3C;/html>
"</span><span class="hljs-string">""</span>;
</code></pre>
<p>텍스트 블록의 주요 기능은 다음과 같습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>여러 줄 문자열: 텍스트 블록을 사용하면 여러 줄 문자열을 더 자연스럽게 표현할 수 있어 코드 가독성을 향상시킵니다.</li>
<li>공백 제어: 각 줄의 시작과 끝 공백이 제거되어 들여쓰기를 더 잘 제어할 수 있습니다.</li>
<li>이스케이프 시퀀스: 텍스트 블록 내에서 이스케이프 시퀀스는 여전히 유효하며 특수 문자를 포함할 수 있습니다.</li>
</ul>
<p>텍스트 블록은 HTML, XML, JSON 또는 SQL 쿼리와 같은 여러 줄 콘텐츠를 포함하는 문자열을 더 쉽게 표현할 수 있도록 설계되었습니다. Java 15나 이후 버전에서 텍스트 블록과 관련된 업데이트나 새로운 기능이 있었을 경우 해당 버전의 공식 문서나 릴리스 노트를 확인하는 것이 좋습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/**
 * TextBlocks에 대한 사용 사례 (Java 15의 새로운 기능 > Text Blocks in Practice)
 * - 마크다운을 사용한 텍스트 블록
 * - 테스트, 하드 코딩된 JSON 문자열 정의
 * - 간단한 템플릿
 */</span>
public <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlocks</span> {

    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) {
        <span class="hljs-title function_">oldStyle</span>();
        <span class="hljs-title function_">emptyBlock</span>();
        <span class="hljs-title function_">jsonBlock</span>();
        <span class="hljs-title function_">jsonMovedEndQuoteBlock</span>();
        <span class="hljs-title function_">jsonMovedBracketsBlock</span>();
    }

    private <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">oldStyle</span>(<span class="hljs-params"></span>) {
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"******** 기존 스타일 ********"</span>);

        <span class="hljs-title class_">String</span> text = <span class="hljs-string">"{\n"</span> +
                <span class="hljs-string">"  \"name\": \"John Doe\",\n"</span> +
                <span class="hljs-string">"  \"age\": 45,\n"</span> +
                <span class="hljs-string">"  \"address\": \"Doe Street, 23, Java Town\"\n"</span> +
                <span class="hljs-string">"}"</span>;
        <span class="hljs-title function_">print</span>(text);
    }

    private <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">emptyBlock</span>(<span class="hljs-params"></span>) {
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"******** 빈 블록 ********"</span>);
        <span class="hljs-title class_">String</span> text = <span class="hljs-string">""</span><span class="hljs-string">"
                "</span><span class="hljs-string">""</span>;
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"|"</span> + text + <span class="hljs-string">"|"</span>);
    }

    private <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">jsonBlock</span>(<span class="hljs-params"></span>) {
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"******** JSON 블록 ********"</span>);

        <span class="hljs-title class_">String</span> text = <span class="hljs-string">""</span><span class="hljs-string">"
                {
                  "</span>name<span class="hljs-string">": "</span><span class="hljs-title class_">John</span> <span class="hljs-title class_">Doe</span><span class="hljs-string">",
                  "</span>age<span class="hljs-string">": 45,
                  "</span>address<span class="hljs-string">": "</span><span class="hljs-title class_">Doe</span> <span class="hljs-title class_">Street</span>, <span class="hljs-number">23</span>, <span class="hljs-title class_">Java</span> <span class="hljs-title class_">Town</span><span class="hljs-string">"
                }
                "</span><span class="hljs-string">""</span>; <span class="hljs-comment">// &#x3C;-- 첫 번째 " 문자와 정렬되어 있으면 들여쓰기 없음</span>
        <span class="hljs-title function_">print</span>(text);
    }

    private <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">jsonMovedEndQuoteBlock</span>(<span class="hljs-params"></span>) {
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"******** JSON 이동된 끝 따옴표 블록 ********"</span>);

        <span class="hljs-title class_">String</span> text = <span class="hljs-string">""</span><span class="hljs-string">"
                  {
                    "</span>name<span class="hljs-string">": "</span><span class="hljs-title class_">John</span> <span class="hljs-title class_">Doe</span><span class="hljs-string">",
                    "</span>age<span class="hljs-string">": 45,
                    "</span>address<span class="hljs-string">": "</span><span class="hljs-title class_">Doe</span> <span class="hljs-title class_">Street</span>, <span class="hljs-number">23</span>, <span class="hljs-title class_">Java</span> <span class="hljs-title class_">Town</span><span class="hljs-string">"
                  }
                       "</span><span class="hljs-string">""</span>;
        <span class="hljs-title function_">print</span>(text);
    }

    private <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">jsonMovedBracketsBlock</span>(<span class="hljs-params"></span>) {
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"******** JSON 이동된 괄호 블록 ********"</span>);

        <span class="hljs-title class_">String</span> text = <span class="hljs-string">""</span><span class="hljs-string">"
                  {
                    "</span>name<span class="hljs-string">": "</span><span class="hljs-title class_">John</span> <span class="hljs-title class_">Doe</span><span class="hljs-string">",
                    "</span>age<span class="hljs-string">": 45,
                    "</span>address<span class="hljs-string">": "</span><span class="hljs-title class_">Doe</span> <span class="hljs-title class_">Street</span>, <span class="hljs-number">23</span>, <span class="hljs-title class_">Java</span> <span class="hljs-title class_">Town</span><span class="hljs-string">"
                  }
                "</span><span class="hljs-string">""</span>; <span class="hljs-comment">// &#x3C;-- 세 번째 " 문자와 정렬되어 2칸 들여쓰기</span>
        <span class="hljs-title function_">print</span>(text);
    }
}
</code></pre>
<h2>instanceof에 대한 패턴 매칭:</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>자바 16의 instanceof에 대한 패턴 매칭은 유용한 기능으로 형식 검사와 추출을 개선합니다. 여기에 이 기능의 주요 측면을 요약해 두었어요:</p>
<p>기능:</p>
<ul>
<li>단일 형식 대신 타입 패턴을 소개합니다.</li>
<li>instanceof 검사 내에서 추출된 객체를 보유할 변수를 선언할 수 있습니다.</li>
<li>형식 검사 및 캐스팅을 더 간결하고 가독성 있게 결합한 표현입니다.</li>
</ul>
<p>혜택:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>번거로운 코드 줄이기: 별도의 instanceof 확인, 형 변환 및 변수 선언이 필요 없게 합니다.</li>
<li>가독성 향상: 코드가 더 명확해지고 복잡한 유형 계층 구조에 대해 이해하기 쉬워집니다.</li>
<li>오류 감소: 잘못된 유형으로 인한 캐스트 예외 발생 가능성이 줄어듭니다.</li>
</ul>
<p>구문</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span> s) {
  <span class="hljs-comment">// 여기서 "s"를 String으로 직접 사용</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">Integer</span>> list) {
  <span class="hljs-comment">// 여기서 "list"를 List &#x3C;Integer>로 직접 사용</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// 다른 경우 처리</span>
}
</code></pre>
<p>예제</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PatternMatchingForInstanceof</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {

        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">"Harry Potter"</span>, Set.of(<span class="hljs-string">"Jon Doe"</span>));

        <span class="hljs-comment">// 옛날 방식</span>
        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Book) {
            <span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> (Book) o;
            print(<span class="hljs-string">"The book's author(s) are "</span> + book.getAuthors());
        }

        <span class="hljs-comment">// 새 방식</span>
        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Book book) {
            print(<span class="hljs-string">"The book's author(s) are "</span> + book.getAuthors());
        }

    }
}
</code></pre>
<h2>레코드:</h2>
<p>자바의 레코드는 변경할 수 없는 데이터를 보관하기 위해 특별히 설계된 특수한 유형의 클래스입니다. 이는 단순한 데이터 구조를 처리할 때 보일러플레이트 코드를 줄이고 가독성 및 유지보수성을 향상시킬 수 있도록 도와줍니다.</p>
<ul>
<li>이들의 주요 특성을 살펴봅시다:</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ol>
<li>간결함:</li>
</ol>
<ul>
<li>기존 클래스와는 달리 레코드는 정의하는 데 필요한 코드가 최소화됩니다. 레코드 선언에서 데이터 필드(구성 요소)만 지정하면 됩니다. 그러면 컴파일러가 다음과 같은 필수 메서드를 자동으로 생성합니다:</li>
<li>각 구성 요소에 대한 매개변수가 있는 생성자.</li>
<li>각 구성 요소에 대한 게터.</li>
<li>구성 요소 값을 기반으로 한 equals 및 hashCode 메서드.</li>
<li>레코드의 상태를 나타내는 toString 메서드.</li>
</ul>
<ol start="2">
<li>변경 불가능성:</li>
</ol>
<ul>
<li>레코드 필드는 final로 선언되어 있어, 레코드가 생성된 후에는 그 내부에 저장된 데이터를 변경할 수 없습니다. 이는 데이터 일관성을 보장하고 스레드 안전성에 대한 고려사항을 단순화합니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ol start="3">
<li>가독성:</li>
</ol>
<ul>
<li>레코드의 자동 생성 메서드와 예측 가능한 동작은 코드 가독성을 향상시키고 레코드가 어떤 것을 나타내며 프로그램의 다른 부분과 어떻게 상호 작용하는지 이해하기 쉽게 만듭니다.</li>
</ul>
<ol start="4">
<li>오류 감소:</li>
</ol>
<ul>
<li>보일러플레이트를 최소화함으로써 레코드는 getter를 잊거나 equals를 잘못 구현하는 것과 같은 일반적인 실수의 위험을 줄입니다. 이는 더 견고하고 신뢰할 수 있는 코드로 이어집니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>전반적으로 레코드는 Java 개발자가 간결하고 불변 그리고 가독성 좋은 데이터 구조를 만드는 데 유용한 도구입니다. 이는 보다 깔끔하고 유지보수 가능한 코드를 유도합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/**
 * 레코드는 데이터 전용 불변 클래스입니다 (따라서 특정한 사용 사례가 있음)
 * 클래스의 특정 형태(예: enum과 같은)로 제한된(전문화된) 형태입니다
 * 상태 변경 등을 의도한 객체에는 적합하지 않습니다.
 * &#x3C;p>
 * 레코드는 다음과 관련이 없습니다:
 * - 보일러플레이트 감소 기법
 * &#x3C;p>
 * 레코드는 생성자, 게터, 필드; equals, hashCode, toString을 생성합니다
 * &#x3C;p>
 * 사용 사례:
 * - 불변 데이터 모델링
 * - 데이터를 읽기 전용으로 메모리에 보관
 * - DTOs - 데이터 전송 객체
 */</span>
public <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecordsDemo</span> {

    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) {
        <span class="hljs-title class_">Product</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>(<span class="hljs-string">"우유"</span>, <span class="hljs-number">50</span>);
        <span class="hljs-title class_">Product</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>(<span class="hljs-string">"우유"</span>, <span class="hljs-number">50</span>);

        <span class="hljs-title function_">print</span>(p1.<span class="hljs-title function_">price</span>()); <span class="hljs-comment">// "get" 접두사 없이 사용</span>
        <span class="hljs-title function_">print</span>(p1);         <span class="hljs-comment">// 자동으로 생성된 toString() 출력- Product[name=우유, price=50]</span>

        <span class="hljs-title function_">print</span>(p1 == p2);       <span class="hljs-comment">// false    - 다른 객체</span>
        <span class="hljs-title function_">print</span>(p1.<span class="hljs-title function_">equals</span>(p2));  <span class="hljs-comment">// true     - 값들(milk, 50)은 auto-generated equals()/hashCode()에 의해 비교됨</span>
    }
}

<span class="hljs-comment">/**
 * 매개변수를 "Components"라고 함
 * 더 많은 필드 원할 시, 시그니처에 추가 필요
 * 확장은 허용되지 않지만 인터페이스 구현은 가능
 */</span>
public record <span class="hljs-title class_">Product</span>(<span class="hljs-title class_">String</span> name, int price) {

    <span class="hljs-comment">// 정적 필드는 가능하지만 비정적은 허용하지 않음</span>
    <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> country = <span class="hljs-string">"US"</span>;

    <span class="hljs-comment">// 모든 필드를 가진 생성자가 생성됨</span>

    <span class="hljs-comment">// Validation 추가 가능</span>
    public <span class="hljs-title class_">Product</span> {
        <span class="hljs-keyword">if</span>(price &#x3C; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();
        }
    }

    <span class="hljs-comment">// toString()과 같은 auto-generated 메소드들 오버라이딩 가능</span>
}
</code></pre>
<h2>날짜 및 시간 형식 API:</h2>
<ul>
<li>Java 16의 DateTimeFormatter API의 일반적 사용법 및 기능: 형식 패턴 이해, 사용자 정의 형식 생성, 날짜 및 시간 구문 분석, 사용 가능한 형식 설정 포함</li>
<li>Java 16에서 소개된 날짜 형식팅을 위한 새로운 기능: 특히 "B" 심볼과 다양한 스타일을 사용한 일시 지원</li>
<li>SimpleDateFormat과 같은 이전 서식기와 DateTimeFormatter의 비교: 각 접근 방식의 장단점 탐색</li>
<li>특정 형식 작업에 DateTimeFormatter 사용 예제: 다양한 로케일에서 날짜 형식화, 타임존 처리, 더 사람이 이해하기 쉬운 표현 생성하기 등을 포함하여.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DateTimeFormatterApi</span> {

    <span class="hljs-keyword">static</span> Map&#x3C;TextStyle, Locale> map = Map.of(
            TextStyle.FULL, Locale.US,
            TextStyle.SHORT, Locale.FRENCH,
            TextStyle.NARROW, Locale.GERMAN
    );

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> entry : map.entrySet()) {

            <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();
            <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DateTimeFormatterBuilder</span>()
                    .appendPattern(<span class="hljs-string">"yyyy-MM-dd hh:mm "</span>)
                    .appendDayPeriodText(entry.getKey())    <span class="hljs-comment">// at night, du soir, abends, etc.</span>
                    .toFormatter(entry.getValue());

            <span class="hljs-type">String</span> <span class="hljs-variable">formattedDateTime</span> <span class="hljs-operator">=</span> now.format(formatter);
            print(formattedDateTime);
        }
    }
}
</code></pre>
<h2>Stream API의 변경 사항:</h2>
<p>Java 16에서 Stream API에 흥미로운 변경 사항이 있었습니다. 더욱 강력하고 편리하게 사용할 수 있게 되었습니다. 주요 하이라이트는 다음과 같습니다:</p>
<ol>
<li>Stream.toList() 메서드: 이 새로운 메서드는 스트림의 요소를 목록으로 수집하는 간결한 방법을 제공합니다. 이전에는 collect(Collectors.toList())를 사용해야 했지만, 이제는 약간 중복된 방법입니다.</li>
</ol>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ol start="2">
<li>
<p>Stream.mapMulti() 메소드: 이 메소드를 사용하면 스트림의 각 요소를 제로 또는 그 이상의 요소로 매핑하여 결과 요소의 새로운 스트림을 생성할 수 있습니다. 복잡한 데이터 구조를 분할하거나 펼치는 데 편리합니다.</p>
</li>
<li>
<p>향상된 줄 바꿈 처리: Java 16에서 java.io.LineNumberReader 클래스에서 줄 바꿈자를 정의하는 방법을 명확히하였습니다. 이는 모순을 제거하고 줄 기반 데이터를 읽을 때 일관된 동작을 보장합니다.</p>
</li>
<li>
<p>기타 작은 변경점:</p>
</li>
</ol>
<ul>
<li>이제 문자열 스트림은 중간 작업이 필요하지 않고 limit 및 skip 메소드를 직접 지원합니다.</li>
<li>peek 메소드를 병렬 스트림과 함께 사용할 수 있으므로 병렬성에 영향을주지 않고 부작용을 발생시킬 수 있습니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamApi</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {

        List&#x3C;Integer> ints = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
                .filter(n -> n &#x3C; <span class="hljs-number">3</span>)
                .toList();  <span class="hljs-comment">// new, instead of the verbose .collect(Collectors.toList())</span>

        ints.forEach(System.out::println);

    }
}
</code></pre>
<h2>Sealed classes(Subclassing):</h2>
<p>Sealed 클래스는 Java 17 (JEP 409)에서 소개된 새로운 기능으로 상속 계층구조에 대해 더 많은 제어를 제공합니다. 본질적으로 클래스나 인터페이스를 확장하거나 구현하는 것을 제한할 수 있습니다. 이는 다양한 이유로 매우 유용할 수 있습니다:</p>
<ol>
<li>향상된 타입 안전성: 허용된 하위 클래스를 명시함으로써 코드를 손상시키거나 보안 취약점을 도입할 수 있는 예기치 않은 확장을 방지합니다.</li>
</ol>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ol start="2">
<li>
<p>개선된 라이브러리 디자인: 라이브러리 내에서 폐쇄된 생태계를 만들 수 있어서, 사용자가 승인된 확장 기능만 사용하고 호환되지 않는 구현을 만들지 않도록 보장할 수 있습니다.</p>
</li>
<li>
<p>쉬운 코드 유지 관리: 가능한 서브클래스 집합을 정확히 알면 코드에 대한 추론이 간단해지며 이해와 유지보수가 쉬워집니다.</p>
</li>
</ol>
<p>sealed 클래스는 어떻게 작동합니까?</p>
<p>sealed 키워드를 사용하여 클래스 또는 인터페이스를 sealed로 선언합니다. 그런 다음 permits 절을 사용하여 확장하거나 구현할 수 있는 클래스 목록을 지정합니다. 이 허용된 클래스만 직접 상속할 수 있고, 다른 모든 클래스는 금지됩니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">sealed <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> {
  permits <span class="hljs-title class_">Circle</span>, <span class="hljs-title class_">Square</span>, <span class="hljs-title class_">Triangle</span>;
  <span class="hljs-comment">// ... 구현 세부사항</span>
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Shape</span> {
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// 사각형이 허용되지 않아 컴파일 오류가 발생합니다</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Shape</span> {
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>봉인된 클래스나 인터페이스는 지정된 클래스와 인터페이스만이 상속하거나 구현할 수 있습니다.</p>
<p>이점:</p>
<ul>
<li>
<ol>
<li>의도를 전달하여 잘 정의되고 제한된 가능한 구현을 강제화할 수 있음</li>
</ol>
</li>
<li>
<ol start="2">
<li>더 나은 보안 — 제 3자 코드로부터의 예기치 않은 또는 무단 서브클래싱과 행위 예방을 돕습니다</li>
</ol>
</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>규칙:</p>
<ul>
<li>
<ol>
<li>sealed 클래스는 "permits"를 사용하여 다른 클래스가 하위 클래스로 지정될 수 있게 합니다.</li>
</ol>
</li>
<li>
<ol start="2">
<li>하위 클래스는 반드시 final, sealed 또는 non-sealed 이어야 합니다. (그렇지 않으면 코드가 컴파일되지 않습니다)</li>
</ol>
</li>
<li>
<ol start="3">
<li>허용된 하위 클래스는 상위 sealed 클래스를 확장해야 합니다. permit을 사용하지 않고 허용하는 것은 허용되지 않습니다.</li>
</ol>
</li>
<li>
<ol start="4">
<li>permits로 지정된 클래스들은 상위 클래스와 근접하게 위치해야 합니다:</li>
</ol>
<ul>
<li>동일한 모듈에 있어야 합니다 (상위 클래스가 명명된 모듈에 있는 경우) (Java 9 모듈화 참조)</li>
<li>동일한 패키지에 있어야 합니다 (상위 클래스가 무명 모듈에 있는 경우).</li>
</ul>
</li>
</ul>
<p>4번 항목에 대한 더 자세한 내용:</p>
<ul>
<li>Sealed 클래스와 그 (직접적인) 하위 클래스는 함께 컴파일되고 유지되어야 하기 때문에 밀접하게 결합됩니다.</li>
<li>모듈화된 환경에서는 "동일한 모듈"; 모듈화되지 않은 환경에서는 이를 가장 잘 나타내는 것이 "동일한 패키지"입니다.</li>
<li>모듈을 사용한다면 모듈이 제공하는 안전한 경계 때문에 몇 가지 추가적인 유연성을 얻을 수 있습니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>기본 UTF-8 설정:</h2>
<p>Java 18에서는 플랫폼의 기본 문자 인코딩이 UTF-8로 변경되었습니다. 이는 현대 표준에 맞추어 문자 처리를 간소화하고 있습니다.</p>
<pre><code class="hljs language-js">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Utf8ByDefault</span> {

    <span class="hljs-comment">// https://openjdk.org/jeps/400 - Platform Default Encoding</span>

    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-title class_">String</span>[] args) throws <span class="hljs-title class_">IOException</span> {

        <span class="hljs-comment">// 문제:</span>
        <span class="hljs-comment">// 1) 윈도우에서는 아스키 테이블 외의 문자, 예를 들어 특이한 유니코드 문자,을 지정하지 않고 FileWriter을 사용하여 쓰기</span>
        <span class="hljs-comment">// 2) 파일을 맥과 같은 UNIX 기반 OS로 복사하거나 전송한 다음 시스템의 기본 문자 인코딩을 사용하여 파일을 읽음</span>
        <span class="hljs-comment">// 3) 예상되는 결과 - 엉망인 출력</span>
        <span class="hljs-comment">// 따라서 문제는 예측불가능한 동작입니다.</span>
        <span class="hljs-title class_">FileWriter</span> writer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">"out.txt"</span>);

        <span class="hljs-comment">// Java 18 이전의 해결책: 항상 문자 집합을 지정하십시오 (그리고 그것을 잊지 않도록 행운을 빕니다!)</span>
        <span class="hljs-title class_">FileWriter</span> writer2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">"out.txt"</span>, <span class="hljs-title class_">StandardCharsets</span>.<span class="hljs-property">UTF_8</span>);

        <span class="hljs-comment">// Java 18부터의 해결책: UTF-8은 이제 기본값이므로 문자 집합을 지정할 필요가 없습니다.</span>

    }
}
</code></pre>
<h2>간단한 웹 서버:</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 새로운 API는 정적 파일을 제공하는 기본 웹 서버를 제공하여 빠른 프로토타이핑 및 임베디드 애플리케이션에 이상적입니다.</p>
<ul>
<li>시스템에 Java 18 이상이 설치되어 있는지 확인합니다.</li>
<li>정적 파일(HTML, CSS, JavaScript, 이미지 등)을 특정 디렉토리에 준비해 두세요.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> com.<span class="hljs-property">sun</span>.<span class="hljs-property">net</span>.<span class="hljs-property">httpserver</span>.<span class="hljs-property">HttpServer</span>;
<span class="hljs-keyword">import</span> com.<span class="hljs-property">sun</span>.<span class="hljs-property">net</span>.<span class="hljs-property">httpserver</span>.<span class="hljs-property">SimpleFileServer</span>;

<span class="hljs-keyword">import</span> java.<span class="hljs-property">net</span>.<span class="hljs-property">InetSocketAddress</span>;

public <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleWebServer</span> {
    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-title class_">String</span>[] args) throws <span class="hljs-title class_">Exception</span> {
        <span class="hljs-title class_">String</span> documentRoot = <span class="hljs-string">"/path/to/your/static/files"</span>;  <span class="hljs-comment">// 실제 디렉토리로 교체합니다</span>
        int port = <span class="hljs-number">8080</span>;  <span class="hljs-comment">// 필요에 따라 포트를 변경할 수 있습니다</span>

        <span class="hljs-title class_">HttpServer</span> server = <span class="hljs-title class_">HttpServer</span>.<span class="hljs-title function_">create</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(port), <span class="hljs-number">0</span>);
        <span class="hljs-title class_">SimpleFileServer</span> fileServer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleFileServer</span>(documentRoot);
        server.<span class="hljs-title function_">setExecutor</span>(<span class="hljs-literal">null</span>);  <span class="hljs-comment">// 단일 스레드 실행자 사용</span>
        server.<span class="hljs-title function_">createContext</span>(<span class="hljs-string">"/"</span>, fileServer);

        server.<span class="hljs-title function_">start</span>();
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"포트 "</span> + port + <span class="hljs-string">"에서 서버가 시작되었습니다."</span>);
    }
}
</code></pre>
<pre><code class="hljs language-js">&#x3C;!<span class="hljs-variable constant_">DOCTYPE</span> html>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">html</span>></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">head</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">title</span>></span>문서 제목<span class="hljs-tag">&#x3C;/<span class="hljs-name">title</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">head</span>></span>

<span class="hljs-tag">&#x3C;<span class="hljs-name">body</span>></span>
이 페이지는 "jwebserver" 명령을 사용하여 Java의 Simple Web Server로 제공될 수 있습니다.
<span class="hljs-tag">&#x3C;/<span class="hljs-name">body</span>></span>

<span class="hljs-tag">&#x3C;/<span class="hljs-name">html</span>></span></span>
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아래와 같은 방법으로 실행해보세요:</p>
<ol>
<li>Java 파일 컴파일하기: javac SimpleWebServer.java</li>
<li>컴파일된 클래스 실행하기: java SimpleWebServer</li>
</ol>
<p>접속하기:</p>
<ul>
<li>웹 브라우저를 열고 <a href="http://localhost:8080" rel="nofollow" target="_blank">http://localhost:8080</a> (또는 지정된 포트)로 이동합니다.</li>
<li>정적 파일 디렉토리에서 기본 파일 (보통 index.html)이 제공되는 것을 확인할 수 있어요.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ol start="5">
<li>서버를 중지하는 방법:</li>
</ol>
<ul>
<li>서버를 중지하려면 실행 중인 터미널에서 Ctrl+C를 누릅니다.</li>
</ul>
<p>가장 간단한 방법으로 시작하기:</p>
<ol>
<li>이 패키지(java18)에서 터미널을 엽니다.</li>
</ol>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ol start="2">
<li>
<p>"java -version"을 실행하고 Java가 적어도 18 버전인지 확인해주세요.</p>
</li>
<li>
<p>"jwebserver" 명령어를 실행해주세요.</p>
</li>
</ol>
<p>다음과 같은 메시지가 표시되어야 합니다:</p>
<p>기본적으로 루프백에 바인딩됩니다. 모든 인터페이스에 대해 사용하려면 "-b 0.0.0.0" 또는 "-b ::"를 사용하십시오.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>127.0.0.1 포트 8000에서 경로/디렉토리 및 하위 디렉토리를 제공하고 있어요.</p>
<p>URL <a href="http://127.0.0.1:8000/" rel="nofollow" target="_blank">http://127.0.0.1:8000/</a></p>
<p>HTML 페이지는 이제 다음 주소에서 제공됩니다: <a href="http://127.0.0.1:8000/java18/doc.html" rel="nofollow" target="_blank">http://127.0.0.1:8000/java18/doc.html</a></p>
<p>IP 주소, 포트 및 기타 매개변수를 변경할 수 있어요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>HEAD() 편의 메서드 추가:</h2>
<pre><code class="hljs language-js">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpHeadDemo</span> {

    <span class="hljs-comment">/**
     * HEAD() 편의 메서드 추가
     */</span>
    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-title class_">String</span>[] args) throws <span class="hljs-title class_">IOException</span>, <span class="hljs-title class_">InterruptedException</span> {
        <span class="hljs-title class_">HttpRequest</span> head = <span class="hljs-title class_">HttpRequest</span>.<span class="hljs-title function_">newBuilder</span>(<span class="hljs-variable constant_">URI</span>.<span class="hljs-title function_">create</span>(<span class="hljs-string">"https://api.github.com/"</span>))
                .<span class="hljs-title function_">HEAD</span>()
                .<span class="hljs-title function_">build</span>();

        <span class="hljs-keyword">var</span> response = <span class="hljs-title class_">HttpClient</span>.<span class="hljs-title function_">newHttpClient</span>().<span class="hljs-title function_">send</span>(head, <span class="hljs-title class_">HttpResponse</span>.<span class="hljs-property">BodyHandlers</span>.<span class="hljs-title function_">ofString</span>());

        <span class="hljs-title function_">print</span>(response);
    }
}
</code></pre>
<p>Method Handles로 Core Reflection 재구현: 이 재구현은 리플렉션 기능의 성능과 안정성을 개선하기 위한 것입니다.</p>
<p>제거를 위한 Finalization 과거화: 자원 정리를 위해 고안된 Finalization은 고유한 단점이 있습니다. 이를 과거화함으로써 더 안전하고 신뢰할 수 있는 대안들이 제공됩니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>미리보기 또는 인큐베이터 기능:</p>
<h2>가상 스레드:</h2>
<p>이 기능은 운영 체제 스레드 위에서 실행되는 가벼운 스레드를 소개하여 이를 통해 동시 프로그래밍을 간단히하고 특정 작업 부하의 성능을 향상시키는 것을 목표로합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아래는 Java 21에서 가상 스레드를 소개하는 간단한 데모입니다:</p>
<ul>
<li>가상 스레드 생성:</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-title class_">Thread</span> vThread1 = <span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">ofVirtual</span>().<span class="hljs-title function_">start</span>(() -> {
  <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">10</span>; i++) {
    <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"가상 스레드 1: "</span> + i);
  }
});

<span class="hljs-title class_">Thread</span> vThread2 = <span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">ofVirtual</span>().<span class="hljs-title function_">start</span>(() -> {
  <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">10</span>; i++) {
    <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"가상 스레드 2: "</span> + i);
  }
});
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ol start="2">
<li>완료 대기:</li>
</ol>
<pre><code class="hljs language-js">vThread1.<span class="hljs-title function_">join</span>();
vThread2.<span class="hljs-title function_">join</span>();
</code></pre>
<p>결과:</p>
<p>이렇게 하면 두 가상 스레드의 출력이 교차되어 풀 OS 스레드의 오버헤드 없이 동시 실행이 나타납니다. 다음과 같은 내용을 볼 수 있습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">가상 스레드 <span class="hljs-number">1</span>: <span class="hljs-number">0</span>
가상 스레드 <span class="hljs-number">2</span>: <span class="hljs-number">0</span>
가상 스레드 <span class="hljs-number">1</span>: <span class="hljs-number">1</span>
가상 스레드 <span class="hljs-number">2</span>: <span class="hljs-number">1</span>
...
가상 스레드 <span class="hljs-number">1</span>: <span class="hljs-number">9</span>
가상 스레드 <span class="hljs-number">2</span>: <span class="hljs-number">9</span>
</code></pre>
<p>가상 스레드 설명:</p>
<p>가상 스레드는 작은 기본 OS 스레드 풀 위에서 실행되는 가벼운 실행 단위입니다. 다음과 같은 여러 가지 장점을 제공합니다:</p>
<ul>
<li>가벼운 무게: OS 스레드와 비교하여, 가상 스레드는 생성 및 컨텍스트 전환 비용이 상당히 낮습니다.</li>
<li>개선된 병행성: 제한된 수의 OS 스레드 내에 효율적으로 더 많은 가상 스레드를 관리할 수 있어서, 특정 작업 부하에 대한 자원을 더 잘 활용할 수 있습니다.</li>
<li>단순화된 병행성 프로그래밍: 가상 스레드는 복잡한 스레드 관리와 동기화를 제거하여, 개발자들에게 병행 프로그래밍을 더 쉽게 만들어 줍니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다음은 가상 스레드의 예제이며 OS/플랫폼 스레드와 대조적입니다. 이 프로그램은 ExecutorService를 사용하여 10,000개의 작업을 생성하고 모든 작업이 완료될 때까지 기다립니다. JDK는 배완 스레드와 OS 스레드의 제한된 수에서 이를 실행하여 쉽게 동시 코드를 작성할 수 있도록 지원합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">try</span> (<span class="hljs-keyword">var</span> executor = <span class="hljs-title class_">Executors</span>.<span class="hljs-title function_">newVirtualThreadPerTaskExecutor</span>()) {
    <span class="hljs-title class_">IntStream</span>.<span class="hljs-title function_">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10_000</span>).<span class="hljs-title function_">forEach</span>(i -> {
        executor.<span class="hljs-title function_">submit</span>(() -> {
            <span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-title class_">Duration</span>.<span class="hljs-title function_">ofSeconds</span>(<span class="hljs-number">1</span>));
            <span class="hljs-keyword">return</span> i;
        });
    });
}  <span class="hljs-comment">// executor.close()는 암시적으로 호출되어 기다립니다</span>
</code></pre>
<h2>레코드 패턴 (프로젝트 앰버):</h2>
<p>레코드는 Java 14에서 미리보기로 도입되었으며, Java 열거형도 함께 제공되었습니다. record는 Java의 또 다른 특별한 종류이며, 클래스 개발 프로세스를 단순한 데이터 운반자로만 동작하는 클래스로 쉽게 만들 수 있도록 도와줍니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>JDK 21에서 레코드 패턴과 타입 패턴을 중첩하여 사용하여 데이터 탐색 및 처리를 선언적이고 조합 가능한 형태로 가능하게 되었습니다.</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// 레코드 생성하기:</span>

<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">Todo</span><span class="hljs-params">(String title, <span class="hljs-type">boolean</span> completed)</span>{}

<span class="hljs-comment">// 객체 생성하기:</span>

<span class="hljs-type">Todo</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Todo</span>(“Learn Java <span class="hljs-number">21</span>”, <span class="hljs-literal">false</span>);
</code></pre>
<p>JDK 21 이전에는 전체 레코드를 분해하여 액세서에 액세스해야 했습니다. 그러나 이제는 값들을 더 간단하게 얻을 수 있습니다. 예를 들어:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printTodo</span><span class="hljs-params">(Object obj)</span> {
    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title function_">Todo</span><span class="hljs-params">(String title, <span class="hljs-type">boolean</span> completed)</span>) {
        System.out.print(title);
        System.out.print(completed);
    }
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>레코드 패턴의 다른 장점은 중첩된 레코드 및 해당 값에 액세스하는 기능입니다. JEP 정의 자체에서 제시된 예시는 ColoredPoint에 중첩된 Rectangle 내부의 Point 값을 얻는 능력을 보여줍니다. 이전보다 더 유용해졌습니다. 이전에는 레코드를 매번 분해해야 했는데, 이제 중첩된 레코드의 값을 쉽게 얻을 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// Java 21부터</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printColorOfUpperLeftPoint</span>(<span class="hljs-params">Rectangle r</span>) {
    <span class="hljs-keyword">if</span> (r <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-title class_">ColoredPoint</span>(<span class="hljs-title class_">Point</span> p, <span class="hljs-title class_">Color</span> c),
                               <span class="hljs-title class_">ColoredPoint</span> lr)) {
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(c);
    }
}
</code></pre>
<h2>순차적 컬렉션:</h2>
<p>JDK 21에서는 새로운 컬렉션 인터페이스 세트가 소개되어 컬렉션 사용 경험을 향상시킵니다. 예를 들어, 컬렉션에서 요소의 역순을 얻고 싶다면, 사용 중인 컬렉션에 따라 번거로울 수 있습니다. 사용 중인 컬렉션에 따라 등장 순서를 가져오는 데 불일치가 있을 수 있습니다. 예를 들어, SortedSet은 하나를 구현하지만 HashSet는 그렇지 않기 때문에 서로 다른 데이터 세트에서 이 작업을 수행하는 것이 번거로울 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/assets/img/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements_2.png">
<p>이 문제를 해결하기 위해 SequencedCollection 인터페이스는 reverse 메서드를 추가하고 첫 번째 및 마지막 요소를 가져오는 기능을 제공하여 순서를 보장합니다. 또한 SequencedMap 및 SequencedSet 인터페이스도 있습니다.</p>
<pre><code class="hljs language-js">interface <span class="hljs-title class_">SequencedCollection</span>&#x3C;E> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Collection</span>&#x3C;E> {
    <span class="hljs-comment">// 새로운 메서드</span>
    <span class="hljs-title class_">SequencedCollection</span>&#x3C;E> <span class="hljs-title function_">reversed</span>();
    <span class="hljs-comment">// Deque에서 승급된 메서드</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span>(E);
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span>(E);
    E <span class="hljs-title function_">getFirst</span>();
    E <span class="hljs-title function_">getLast</span>();
    E <span class="hljs-title function_">removeFirst</span>();
    E <span class="hljs-title function_">removeLast</span>();
}
</code></pre>
<h2>문자열 템플릿:</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>문자열 템플릿은 JDK 21의 미리 보기 기능입니다. 그러나 이는 문자열 조작에 더 많은 신뢰성과 더 나은 경험을 제공하여 때로는 원하지 않는 결과로 이어질 수 있는 일반적인 함정을 피하기 위해 노력합니다. 이제 템플릿 표현식을 작성하고 문자열에서 렌더링할 수 있습니다.</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// Java 21부터</span>
<span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Ajay"</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">greeting</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Hello \{name}"</span>;
System.out.println(greeting);
</code></pre>
<p>이 경우 두 번째 줄이 표현식이며 호출시 Hello Ajay를 렌더링해야 합니다. 또한 보안 문제를 일으킬 수 있는 SQL 문 또는 HTML과 같은 불법적인 문자열의 가능성이 있는 경우 템플릿 규칙은 이스케이프된 따옴표만 허용하고 HTML 문서에서는 불법 엔티티를 허용하지 않습니다.</p>
<h1>읽어 주셔서 감사합니다.</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>👏 위 이야기에 박수를 보내주시고 저를 팔로우해주세요 👉</li>
<li>📰 미디엄에서 더 많은 콘텐츠를 읽어보세요 (자바 개발자 인터뷰에 관한 총 50개의 이야기)</li>
</ul>
<p>제 책들은 여기서 확인하실 수 있습니다:</p>
<ul>
<li>아마존에서 제공하는 <a href="Amazon">가이드: 명쾌한 자바 개발자 인터뷰 (킨들북)</a> 및 Gumroad (PDF 형식).</li>
<li>Gumroad에서 제공하는 [가이드: 명쾌한 스프링 부트 마이크로서비스 인터뷰 (PDF 형식)] 및 아마존 (킨들 eBook).</li>
<li>🔔 팔로우해보세요: LinkedIn | Twitter | YouTube</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"자바 8부터 자바 21까지의 포괄적인 여정 중요 API 개선 사항의 코드 예제","description":"","date":"2024-06-19 21:56","slug":"2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements","content":"\n## 안녕하세요 친구들, 이 기사에서는 다양한 Java 버전에 대해 이야기하고 싶습니다. 나는 Java 8부터 Java 21까지의 각 버전에서 소개된 모든 중요한 기능과 API를 다루고, 좀 더 심도있는 통찰력을 얻기 위해 코딩 예제를 제시하려고 합니다.\n\n이는 Java 초보자뿐만 아니라 Java 8이나 Java 11과 같은 오래된 버전의 Java에서 작업하고 있는 Java 개발자들에게 도움이 될 것입니다. 자바 세계에서 무슨 일이 일어나고 있는지업데이트하고 싶어 하는 사람들에게 유용할 것입니다.\n\n자 그럼 시작해봅시다,\n\n![이미지](/assets/img/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 특징:\n\n람다 표현식:\n\n- 익명 함수 사용으로 함수형 프로그래밍 가능.\n- 함수형 인터페이스 작성을 위한 간결한 구문.\n\n함수형 인터페이스:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 람다 표현식을 사용하는 데 도움이되는 단일 추상 메소드를 가진 인터페이스입니다.\n- @FunctionalInterface 어노테이션을 사용하여 해당 인터페이스를 표시합니다.\n\n스트림 API:\n\n- 요소 시퀀스를 처리하기 위해 Stream이라는 새로운 추상화를 소개합니다.\n- filter, map, reduce 등의 함수형 스타일 작업을 지원합니다.\n\n메소드 참조:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 람다 표현식에 대한 간편한 표기법을 제공합니다.\n- 메서드나 생성자를 :: 연산자를 사용하여 참조할 수 있습니다.\n\nOptional 클래스:\n\n- 비어 있을 수도 있고 비어 있지 않은 값을 포함할 수 있는 컨테이너 객체입니다.\n- null 체크를 더 효과적으로 처리하고 NullPointerException을 방지하는 데 도움이 됩니다.\n\n새로운 날짜 및 시간 API:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- java.time 패키지는 날짜와 시간을 다루는 보다 포괄적이고 유연한 API를 소개했습니다.\n- 이전의 java.util.Date 및 java.util.Calendar 클래스에서 발생한 다양한 문제를 해결합니다.\n\n기본 메소드:\n\n- 인터페이스에 메소드 구현을 허용합니다.\n- 기존 구현을 망가뜨리지 않고 인터페이스를 발전시키는 데 도움이 됩니다.\n\nNashorn JavaScript 엔진:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이전 Rhino JavaScript 엔진을 대체합니다.\n- 더 나은 성능을 제공하며 최신 JavaScript 표준과 더 호환됩니다.\n\nParallel Streams:\n\n- parallel() 메서드를 사용하여 스트림을 병렬 처리할 수 있습니다.\n- 특정 유형의 작업에서 멀티코어 시스템에서 성능을 향상시킵니다.\n\nCollectors:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 일반적인 축소 작업을 위한 Collectors 클래스의 유틸리티 메서드 집합을 소개합니다. 예를들어 toList(), toSet(), joining() 등이 있습니다.\n\njava.util.function 패키지의 함수형 인터페이스:\n\n- 람다 표현식을 지원하기 위해 Predicate, Function, Consumer 및 Supplier와 같은 새로운 함수형 인터페이스가 추가되었습니다.\n\n## 개선된 Process API:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 자바 9은 원시 프로세스를 더 잘 제어할 수 있도록 Process API에 개선 사항을 도입했습니다. 새로운 ProcessHandle 클래스를 사용하면 개발자가 프로세스와 관련된 정보를 얻고 상호 작용할 수 있습니다.\n\n```js\n// ProcessHandle API를 사용하여 현재 프로세스에 대한 정보 가져오기\npublic class ProcessHandleExample {\n    public static void main(String[] args) {\n        ProcessHandle currentProcess = ProcessHandle.current();\n        System.out.println(\"프로세스 ID: \" + currentProcess.pid());\n        System.out.println(\"실행 중? \" + currentProcess.isAlive());\n    }\n}\n```\n\n## 컬렉션 팩토리 메서드:\n\n- 자바 9에서는 컬렉션 인터페이스(List, Set, Map 등)에 새로운 정적 팩토리 메서드를 추가하여 이러한 컬렉션의 불변 인스턴스를 더 편리하게 생성할 수 있게 했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport java.util.List;\n\npublic class CollectionFactoryMethodsExample {\n    public static void main(String[] args) {\n        // List.of() 팩토리 메서드를 사용하여 변경할 수 없는 목록 생성\n        List\u003cString\u003e colors = List.of(\"Red\", \"Green\", \"Blue\");\n        System.out.println(colors);\n    }\n}\n```\n\n## 향상된 스트림 API:\n\n- takeWhile, dropWhile, ofNullable과 같은 여러 새로운 메서드로 스트림 API가 향상되어 스트림 작업의 유연성과 기능성을 향상시켰습니다.\n\n```js\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class StreamAPIImprovementsExample {\n    public static void main(String[] args) {\n        // 예시 1: takeWhile\n        List\u003cInteger\u003e numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n        List\u003cInteger\u003e lessThanFive = numbers.stream()\n                .takeWhile(n -\u003e n \u003c 5)\n                .collect(Collectors.toList());\n\n        System.out.println(\"5보다 작은 숫자: \" + lessThanFive);\n\n        // 예시 2: dropWhile\n        List\u003cInteger\u003e greaterThanThree = numbers.stream()\n                .dropWhile(n -\u003e n \u003c= 3)\n                .collect(Collectors.toList());\n\n        System.out.println(\"3보다 큰 숫자: \" + greaterThanThree);\n\n        // 예시 3: ofNullable\n\n        // 예시 3: ofNullable\n        String value1 = \"안녕\";\n        String value2 = null;\n\n        // null이 아닌 값이 있는 예시\n        Stream.ofNullable(value1)\n                .ifPresentOrElse(v -\u003e System.out.println(\"ofNullable 예제 - null이 아닌 값: \" + v),\n                        () -\u003e System.out.println(\"ofNullable 예제 - null 값\"));\n\n        // null 값이 있는 예시\n        Stream.ofNullable(value2)\n                .ifPresentOrElse(v -\u003e System.out.println(\"ofNullable 예제 - null이 아닌 값: \" + v),\n                        () -\u003e System.out.println(\"ofNullable 예제 - null 값\"));\n\n        // null 안전한 스트림 예시\n        List\u003cString\u003e names = Arrays.asList(\"Alice\", \"Bob\", null, \"Charlie\", null, \"David\");\n        List\u003cString\u003e nonNullNames = names.stream()\n                .flatMap(name -\u003e StreamAPIImprovementsExample.nullSafeStream(name))\n                .collect(Collectors.toList());\n\n        System.out.println(\"null이 아닌 이름: \" + nonNullNames);\n    }\n\n    // 잠재적으로 null인 값을 스트림으로 만드는 헬퍼 메서드\n    private static \u003cT\u003e java.util.stream.Stream\u003cT\u003e nullSafeStream(T value) {\n        return value == null ? java.util.stream.Stream.empty() : java.util.stream.Stream.of(value);\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예제에서:\n\n- takeWhile은 특정 조건이 충족될 때까지 스트림에서 요소를 가져오는 데 사용됩니다 (이 경우에는 5보다 작은 숫자).\n- dropWhile은 특정 조건이 충족될 때까지 스트림에서 요소를 삭제하는 데 사용됩니다 (이 경우에는 3 이하의 숫자).\n- ofNullable은 잠재적으로 null인 값을 사용하여 스트림을 생성하고 null 값을 필터링하여 null 이름을 제외합니다.\n\n## 인터페이스의 비공개 메서드:\n\n- Java 9의 인터페이스는 비공개 메서드를 가질 수 있습니다. 이를 통해 공통 기능을 인터페이스 내에 캡슐화하여 외부 클래스에 노출하지 않고 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// 프라이빗 메서드를 가진 인터페이스\npublic interface PrivateMethodInterface {\n    default void publicMethod() {\n        // 퍼블릭 메서드에서 프라이빗 메서드 호출 가능\n        privateMethod();\n    }\n\n    private void privateMethod() {\n        System.out.println(\"인터페이스 안의 프라이빗 메서드\");\n    }\n}\n```\n\nHTTP/2 클라이언트:\n\n- Java 9에서는 HTTP/2 및 WebSocket을 지원하는 새로운 가벼운 HTTP 클라이언트가 도입되었습니다. 이 클라이언트는 예전 HttpURLConnection API보다 효율적이고 유연하게 설계되었습니다.\n\n```java\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\n\npublic class HttpClientExample {\n    public static void main(String[] args) throws Exception {\n        HttpClient httpClient = HttpClient.newHttpClient();\n        HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(new URI(\"https://www.example.com\"))\n                .GET()\n                .build();\n\n        HttpResponse\u003cString\u003e response = httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString());\n        System.out.println(\"응답 코드: \" + response.statusCode());\n        System.out.println(\"응답 본문: \" + response.body());\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n로컬 변수 타입 추론 (var):\n\n- 자바 10에서는 var 키워드를 사용하여 로컬 변수 타입 추론 기능을 도입했습니다. 이를 통해 개발자는 타입을 명시적으로 지정하지 않고 로컬 변수를 선언할 수 있으며, 할당된 값에 기반하여 컴파일러가 추론하도록 합니다.\n\n```js\npublic class LocalVarInference {\n\n    /**\n     * 허용: 로컬 변수로만 사용\n     * 허용되지 않음: 클래스 필드, 메소드 매개변수 등 다른 곳 (멤버 변수, 여타곳)\n     * var 키워드 책임있게 사용하는 것이 좋습니다!\n     *\n     * 사용 사례:\n     *  - 타입이 명확한 경우 (문자열, 정수)\n     *  - 너무 긴, 복잡한 타입을 줄이기 위하여\n     *\n     * 사용하지 말아야 할 때:\n     *      - 반환 값이 명확하지 않은 경우 (var data = service.getData();)\n     */\n\n    public static void main(String[] args) {\n\n        // 허용되지만 장점이 별로 없음\n        var b = \"b\";\n        var c = 5; // int\n        var d = 5.0; // double\n        var httpClient = HttpClient.newHttpClient();\n\n        // 추론할때 쉬운 경우 :)\n        var list = List.of(1, 2.0, \"3\");\n\n        // 이름이 긴 타입일 때 장점이 더욱 분명해집니다\n        var reader = new BufferedReader(null);\n        // vs.\n        BufferedReader reader2 = new BufferedReader(null);\n    }\n}\n```\n\nOptional API - 새로운 메소드가 도입되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic class OptionalApi {\n\n    /**\n     * 새로운 .orElseThrow() 메서드\n     */\n    public static void main(String[] args) {\n\n        Optional\u003cFlight\u003e earliestFlight = FlightSchedule.getFlights()\n                .stream()\n                .filter(f -\u003e \"Boston\".equals(f.from()))\n                .filter(f -\u003e \"San Francisco\".equals(f.to()))\n                .min(comparing(Flight::date));\n\n        earliestFlight.orElseThrow(FlightNotFoundException::new);\n    }\n}\n```\n\nHTTP client\n\n```java\npublic class HttpClientBasicExample {\n\n    /**\n     * 클라이언트 생성, GET 요청 보내기, 응답 정보 출력\n     */\n    public static void main(String... args) throws Exception {\n        HttpClient client = HttpClient.newHttpClient();\n\n        HttpRequest request =\n                HttpRequest.newBuilder(URI.create(\"https://github.com/\"))\n                        .GET()  // 기본값, 생략 가능\n                        .build();\n\n        HttpResponse\u003cString\u003e response =\n                client.send(request, HttpResponse.BodyHandlers.ofString());\n\n        print(\"상태 코드: \" + response.statusCode());\n\n        print(response.headers().map());\n    }\n}\n```\n\n## 새로운 파일 메서드:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJava 11에서는 java.nio.file 패키지에 여러 가지 새로운 메서드가 추가되었는데, 파일 및 디렉토리 작업에 대한 추가 기능을 제공합니다. 주목할 만한 몇 가지 메서드는 다음과 같습니다:\n\n- Files.readString(Path path) 및 Files.writeString(Path path, CharSequence content, OpenOption... options):\n\n- 이러한 메서드를 사용하여 파일의 내용을 문자열로 읽고 쓰는 작업을 간단하게 처리할 수 있습니다. readString 메서드는 파일의 전체 내용을 문자열로 읽어오고, writeString 메서드는 문자열을 파일에 씁니다.\n\n2. Files.readAllLines(Path path) 및 Files.write(Path path, Iterable\u003c? extends CharSequence\u003e lines, OpenOption... options):\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이러한 메서드는 파일 내용을 문자열 목록으로 읽고 쓰는 작업을 간단하게 해줍니다. readAllLines 메서드는 파일에서 모든 줄을 목록으로 읽고, write 메서드는 문자열 컬렉션을 파일에 쓰기 위한 메서드입니다.\n\n3. Files.newBufferedReader(Path path) 및 Files.newBufferedWriter(Path path, OpenOption... options):\n\n- 이러한 메서드는 파일을 효율적으로 읽고 쓰기 위한 버퍼드 리더와 라이터를 생성합니다. 이들은 문자 스트림을 다루는 프로세스를 간단하게 합니다.\n\n4. files.mismatch(Path path1, Path path2):\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이 메서드는 두 파일의 내용을 비교하여 첫 번째 불일치하는 바이트의 위치를 반환합니다. 파일이 동일한 경우 -1을 반환합니다.\n\n```js\npublic class NewFilesMethods {\n\n    static String filePath = System.getProperty(\"user.dir\") + \"/src/main/resources/\";\n    static String file_1 = filePath + \"file_1.txt\";\n\n    /**\n     * Files.readString() and .writeString()\n     */\n    public static void main(String[] args) throws IOException {\n\n        // 파일 읽기가 이제 훨씬 쉬워졌습니다.\n        // 대용량 파일과 사용하면 안됨\n        Path path = Paths.get(file_1);\n        String content = Files.readString(path);\n        print(content);\n\n        Path newFile = Paths.get(filePath + \"newFile.txt\");\n        if(!Files.exists(newFile)) {\n            Files.writeString(newFile, \"some str\", StandardOpenOption.CREATE);\n        } else {\n            Files.writeString(newFile, \"some str\", StandardOpenOption.TRUNCATE_EXISTING);\n        }\n    }\n}\n```\n\n## 콤팩트 숫자 포맷팅:\n\nJava 12에서 JEP 357의 일환으로 \"콤팩트 숫자 포맷팅\"이라는 새로운 기능이 소개되었습니다. 이 개선은 지역별 방식으로 대형 숫자를 더 간결하게 포맷하는 방법을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\njava.text 패키지의 NumberFormat 클래스가 새로운 Style enum을 지원할 수 있도록 업데이트되었습니다. 이 Style에는 Style.SHORT 및 Style.LONG 상수가 포함되어 있습니다. 이러한 스타일은 특정 로케일에 기반해 큰 숫자를 간결한 형태로 포맷하는 데 사용할 수 있습니다.\n\n```java\nimport java.text.NumberFormat;\nimport java.util.Locale;\n\npublic class CompactNumberFormattingExample {\n    public static void main(String[] args) {\n        // 컴팩트 스타일의 숫자 포매터 생성\n        NumberFormat compactFormatter = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);\n\n        // 큰 숫자 형식화\n        System.out.println(\"Short Format: \" + compactFormatter.format(1000));  // 결과: 1K\n        System.out.println(\"Short Format: \" + compactFormatter.format(1000000));  // 결과: 1M\n\n        // 긴 형식의 컴팩트 스타일 숫자 포매터 생성\n        NumberFormat compactLongFormatter = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.LONG);\n\n        // 긴 스타일로 큰 숫자 형식화\n        System.out.println(\"Long Format: \" + compactLongFormatter.format(10000000));  // 결과: 10 million\n        System.out.println(\"Long Format: \" + compactLongFormatter.format(1000000000));  // 결과: 1 billion\n    }\n}\n```\n\n## String::indent (JEP 326):\n\n- Java 12의 String 클래스에는 indent(int n)이라는 새로운 메서드가 도입되었습니다. 이 메서드는 문자열의 각 줄의 들여쓰기를 지정된 공백 수만큼 조정하는 데 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\nString indentedString = \"Hello\\nWorld\".indent(3);\n// indentedString이 이제 \"   Hello\\n   World\"가 됩니다.\n```\n\njava.util.Arrays에 추가된 새로운 메서드 (JEP 326):\n\n- Java 12에서는 java.util.Arrays 클래스에 copyOfRange 및 Comparator를 사용하는 equals 변형 등을 포함한 여러 새로운 메서드가 추가되었습니다.\n\njava.util.stream.Collectors의 개선 사항 (JEP 325):\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Java 12에서 도입된 Collectors 유틸리티 클래스에는 teeing과 같은 새로운 수집기가 추가되었는데, 이를 사용하면 두 개의 수집기를 결합하여 하나의 수집기로 만들 수 있습니다.\n\n## 새로운 파일 메소드:\n\n```js\npublic class NewFilesMethod {\n\n    static String filePath = System.getProperty(\"user.dir\") + \"/src/main/resources/\";\n    static String file_1 = filePath + \"file_1.txt\";\n    static String file_2 = filePath + \"file_2.txt\";\n\n    public static void main(String[] args) throws IOException {\n\n        // 두 파일의 내용에서 첫 번째 불일치하는 바이트의 위치를 찾아 반환합니다.\n        // 불일치가 없는 경우 -1L을 반환합니다.\n        long result = Files.mismatch(Paths.get(file_1), Paths.get(file_2));\n\n        print(result);      // -1\n    }\n}\n```\n\n특별히 흥미로운 일은 없었습니다:\n\n- ByteBuffer에 대한 API 업데이트\n- 지역화 업데이트 (새로운 문자 및 이모지 지원)\n- GC 업데이트\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## “Switch Expressions” (SE) 대신 “Switch Statements” (SS):\n\n향상된 Switch 표현식:\n\n- Java 12에서 미리보기 기능으로 소개되었으며 Java 13에서 최종화된 스위치 표현식은 개발자들이 switch 문을 표현식으로 사용할 수 있도록 해주어 더 간결하고 표현력 있는 구문을 제공합니다.\n\n```java\nint dayOfWeek = 2;\nString dayType = switch (dayOfWeek) {\n    case 1, 2, 3, 4, 5 -\u003e \"평일\";\n    case 6, 7 -\u003e \"주말\";\n    default -\u003e throw new IllegalArgumentException(\"유효하지 않은 요일: \" + dayOfWeek);\n};\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"수확\" 문장:\n\n- \"수확\" 문장은 스위치 표현식을 보완하기 위해 Java 14에서 소개되었습니다. 이를 사용하여 스위치 암에서 반환할 값을 지정할 수 있어, 명령형과 함수형 스타일을 융합하는 데 더 많은 유연성을 제공합니다.\n\n```js\nString dayType = switch (dayOfWeek) {\n    case 1, 2, 3, 4, 5 -\u003e {\n        System.out.println(\"근무일\");\n        yield \"평일\";\n    }\n    case 6, 7 -\u003e {\n        System.out.println(\"주말\");\n        yield \"주말\";\n    }\n    default -\u003e throw new IllegalArgumentException(\"유효하지 않은 요일: \" + dayOfWeek);\n};\n```\n\n또 다른 예시,\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\n/**\n * \"스위치 표현식\" (SE) 대신 \"스위치 문\" (SS)\n * (둘 다 사용할 수 있지만 SE가 SS보다 낫습니다)\n */\npublic class SwitchExpressions {\n\n    public static void main(String[] args) {\n\n        oldStyleWithBreak(FruitType.APPLE);\n\n        withSwitchExpression(FruitType.PEAR);\n\n        switchExpressionWithReturn(FruitType.KIWI);\n\n        switchWithYield(FruitType.PINEAPPLE);\n    }\n\n    // 예전 방식은 더 복잡하고 오류 발생 가능성이 높음 (\"break;\"을 잊으면 switch가 지나가버릴 수 있음)\n    private static void oldStyleWithBreak(FruitType fruit) {\n        print(\"==== break를 사용한 예전 방식 ====\");\n        switch (fruit) {\n            case APPLE, PEAR:\n                print(\"보통 과일\");\n                break;\n            case PINEAPPLE, KIWI:\n                print(\"이국적인 과일\");\n                break;\n            default:\n                print(\"정의되지 않은 과일\");\n        }\n    }\n\n    private static void withSwitchExpression(FruitType fruit) {\n        print(\"==== 스위치 표현식을 사용한 방식 ====\");\n        switch (fruit) {\n            case APPLE, PEAR -\u003e print(\"보통 과일\");\n            case PINEAPPLE -\u003e print(\"이국적인 과일\");\n            default -\u003e print(\"정의되지 않은 과일\");\n        }\n    }\n\n    private static void switchExpressionWithReturn(FruitType fruit) {\n        print(\"==== 반환 값이 있는 경우 ====\");\n\n        // 직접 \"return switch\"을 사용할 수도 있음\n        String text = switch (fruit) {\n            case APPLE, PEAR -\u003e \"보통 과일\";\n            case PINEAPPLE -\u003e \"이국적인 과일\";\n            default -\u003e \"정의되지 않은 과일\";\n        };\n        print(text);\n    }\n\n    /**\n     * \"Yield\"는 \"return\"과 비슷하지만 중요한 차이가 있음:\n     * \"yield\"는 값을 반환하고 switch 문을 종료함. 실행은 특정 메서드 내에서 유지됨\n     * \"return\"은 switch문 및 특정 메서드를 종료함\n     */\n    // https://stackoverflow.com/questions/58049131/what-does-the-new-keyword-yield-mean-in-java-13\n    private static void switchWithYield(FruitType fruit) {\n        print(\"==== yield를 사용한 경우 ====\");\n        String text = switch (fruit) {\n            case APPLE, PEAR -\u003e {\n                print(\"주어진 과일은: \" + fruit);\n                yield \"보통 과일\";\n            }\n            case PINEAPPLE -\u003e \"이국적인 과일\";\n            default -\u003e \"정의되지 않은 과일\";\n        };\n        print(text);\n    }\n\n    public enum FruitType {APPLE, PEAR, PINEAPPLE, KIWI}\n}\n```\n\n## 텍스트 블록\n\n텍스트 블록은 여러 줄에 걸친 문자열 리터럴을 나타내는 새로운 유형의 리터럴입니다. 여러 줄에 걸친 소스 코드의 문자열을 작성하고 유지하는 작업을 간단하게 만들면서 이스케이프 시퀀스를 피하려고 합니다.\n\n텍스트 블록을 사용하지 않은 예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nString html = \"\"\"\n\u003chtml\u003e\n    \u003cbody\u003e\n        \u003cp\u003eHello, world\u003c/p\u003e\n    \u003c/body\u003e\n\u003c/html\u003e\n\"\"\";\n```\n\n텍스트 블록의 주요 기능은 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 여러 줄 문자열: 텍스트 블록을 사용하면 여러 줄 문자열을 더 자연스럽게 표현할 수 있어 코드 가독성을 향상시킵니다.\n- 공백 제어: 각 줄의 시작과 끝 공백이 제거되어 들여쓰기를 더 잘 제어할 수 있습니다.\n- 이스케이프 시퀀스: 텍스트 블록 내에서 이스케이프 시퀀스는 여전히 유효하며 특수 문자를 포함할 수 있습니다.\n\n텍스트 블록은 HTML, XML, JSON 또는 SQL 쿼리와 같은 여러 줄 콘텐츠를 포함하는 문자열을 더 쉽게 표현할 수 있도록 설계되었습니다. Java 15나 이후 버전에서 텍스트 블록과 관련된 업데이트나 새로운 기능이 있었을 경우 해당 버전의 공식 문서나 릴리스 노트를 확인하는 것이 좋습니다.\n\n```js\n/**\n * TextBlocks에 대한 사용 사례 (Java 15의 새로운 기능 \u003e Text Blocks in Practice)\n * - 마크다운을 사용한 텍스트 블록\n * - 테스트, 하드 코딩된 JSON 문자열 정의\n * - 간단한 템플릿\n */\npublic class TextBlocks {\n\n    public static void main(String[] args) {\n        oldStyle();\n        emptyBlock();\n        jsonBlock();\n        jsonMovedEndQuoteBlock();\n        jsonMovedBracketsBlock();\n    }\n\n    private static void oldStyle() {\n        print(\"******** 기존 스타일 ********\");\n\n        String text = \"{\\n\" +\n                \"  \\\"name\\\": \\\"John Doe\\\",\\n\" +\n                \"  \\\"age\\\": 45,\\n\" +\n                \"  \\\"address\\\": \\\"Doe Street, 23, Java Town\\\"\\n\" +\n                \"}\";\n        print(text);\n    }\n\n    private static void emptyBlock() {\n        print(\"******** 빈 블록 ********\");\n        String text = \"\"\"\n                \"\"\";\n        print(\"|\" + text + \"|\");\n    }\n\n    private static void jsonBlock() {\n        print(\"******** JSON 블록 ********\");\n\n        String text = \"\"\"\n                {\n                  \"name\": \"John Doe\",\n                  \"age\": 45,\n                  \"address\": \"Doe Street, 23, Java Town\"\n                }\n                \"\"\"; // \u003c-- 첫 번째 \" 문자와 정렬되어 있으면 들여쓰기 없음\n        print(text);\n    }\n\n    private static void jsonMovedEndQuoteBlock() {\n        print(\"******** JSON 이동된 끝 따옴표 블록 ********\");\n\n        String text = \"\"\"\n                  {\n                    \"name\": \"John Doe\",\n                    \"age\": 45,\n                    \"address\": \"Doe Street, 23, Java Town\"\n                  }\n                       \"\"\";\n        print(text);\n    }\n\n    private static void jsonMovedBracketsBlock() {\n        print(\"******** JSON 이동된 괄호 블록 ********\");\n\n        String text = \"\"\"\n                  {\n                    \"name\": \"John Doe\",\n                    \"age\": 45,\n                    \"address\": \"Doe Street, 23, Java Town\"\n                  }\n                \"\"\"; // \u003c-- 세 번째 \" 문자와 정렬되어 2칸 들여쓰기\n        print(text);\n    }\n}\n```\n\n## instanceof에 대한 패턴 매칭:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바 16의 instanceof에 대한 패턴 매칭은 유용한 기능으로 형식 검사와 추출을 개선합니다. 여기에 이 기능의 주요 측면을 요약해 두었어요:\n\n기능:\n\n- 단일 형식 대신 타입 패턴을 소개합니다.\n- instanceof 검사 내에서 추출된 객체를 보유할 변수를 선언할 수 있습니다.\n- 형식 검사 및 캐스팅을 더 간결하고 가독성 있게 결합한 표현입니다.\n\n혜택:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 번거로운 코드 줄이기: 별도의 instanceof 확인, 형 변환 및 변수 선언이 필요 없게 합니다.\n- 가독성 향상: 코드가 더 명확해지고 복잡한 유형 계층 구조에 대해 이해하기 쉬워집니다.\n- 오류 감소: 잘못된 유형으로 인한 캐스트 예외 발생 가능성이 줄어듭니다.\n\n구문\n\n```javascript\nif (obj instanceof String s) {\n  // 여기서 \"s\"를 String으로 직접 사용\n} else if (obj instanceof List\u003cInteger\u003e list) {\n  // 여기서 \"list\"를 List \u003cInteger\u003e로 직접 사용\n} else {\n  // 다른 경우 처리\n}\n```\n\n예제\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic class PatternMatchingForInstanceof {\n\n    public static void main(String[] args) {\n\n        Object o = new Book(\"Harry Potter\", Set.of(\"Jon Doe\"));\n\n        // 옛날 방식\n        if (o instanceof Book) {\n            Book book = (Book) o;\n            print(\"The book's author(s) are \" + book.getAuthors());\n        }\n\n        // 새 방식\n        if (o instanceof Book book) {\n            print(\"The book's author(s) are \" + book.getAuthors());\n        }\n\n    }\n}\n```\n\n## 레코드:\n\n자바의 레코드는 변경할 수 없는 데이터를 보관하기 위해 특별히 설계된 특수한 유형의 클래스입니다. 이는 단순한 데이터 구조를 처리할 때 보일러플레이트 코드를 줄이고 가독성 및 유지보수성을 향상시킬 수 있도록 도와줍니다.\n\n- 이들의 주요 특성을 살펴봅시다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n1. 간결함:\n\n- 기존 클래스와는 달리 레코드는 정의하는 데 필요한 코드가 최소화됩니다. 레코드 선언에서 데이터 필드(구성 요소)만 지정하면 됩니다. 그러면 컴파일러가 다음과 같은 필수 메서드를 자동으로 생성합니다:\n- 각 구성 요소에 대한 매개변수가 있는 생성자.\n- 각 구성 요소에 대한 게터.\n- 구성 요소 값을 기반으로 한 equals 및 hashCode 메서드.\n- 레코드의 상태를 나타내는 toString 메서드.\n\n2. 변경 불가능성:\n\n- 레코드 필드는 final로 선언되어 있어, 레코드가 생성된 후에는 그 내부에 저장된 데이터를 변경할 수 없습니다. 이는 데이터 일관성을 보장하고 스레드 안전성에 대한 고려사항을 단순화합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 가독성:\n\n- 레코드의 자동 생성 메서드와 예측 가능한 동작은 코드 가독성을 향상시키고 레코드가 어떤 것을 나타내며 프로그램의 다른 부분과 어떻게 상호 작용하는지 이해하기 쉽게 만듭니다.\n\n4. 오류 감소:\n\n- 보일러플레이트를 최소화함으로써 레코드는 getter를 잊거나 equals를 잘못 구현하는 것과 같은 일반적인 실수의 위험을 줄입니다. 이는 더 견고하고 신뢰할 수 있는 코드로 이어집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n전반적으로 레코드는 Java 개발자가 간결하고 불변 그리고 가독성 좋은 데이터 구조를 만드는 데 유용한 도구입니다. 이는 보다 깔끔하고 유지보수 가능한 코드를 유도합니다.\n\n```js\n/**\n * 레코드는 데이터 전용 불변 클래스입니다 (따라서 특정한 사용 사례가 있음)\n * 클래스의 특정 형태(예: enum과 같은)로 제한된(전문화된) 형태입니다\n * 상태 변경 등을 의도한 객체에는 적합하지 않습니다.\n * \u003cp\u003e\n * 레코드는 다음과 관련이 없습니다:\n * - 보일러플레이트 감소 기법\n * \u003cp\u003e\n * 레코드는 생성자, 게터, 필드; equals, hashCode, toString을 생성합니다\n * \u003cp\u003e\n * 사용 사례:\n * - 불변 데이터 모델링\n * - 데이터를 읽기 전용으로 메모리에 보관\n * - DTOs - 데이터 전송 객체\n */\npublic class RecordsDemo {\n\n    public static void main(String[] args) {\n        Product p1 = new Product(\"우유\", 50);\n        Product p2 = new Product(\"우유\", 50);\n\n        print(p1.price()); // \"get\" 접두사 없이 사용\n        print(p1);         // 자동으로 생성된 toString() 출력- Product[name=우유, price=50]\n\n        print(p1 == p2);       // false    - 다른 객체\n        print(p1.equals(p2));  // true     - 값들(milk, 50)은 auto-generated equals()/hashCode()에 의해 비교됨\n    }\n}\n\n/**\n * 매개변수를 \"Components\"라고 함\n * 더 많은 필드 원할 시, 시그니처에 추가 필요\n * 확장은 허용되지 않지만 인터페이스 구현은 가능\n */\npublic record Product(String name, int price) {\n\n    // 정적 필드는 가능하지만 비정적은 허용하지 않음\n    static String country = \"US\";\n\n    // 모든 필드를 가진 생성자가 생성됨\n\n    // Validation 추가 가능\n    public Product {\n        if(price \u003c 0) {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    // toString()과 같은 auto-generated 메소드들 오버라이딩 가능\n}\n```\n\n## 날짜 및 시간 형식 API:\n\n- Java 16의 DateTimeFormatter API의 일반적 사용법 및 기능: 형식 패턴 이해, 사용자 정의 형식 생성, 날짜 및 시간 구문 분석, 사용 가능한 형식 설정 포함\n- Java 16에서 소개된 날짜 형식팅을 위한 새로운 기능: 특히 \"B\" 심볼과 다양한 스타일을 사용한 일시 지원\n- SimpleDateFormat과 같은 이전 서식기와 DateTimeFormatter의 비교: 각 접근 방식의 장단점 탐색\n- 특정 형식 작업에 DateTimeFormatter 사용 예제: 다양한 로케일에서 날짜 형식화, 타임존 처리, 더 사람이 이해하기 쉬운 표현 생성하기 등을 포함하여.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic class DateTimeFormatterApi {\n\n    static Map\u003cTextStyle, Locale\u003e map = Map.of(\n            TextStyle.FULL, Locale.US,\n            TextStyle.SHORT, Locale.FRENCH,\n            TextStyle.NARROW, Locale.GERMAN\n    );\n\n    public static void main(String[] args) {\n\n        for (var entry : map.entrySet()) {\n\n            LocalDateTime now = LocalDateTime.now();\n            DateTimeFormatter formatter = new DateTimeFormatterBuilder()\n                    .appendPattern(\"yyyy-MM-dd hh:mm \")\n                    .appendDayPeriodText(entry.getKey())    // at night, du soir, abends, etc.\n                    .toFormatter(entry.getValue());\n\n            String formattedDateTime = now.format(formatter);\n            print(formattedDateTime);\n        }\n    }\n}\n```\n\n## Stream API의 변경 사항:\n\nJava 16에서 Stream API에 흥미로운 변경 사항이 있었습니다. 더욱 강력하고 편리하게 사용할 수 있게 되었습니다. 주요 하이라이트는 다음과 같습니다:\n\n1. Stream.toList() 메서드: 이 새로운 메서드는 스트림의 요소를 목록으로 수집하는 간결한 방법을 제공합니다. 이전에는 collect(Collectors.toList())를 사용해야 했지만, 이제는 약간 중복된 방법입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. Stream.mapMulti() 메소드: 이 메소드를 사용하면 스트림의 각 요소를 제로 또는 그 이상의 요소로 매핑하여 결과 요소의 새로운 스트림을 생성할 수 있습니다. 복잡한 데이터 구조를 분할하거나 펼치는 데 편리합니다.\n\n3. 향상된 줄 바꿈 처리: Java 16에서 java.io.LineNumberReader 클래스에서 줄 바꿈자를 정의하는 방법을 명확히하였습니다. 이는 모순을 제거하고 줄 기반 데이터를 읽을 때 일관된 동작을 보장합니다.\n\n4. 기타 작은 변경점:\n\n- 이제 문자열 스트림은 중간 작업이 필요하지 않고 limit 및 skip 메소드를 직접 지원합니다.\n- peek 메소드를 병렬 스트림과 함께 사용할 수 있으므로 병렬성에 영향을주지 않고 부작용을 발생시킬 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic class StreamApi {\n\n    public static void main(String[] args) {\n\n        List\u003cInteger\u003e ints = Stream.of(1, 2, 3)\n                .filter(n -\u003e n \u003c 3)\n                .toList();  // new, instead of the verbose .collect(Collectors.toList())\n\n        ints.forEach(System.out::println);\n\n    }\n}\n```\n\n## Sealed classes(Subclassing):\n\nSealed 클래스는 Java 17 (JEP 409)에서 소개된 새로운 기능으로 상속 계층구조에 대해 더 많은 제어를 제공합니다. 본질적으로 클래스나 인터페이스를 확장하거나 구현하는 것을 제한할 수 있습니다. 이는 다양한 이유로 매우 유용할 수 있습니다:\n\n1. 향상된 타입 안전성: 허용된 하위 클래스를 명시함으로써 코드를 손상시키거나 보안 취약점을 도입할 수 있는 예기치 않은 확장을 방지합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. 개선된 라이브러리 디자인: 라이브러리 내에서 폐쇄된 생태계를 만들 수 있어서, 사용자가 승인된 확장 기능만 사용하고 호환되지 않는 구현을 만들지 않도록 보장할 수 있습니다.\n\n3. 쉬운 코드 유지 관리: 가능한 서브클래스 집합을 정확히 알면 코드에 대한 추론이 간단해지며 이해와 유지보수가 쉬워집니다.\n\nsealed 클래스는 어떻게 작동합니까?\n\nsealed 키워드를 사용하여 클래스 또는 인터페이스를 sealed로 선언합니다. 그런 다음 permits 절을 사용하여 확장하거나 구현할 수 있는 클래스 목록을 지정합니다. 이 허용된 클래스만 직접 상속할 수 있고, 다른 모든 클래스는 금지됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nsealed class Shape {\n  permits Circle, Square, Triangle;\n  // ... 구현 세부사항\n}\n\nclass Circle extends Shape {\n  // ...\n}\n\n// 사각형이 허용되지 않아 컴파일 오류가 발생합니다\nclass Rectangle extends Shape {\n  // ...\n}\n```\n\n봉인된 클래스나 인터페이스는 지정된 클래스와 인터페이스만이 상속하거나 구현할 수 있습니다.\n\n이점:\n\n- 1. 의도를 전달하여 잘 정의되고 제한된 가능한 구현을 강제화할 수 있음\n- 2. 더 나은 보안 — 제 3자 코드로부터의 예기치 않은 또는 무단 서브클래싱과 행위 예방을 돕습니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n규칙:\n\n- 1. sealed 클래스는 \"permits\"를 사용하여 다른 클래스가 하위 클래스로 지정될 수 있게 합니다.\n- 2. 하위 클래스는 반드시 final, sealed 또는 non-sealed 이어야 합니다. (그렇지 않으면 코드가 컴파일되지 않습니다)\n- 3. 허용된 하위 클래스는 상위 sealed 클래스를 확장해야 합니다. permit을 사용하지 않고 허용하는 것은 허용되지 않습니다.\n- 4. permits로 지정된 클래스들은 상위 클래스와 근접하게 위치해야 합니다:\n  - 동일한 모듈에 있어야 합니다 (상위 클래스가 명명된 모듈에 있는 경우) (Java 9 모듈화 참조)\n  - 동일한 패키지에 있어야 합니다 (상위 클래스가 무명 모듈에 있는 경우).\n\n4번 항목에 대한 더 자세한 내용:\n\n- Sealed 클래스와 그 (직접적인) 하위 클래스는 함께 컴파일되고 유지되어야 하기 때문에 밀접하게 결합됩니다.\n- 모듈화된 환경에서는 \"동일한 모듈\"; 모듈화되지 않은 환경에서는 이를 가장 잘 나타내는 것이 \"동일한 패키지\"입니다.\n- 모듈을 사용한다면 모듈이 제공하는 안전한 경계 때문에 몇 가지 추가적인 유연성을 얻을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 기본 UTF-8 설정:\n\nJava 18에서는 플랫폼의 기본 문자 인코딩이 UTF-8로 변경되었습니다. 이는 현대 표준에 맞추어 문자 처리를 간소화하고 있습니다.\n\n```js\npublic class Utf8ByDefault {\n\n    // https://openjdk.org/jeps/400 - Platform Default Encoding\n\n    public static void main(String[] args) throws IOException {\n\n        // 문제:\n        // 1) 윈도우에서는 아스키 테이블 외의 문자, 예를 들어 특이한 유니코드 문자,을 지정하지 않고 FileWriter을 사용하여 쓰기\n        // 2) 파일을 맥과 같은 UNIX 기반 OS로 복사하거나 전송한 다음 시스템의 기본 문자 인코딩을 사용하여 파일을 읽음\n        // 3) 예상되는 결과 - 엉망인 출력\n        // 따라서 문제는 예측불가능한 동작입니다.\n        FileWriter writer = new FileWriter(\"out.txt\");\n\n        // Java 18 이전의 해결책: 항상 문자 집합을 지정하십시오 (그리고 그것을 잊지 않도록 행운을 빕니다!)\n        FileWriter writer2 = new FileWriter(\"out.txt\", StandardCharsets.UTF_8);\n\n        // Java 18부터의 해결책: UTF-8은 이제 기본값이므로 문자 집합을 지정할 필요가 없습니다.\n\n    }\n}\n```\n\n## 간단한 웹 서버:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 새로운 API는 정적 파일을 제공하는 기본 웹 서버를 제공하여 빠른 프로토타이핑 및 임베디드 애플리케이션에 이상적입니다.\n\n- 시스템에 Java 18 이상이 설치되어 있는지 확인합니다.\n- 정적 파일(HTML, CSS, JavaScript, 이미지 등)을 특정 디렉토리에 준비해 두세요.\n\n```js\nimport com.sun.net.httpserver.HttpServer;\nimport com.sun.net.httpserver.SimpleFileServer;\n\nimport java.net.InetSocketAddress;\n\npublic class SimpleWebServer {\n    public static void main(String[] args) throws Exception {\n        String documentRoot = \"/path/to/your/static/files\";  // 실제 디렉토리로 교체합니다\n        int port = 8080;  // 필요에 따라 포트를 변경할 수 있습니다\n\n        HttpServer server = HttpServer.create(new InetSocketAddress(port), 0);\n        SimpleFileServer fileServer = new SimpleFileServer(documentRoot);\n        server.setExecutor(null);  // 단일 스레드 실행자 사용\n        server.createContext(\"/\", fileServer);\n\n        server.start();\n        System.out.println(\"포트 \" + port + \"에서 서버가 시작되었습니다.\");\n    }\n}\n```\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003chead\u003e\n    \u003ctitle\u003e문서 제목\u003c/title\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\n이 페이지는 \"jwebserver\" 명령을 사용하여 Java의 Simple Web Server로 제공될 수 있습니다.\n\u003c/body\u003e\n\n\u003c/html\u003e\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같은 방법으로 실행해보세요:\n\n1. Java 파일 컴파일하기: javac SimpleWebServer.java\n2. 컴파일된 클래스 실행하기: java SimpleWebServer\n\n접속하기:\n\n- 웹 브라우저를 열고 http://localhost:8080 (또는 지정된 포트)로 이동합니다.\n- 정적 파일 디렉토리에서 기본 파일 (보통 index.html)이 제공되는 것을 확인할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n5. 서버를 중지하는 방법:\n\n- 서버를 중지하려면 실행 중인 터미널에서 Ctrl+C를 누릅니다.\n\n가장 간단한 방법으로 시작하기:\n\n1. 이 패키지(java18)에서 터미널을 엽니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. \"java -version\"을 실행하고 Java가 적어도 18 버전인지 확인해주세요.\n\n3. \"jwebserver\" 명령어를 실행해주세요.\n\n다음과 같은 메시지가 표시되어야 합니다:\n\n기본적으로 루프백에 바인딩됩니다. 모든 인터페이스에 대해 사용하려면 \"-b 0.0.0.0\" 또는 \"-b ::\"를 사용하십시오.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n127.0.0.1 포트 8000에서 경로/디렉토리 및 하위 디렉토리를 제공하고 있어요.\n\nURL http://127.0.0.1:8000/\n\nHTML 페이지는 이제 다음 주소에서 제공됩니다: http://127.0.0.1:8000/java18/doc.html\n\nIP 주소, 포트 및 기타 매개변수를 변경할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## HEAD() 편의 메서드 추가:\n\n```js\npublic class HttpHeadDemo {\n\n    /**\n     * HEAD() 편의 메서드 추가\n     */\n    public static void main(String[] args) throws IOException, InterruptedException {\n        HttpRequest head = HttpRequest.newBuilder(URI.create(\"https://api.github.com/\"))\n                .HEAD()\n                .build();\n\n        var response = HttpClient.newHttpClient().send(head, HttpResponse.BodyHandlers.ofString());\n\n        print(response);\n    }\n}\n```\n\nMethod Handles로 Core Reflection 재구현: 이 재구현은 리플렉션 기능의 성능과 안정성을 개선하기 위한 것입니다.\n\n제거를 위한 Finalization 과거화: 자원 정리를 위해 고안된 Finalization은 고유한 단점이 있습니다. 이를 과거화함으로써 더 안전하고 신뢰할 수 있는 대안들이 제공됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n미리보기 또는 인큐베이터 기능:\n\n## 가상 스레드:\n\n이 기능은 운영 체제 스레드 위에서 실행되는 가벼운 스레드를 소개하여 이를 통해 동시 프로그래밍을 간단히하고 특정 작업 부하의 성능을 향상시키는 것을 목표로합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Java 21에서 가상 스레드를 소개하는 간단한 데모입니다:\n\n- 가상 스레드 생성:\n\n```js\nThread vThread1 = Thread.ofVirtual().start(() -\u003e {\n  for (int i = 0; i \u003c 10; i++) {\n    System.out.println(\"가상 스레드 1: \" + i);\n  }\n});\n\nThread vThread2 = Thread.ofVirtual().start(() -\u003e {\n  for (int i = 0; i \u003c 10; i++) {\n    System.out.println(\"가상 스레드 2: \" + i);\n  }\n});\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. 완료 대기:\n\n```js\nvThread1.join();\nvThread2.join();\n```\n\n결과:\n\n이렇게 하면 두 가상 스레드의 출력이 교차되어 풀 OS 스레드의 오버헤드 없이 동시 실행이 나타납니다. 다음과 같은 내용을 볼 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n가상 스레드 1: 0\n가상 스레드 2: 0\n가상 스레드 1: 1\n가상 스레드 2: 1\n...\n가상 스레드 1: 9\n가상 스레드 2: 9\n```\n\n가상 스레드 설명:\n\n가상 스레드는 작은 기본 OS 스레드 풀 위에서 실행되는 가벼운 실행 단위입니다. 다음과 같은 여러 가지 장점을 제공합니다:\n\n- 가벼운 무게: OS 스레드와 비교하여, 가상 스레드는 생성 및 컨텍스트 전환 비용이 상당히 낮습니다.\n- 개선된 병행성: 제한된 수의 OS 스레드 내에 효율적으로 더 많은 가상 스레드를 관리할 수 있어서, 특정 작업 부하에 대한 자원을 더 잘 활용할 수 있습니다.\n- 단순화된 병행성 프로그래밍: 가상 스레드는 복잡한 스레드 관리와 동기화를 제거하여, 개발자들에게 병행 프로그래밍을 더 쉽게 만들어 줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 가상 스레드의 예제이며 OS/플랫폼 스레드와 대조적입니다. 이 프로그램은 ExecutorService를 사용하여 10,000개의 작업을 생성하고 모든 작업이 완료될 때까지 기다립니다. JDK는 배완 스레드와 OS 스레드의 제한된 수에서 이를 실행하여 쉽게 동시 코드를 작성할 수 있도록 지원합니다.\n\n```js\ntry (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n    IntStream.range(0, 10_000).forEach(i -\u003e {\n        executor.submit(() -\u003e {\n            Thread.sleep(Duration.ofSeconds(1));\n            return i;\n        });\n    });\n}  // executor.close()는 암시적으로 호출되어 기다립니다\n```\n\n## 레코드 패턴 (프로젝트 앰버):\n\n레코드는 Java 14에서 미리보기로 도입되었으며, Java 열거형도 함께 제공되었습니다. record는 Java의 또 다른 특별한 종류이며, 클래스 개발 프로세스를 단순한 데이터 운반자로만 동작하는 클래스로 쉽게 만들 수 있도록 도와줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJDK 21에서 레코드 패턴과 타입 패턴을 중첩하여 사용하여 데이터 탐색 및 처리를 선언적이고 조합 가능한 형태로 가능하게 되었습니다.\n\n```java\n// 레코드 생성하기:\n\npublic record Todo(String title, boolean completed){}\n\n// 객체 생성하기:\n\nTodo t = new Todo(“Learn Java 21”, false);\n```\n\nJDK 21 이전에는 전체 레코드를 분해하여 액세서에 액세스해야 했습니다. 그러나 이제는 값들을 더 간단하게 얻을 수 있습니다. 예를 들어:\n\n```java\nstatic void printTodo(Object obj) {\n    if (obj instanceof Todo(String title, boolean completed)) {\n        System.out.print(title);\n        System.out.print(completed);\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n레코드 패턴의 다른 장점은 중첩된 레코드 및 해당 값에 액세스하는 기능입니다. JEP 정의 자체에서 제시된 예시는 ColoredPoint에 중첩된 Rectangle 내부의 Point 값을 얻는 능력을 보여줍니다. 이전보다 더 유용해졌습니다. 이전에는 레코드를 매번 분해해야 했는데, 이제 중첩된 레코드의 값을 쉽게 얻을 수 있습니다.\n\n```js\n// Java 21부터\nstatic void printColorOfUpperLeftPoint(Rectangle r) {\n    if (r instanceof Rectangle(ColoredPoint(Point p, Color c),\n                               ColoredPoint lr)) {\n        System.out.println(c);\n    }\n}\n```\n\n## 순차적 컬렉션:\n\nJDK 21에서는 새로운 컬렉션 인터페이스 세트가 소개되어 컬렉션 사용 경험을 향상시킵니다. 예를 들어, 컬렉션에서 요소의 역순을 얻고 싶다면, 사용 중인 컬렉션에 따라 번거로울 수 있습니다. 사용 중인 컬렉션에 따라 등장 순서를 가져오는 데 불일치가 있을 수 있습니다. 예를 들어, SortedSet은 하나를 구현하지만 HashSet는 그렇지 않기 때문에 서로 다른 데이터 세트에서 이 작업을 수행하는 것이 번거로울 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements_2.png\" /\u003e\n\n이 문제를 해결하기 위해 SequencedCollection 인터페이스는 reverse 메서드를 추가하고 첫 번째 및 마지막 요소를 가져오는 기능을 제공하여 순서를 보장합니다. 또한 SequencedMap 및 SequencedSet 인터페이스도 있습니다.\n\n```js\ninterface SequencedCollection\u003cE\u003e extends Collection\u003cE\u003e {\n    // 새로운 메서드\n    SequencedCollection\u003cE\u003e reversed();\n    // Deque에서 승급된 메서드\n    void addFirst(E);\n    void addLast(E);\n    E getFirst();\n    E getLast();\n    E removeFirst();\n    E removeLast();\n}\n```\n\n## 문자열 템플릿:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n문자열 템플릿은 JDK 21의 미리 보기 기능입니다. 그러나 이는 문자열 조작에 더 많은 신뢰성과 더 나은 경험을 제공하여 때로는 원하지 않는 결과로 이어질 수 있는 일반적인 함정을 피하기 위해 노력합니다. 이제 템플릿 표현식을 작성하고 문자열에서 렌더링할 수 있습니다.\n\n```java\n// Java 21부터\nString name = \"Ajay\";\nString greeting = \"Hello \\{name}\";\nSystem.out.println(greeting);\n```\n\n이 경우 두 번째 줄이 표현식이며 호출시 Hello Ajay를 렌더링해야 합니다. 또한 보안 문제를 일으킬 수 있는 SQL 문 또는 HTML과 같은 불법적인 문자열의 가능성이 있는 경우 템플릿 규칙은 이스케이프된 따옴표만 허용하고 HTML 문서에서는 불법 엔티티를 허용하지 않습니다.\n\n# 읽어 주셔서 감사합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 👏 위 이야기에 박수를 보내주시고 저를 팔로우해주세요 👉\n- 📰 미디엄에서 더 많은 콘텐츠를 읽어보세요 (자바 개발자 인터뷰에 관한 총 50개의 이야기)\n\n제 책들은 여기서 확인하실 수 있습니다:\n\n- 아마존에서 제공하는 [가이드: 명쾌한 자바 개발자 인터뷰 (킨들북)](Amazon) 및 Gumroad (PDF 형식).\n- Gumroad에서 제공하는 [가이드: 명쾌한 스프링 부트 마이크로서비스 인터뷰 (PDF 형식)] 및 아마존 (킨들 eBook).\n- 🔔 팔로우해보세요: LinkedIn | Twitter | YouTube\n","ogImage":{"url":"/assets/img/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements_0.png"},"coverImage":"/assets/img/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements_0.png","tag":["Tech"],"readingTime":46},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e안녕하세요 친구들, 이 기사에서는 다양한 Java 버전에 대해 이야기하고 싶습니다. 나는 Java 8부터 Java 21까지의 각 버전에서 소개된 모든 중요한 기능과 API를 다루고, 좀 더 심도있는 통찰력을 얻기 위해 코딩 예제를 제시하려고 합니다.\u003c/h2\u003e\n\u003cp\u003e이는 Java 초보자뿐만 아니라 Java 8이나 Java 11과 같은 오래된 버전의 Java에서 작업하고 있는 Java 개발자들에게 도움이 될 것입니다. 자바 세계에서 무슨 일이 일어나고 있는지업데이트하고 싶어 하는 사람들에게 유용할 것입니다.\u003c/p\u003e\n\u003cp\u003e자 그럼 시작해봅시다,\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e특징:\u003c/h2\u003e\n\u003cp\u003e람다 표현식:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e익명 함수 사용으로 함수형 프로그래밍 가능.\u003c/li\u003e\n\u003cli\u003e함수형 인터페이스 작성을 위한 간결한 구문.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e함수형 인터페이스:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e람다 표현식을 사용하는 데 도움이되는 단일 추상 메소드를 가진 인터페이스입니다.\u003c/li\u003e\n\u003cli\u003e@FunctionalInterface 어노테이션을 사용하여 해당 인터페이스를 표시합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e스트림 API:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e요소 시퀀스를 처리하기 위해 Stream이라는 새로운 추상화를 소개합니다.\u003c/li\u003e\n\u003cli\u003efilter, map, reduce 등의 함수형 스타일 작업을 지원합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e메소드 참조:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e람다 표현식에 대한 간편한 표기법을 제공합니다.\u003c/li\u003e\n\u003cli\u003e메서드나 생성자를 :: 연산자를 사용하여 참조할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOptional 클래스:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e비어 있을 수도 있고 비어 있지 않은 값을 포함할 수 있는 컨테이너 객체입니다.\u003c/li\u003e\n\u003cli\u003enull 체크를 더 효과적으로 처리하고 NullPointerException을 방지하는 데 도움이 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e새로운 날짜 및 시간 API:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003ejava.time 패키지는 날짜와 시간을 다루는 보다 포괄적이고 유연한 API를 소개했습니다.\u003c/li\u003e\n\u003cli\u003e이전의 java.util.Date 및 java.util.Calendar 클래스에서 발생한 다양한 문제를 해결합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e기본 메소드:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e인터페이스에 메소드 구현을 허용합니다.\u003c/li\u003e\n\u003cli\u003e기존 구현을 망가뜨리지 않고 인터페이스를 발전시키는 데 도움이 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNashorn JavaScript 엔진:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e이전 Rhino JavaScript 엔진을 대체합니다.\u003c/li\u003e\n\u003cli\u003e더 나은 성능을 제공하며 최신 JavaScript 표준과 더 호환됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eParallel Streams:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eparallel() 메서드를 사용하여 스트림을 병렬 처리할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e특정 유형의 작업에서 멀티코어 시스템에서 성능을 향상시킵니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCollectors:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e일반적인 축소 작업을 위한 Collectors 클래스의 유틸리티 메서드 집합을 소개합니다. 예를들어 toList(), toSet(), joining() 등이 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ejava.util.function 패키지의 함수형 인터페이스:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e람다 표현식을 지원하기 위해 Predicate, Function, Consumer 및 Supplier와 같은 새로운 함수형 인터페이스가 추가되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e개선된 Process API:\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e자바 9은 원시 프로세스를 더 잘 제어할 수 있도록 Process API에 개선 사항을 도입했습니다. 새로운 ProcessHandle 클래스를 사용하면 개발자가 프로세스와 관련된 정보를 얻고 상호 작용할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ProcessHandle API를 사용하여 현재 프로세스에 대한 정보 가져오기\u003c/span\u003e\npublic \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProcessHandleExample\u003c/span\u003e {\n    public \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e[] args\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title class_\"\u003eProcessHandle\u003c/span\u003e currentProcess = \u003cspan class=\"hljs-title class_\"\u003eProcessHandle\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecurrent\u003c/span\u003e();\n        \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eout\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"프로세스 ID: \"\u003c/span\u003e + currentProcess.\u003cspan class=\"hljs-title function_\"\u003epid\u003c/span\u003e());\n        \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eout\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"실행 중? \"\u003c/span\u003e + currentProcess.\u003cspan class=\"hljs-title function_\"\u003eisAlive\u003c/span\u003e());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e컬렉션 팩토리 메서드:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e자바 9에서는 컬렉션 인터페이스(List, Set, Map 등)에 새로운 정적 팩토리 메서드를 추가하여 이러한 컬렉션의 불변 인스턴스를 더 편리하게 생성할 수 있게 했습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e java.\u003cspan class=\"hljs-property\"\u003eutil\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eList\u003c/span\u003e;\n\npublic \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCollectionFactoryMethodsExample\u003c/span\u003e {\n    public \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e[] args\u003c/span\u003e) {\n        \u003cspan class=\"hljs-comment\"\u003e// List.of() 팩토리 메서드를 사용하여 변경할 수 없는 목록 생성\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\u003e colors = \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Red\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Green\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Blue\"\u003c/span\u003e);\n        \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eout\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(colors);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e향상된 스트림 API:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003etakeWhile, dropWhile, ofNullable과 같은 여러 새로운 메서드로 스트림 API가 향상되어 스트림 작업의 유연성과 기능성을 향상시켰습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e java.\u003cspan class=\"hljs-property\"\u003eutil\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eArrays\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e java.\u003cspan class=\"hljs-property\"\u003eutil\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eList\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e java.\u003cspan class=\"hljs-property\"\u003eutil\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estream\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eCollectors\u003c/span\u003e;\n\npublic \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStreamAPIImprovementsExample\u003c/span\u003e {\n    public \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e[] args\u003c/span\u003e) {\n        \u003cspan class=\"hljs-comment\"\u003e// 예시 1: takeWhile\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eInteger\u003c/span\u003e\u003e numbers = \u003cspan class=\"hljs-title class_\"\u003eArrays\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003easList\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e);\n        \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eInteger\u003c/span\u003e\u003e lessThanFive = numbers.\u003cspan class=\"hljs-title function_\"\u003estream\u003c/span\u003e()\n                .\u003cspan class=\"hljs-title function_\"\u003etakeWhile\u003c/span\u003e(n -\u003e n \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)\n                .\u003cspan class=\"hljs-title function_\"\u003ecollect\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eCollectors\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etoList\u003c/span\u003e());\n\n        \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eout\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"5보다 작은 숫자: \"\u003c/span\u003e + lessThanFive);\n\n        \u003cspan class=\"hljs-comment\"\u003e// 예시 2: dropWhile\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eInteger\u003c/span\u003e\u003e greaterThanThree = numbers.\u003cspan class=\"hljs-title function_\"\u003estream\u003c/span\u003e()\n                .\u003cspan class=\"hljs-title function_\"\u003edropWhile\u003c/span\u003e(n -\u003e n \u0026#x3C;= \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)\n                .\u003cspan class=\"hljs-title function_\"\u003ecollect\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eCollectors\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etoList\u003c/span\u003e());\n\n        \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eout\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"3보다 큰 숫자: \"\u003c/span\u003e + greaterThanThree);\n\n        \u003cspan class=\"hljs-comment\"\u003e// 예시 3: ofNullable\u003c/span\u003e\n\n        \u003cspan class=\"hljs-comment\"\u003e// 예시 3: ofNullable\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e value1 = \u003cspan class=\"hljs-string\"\u003e\"안녕\"\u003c/span\u003e;\n        \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e value2 = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\n        \u003cspan class=\"hljs-comment\"\u003e// null이 아닌 값이 있는 예시\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eStream\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eofNullable\u003c/span\u003e(value1)\n                .\u003cspan class=\"hljs-title function_\"\u003eifPresentOrElse\u003c/span\u003e(v -\u003e \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eout\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"ofNullable 예제 - null이 아닌 값: \"\u003c/span\u003e + v),\n                        () -\u003e \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eout\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"ofNullable 예제 - null 값\"\u003c/span\u003e));\n\n        \u003cspan class=\"hljs-comment\"\u003e// null 값이 있는 예시\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eStream\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eofNullable\u003c/span\u003e(value2)\n                .\u003cspan class=\"hljs-title function_\"\u003eifPresentOrElse\u003c/span\u003e(v -\u003e \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eout\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"ofNullable 예제 - null이 아닌 값: \"\u003c/span\u003e + v),\n                        () -\u003e \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eout\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"ofNullable 예제 - null 값\"\u003c/span\u003e));\n\n        \u003cspan class=\"hljs-comment\"\u003e// null 안전한 스트림 예시\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\u003e names = \u003cspan class=\"hljs-title class_\"\u003eArrays\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003easList\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Alice\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Bob\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Charlie\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"David\"\u003c/span\u003e);\n        \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\u003e nonNullNames = names.\u003cspan class=\"hljs-title function_\"\u003estream\u003c/span\u003e()\n                .\u003cspan class=\"hljs-title function_\"\u003eflatMap\u003c/span\u003e(name -\u003e \u003cspan class=\"hljs-title class_\"\u003eStreamAPIImprovementsExample\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enullSafeStream\u003c/span\u003e(name))\n                .\u003cspan class=\"hljs-title function_\"\u003ecollect\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eCollectors\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etoList\u003c/span\u003e());\n\n        \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eout\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"null이 아닌 이름: \"\u003c/span\u003e + nonNullNames);\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// 잠재적으로 null인 값을 스트림으로 만드는 헬퍼 메서드\u003c/span\u003e\n    private \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u0026#x3C;T\u003e java.\u003cspan class=\"hljs-property\"\u003eutil\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estream\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eStream\u003c/span\u003e\u0026#x3C;T\u003e \u003cspan class=\"hljs-title function_\"\u003enullSafeStream\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eT value\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e value == \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e ? java.\u003cspan class=\"hljs-property\"\u003eutil\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estream\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eStream\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eempty\u003c/span\u003e() : java.\u003cspan class=\"hljs-property\"\u003eutil\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estream\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eStream\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(value);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 예제에서:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003etakeWhile은 특정 조건이 충족될 때까지 스트림에서 요소를 가져오는 데 사용됩니다 (이 경우에는 5보다 작은 숫자).\u003c/li\u003e\n\u003cli\u003edropWhile은 특정 조건이 충족될 때까지 스트림에서 요소를 삭제하는 데 사용됩니다 (이 경우에는 3 이하의 숫자).\u003c/li\u003e\n\u003cli\u003eofNullable은 잠재적으로 null인 값을 사용하여 스트림을 생성하고 null 값을 필터링하여 null 이름을 제외합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e인터페이스의 비공개 메서드:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eJava 9의 인터페이스는 비공개 메서드를 가질 수 있습니다. 이를 통해 공통 기능을 인터페이스 내에 캡슐화하여 외부 클래스에 노출하지 않고 사용할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 프라이빗 메서드를 가진 인터페이스\u003c/span\u003e\npublic interface \u003cspan class=\"hljs-title class_\"\u003ePrivateMethodInterface\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003epublicMethod\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-comment\"\u003e// 퍼블릭 메서드에서 프라이빗 메서드 호출 가능\u003c/span\u003e\n        \u003cspan class=\"hljs-title function_\"\u003eprivateMethod\u003c/span\u003e();\n    }\n\n    private \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprivateMethod\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eout\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"인터페이스 안의 프라이빗 메서드\"\u003c/span\u003e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHTTP/2 클라이언트:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eJava 9에서는 HTTP/2 및 WebSocket을 지원하는 새로운 가벼운 HTTP 클라이언트가 도입되었습니다. 이 클라이언트는 예전 HttpURLConnection API보다 효율적이고 유연하게 설계되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e java.net.URI;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e java.net.http.HttpClient;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e java.net.http.HttpRequest;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e java.net.http.HttpResponse;\n\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHttpClientExample\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethrows\u003c/span\u003e Exception {\n        \u003cspan class=\"hljs-type\"\u003eHttpClient\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ehttpClient\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e HttpClient.newHttpClient();\n        \u003cspan class=\"hljs-type\"\u003eHttpRequest\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ehttpRequest\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e HttpRequest.newBuilder()\n                .uri(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eURI\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"https://www.example.com\"\u003c/span\u003e))\n                .GET()\n                .build();\n\n        HttpResponse\u0026#x3C;String\u003e response = httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString());\n        System.out.println(\u003cspan class=\"hljs-string\"\u003e\"응답 코드: \"\u003c/span\u003e + response.statusCode());\n        System.out.println(\u003cspan class=\"hljs-string\"\u003e\"응답 본문: \"\u003c/span\u003e + response.body());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e로컬 변수 타입 추론 (var):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e자바 10에서는 var 키워드를 사용하여 로컬 변수 타입 추론 기능을 도입했습니다. 이를 통해 개발자는 타입을 명시적으로 지정하지 않고 로컬 변수를 선언할 수 있으며, 할당된 값에 기반하여 컴파일러가 추론하도록 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epublic \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLocalVarInference\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-comment\"\u003e/**\n     * 허용: 로컬 변수로만 사용\n     * 허용되지 않음: 클래스 필드, 메소드 매개변수 등 다른 곳 (멤버 변수, 여타곳)\n     * var 키워드 책임있게 사용하는 것이 좋습니다!\n     *\n     * 사용 사례:\n     *  - 타입이 명확한 경우 (문자열, 정수)\n     *  - 너무 긴, 복잡한 타입을 줄이기 위하여\n     *\n     * 사용하지 말아야 할 때:\n     *      - 반환 값이 명확하지 않은 경우 (var data = service.getData();)\n     */\u003c/span\u003e\n\n    public \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e[] args\u003c/span\u003e) {\n\n        \u003cspan class=\"hljs-comment\"\u003e// 허용되지만 장점이 별로 없음\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e b = \u003cspan class=\"hljs-string\"\u003e\"b\"\u003c/span\u003e;\n        \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e c = \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// int\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e d = \u003cspan class=\"hljs-number\"\u003e5.0\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// double\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e httpClient = \u003cspan class=\"hljs-title class_\"\u003eHttpClient\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enewHttpClient\u003c/span\u003e();\n\n        \u003cspan class=\"hljs-comment\"\u003e// 추론할때 쉬운 경우 :)\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e list = \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"3\"\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-comment\"\u003e// 이름이 긴 타입일 때 장점이 더욱 분명해집니다\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e reader = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBufferedReader\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n        \u003cspan class=\"hljs-comment\"\u003e// vs.\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eBufferedReader\u003c/span\u003e reader2 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBufferedReader\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOptional API - 새로운 메소드가 도입되었습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOptionalApi\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-comment\"\u003e/**\n     * 새로운 .orElseThrow() 메서드\n     */\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n\n        Optional\u0026#x3C;Flight\u003e earliestFlight = FlightSchedule.getFlights()\n                .stream()\n                .filter(f -\u003e \u003cspan class=\"hljs-string\"\u003e\"Boston\"\u003c/span\u003e.equals(f.from()))\n                .filter(f -\u003e \u003cspan class=\"hljs-string\"\u003e\"San Francisco\"\u003c/span\u003e.equals(f.to()))\n                .min(comparing(Flight::date));\n\n        earliestFlight.orElseThrow(FlightNotFoundException::\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHTTP client\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHttpClientBasicExample\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-comment\"\u003e/**\n     * 클라이언트 생성, GET 요청 보내기, 응답 정보 출력\n     */\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String... args)\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethrows\u003c/span\u003e Exception {\n        \u003cspan class=\"hljs-type\"\u003eHttpClient\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eclient\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e HttpClient.newHttpClient();\n\n        \u003cspan class=\"hljs-type\"\u003eHttpRequest\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003erequest\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e\n                HttpRequest.newBuilder(URI.create(\u003cspan class=\"hljs-string\"\u003e\"https://github.com/\"\u003c/span\u003e))\n                        .GET()  \u003cspan class=\"hljs-comment\"\u003e// 기본값, 생략 가능\u003c/span\u003e\n                        .build();\n\n        HttpResponse\u0026#x3C;String\u003e response =\n                client.send(request, HttpResponse.BodyHandlers.ofString());\n\n        print(\u003cspan class=\"hljs-string\"\u003e\"상태 코드: \"\u003c/span\u003e + response.statusCode());\n\n        print(response.headers().map());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e새로운 파일 메서드:\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eJava 11에서는 java.nio.file 패키지에 여러 가지 새로운 메서드가 추가되었는데, 파일 및 디렉토리 작업에 대한 추가 기능을 제공합니다. 주목할 만한 몇 가지 메서드는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eFiles.readString(Path path) 및 Files.writeString(Path path, CharSequence content, OpenOption... options):\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e이러한 메서드를 사용하여 파일의 내용을 문자열로 읽고 쓰는 작업을 간단하게 처리할 수 있습니다. readString 메서드는 파일의 전체 내용을 문자열로 읽어오고, writeString 메서드는 문자열을 파일에 씁니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eFiles.readAllLines(Path path) 및 Files.write(Path path, Iterable\u0026#x3C;? extends CharSequence\u003e lines, OpenOption... options):\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e이러한 메서드는 파일 내용을 문자열 목록으로 읽고 쓰는 작업을 간단하게 해줍니다. readAllLines 메서드는 파일에서 모든 줄을 목록으로 읽고, write 메서드는 문자열 컬렉션을 파일에 쓰기 위한 메서드입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eFiles.newBufferedReader(Path path) 및 Files.newBufferedWriter(Path path, OpenOption... options):\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e이러한 메서드는 파일을 효율적으로 읽고 쓰기 위한 버퍼드 리더와 라이터를 생성합니다. 이들은 문자 스트림을 다루는 프로세스를 간단하게 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003efiles.mismatch(Path path1, Path path2):\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e이 메서드는 두 파일의 내용을 비교하여 첫 번째 불일치하는 바이트의 위치를 반환합니다. 파일이 동일한 경우 -1을 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epublic \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNewFilesMethods\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e filePath = \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetProperty\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"user.dir\"\u003c/span\u003e) + \u003cspan class=\"hljs-string\"\u003e\"/src/main/resources/\"\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e file_1 = filePath + \u003cspan class=\"hljs-string\"\u003e\"file_1.txt\"\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-comment\"\u003e/**\n     * Files.readString() and .writeString()\n     */\u003c/span\u003e\n    public \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e[] args) throws \u003cspan class=\"hljs-title class_\"\u003eIOException\u003c/span\u003e {\n\n        \u003cspan class=\"hljs-comment\"\u003e// 파일 읽기가 이제 훨씬 쉬워졌습니다.\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// 대용량 파일과 사용하면 안됨\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e path = \u003cspan class=\"hljs-title class_\"\u003ePaths\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(file_1);\n        \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e content = \u003cspan class=\"hljs-title class_\"\u003eFiles\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ereadString\u003c/span\u003e(path);\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(content);\n\n        \u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e newFile = \u003cspan class=\"hljs-title class_\"\u003ePaths\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(filePath + \u003cspan class=\"hljs-string\"\u003e\"newFile.txt\"\u003c/span\u003e);\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(!\u003cspan class=\"hljs-title class_\"\u003eFiles\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexists\u003c/span\u003e(newFile)) {\n            \u003cspan class=\"hljs-title class_\"\u003eFiles\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ewriteString\u003c/span\u003e(newFile, \u003cspan class=\"hljs-string\"\u003e\"some str\"\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eStandardOpenOption\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eCREATE\u003c/span\u003e);\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-title class_\"\u003eFiles\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ewriteString\u003c/span\u003e(newFile, \u003cspan class=\"hljs-string\"\u003e\"some str\"\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eStandardOpenOption\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eTRUNCATE_EXISTING\u003c/span\u003e);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e콤팩트 숫자 포맷팅:\u003c/h2\u003e\n\u003cp\u003eJava 12에서 JEP 357의 일환으로 \"콤팩트 숫자 포맷팅\"이라는 새로운 기능이 소개되었습니다. 이 개선은 지역별 방식으로 대형 숫자를 더 간결하게 포맷하는 방법을 제공합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003ejava.text 패키지의 NumberFormat 클래스가 새로운 Style enum을 지원할 수 있도록 업데이트되었습니다. 이 Style에는 Style.SHORT 및 Style.LONG 상수가 포함되어 있습니다. 이러한 스타일은 특정 로케일에 기반해 큰 숫자를 간결한 형태로 포맷하는 데 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e java.text.NumberFormat;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e java.util.Locale;\n\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCompactNumberFormattingExample\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// 컴팩트 스타일의 숫자 포매터 생성\u003c/span\u003e\n        \u003cspan class=\"hljs-type\"\u003eNumberFormat\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ecompactFormatter\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);\n\n        \u003cspan class=\"hljs-comment\"\u003e// 큰 숫자 형식화\u003c/span\u003e\n        System.out.println(\u003cspan class=\"hljs-string\"\u003e\"Short Format: \"\u003c/span\u003e + compactFormatter.format(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e));  \u003cspan class=\"hljs-comment\"\u003e// 결과: 1K\u003c/span\u003e\n        System.out.println(\u003cspan class=\"hljs-string\"\u003e\"Short Format: \"\u003c/span\u003e + compactFormatter.format(\u003cspan class=\"hljs-number\"\u003e1000000\u003c/span\u003e));  \u003cspan class=\"hljs-comment\"\u003e// 결과: 1M\u003c/span\u003e\n\n        \u003cspan class=\"hljs-comment\"\u003e// 긴 형식의 컴팩트 스타일 숫자 포매터 생성\u003c/span\u003e\n        \u003cspan class=\"hljs-type\"\u003eNumberFormat\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ecompactLongFormatter\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.LONG);\n\n        \u003cspan class=\"hljs-comment\"\u003e// 긴 스타일로 큰 숫자 형식화\u003c/span\u003e\n        System.out.println(\u003cspan class=\"hljs-string\"\u003e\"Long Format: \"\u003c/span\u003e + compactLongFormatter.format(\u003cspan class=\"hljs-number\"\u003e10000000\u003c/span\u003e));  \u003cspan class=\"hljs-comment\"\u003e// 결과: 10 million\u003c/span\u003e\n        System.out.println(\u003cspan class=\"hljs-string\"\u003e\"Long Format: \"\u003c/span\u003e + compactLongFormatter.format(\u003cspan class=\"hljs-number\"\u003e1000000000\u003c/span\u003e));  \u003cspan class=\"hljs-comment\"\u003e// 결과: 1 billion\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eString::indent (JEP 326):\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eJava 12의 String 클래스에는 indent(int n)이라는 새로운 메서드가 도입되었습니다. 이 메서드는 문자열의 각 줄의 들여쓰기를 지정된 공백 수만큼 조정하는 데 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eindentedString\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Hello\\nWorld\"\u003c/span\u003e.indent(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// indentedString이 이제 \"   Hello\\n   World\"가 됩니다.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ejava.util.Arrays에 추가된 새로운 메서드 (JEP 326):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eJava 12에서는 java.util.Arrays 클래스에 copyOfRange 및 Comparator를 사용하는 equals 변형 등을 포함한 여러 새로운 메서드가 추가되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ejava.util.stream.Collectors의 개선 사항 (JEP 325):\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003eJava 12에서 도입된 Collectors 유틸리티 클래스에는 teeing과 같은 새로운 수집기가 추가되었는데, 이를 사용하면 두 개의 수집기를 결합하여 하나의 수집기로 만들 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e새로운 파일 메소드:\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epublic \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNewFilesMethod\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e filePath = \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetProperty\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"user.dir\"\u003c/span\u003e) + \u003cspan class=\"hljs-string\"\u003e\"/src/main/resources/\"\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e file_1 = filePath + \u003cspan class=\"hljs-string\"\u003e\"file_1.txt\"\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e file_2 = filePath + \u003cspan class=\"hljs-string\"\u003e\"file_2.txt\"\u003c/span\u003e;\n\n    public \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e[] args) throws \u003cspan class=\"hljs-title class_\"\u003eIOException\u003c/span\u003e {\n\n        \u003cspan class=\"hljs-comment\"\u003e// 두 파일의 내용에서 첫 번째 불일치하는 바이트의 위치를 찾아 반환합니다.\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// 불일치가 없는 경우 -1L을 반환합니다.\u003c/span\u003e\n        long result = \u003cspan class=\"hljs-title class_\"\u003eFiles\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emismatch\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003ePaths\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(file_1), \u003cspan class=\"hljs-title class_\"\u003ePaths\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(file_2));\n\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(result);      \u003cspan class=\"hljs-comment\"\u003e// -1\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e특별히 흥미로운 일은 없었습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eByteBuffer에 대한 API 업데이트\u003c/li\u003e\n\u003cli\u003e지역화 업데이트 (새로운 문자 및 이모지 지원)\u003c/li\u003e\n\u003cli\u003eGC 업데이트\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e“Switch Expressions” (SE) 대신 “Switch Statements” (SS):\u003c/h2\u003e\n\u003cp\u003e향상된 Switch 표현식:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eJava 12에서 미리보기 기능으로 소개되었으며 Java 13에서 최종화된 스위치 표현식은 개발자들이 switch 문을 표현식으로 사용할 수 있도록 해주어 더 간결하고 표현력 있는 구문을 제공합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003edayOfWeek\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n\u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003edayType\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (dayOfWeek) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e -\u003e \u003cspan class=\"hljs-string\"\u003e\"평일\"\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e -\u003e \u003cspan class=\"hljs-string\"\u003e\"주말\"\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e -\u003e \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIllegalArgumentException\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"유효하지 않은 요일: \"\u003c/span\u003e + dayOfWeek);\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\"수확\" 문장:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\"수확\" 문장은 스위치 표현식을 보완하기 위해 Java 14에서 소개되었습니다. 이를 사용하여 스위치 암에서 반환할 값을 지정할 수 있어, 명령형과 함수형 스타일을 융합하는 데 더 많은 유연성을 제공합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e dayType = \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (dayOfWeek) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e -\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eout\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"근무일\"\u003c/span\u003e);\n        \u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"평일\"\u003c/span\u003e;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e -\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eout\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"주말\"\u003c/span\u003e);\n        \u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"주말\"\u003c/span\u003e;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e -\u003e \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIllegalArgumentException\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"유효하지 않은 요일: \"\u003c/span\u003e + dayOfWeek);\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또 다른 예시,\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-comment\"\u003e/**\n * \"스위치 표현식\" (SE) 대신 \"스위치 문\" (SS)\n * (둘 다 사용할 수 있지만 SE가 SS보다 낫습니다)\n */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSwitchExpressions\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n\n        oldStyleWithBreak(FruitType.APPLE);\n\n        withSwitchExpression(FruitType.PEAR);\n\n        switchExpressionWithReturn(FruitType.KIWI);\n\n        switchWithYield(FruitType.PINEAPPLE);\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// 예전 방식은 더 복잡하고 오류 발생 가능성이 높음 (\"break;\"을 잊으면 switch가 지나가버릴 수 있음)\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eoldStyleWithBreak\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(FruitType fruit)\u003c/span\u003e {\n        print(\u003cspan class=\"hljs-string\"\u003e\"==== break를 사용한 예전 방식 ====\"\u003c/span\u003e);\n        \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (fruit) {\n            \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e APPLE, PEAR:\n                print(\u003cspan class=\"hljs-string\"\u003e\"보통 과일\"\u003c/span\u003e);\n                \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n            \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e PINEAPPLE, KIWI:\n                print(\u003cspan class=\"hljs-string\"\u003e\"이국적인 과일\"\u003c/span\u003e);\n                \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n            \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e:\n                print(\u003cspan class=\"hljs-string\"\u003e\"정의되지 않은 과일\"\u003c/span\u003e);\n        }\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ewithSwitchExpression\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(FruitType fruit)\u003c/span\u003e {\n        print(\u003cspan class=\"hljs-string\"\u003e\"==== 스위치 표현식을 사용한 방식 ====\"\u003c/span\u003e);\n        \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (fruit) {\n            \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e APPLE, PEAR -\u003e print(\u003cspan class=\"hljs-string\"\u003e\"보통 과일\"\u003c/span\u003e);\n            \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e PINEAPPLE -\u003e print(\u003cspan class=\"hljs-string\"\u003e\"이국적인 과일\"\u003c/span\u003e);\n            \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e -\u003e print(\u003cspan class=\"hljs-string\"\u003e\"정의되지 않은 과일\"\u003c/span\u003e);\n        }\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eswitchExpressionWithReturn\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(FruitType fruit)\u003c/span\u003e {\n        print(\u003cspan class=\"hljs-string\"\u003e\"==== 반환 값이 있는 경우 ====\"\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-comment\"\u003e// 직접 \"return switch\"을 사용할 수도 있음\u003c/span\u003e\n        \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003etext\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (fruit) {\n            \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e APPLE, PEAR -\u003e \u003cspan class=\"hljs-string\"\u003e\"보통 과일\"\u003c/span\u003e;\n            \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e PINEAPPLE -\u003e \u003cspan class=\"hljs-string\"\u003e\"이국적인 과일\"\u003c/span\u003e;\n            \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e -\u003e \u003cspan class=\"hljs-string\"\u003e\"정의되지 않은 과일\"\u003c/span\u003e;\n        };\n        print(text);\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e/**\n     * \"Yield\"는 \"return\"과 비슷하지만 중요한 차이가 있음:\n     * \"yield\"는 값을 반환하고 switch 문을 종료함. 실행은 특정 메서드 내에서 유지됨\n     * \"return\"은 switch문 및 특정 메서드를 종료함\n     */\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// https://stackoverflow.com/questions/58049131/what-does-the-new-keyword-yield-mean-in-java-13\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eswitchWithYield\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(FruitType fruit)\u003c/span\u003e {\n        print(\u003cspan class=\"hljs-string\"\u003e\"==== yield를 사용한 경우 ====\"\u003c/span\u003e);\n        \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003etext\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (fruit) {\n            \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e APPLE, PEAR -\u003e {\n                print(\u003cspan class=\"hljs-string\"\u003e\"주어진 과일은: \"\u003c/span\u003e + fruit);\n                \u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"보통 과일\"\u003c/span\u003e;\n            }\n            \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e PINEAPPLE -\u003e \u003cspan class=\"hljs-string\"\u003e\"이국적인 과일\"\u003c/span\u003e;\n            \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e -\u003e \u003cspan class=\"hljs-string\"\u003e\"정의되지 않은 과일\"\u003c/span\u003e;\n        };\n        print(text);\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eenum\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFruitType\u003c/span\u003e {APPLE, PEAR, PINEAPPLE, KIWI}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e텍스트 블록\u003c/h2\u003e\n\u003cp\u003e텍스트 블록은 여러 줄에 걸친 문자열 리터럴을 나타내는 새로운 유형의 리터럴입니다. 여러 줄에 걸친 소스 코드의 문자열을 작성하고 유지하는 작업을 간단하게 만들면서 이스케이프 시퀀스를 피하려고 합니다.\u003c/p\u003e\n\u003cp\u003e텍스트 블록을 사용하지 않은 예시:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e html = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n\u0026#x3C;html\u003e\n    \u0026#x3C;body\u003e\n        \u0026#x3C;p\u003eHello, world\u0026#x3C;/p\u003e\n    \u0026#x3C;/body\u003e\n\u0026#x3C;/html\u003e\n\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e텍스트 블록의 주요 기능은 다음과 같습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e여러 줄 문자열: 텍스트 블록을 사용하면 여러 줄 문자열을 더 자연스럽게 표현할 수 있어 코드 가독성을 향상시킵니다.\u003c/li\u003e\n\u003cli\u003e공백 제어: 각 줄의 시작과 끝 공백이 제거되어 들여쓰기를 더 잘 제어할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e이스케이프 시퀀스: 텍스트 블록 내에서 이스케이프 시퀀스는 여전히 유효하며 특수 문자를 포함할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e텍스트 블록은 HTML, XML, JSON 또는 SQL 쿼리와 같은 여러 줄 콘텐츠를 포함하는 문자열을 더 쉽게 표현할 수 있도록 설계되었습니다. Java 15나 이후 버전에서 텍스트 블록과 관련된 업데이트나 새로운 기능이 있었을 경우 해당 버전의 공식 문서나 릴리스 노트를 확인하는 것이 좋습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/**\n * TextBlocks에 대한 사용 사례 (Java 15의 새로운 기능 \u003e Text Blocks in Practice)\n * - 마크다운을 사용한 텍스트 블록\n * - 테스트, 하드 코딩된 JSON 문자열 정의\n * - 간단한 템플릿\n */\u003c/span\u003e\npublic \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTextBlocks\u003c/span\u003e {\n\n    public \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e[] args\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title function_\"\u003eoldStyle\u003c/span\u003e();\n        \u003cspan class=\"hljs-title function_\"\u003eemptyBlock\u003c/span\u003e();\n        \u003cspan class=\"hljs-title function_\"\u003ejsonBlock\u003c/span\u003e();\n        \u003cspan class=\"hljs-title function_\"\u003ejsonMovedEndQuoteBlock\u003c/span\u003e();\n        \u003cspan class=\"hljs-title function_\"\u003ejsonMovedBracketsBlock\u003c/span\u003e();\n    }\n\n    private \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eoldStyle\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"******** 기존 스타일 ********\"\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e text = \u003cspan class=\"hljs-string\"\u003e\"{\\n\"\u003c/span\u003e +\n                \u003cspan class=\"hljs-string\"\u003e\"  \\\"name\\\": \\\"John Doe\\\",\\n\"\u003c/span\u003e +\n                \u003cspan class=\"hljs-string\"\u003e\"  \\\"age\\\": 45,\\n\"\u003c/span\u003e +\n                \u003cspan class=\"hljs-string\"\u003e\"  \\\"address\\\": \\\"Doe Street, 23, Java Town\\\"\\n\"\u003c/span\u003e +\n                \u003cspan class=\"hljs-string\"\u003e\"}\"\u003c/span\u003e;\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(text);\n    }\n\n    private \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eemptyBlock\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"******** 빈 블록 ********\"\u003c/span\u003e);\n        \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e text = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n                \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e;\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"|\"\u003c/span\u003e + text + \u003cspan class=\"hljs-string\"\u003e\"|\"\u003c/span\u003e);\n    }\n\n    private \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ejsonBlock\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"******** JSON 블록 ********\"\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e text = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n                {\n                  \"\u003c/span\u003ename\u003cspan class=\"hljs-string\"\u003e\": \"\u003c/span\u003e\u003cspan class=\"hljs-title class_\"\u003eJohn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDoe\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\",\n                  \"\u003c/span\u003eage\u003cspan class=\"hljs-string\"\u003e\": 45,\n                  \"\u003c/span\u003eaddress\u003cspan class=\"hljs-string\"\u003e\": \"\u003c/span\u003e\u003cspan class=\"hljs-title class_\"\u003eDoe\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStreet\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e23\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eJava\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTown\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n                }\n                \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// \u0026#x3C;-- 첫 번째 \" 문자와 정렬되어 있으면 들여쓰기 없음\u003c/span\u003e\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(text);\n    }\n\n    private \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ejsonMovedEndQuoteBlock\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"******** JSON 이동된 끝 따옴표 블록 ********\"\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e text = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n                  {\n                    \"\u003c/span\u003ename\u003cspan class=\"hljs-string\"\u003e\": \"\u003c/span\u003e\u003cspan class=\"hljs-title class_\"\u003eJohn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDoe\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\",\n                    \"\u003c/span\u003eage\u003cspan class=\"hljs-string\"\u003e\": 45,\n                    \"\u003c/span\u003eaddress\u003cspan class=\"hljs-string\"\u003e\": \"\u003c/span\u003e\u003cspan class=\"hljs-title class_\"\u003eDoe\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStreet\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e23\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eJava\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTown\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n                  }\n                       \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e;\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(text);\n    }\n\n    private \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ejsonMovedBracketsBlock\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"******** JSON 이동된 괄호 블록 ********\"\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e text = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n                  {\n                    \"\u003c/span\u003ename\u003cspan class=\"hljs-string\"\u003e\": \"\u003c/span\u003e\u003cspan class=\"hljs-title class_\"\u003eJohn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDoe\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\",\n                    \"\u003c/span\u003eage\u003cspan class=\"hljs-string\"\u003e\": 45,\n                    \"\u003c/span\u003eaddress\u003cspan class=\"hljs-string\"\u003e\": \"\u003c/span\u003e\u003cspan class=\"hljs-title class_\"\u003eDoe\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStreet\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e23\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eJava\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTown\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n                  }\n                \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// \u0026#x3C;-- 세 번째 \" 문자와 정렬되어 2칸 들여쓰기\u003c/span\u003e\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(text);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003einstanceof에 대한 패턴 매칭:\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e자바 16의 instanceof에 대한 패턴 매칭은 유용한 기능으로 형식 검사와 추출을 개선합니다. 여기에 이 기능의 주요 측면을 요약해 두었어요:\u003c/p\u003e\n\u003cp\u003e기능:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e단일 형식 대신 타입 패턴을 소개합니다.\u003c/li\u003e\n\u003cli\u003einstanceof 검사 내에서 추출된 객체를 보유할 변수를 선언할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e형식 검사 및 캐스팅을 더 간결하고 가독성 있게 결합한 표현입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e혜택:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e번거로운 코드 줄이기: 별도의 instanceof 확인, 형 변환 및 변수 선언이 필요 없게 합니다.\u003c/li\u003e\n\u003cli\u003e가독성 향상: 코드가 더 명확해지고 복잡한 유형 계층 구조에 대해 이해하기 쉬워집니다.\u003c/li\u003e\n\u003cli\u003e오류 감소: 잘못된 유형으로 인한 캐스트 예외 발생 가능성이 줄어듭니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e구문\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (obj \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e s) {\n  \u003cspan class=\"hljs-comment\"\u003e// 여기서 \"s\"를 String으로 직접 사용\u003c/span\u003e\n} \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (obj \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eInteger\u003c/span\u003e\u003e list) {\n  \u003cspan class=\"hljs-comment\"\u003e// 여기서 \"list\"를 List \u0026#x3C;Integer\u003e로 직접 사용\u003c/span\u003e\n} \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 다른 경우 처리\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예제\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePatternMatchingForInstanceof\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n\n        \u003cspan class=\"hljs-type\"\u003eObject\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eo\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBook\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Harry Potter\"\u003c/span\u003e, Set.of(\u003cspan class=\"hljs-string\"\u003e\"Jon Doe\"\u003c/span\u003e));\n\n        \u003cspan class=\"hljs-comment\"\u003e// 옛날 방식\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (o \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e Book) {\n            \u003cspan class=\"hljs-type\"\u003eBook\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ebook\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e (Book) o;\n            print(\u003cspan class=\"hljs-string\"\u003e\"The book's author(s) are \"\u003c/span\u003e + book.getAuthors());\n        }\n\n        \u003cspan class=\"hljs-comment\"\u003e// 새 방식\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (o \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e Book book) {\n            print(\u003cspan class=\"hljs-string\"\u003e\"The book's author(s) are \"\u003c/span\u003e + book.getAuthors());\n        }\n\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e레코드:\u003c/h2\u003e\n\u003cp\u003e자바의 레코드는 변경할 수 없는 데이터를 보관하기 위해 특별히 설계된 특수한 유형의 클래스입니다. 이는 단순한 데이터 구조를 처리할 때 보일러플레이트 코드를 줄이고 가독성 및 유지보수성을 향상시킬 수 있도록 도와줍니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이들의 주요 특성을 살펴봅시다:\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003col\u003e\n\u003cli\u003e간결함:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e기존 클래스와는 달리 레코드는 정의하는 데 필요한 코드가 최소화됩니다. 레코드 선언에서 데이터 필드(구성 요소)만 지정하면 됩니다. 그러면 컴파일러가 다음과 같은 필수 메서드를 자동으로 생성합니다:\u003c/li\u003e\n\u003cli\u003e각 구성 요소에 대한 매개변수가 있는 생성자.\u003c/li\u003e\n\u003cli\u003e각 구성 요소에 대한 게터.\u003c/li\u003e\n\u003cli\u003e구성 요소 값을 기반으로 한 equals 및 hashCode 메서드.\u003c/li\u003e\n\u003cli\u003e레코드의 상태를 나타내는 toString 메서드.\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e변경 불가능성:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e레코드 필드는 final로 선언되어 있어, 레코드가 생성된 후에는 그 내부에 저장된 데이터를 변경할 수 없습니다. 이는 데이터 일관성을 보장하고 스레드 안전성에 대한 고려사항을 단순화합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e가독성:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e레코드의 자동 생성 메서드와 예측 가능한 동작은 코드 가독성을 향상시키고 레코드가 어떤 것을 나타내며 프로그램의 다른 부분과 어떻게 상호 작용하는지 이해하기 쉽게 만듭니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e오류 감소:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e보일러플레이트를 최소화함으로써 레코드는 getter를 잊거나 equals를 잘못 구현하는 것과 같은 일반적인 실수의 위험을 줄입니다. 이는 더 견고하고 신뢰할 수 있는 코드로 이어집니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e전반적으로 레코드는 Java 개발자가 간결하고 불변 그리고 가독성 좋은 데이터 구조를 만드는 데 유용한 도구입니다. 이는 보다 깔끔하고 유지보수 가능한 코드를 유도합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/**\n * 레코드는 데이터 전용 불변 클래스입니다 (따라서 특정한 사용 사례가 있음)\n * 클래스의 특정 형태(예: enum과 같은)로 제한된(전문화된) 형태입니다\n * 상태 변경 등을 의도한 객체에는 적합하지 않습니다.\n * \u0026#x3C;p\u003e\n * 레코드는 다음과 관련이 없습니다:\n * - 보일러플레이트 감소 기법\n * \u0026#x3C;p\u003e\n * 레코드는 생성자, 게터, 필드; equals, hashCode, toString을 생성합니다\n * \u0026#x3C;p\u003e\n * 사용 사례:\n * - 불변 데이터 모델링\n * - 데이터를 읽기 전용으로 메모리에 보관\n * - DTOs - 데이터 전송 객체\n */\u003c/span\u003e\npublic \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRecordsDemo\u003c/span\u003e {\n\n    public \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e[] args\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title class_\"\u003eProduct\u003c/span\u003e p1 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProduct\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"우유\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e);\n        \u003cspan class=\"hljs-title class_\"\u003eProduct\u003c/span\u003e p2 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProduct\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"우유\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(p1.\u003cspan class=\"hljs-title function_\"\u003eprice\u003c/span\u003e()); \u003cspan class=\"hljs-comment\"\u003e// \"get\" 접두사 없이 사용\u003c/span\u003e\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(p1);         \u003cspan class=\"hljs-comment\"\u003e// 자동으로 생성된 toString() 출력- Product[name=우유, price=50]\u003c/span\u003e\n\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(p1 == p2);       \u003cspan class=\"hljs-comment\"\u003e// false    - 다른 객체\u003c/span\u003e\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(p1.\u003cspan class=\"hljs-title function_\"\u003eequals\u003c/span\u003e(p2));  \u003cspan class=\"hljs-comment\"\u003e// true     - 값들(milk, 50)은 auto-generated equals()/hashCode()에 의해 비교됨\u003c/span\u003e\n    }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e/**\n * 매개변수를 \"Components\"라고 함\n * 더 많은 필드 원할 시, 시그니처에 추가 필요\n * 확장은 허용되지 않지만 인터페이스 구현은 가능\n */\u003c/span\u003e\npublic record \u003cspan class=\"hljs-title class_\"\u003eProduct\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e name, int price) {\n\n    \u003cspan class=\"hljs-comment\"\u003e// 정적 필드는 가능하지만 비정적은 허용하지 않음\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e country = \u003cspan class=\"hljs-string\"\u003e\"US\"\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 모든 필드를 가진 생성자가 생성됨\u003c/span\u003e\n\n    \u003cspan class=\"hljs-comment\"\u003e// Validation 추가 가능\u003c/span\u003e\n    public \u003cspan class=\"hljs-title class_\"\u003eProduct\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(price \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIllegalArgumentException\u003c/span\u003e();\n        }\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// toString()과 같은 auto-generated 메소드들 오버라이딩 가능\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e날짜 및 시간 형식 API:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eJava 16의 DateTimeFormatter API의 일반적 사용법 및 기능: 형식 패턴 이해, 사용자 정의 형식 생성, 날짜 및 시간 구문 분석, 사용 가능한 형식 설정 포함\u003c/li\u003e\n\u003cli\u003eJava 16에서 소개된 날짜 형식팅을 위한 새로운 기능: 특히 \"B\" 심볼과 다양한 스타일을 사용한 일시 지원\u003c/li\u003e\n\u003cli\u003eSimpleDateFormat과 같은 이전 서식기와 DateTimeFormatter의 비교: 각 접근 방식의 장단점 탐색\u003c/li\u003e\n\u003cli\u003e특정 형식 작업에 DateTimeFormatter 사용 예제: 다양한 로케일에서 날짜 형식화, 타임존 처리, 더 사람이 이해하기 쉬운 표현 생성하기 등을 포함하여.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDateTimeFormatterApi\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e Map\u0026#x3C;TextStyle, Locale\u003e map = Map.of(\n            TextStyle.FULL, Locale.US,\n            TextStyle.SHORT, Locale.FRENCH,\n            TextStyle.NARROW, Locale.GERMAN\n    );\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e entry : map.entrySet()) {\n\n            \u003cspan class=\"hljs-type\"\u003eLocalDateTime\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003enow\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e LocalDateTime.now();\n            \u003cspan class=\"hljs-type\"\u003eDateTimeFormatter\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eformatter\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDateTimeFormatterBuilder\u003c/span\u003e()\n                    .appendPattern(\u003cspan class=\"hljs-string\"\u003e\"yyyy-MM-dd hh:mm \"\u003c/span\u003e)\n                    .appendDayPeriodText(entry.getKey())    \u003cspan class=\"hljs-comment\"\u003e// at night, du soir, abends, etc.\u003c/span\u003e\n                    .toFormatter(entry.getValue());\n\n            \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eformattedDateTime\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e now.format(formatter);\n            print(formattedDateTime);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eStream API의 변경 사항:\u003c/h2\u003e\n\u003cp\u003eJava 16에서 Stream API에 흥미로운 변경 사항이 있었습니다. 더욱 강력하고 편리하게 사용할 수 있게 되었습니다. 주요 하이라이트는 다음과 같습니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eStream.toList() 메서드: 이 새로운 메서드는 스트림의 요소를 목록으로 수집하는 간결한 방법을 제공합니다. 이전에는 collect(Collectors.toList())를 사용해야 했지만, 이제는 약간 중복된 방법입니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\n\u003cp\u003eStream.mapMulti() 메소드: 이 메소드를 사용하면 스트림의 각 요소를 제로 또는 그 이상의 요소로 매핑하여 결과 요소의 새로운 스트림을 생성할 수 있습니다. 복잡한 데이터 구조를 분할하거나 펼치는 데 편리합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e향상된 줄 바꿈 처리: Java 16에서 java.io.LineNumberReader 클래스에서 줄 바꿈자를 정의하는 방법을 명확히하였습니다. 이는 모순을 제거하고 줄 기반 데이터를 읽을 때 일관된 동작을 보장합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e기타 작은 변경점:\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e이제 문자열 스트림은 중간 작업이 필요하지 않고 limit 및 skip 메소드를 직접 지원합니다.\u003c/li\u003e\n\u003cli\u003epeek 메소드를 병렬 스트림과 함께 사용할 수 있으므로 병렬성에 영향을주지 않고 부작용을 발생시킬 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStreamApi\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n\n        List\u0026#x3C;Integer\u003e ints = Stream.of(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)\n                .filter(n -\u003e n \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)\n                .toList();  \u003cspan class=\"hljs-comment\"\u003e// new, instead of the verbose .collect(Collectors.toList())\u003c/span\u003e\n\n        ints.forEach(System.out::println);\n\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eSealed classes(Subclassing):\u003c/h2\u003e\n\u003cp\u003eSealed 클래스는 Java 17 (JEP 409)에서 소개된 새로운 기능으로 상속 계층구조에 대해 더 많은 제어를 제공합니다. 본질적으로 클래스나 인터페이스를 확장하거나 구현하는 것을 제한할 수 있습니다. 이는 다양한 이유로 매우 유용할 수 있습니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e향상된 타입 안전성: 허용된 하위 클래스를 명시함으로써 코드를 손상시키거나 보안 취약점을 도입할 수 있는 예기치 않은 확장을 방지합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\n\u003cp\u003e개선된 라이브러리 디자인: 라이브러리 내에서 폐쇄된 생태계를 만들 수 있어서, 사용자가 승인된 확장 기능만 사용하고 호환되지 않는 구현을 만들지 않도록 보장할 수 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e쉬운 코드 유지 관리: 가능한 서브클래스 집합을 정확히 알면 코드에 대한 추론이 간단해지며 이해와 유지보수가 쉬워집니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003esealed 클래스는 어떻게 작동합니까?\u003c/p\u003e\n\u003cp\u003esealed 키워드를 사용하여 클래스 또는 인터페이스를 sealed로 선언합니다. 그런 다음 permits 절을 사용하여 확장하거나 구현할 수 있는 클래스 목록을 지정합니다. 이 허용된 클래스만 직접 상속할 수 있고, 다른 모든 클래스는 금지됩니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esealed \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eShape\u003c/span\u003e {\n  permits \u003cspan class=\"hljs-title class_\"\u003eCircle\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eSquare\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eTriangle\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// ... 구현 세부사항\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCircle\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eShape\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 사각형이 허용되지 않아 컴파일 오류가 발생합니다\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRectangle\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eShape\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e봉인된 클래스나 인터페이스는 지정된 클래스와 인터페이스만이 상속하거나 구현할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003col\u003e\n\u003cli\u003e의도를 전달하여 잘 정의되고 제한된 가능한 구현을 강제화할 수 있음\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e더 나은 보안 — 제 3자 코드로부터의 예기치 않은 또는 무단 서브클래싱과 행위 예방을 돕습니다\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e규칙:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003col\u003e\n\u003cli\u003esealed 클래스는 \"permits\"를 사용하여 다른 클래스가 하위 클래스로 지정될 수 있게 합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e하위 클래스는 반드시 final, sealed 또는 non-sealed 이어야 합니다. (그렇지 않으면 코드가 컴파일되지 않습니다)\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e허용된 하위 클래스는 상위 sealed 클래스를 확장해야 합니다. permit을 사용하지 않고 허용하는 것은 허용되지 않습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003epermits로 지정된 클래스들은 상위 클래스와 근접하게 위치해야 합니다:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e동일한 모듈에 있어야 합니다 (상위 클래스가 명명된 모듈에 있는 경우) (Java 9 모듈화 참조)\u003c/li\u003e\n\u003cli\u003e동일한 패키지에 있어야 합니다 (상위 클래스가 무명 모듈에 있는 경우).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e4번 항목에 대한 더 자세한 내용:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSealed 클래스와 그 (직접적인) 하위 클래스는 함께 컴파일되고 유지되어야 하기 때문에 밀접하게 결합됩니다.\u003c/li\u003e\n\u003cli\u003e모듈화된 환경에서는 \"동일한 모듈\"; 모듈화되지 않은 환경에서는 이를 가장 잘 나타내는 것이 \"동일한 패키지\"입니다.\u003c/li\u003e\n\u003cli\u003e모듈을 사용한다면 모듈이 제공하는 안전한 경계 때문에 몇 가지 추가적인 유연성을 얻을 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e기본 UTF-8 설정:\u003c/h2\u003e\n\u003cp\u003eJava 18에서는 플랫폼의 기본 문자 인코딩이 UTF-8로 변경되었습니다. 이는 현대 표준에 맞추어 문자 처리를 간소화하고 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epublic \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUtf8ByDefault\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-comment\"\u003e// https://openjdk.org/jeps/400 - Platform Default Encoding\u003c/span\u003e\n\n    public \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e[] args) throws \u003cspan class=\"hljs-title class_\"\u003eIOException\u003c/span\u003e {\n\n        \u003cspan class=\"hljs-comment\"\u003e// 문제:\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// 1) 윈도우에서는 아스키 테이블 외의 문자, 예를 들어 특이한 유니코드 문자,을 지정하지 않고 FileWriter을 사용하여 쓰기\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// 2) 파일을 맥과 같은 UNIX 기반 OS로 복사하거나 전송한 다음 시스템의 기본 문자 인코딩을 사용하여 파일을 읽음\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// 3) 예상되는 결과 - 엉망인 출력\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// 따라서 문제는 예측불가능한 동작입니다.\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eFileWriter\u003c/span\u003e writer = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFileWriter\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"out.txt\"\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-comment\"\u003e// Java 18 이전의 해결책: 항상 문자 집합을 지정하십시오 (그리고 그것을 잊지 않도록 행운을 빕니다!)\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eFileWriter\u003c/span\u003e writer2 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFileWriter\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"out.txt\"\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eStandardCharsets\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eUTF_8\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-comment\"\u003e// Java 18부터의 해결책: UTF-8은 이제 기본값이므로 문자 집합을 지정할 필요가 없습니다.\u003c/span\u003e\n\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e간단한 웹 서버:\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 새로운 API는 정적 파일을 제공하는 기본 웹 서버를 제공하여 빠른 프로토타이핑 및 임베디드 애플리케이션에 이상적입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e시스템에 Java 18 이상이 설치되어 있는지 확인합니다.\u003c/li\u003e\n\u003cli\u003e정적 파일(HTML, CSS, JavaScript, 이미지 등)을 특정 디렉토리에 준비해 두세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e com.\u003cspan class=\"hljs-property\"\u003esun\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enet\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ehttpserver\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eHttpServer\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e com.\u003cspan class=\"hljs-property\"\u003esun\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enet\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ehttpserver\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eSimpleFileServer\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e java.\u003cspan class=\"hljs-property\"\u003enet\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eInetSocketAddress\u003c/span\u003e;\n\npublic \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSimpleWebServer\u003c/span\u003e {\n    public \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e[] args) throws \u003cspan class=\"hljs-title class_\"\u003eException\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e documentRoot = \u003cspan class=\"hljs-string\"\u003e\"/path/to/your/static/files\"\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// 실제 디렉토리로 교체합니다\u003c/span\u003e\n        int port = \u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// 필요에 따라 포트를 변경할 수 있습니다\u003c/span\u003e\n\n        \u003cspan class=\"hljs-title class_\"\u003eHttpServer\u003c/span\u003e server = \u003cspan class=\"hljs-title class_\"\u003eHttpServer\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInetSocketAddress\u003c/span\u003e(port), \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n        \u003cspan class=\"hljs-title class_\"\u003eSimpleFileServer\u003c/span\u003e fileServer = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSimpleFileServer\u003c/span\u003e(documentRoot);\n        server.\u003cspan class=\"hljs-title function_\"\u003esetExecutor\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);  \u003cspan class=\"hljs-comment\"\u003e// 단일 스레드 실행자 사용\u003c/span\u003e\n        server.\u003cspan class=\"hljs-title function_\"\u003ecreateContext\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e, fileServer);\n\n        server.\u003cspan class=\"hljs-title function_\"\u003estart\u003c/span\u003e();\n        \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eout\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"포트 \"\u003c/span\u003e + port + \u003cspan class=\"hljs-string\"\u003e\"에서 서버가 시작되었습니다.\"\u003c/span\u003e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;!\u003cspan class=\"hljs-variable constant_\"\u003eDOCTYPE\u003c/span\u003e html\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ehtml\u003c/span\u003e\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ehead\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003etitle\u003c/span\u003e\u003e\u003c/span\u003e문서 제목\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003etitle\u003c/span\u003e\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ehead\u003c/span\u003e\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u003e\u003c/span\u003e\n이 페이지는 \"jwebserver\" 명령을 사용하여 Java의 Simple Web Server로 제공될 수 있습니다.\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ehtml\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아래와 같은 방법으로 실행해보세요:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eJava 파일 컴파일하기: javac SimpleWebServer.java\u003c/li\u003e\n\u003cli\u003e컴파일된 클래스 실행하기: java SimpleWebServer\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e접속하기:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e웹 브라우저를 열고 \u003ca href=\"http://localhost:8080\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://localhost:8080\u003c/a\u003e (또는 지정된 포트)로 이동합니다.\u003c/li\u003e\n\u003cli\u003e정적 파일 디렉토리에서 기본 파일 (보통 index.html)이 제공되는 것을 확인할 수 있어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e서버를 중지하는 방법:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e서버를 중지하려면 실행 중인 터미널에서 Ctrl+C를 누릅니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e가장 간단한 방법으로 시작하기:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e이 패키지(java18)에서 터미널을 엽니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\n\u003cp\u003e\"java -version\"을 실행하고 Java가 적어도 18 버전인지 확인해주세요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\"jwebserver\" 명령어를 실행해주세요.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e다음과 같은 메시지가 표시되어야 합니다:\u003c/p\u003e\n\u003cp\u003e기본적으로 루프백에 바인딩됩니다. 모든 인터페이스에 대해 사용하려면 \"-b 0.0.0.0\" 또는 \"-b ::\"를 사용하십시오.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e127.0.0.1 포트 8000에서 경로/디렉토리 및 하위 디렉토리를 제공하고 있어요.\u003c/p\u003e\n\u003cp\u003eURL \u003ca href=\"http://127.0.0.1:8000/\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://127.0.0.1:8000/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eHTML 페이지는 이제 다음 주소에서 제공됩니다: \u003ca href=\"http://127.0.0.1:8000/java18/doc.html\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://127.0.0.1:8000/java18/doc.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eIP 주소, 포트 및 기타 매개변수를 변경할 수 있어요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003eHEAD() 편의 메서드 추가:\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epublic \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHttpHeadDemo\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-comment\"\u003e/**\n     * HEAD() 편의 메서드 추가\n     */\u003c/span\u003e\n    public \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e[] args) throws \u003cspan class=\"hljs-title class_\"\u003eIOException\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eInterruptedException\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eHttpRequest\u003c/span\u003e head = \u003cspan class=\"hljs-title class_\"\u003eHttpRequest\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enewBuilder\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eURI\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"https://api.github.com/\"\u003c/span\u003e))\n                .\u003cspan class=\"hljs-title function_\"\u003eHEAD\u003c/span\u003e()\n                .\u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e();\n\n        \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e response = \u003cspan class=\"hljs-title class_\"\u003eHttpClient\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enewHttpClient\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(head, \u003cspan class=\"hljs-title class_\"\u003eHttpResponse\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eBodyHandlers\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eofString\u003c/span\u003e());\n\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(response);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMethod Handles로 Core Reflection 재구현: 이 재구현은 리플렉션 기능의 성능과 안정성을 개선하기 위한 것입니다.\u003c/p\u003e\n\u003cp\u003e제거를 위한 Finalization 과거화: 자원 정리를 위해 고안된 Finalization은 고유한 단점이 있습니다. 이를 과거화함으로써 더 안전하고 신뢰할 수 있는 대안들이 제공됩니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e미리보기 또는 인큐베이터 기능:\u003c/p\u003e\n\u003ch2\u003e가상 스레드:\u003c/h2\u003e\n\u003cp\u003e이 기능은 운영 체제 스레드 위에서 실행되는 가벼운 스레드를 소개하여 이를 통해 동시 프로그래밍을 간단히하고 특정 작업 부하의 성능을 향상시키는 것을 목표로합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아래는 Java 21에서 가상 스레드를 소개하는 간단한 데모입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e가상 스레드 생성:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e vThread1 = \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eofVirtual\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003estart\u003c/span\u003e(() -\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (int i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e; i++) {\n    \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eout\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"가상 스레드 1: \"\u003c/span\u003e + i);\n  }\n});\n\n\u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e vThread2 = \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eofVirtual\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003estart\u003c/span\u003e(() -\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (int i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e; i++) {\n    \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eout\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"가상 스레드 2: \"\u003c/span\u003e + i);\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e완료 대기:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003evThread1.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e();\nvThread2.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e결과:\u003c/p\u003e\n\u003cp\u003e이렇게 하면 두 가상 스레드의 출력이 교차되어 풀 OS 스레드의 오버헤드 없이 동시 실행이 나타납니다. 다음과 같은 내용을 볼 수 있습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e가상 스레드 \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n가상 스레드 \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n가상 스레드 \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n가상 스레드 \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n...\n가상 스레드 \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e\n가상 스레드 \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e가상 스레드 설명:\u003c/p\u003e\n\u003cp\u003e가상 스레드는 작은 기본 OS 스레드 풀 위에서 실행되는 가벼운 실행 단위입니다. 다음과 같은 여러 가지 장점을 제공합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e가벼운 무게: OS 스레드와 비교하여, 가상 스레드는 생성 및 컨텍스트 전환 비용이 상당히 낮습니다.\u003c/li\u003e\n\u003cli\u003e개선된 병행성: 제한된 수의 OS 스레드 내에 효율적으로 더 많은 가상 스레드를 관리할 수 있어서, 특정 작업 부하에 대한 자원을 더 잘 활용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e단순화된 병행성 프로그래밍: 가상 스레드는 복잡한 스레드 관리와 동기화를 제거하여, 개발자들에게 병행 프로그래밍을 더 쉽게 만들어 줍니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다음은 가상 스레드의 예제이며 OS/플랫폼 스레드와 대조적입니다. 이 프로그램은 ExecutorService를 사용하여 10,000개의 작업을 생성하고 모든 작업이 완료될 때까지 기다립니다. JDK는 배완 스레드와 OS 스레드의 제한된 수에서 이를 실행하여 쉽게 동시 코드를 작성할 수 있도록 지원합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e executor = \u003cspan class=\"hljs-title class_\"\u003eExecutors\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enewVirtualThreadPerTaskExecutor\u003c/span\u003e()) {\n    \u003cspan class=\"hljs-title class_\"\u003eIntStream\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10_000\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(i -\u003e {\n        executor.\u003cspan class=\"hljs-title function_\"\u003esubmit\u003c/span\u003e(() -\u003e {\n            \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esleep\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDuration\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eofSeconds\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e));\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e i;\n        });\n    });\n}  \u003cspan class=\"hljs-comment\"\u003e// executor.close()는 암시적으로 호출되어 기다립니다\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e레코드 패턴 (프로젝트 앰버):\u003c/h2\u003e\n\u003cp\u003e레코드는 Java 14에서 미리보기로 도입되었으며, Java 열거형도 함께 제공되었습니다. record는 Java의 또 다른 특별한 종류이며, 클래스 개발 프로세스를 단순한 데이터 운반자로만 동작하는 클래스로 쉽게 만들 수 있도록 도와줍니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eJDK 21에서 레코드 패턴과 타입 패턴을 중첩하여 사용하여 데이터 탐색 및 처리를 선언적이고 조합 가능한 형태로 가능하게 되었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 레코드 생성하기:\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003erecord\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTodo\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String title, \u003cspan class=\"hljs-type\"\u003eboolean\u003c/span\u003e completed)\u003c/span\u003e{}\n\n\u003cspan class=\"hljs-comment\"\u003e// 객체 생성하기:\u003c/span\u003e\n\n\u003cspan class=\"hljs-type\"\u003eTodo\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003et\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTodo\u003c/span\u003e(“Learn Java \u003cspan class=\"hljs-number\"\u003e21\u003c/span\u003e”, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJDK 21 이전에는 전체 레코드를 분해하여 액세서에 액세스해야 했습니다. 그러나 이제는 값들을 더 간단하게 얻을 수 있습니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprintTodo\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(Object obj)\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (obj \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eTodo\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String title, \u003cspan class=\"hljs-type\"\u003eboolean\u003c/span\u003e completed)\u003c/span\u003e) {\n        System.out.print(title);\n        System.out.print(completed);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e레코드 패턴의 다른 장점은 중첩된 레코드 및 해당 값에 액세스하는 기능입니다. JEP 정의 자체에서 제시된 예시는 ColoredPoint에 중첩된 Rectangle 내부의 Point 값을 얻는 능력을 보여줍니다. 이전보다 더 유용해졌습니다. 이전에는 레코드를 매번 분해해야 했는데, 이제 중첩된 레코드의 값을 쉽게 얻을 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Java 21부터\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprintColorOfUpperLeftPoint\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eRectangle r\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (r \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRectangle\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eColoredPoint\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003ePoint\u003c/span\u003e p, \u003cspan class=\"hljs-title class_\"\u003eColor\u003c/span\u003e c),\n                               \u003cspan class=\"hljs-title class_\"\u003eColoredPoint\u003c/span\u003e lr)) {\n        \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eout\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(c);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e순차적 컬렉션:\u003c/h2\u003e\n\u003cp\u003eJDK 21에서는 새로운 컬렉션 인터페이스 세트가 소개되어 컬렉션 사용 경험을 향상시킵니다. 예를 들어, 컬렉션에서 요소의 역순을 얻고 싶다면, 사용 중인 컬렉션에 따라 번거로울 수 있습니다. 사용 중인 컬렉션에 따라 등장 순서를 가져오는 데 불일치가 있을 수 있습니다. 예를 들어, SortedSet은 하나를 구현하지만 HashSet는 그렇지 않기 때문에 서로 다른 데이터 세트에서 이 작업을 수행하는 것이 번거로울 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/assets/img/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements_2.png\"\u003e\n\u003cp\u003e이 문제를 해결하기 위해 SequencedCollection 인터페이스는 reverse 메서드를 추가하고 첫 번째 및 마지막 요소를 가져오는 기능을 제공하여 순서를 보장합니다. 또한 SequencedMap 및 SequencedSet 인터페이스도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003einterface \u003cspan class=\"hljs-title class_\"\u003eSequencedCollection\u003c/span\u003e\u0026#x3C;E\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCollection\u003c/span\u003e\u0026#x3C;E\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 새로운 메서드\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eSequencedCollection\u003c/span\u003e\u0026#x3C;E\u003e \u003cspan class=\"hljs-title function_\"\u003ereversed\u003c/span\u003e();\n    \u003cspan class=\"hljs-comment\"\u003e// Deque에서 승급된 메서드\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eaddFirst\u003c/span\u003e(E);\n    \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eaddLast\u003c/span\u003e(E);\n    E \u003cspan class=\"hljs-title function_\"\u003egetFirst\u003c/span\u003e();\n    E \u003cspan class=\"hljs-title function_\"\u003egetLast\u003c/span\u003e();\n    E \u003cspan class=\"hljs-title function_\"\u003eremoveFirst\u003c/span\u003e();\n    E \u003cspan class=\"hljs-title function_\"\u003eremoveLast\u003c/span\u003e();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e문자열 템플릿:\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e문자열 템플릿은 JDK 21의 미리 보기 기능입니다. 그러나 이는 문자열 조작에 더 많은 신뢰성과 더 나은 경험을 제공하여 때로는 원하지 않는 결과로 이어질 수 있는 일반적인 함정을 피하기 위해 노력합니다. 이제 템플릿 표현식을 작성하고 문자열에서 렌더링할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Java 21부터\u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ename\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Ajay\"\u003c/span\u003e;\n\u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003egreeting\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Hello \\{name}\"\u003c/span\u003e;\nSystem.out.println(greeting);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 경우 두 번째 줄이 표현식이며 호출시 Hello Ajay를 렌더링해야 합니다. 또한 보안 문제를 일으킬 수 있는 SQL 문 또는 HTML과 같은 불법적인 문자열의 가능성이 있는 경우 템플릿 규칙은 이스케이프된 따옴표만 허용하고 HTML 문서에서는 불법 엔티티를 허용하지 않습니다.\u003c/p\u003e\n\u003ch1\u003e읽어 주셔서 감사합니다.\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e👏 위 이야기에 박수를 보내주시고 저를 팔로우해주세요 👉\u003c/li\u003e\n\u003cli\u003e📰 미디엄에서 더 많은 콘텐츠를 읽어보세요 (자바 개발자 인터뷰에 관한 총 50개의 이야기)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e제 책들은 여기서 확인하실 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e아마존에서 제공하는 \u003ca href=\"Amazon\"\u003e가이드: 명쾌한 자바 개발자 인터뷰 (킨들북)\u003c/a\u003e 및 Gumroad (PDF 형식).\u003c/li\u003e\n\u003cli\u003eGumroad에서 제공하는 [가이드: 명쾌한 스프링 부트 마이크로서비스 인터뷰 (PDF 형식)] 및 아마존 (킨들 eBook).\u003c/li\u003e\n\u003cli\u003e🔔 팔로우해보세요: LinkedIn | Twitter | YouTube\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements"},"buildId":"wfHLuDA3kTGBYfaM5IGXk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>