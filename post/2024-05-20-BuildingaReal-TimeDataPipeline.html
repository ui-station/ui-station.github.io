<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>실시간 데이터 파이프라인 구축하기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-20-BuildingaReal-TimeDataPipeline" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="실시간 데이터 파이프라인 구축하기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="실시간 데이터 파이프라인 구축하기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-20-BuildingaReal-TimeDataPipeline" data-gatsby-head="true"/><meta name="twitter:title" content="실시간 데이터 파이프라인 구축하기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-20 18:45" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-561ae49ab5aab7f5.js" defer=""></script><script src="/_next/static/R1x9p1CQYDDJESXyLXKOK/_buildManifest.js" defer=""></script><script src="/_next/static/R1x9p1CQYDDJESXyLXKOK/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">실시간 데이터 파이프라인 구축하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="실시간 데이터 파이프라인 구축하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 20, 2024</span><span class="posts_reading_time__f7YPP">13<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-20-BuildingaReal-TimeDataPipeline&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><h2>카프카(Kafka), 폴라스(Polars), 델타 레이크(Delta Lake)를 활용한 실시간 분석</h2>
<p>데이터 엔지니어라면 언젠가는 실시간 데이터에 대한 비즈니스 요구사항을 직면해야 할 것입니다. 이는 빨리 오겠다는 것이 확실합니다. 실시간 데이터 처리는 기업이 신속하게 정보 기반 결정을 내릴 수 있도록 필수적으로 중요해지고 있으며, 아파치 카프카는 확장 가능하고 오류 허용성 있는 실시간 데이터 파이프라인을 구축하기 위한 인기 있는 플랫폼으로 부상했습니다.</p>
<p>이 기사에서는 카프카, 폴라스, 델타 레이크를 사용하여 실시간 데이터 파이프라인을 만드는 방법을 실제로 보여드리겠습니다. 그리 어렵지 않습니다! 자신도 이를 시도할 수 있는 코드는 여기에서 확인하실 수 있습니다. 유용하다고 느끼신다면 ⭐️을 주세요.</p>
<p>기술적인 기사가 될 예정이니, 코드 스니펫이 많이 포함될 것입니다.</p>
<div class="content-ad"></div>
<h1>따라오기 시작하기 위해 설정해야 할 사항</h1>
<p>시작하기 위해 몇 가지 구성 요소를 설정해 두었습니다:</p>
<p>Kafka 브로커: Docker Compose를 사용하여 Kafka와 Zookeeper 컨테이너를 실행했습니다. docker-compose.yml 파일에는 필요한 서비스와 구성이 정의되어 있습니다. 이에 대해 자세히 다루지는 않겠습니다. 이 파일은 어디에서든 다운로드할 수 있는 기본적인 docker-compose.yml입니다. 데이터 엔지니어링 팀이 Kafka 환경을 관리하는 것으로 간주하지 않겠습니다. 당신이 담당하고 있는 플랫폼 또는 데브옵스 팀이 그 역할을 맡고 있을 것이라고 가정하겠습니다.</p>
<p>발행자: Python 스크립트인 publisher.py를 만들었습니다. 이 스크립트는 일련의 csv 파일에 저장된 샘플 데이터를 Kafka 주제에 발행합니다.</p>
<div class="content-ad"></div>
<p>구독자님: 새로운 Python 스크립트인 subscriber.py를 만들었어요. 이 스크립트는 Kafka 토픽에서 메시지를 가져와 Polars를 사용하여 Delta 테이블에 쓰는 역할을 해요.</p>
<p>질문: 추가적으로 한 가지 더, query.py라는 마지막 Python 스크립트를 만들었어요. 이 스크립트는 Delta 테이블에 포함된 데이터를 가져와 조인하고, 조인된 데이터를 포함한 데이터프레임을 화면에 출력합니다.</p>
<p>매개변수: Python 스크립트 내에 설정 매개변수를 저장하는 대신 toml 파일을 사용했어요. 이렇게 하면 매개변수를 변경하고 싶어도 코드를 손대지 않아도 돼요.</p>
<h1>단순히 실행만 하려면</h1>
<div class="content-ad"></div>
<p>원하는 부분으로 건너뛰고 싶으세요? 알겠어요! 여기 실행하는 순서입니다:</p>
<p>먼저 Kafka 브로커를 실행하려면 Docker가 설치되어 있어야 합니다. 메인 폴더 내에서 docker-compose up을 실행할 수 있어요. 먼저 몇 가지 파일을 다운로드해야 하며, 그 후에 프로세스들이 시작되면 화면에 많은 텍스트가 표시될 거예요:</p>
<p><img src="/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_0.png" alt="이미지"/></p>
<p>그 다음으로, publisher용 새 터미널 세션을 열고, subscriber용 또 다른 터미널 세션을 열어 보세요. Docker 컨테이너를 설정하지는 않았지만, 이들을 독립적인 Docker 컨테이너로 설정할 방법에 대해 알아보고 싶다면 이 기사를 확인해 보세요. 대신, 새로운 가상 Python 환경을 만들어서 그 안에 설치할 걸 권장드려요. python3 -m venv venv로 가상 환경을 생성한 다음 venv/bin/activate를 입력하여 새로운 가상 환경으로 전환하고, requirements.txt에 정의된 필수 패키지를 pip install -r로 설치하시면 됩니다.</p>
<div class="content-ad"></div>
<p>모든 준비가 완료되었습니다. 먼저 터미널 창에서 subscriber.py를 실행한 후, 준비가 되면 publisher.py를 실행하세요. publisher에서 전송된 마이크로 배치를 볼 수 있으며, 동시에 subscriber가 실시간으로 수신하는 것을 볼 수 있을 겁니다. 그러나 subscriber와 publisher를 올바른 순서로 로드해야 합니다. subscriber가 준비되기 전에 publisher가 모두 보내버리는 일이 없도록 주의하세요. 이 경량 데모에서는 보관 기간을 설정하지 않았으니 주의해주세요.</p>
<p>아래 스크린샷을 보면, 왼쪽에 publisher가 있고 오른쪽에 subscriber가 있는 분할 된 터미널이 있습니다. 왼쪽에서 전송되는 일괄처리된 데이터를 보고, 오른쪽에서는 개별 레코드가 처리되는 것을 볼 수 있습니다.</p>
<p><img src="/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_1.png" alt="Publisher 및 Subscriber 스크린샷"/></p>
<p>모든 레코드가 전송된 후에는 publisher가 연결을 종료할 것입니다. subscriber는 프로세스가 종료될 때까지 계속 수신 대기 상태에 머무를 것입니다.</p>
<div class="content-ad"></div>
<p>마지막 단계는 query.py 파일을 실행하여 다른 화면을 로드하고 쿼리 결과를 확인하는 것입니다. 화면에 DataFrame이 출력되는데, 이겇이 우리의 작업 결과입니다. 이러한 csv 파일 각각이 Kafka를 통해 Delta 테이블로 이동되었으며, 이제 올바른 데이터 유형과 필드 이름을 가진 단일 DataFrame으로 변환되었습니다. 필요하다면, 발행물을 시작하는 동시에 실행할 수 있으며, 여러 번 실행하면 데이터가 흐르는 것을 확인할 수 있습니다.</p>
<p><img src="/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_2.png" alt="이미지"/></p>
<p>여기까지입니다! 몇 개의 csv 파일을 Kafka를 통해 마이크로 배치로 로드한 다음 이를 Delta 테이블로 다운스트림으로 스트리밍했습니다. 그 후 데이터를 쿼리하고 변환하여 직원, 부서, 고객, 판매 일자, 판매 지역 및 판매 금액을 모두 포함한 단일 DataFrame으로 통합했습니다.</p>
<p>만약 궁금하시다면, 각 테이블의 기본 키를 기반으로 파일을 로드하기 위해 병합 프로세스를 사용했습니다. 그래서 데이터를 변경하고 다시로드하면 Delta 테이블에서 데이터를 우아하게 업데이트할 수 있습니다. 아래에서 csv에서 Finance 부서 레코드를 FinTech로 변경하고 두 번째로 실행했더니 어떻게 변경되는지 확인해보세요:</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_3.png" alt="이미지"/></p>
<p>계속 읽어 보면 어떻게 작동하는지 알 수 있어요...</p>
<h1>발행자</h1>
<p>발행자 스크립트는 데이터를 Kafka로 보내는 데 사용됩니다. 전체 파일은 여기에서 찾을 수 있어요. 일부 구성을 설정한 후, 파일을 시작하는 지점인 아래쪽에서 여정을 시작해요:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main()&quot;</span>:
    producer = <span class="hljs-title function_">create_producer</span>(bootstrap_servers)
    
    <span class="hljs-attr">try</span>:
        <span class="hljs-title function_">process_files_and_send</span>(producer, topics, batch_size)
    <span class="hljs-attr">finally</span>:
        producer.<span class="hljs-title function_">close</span>()
</code></pre>
<p>카프카 프로듀서를 producer로 인스턴스화하고 서버 세부 정보를 전달했습니다. 그런 다음 파일을 처리하려고 시도하고 완료되면 연결을 닫습니다. 간단하죠! 이제 파일의 맨 위로 돌아가서 각 함수를 하나씩 작업할 수 있습니다.</p>
<h2>create_producer</h2>
<pre><code class="hljs language-js">def <span class="hljs-title function_">create_producer</span>(bootstrap_servers):
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">KafkaProducer</span>(
        bootstrap_servers=bootstrap_servers,
        value_serializer=lambda <span class="hljs-attr">v</span>: json.<span class="hljs-title function_">dumps</span>(v).<span class="hljs-title function_">encode</span>(<span class="hljs-string">&quot;utf-8&quot;</span>)
    )
</code></pre>
<div class="content-ad"></div>
<p>여기에는 그다지 많은 내용이 없어요. 저는 단순히 KafkaProducer를 함수로 래핑하여 제 개인적인 것으로 만들었어요. 서버 세부 정보를 전달하고, 매개변수인 v를 취하고 해당 매개변수로 전달된 내용을 JSON으로 변환하는 람다 함수를 사용했어요. 그 JSON은 UTF-8로 인코딩되어요. 많은 데이터 처리 함수가 문자열 대신 바이트 형식의 데이터를 예상하기 때문에 이것은 필수적입니다.</p>
<h2>send_messages</h2>
<pre><code class="hljs language-js">def <span class="hljs-title function_">send_messages</span>(producer, topic, messages):
    <span class="hljs-attr">try</span>:
        <span class="hljs-keyword">for</span> message <span class="hljs-keyword">in</span> <span class="hljs-attr">messages</span>:
            producer.<span class="hljs-title function_">send</span>(topic, value=message)
        producer.<span class="hljs-title function_">flush</span>()
        logging.<span class="hljs-title function_">info</span>(f<span class="hljs-string">&quot;Batch of messages sent to topic &#x27;{topic}&#x27;.&quot;</span>)
    except <span class="hljs-title class_">Exception</span> <span class="hljs-keyword">as</span> <span class="hljs-attr">e</span>:
        logging.<span class="hljs-title function_">error</span>(f<span class="hljs-string">&quot;Failed to send messages to topic &#x27;{topic}&#x27;. Error: {e}&quot;</span>)
</code></pre>
<p>저는 아직 클래스를 사용하지 않았기 때문에 다음에 이것을 설정하고 있어요. 실제로 사용될 때 미리 로드되고 준비되어 있어야 해요. 여기서는 Kafka로 데이터를 전송하려고 노력해요. 각 메시지마다 Kafka Producer를 사용하고 메시지를 주제로 보내요. 그런 다음 보낸 것을 기록하거나 필요한 경우 발생한 오류를 기록해 내용이 잘못됐는지 조사할 수 있어요.</p>
<div class="content-ad"></div>
<h2>process_files_and_send</h2>
<pre><code class="hljs language-js">def <span class="hljs-title function_">process_files_and_send</span>(producer, topics, batch_size):
    <span class="hljs-keyword">for</span> topic <span class="hljs-keyword">in</span> <span class="hljs-attr">topics</span>:
        <span class="hljs-attr">try</span>:
            <span class="hljs-keyword">with</span> <span class="hljs-title function_">open</span>(f<span class="hljs-string">&quot;{raw_path}/{topic}.csv&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8-sig&quot;</span>) <span class="hljs-keyword">as</span> <span class="hljs-attr">csvfile</span>:
                csvreader = csv.<span class="hljs-title class_">DictReader</span>(csvfile)
                batch = []

                <span class="hljs-keyword">for</span> rows <span class="hljs-keyword">in</span> <span class="hljs-attr">csvreader</span>:
                    batch.<span class="hljs-title function_">append</span>(rows)
                    <span class="hljs-keyword">if</span> <span class="hljs-title function_">len</span>(batch) &gt;= <span class="hljs-attr">batch_size</span>:
                        <span class="hljs-title function_">send_messages</span>(producer, topic, batch)
                        batch = []

                # <span class="hljs-title class_">Send</span> any remaining messages <span class="hljs-keyword">in</span> the last batch
                <span class="hljs-keyword">if</span> <span class="hljs-attr">batch</span>:
                    <span class="hljs-title function_">send_messages</span>(producer, topic, batch)

        except <span class="hljs-title class_">FileNotFoundError</span>:
            logging.<span class="hljs-title function_">error</span>(f<span class="hljs-string">&quot;File not found: {raw_path}/{topic}.csv&quot;</span>)
        except <span class="hljs-title class_">Exception</span> <span class="hljs-keyword">as</span> <span class="hljs-attr">e</span>:
            logging.<span class="hljs-title function_">error</span>(f<span class="hljs-string">&quot;Error processing file for topic &#x27;{topic}&#x27;: {e}&quot;</span>)
</code></pre>
<p>여기가 번잡한 부분이고, 데이터를 보내는 작업을 마치게 될 거야.</p>
<p>제가 프로듀서를 맨 처음에 인스턴스화할 때 전달하고, 토픽들도 함께 전달해주는 함수를 만들었어요. 그런 다음 각 토픽을 순회하면서 처리해요. 각 토픽은 csv 파일과 관련이 있기 때문에, 먼저 파일을 열려고 시도하는 거죠.</p>
<div class="content-ad"></div>
<p>배치 크기를 입력 매개변수로 정의했다는 것을 알 수 있을 겁니다. 이건 정말 필수적인 것은 아니지만, csv 파일에서 데이터를 가져오는 대신에 웹페이지나 다른 스트리밍 서비스에서 가져오는 것이 아니기 때문에, 메시지를 배치로 묶어서 그룹으로 보내고 싶었습니다. 이렇게 하면 작업이 빨라집니다. 저는 toml 파일 내에서 배치 크기를 10으로 설정했는데, 이는 사실상 한 번에 csv 파일의 10줄에 해당합니다.</p>
<p>그런 다음 각 행을 배치에 추가하면서 배치 한도에 도달할 때까지 작업을 수행한 후 데이터를 전송하고 배치를 비웁니다. 작업을 마치면 마지막 메시지로 배치를 정리합니다 (남은 레코드가 5개만 남았을 수 있지만, 그래도 모두 보내고 싶습니다).</p>
<p>마지막으로, raw 파일을 찾을 수 없는 경우나 발생할 수 있는 기타 일반적인 오류에 대한 오류 처리가 있습니다.</p>
<p>이것이 publisher.py 파일의 내용입니다. 이해가 되시겠나요? 이제 subscriber.py 파일로 넘어가 봅시다!</p>
<div class="content-ad"></div>
<h1>구독자</h1>
<p>구독자는 Kafka 주제를 청취하고, 새 레코드를 발견했을 때 특정 작업을 수행하는 데 사용됩니다. 이 경우, 해당 레코드의 내용을 가져와 Delta 테이블에 저장합니다. 여기서 전체 코드를 찾을 수 있는 코드를 통해 코드를 하나씩 살펴보겠습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:
    consumer = <span class="hljs-title function_">create_consumer</span>(topics, bootstrap_servers)
    <span class="hljs-keyword">for</span> message <span class="hljs-keyword">in</span> <span class="hljs-attr">consumer</span>:
        <span class="hljs-title function_">process_message</span>(message.<span class="hljs-property">topic</span>, message.<span class="hljs-property">value</span>)
</code></pre>
<p>발행자와 비슷하게, 첫 번째로 하는 일은 주제 및 서버 세부 정보를 구성 변수로 제공하고, 이를 전달하여 소비자를 인스턴스화하는 것입니다. 그런 다음 소비한 각 메시지를 처리합니다. 간단하지요. 하지만 함수별로 좀 더 자세히 살펴보겠습니다.</p>
<div class="content-ad"></div>
<h2>소비자 생성</h2>
<pre><code class="hljs language-js">def <span class="hljs-title function_">create_consumer</span>(topics, bootstrap_servers):
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">KafkaConsumer</span>(
        *topics,
        bootstrap_servers = bootstrap_servers,
        value_deserializer = lambda <span class="hljs-attr">v</span>: json.<span class="hljs-title function_">loads</span>(v.<span class="hljs-title function_">decode</span>(<span class="hljs-string">&quot;utf-8&quot;</span>))
</code></pre>
<p>우리 Python의 진입점에서 첫 번째 줄은 소비자를 인스턴스화하는 것이었습니다. 이것은 기본적으로 KafkaConsumer의 래퍼일 뿐입니다. 퍼블리셔와 다른 것은 아무 것도 하지 않습니다.</p>
<h2>메시지 처리</h2>
<div class="content-ad"></div>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_message</span>(<span class="hljs-params">topic, data</span>):
    df = pl.from_records([data])
    delta_table_path = <span class="hljs-string">f&quot;<span class="hljs-subst">{delta_path}</span>/<span class="hljs-subst">{topic}</span>&quot;</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(delta_table_path):
        write_delta_table(df, delta_table_path, <span class="hljs-string">&quot;insert&quot;</span>)
    <span class="hljs-keyword">else</span>:
        merge_into_delta_table(df, delta_table_path)
</code></pre>
<p>메시지를 받을 때마다 그것을 처리하는 방법을 알아야 합니다. 저는 여기서 두 가지 방법을 선택했습니다. 먼저 Delta 테이블이 저장된 경로를 가져와 해당 경로가 존재하는지 확인합니다. 경로가 존재하지 않으면 새 레코드를 삽입하기 위해 insert 매개변수를 사용하여 write_delta_table 함수를 호출합니다. 그러나 경로가 이미 존재한다면, merge_into_delta_table 함수를 호출합니다. 이를 통해 데이터를 여러 번로드할 수 있게 하면서 단순히 테이블을 점점 더 크게 만들지 않습니다. 이미 변경된 기존 항목을 업데이트하고 새 레코드만 추가합니다.</p>
<p>이러한 함수들을 좀 더 자세히 살펴봅시다.</p>
<h2>write_delta_table</h2>
<div class="content-ad"></div>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">write_delta_table</span>(<span class="hljs-params">df, path, mode</span>):
    <span class="hljs-keyword">try</span>:
        df.write_delta(target=path, mode=mode)
        logging.info(<span class="hljs-string">f&quot;<span class="hljs-subst">{mode.capitalize()}</span>ed message to Delta table: <span class="hljs-subst">{df}</span>&quot;</span>)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        logging.error(<span class="hljs-string">f&quot;Failed to <span class="hljs-subst">{mode}</span> message to Delta table: <span class="hljs-subst">{df}</span>&quot;</span>)
        logging.error(<span class="hljs-string">f&quot;Error: <span class="hljs-subst">{e}</span>&quot;</span>)
</code></pre>
<p>테이블 태그를 마크다운 형식으로 변경해주시기 바랍니다.</p>
<p>여기서는 DataFrame, 주제 경로, 그리고 모드(삽입)를 간단히 전달하고 네이티브 Polars 기능을 사용하여 Delta 테이블에 작성합니다. 작업이 성공했음을 로그에 남기거나 실패했을 때 오류를 캡처하여 조사할 수 있도록 합니다.</p>
<h2>merge_into_delta_table</h2>
<p>여기에는 조금 더 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_into_delta_table</span>(<span class="hljs-params">df, path</span>):
    <span class="hljs-keyword">try</span>:
        df.write_delta(
            target=path, mode=<span class="hljs-string">&quot;merge&quot;</span>,
            delta_merge_options={
                <span class="hljs-string">&quot;predicate&quot;</span>: <span class="hljs-string">&quot;s.id = t.id&quot;</span>,
                <span class="hljs-string">&quot;source_alias&quot;</span>: <span class="hljs-string">&quot;s&quot;</span>,
                <span class="hljs-string">&quot;target_alias&quot;</span>: <span class="hljs-string">&quot;t&quot;</span>,
            }
        ).when_matched_update_all().when_not_matched_insert_all().execute()
        logging.info(<span class="hljs-string">f&quot;Merged message to Delta table: <span class="hljs-subst">{df}</span>&quot;</span>)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        logging.error(<span class="hljs-string">f&quot;Failed to merge message to Delta table: <span class="hljs-subst">{df}</span>&quot;</span>)
        logging.error(<span class="hljs-string">f&quot;Error: <span class="hljs-subst">{e}</span>&quot;</span>)
</code></pre>
<p>여기에서 모드를 전달하지 않아도 됩니다. 왜냐하면 모드가 &quot;merge&quot;로 설정될 것이라는 것을 알기 때문입니다. 제 모든 테이블에는 id라는 동일한 이름을 가진 기본 키가 있으므로 한 번 정의하고 이 함수를 완전히 재사용하기 쉽습니다. 일치하는 경우 데이터가 업데이트되고, 일치하지 않는 경우 데이터가 삽입됩니다. 이것이 기본적으로 upsert입니다. 성공과 실패를 여전히 기록했습니다.</p>
<p>여기가 파이프라인의 전부입니다. 정말 간단합니다. 데이터를 게시하고 데이터를 구독하여 디스크에 저장합니다. 다음에는 해당 데이터를 쿼리하고 모든 것을 함께 가져오는 DataFrame을 가져오는 방법을 살펴볼 것입니다.</p>
<h1>쿼리</h1>
<div class="content-ad"></div>
<p>이 시점에서 Kafka는 더 이상 사용되지 않습니다. 모든 것이 Delta 테이블에 있으며 쿼리만 필요합니다. 전체 코드는 여기에 있습니다. Delta 테이블을 각각 데이터프레임 집합으로 불러오기 시작했습니다:</p>
<pre><code class="hljs language-js">client = pl.<span class="hljs-title function_">read_delta</span>(f<span class="hljs-string">&quot;{delta_path}/client&quot;</span>)
department = pl.<span class="hljs-title function_">read_delta</span>(f<span class="hljs-string">&quot;{delta_path}/department&quot;</span>)
employee = pl.<span class="hljs-title function_">read_delta</span>(f<span class="hljs-string">&quot;{delta_path}/employee&quot;</span>)
sale = pl.<span class="hljs-title function_">read_delta</span>(f<span class="hljs-string">&quot;{delta_path}/sale&quot;</span>)
</code></pre>
<p>client와 employee 데이터프레임에는 first_name과 last_name 속성이 같습니다. 데이터프레임 이름 외에는 구별할 요소가 없습니다. 각각에 first_name과 last_name을 붙여 공백을 구분자로 사용한 새로운 속성을 추가하고 적절히 이름을 지었습니다. 이렇게 하면 두 데이터프레임을 하나의 데이터프레임으로 결합할 때 무엇이 무엇인지 알 수 있습니다:</p>
<pre><code class="hljs language-js">client = client.<span class="hljs-title function_">with_columns</span>(
    pl.<span class="hljs-title function_">concat_str</span>([<span class="hljs-string">&quot;first_name&quot;</span>, <span class="hljs-string">&quot;last_name&quot;</span>], separator = <span class="hljs-string">&quot; &quot;</span>).<span class="hljs-title function_">alias</span>(<span class="hljs-string">&quot;client_name&quot;</span>)
    )

employee = employee.<span class="hljs-title function_">with_columns</span>(
    pl.<span class="hljs-title function_">concat_str</span>([<span class="hljs-string">&quot;first_name&quot;</span>, <span class="hljs-string">&quot;last_name&quot;</span>], separator = <span class="hljs-string">&quot; &quot;</span>).<span class="hljs-title function_">alias</span>(<span class="hljs-string">&quot;employee_name&quot;</span>)
    )
</code></pre>
<div class="content-ad"></div>
<p>직원 DataFrame에는 department_id라는 추가 속성이 포함되어 있습니다. 이를 사용하여 직원과 부서를 함께 결합한 새 DataFrame을 생성할 수 있어요:</p>
<pre><code class="hljs language-js">employee_dept = employee.<span class="hljs-title function_">join</span>(
        department, 
        left_on = <span class="hljs-string">&quot;department_id&quot;</span>, 
        right_on = <span class="hljs-string">&quot;id&quot;</span>, 
        how = <span class="hljs-string">&quot;inner&quot;</span>).<span class="hljs-title function_">select</span>(
                [<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;employee_name&quot;</span>, <span class="hljs-string">&quot;department_id&quot;</span>, <span class="hljs-string">&quot;department&quot;</span>]
                )
</code></pre>
<p>직원 DataFrame을 기반으로, 부서 DataFrame과 조인을 생성했는데, 직원 DataFrame의 department_id와 부서 DataFrame의 id를 일치하는 조인 조건으로 지정했어요. 모든 직원이 부서를 가져야 하기 때문에 INNER JOIN을 조인 유형으로 선택했고, 이후 유지할 속성을 선택했어요.</p>
<p>마지막으로, 한 마지막 문장으로 모두 함께 결합할 수 있어요:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">complete = sale.<span class="hljs-title function_">join</span>(
        employee_dept,
        left_on = <span class="hljs-string">&quot;employee_id&quot;</span>, 
        right_on = <span class="hljs-string">&quot;id&quot;</span>, 
        ).<span class="hljs-title function_">join</span>(
                client, 
                left_on = <span class="hljs-string">&quot;client_id&quot;</span>, 
                right_on = <span class="hljs-string">&quot;id&quot;</span>, 
                how = <span class="hljs-string">&quot;inner&quot;</span>
                ).<span class="hljs-title function_">select</span>(
                        pl.<span class="hljs-title function_">col</span>(<span class="hljs-string">&quot;id&quot;</span>).<span class="hljs-property">str</span>.<span class="hljs-title function_">to_integer</span>(),
                        pl.<span class="hljs-title function_">col</span>(<span class="hljs-string">&quot;employee_name&quot;</span>), 
                        pl.<span class="hljs-title function_">col</span>(<span class="hljs-string">&quot;department&quot;</span>), 
                        pl.<span class="hljs-title function_">col</span>(<span class="hljs-string">&quot;client_name&quot;</span>), 
                        pl.<span class="hljs-title function_">col</span>(<span class="hljs-string">&quot;date&quot;</span>).<span class="hljs-property">str</span>.<span class="hljs-title function_">to_date</span>(<span class="hljs-string">&quot;%d/%m/%Y&quot;</span>), 
                        pl.<span class="hljs-title function_">col</span>(<span class="hljs-string">&quot;region&quot;</span>), 
                        pl.<span class="hljs-title function_">col</span>(<span class="hljs-string">&quot;sale&quot;</span>).<span class="hljs-property">str</span>.<span class="hljs-title function_">to_decimal</span>(<span class="hljs-number">2</span>),
                        )
</code></pre>
<p>저는 sale DataFrame에서 시작하여 방금 생성한 employee_dept DataFrame에 조인을 수행합니다. 이제 이는 sale, employee 및 department를 결합하는 것입니다. 그런 다음 client DataFrame을 다시 조인한 다음 원하는 속성을 선택합니다. 그러나 이 경우 데이터 유형을 변경했습니다. 데이터는 csv를 통해 가져온 것이기 때문에 원래 데이터 유형이 없었습니다. 따라서 id는 정수이어야 한다고 지정했습니다. 날짜는 날짜 유형이어야 하며, 형식을 지정했으며, sale 속성이 두 자리 소수점(달러 및 센트)인 것을 지정했습니다.</p>
<p>마지막 단계는 결과를 출력하는 것입니다:</p>
<img src="/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_4.png"/>
<div class="content-ad"></div>
<h1>결론</h1>
<p>본 글에서는 Kafka, Polars, 그리고 Delta Lake를 활용하여 실시간 데이터 파이프라인을 구축하는 방법을 살펴보았습니다. 메시지 스트리밍을 위해 Kafka를 활용하고, 데이터 처리를 위해 Polars를 사용하며, 안정적인 저장소로 Delta Lake를 활용하여 확장 가능하고 오류 허용성 있는 데이터 파이프라인을 만들 수 있습니다.</p>
<p>저장소의 코드 샘플은 파이프라인의 기본 설정과 기능을 보여줍니다. 데이터 보존 정책 구성, S3 객체 저장소에 데이터 보관, 다른 시스템과 통합하는 등 특정 요구 사항에 맞게 코드를 확장하고 사용자화할 수 있습니다.</p>
<p>이 아키텍처를 채택함으로써 기업은 실시간 데이터를 효율적으로 처리하고 분석하여 데이터 기반 결정을 내리고 신속하게 변화에 대응할 수 있습니다.</p>
<div class="content-ad"></div>
<p>이 글이 유용했길 바랍니다. 만약 그렇다면 👏 한 번 눌러주시겠어요? 그리고 더 보고 싶으면 구독해주세요. 매주 한 두 편의 글을 업로드하고 있어요.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"실시간 데이터 파이프라인 구축하기","description":"","date":"2024-05-20 18:45","slug":"2024-05-20-BuildingaReal-TimeDataPipeline","content":"\n\n## 카프카(Kafka), 폴라스(Polars), 델타 레이크(Delta Lake)를 활용한 실시간 분석\n\n데이터 엔지니어라면 언젠가는 실시간 데이터에 대한 비즈니스 요구사항을 직면해야 할 것입니다. 이는 빨리 오겠다는 것이 확실합니다. 실시간 데이터 처리는 기업이 신속하게 정보 기반 결정을 내릴 수 있도록 필수적으로 중요해지고 있으며, 아파치 카프카는 확장 가능하고 오류 허용성 있는 실시간 데이터 파이프라인을 구축하기 위한 인기 있는 플랫폼으로 부상했습니다.\n\n이 기사에서는 카프카, 폴라스, 델타 레이크를 사용하여 실시간 데이터 파이프라인을 만드는 방법을 실제로 보여드리겠습니다. 그리 어렵지 않습니다! 자신도 이를 시도할 수 있는 코드는 여기에서 확인하실 수 있습니다. 유용하다고 느끼신다면 ⭐️을 주세요.\n\n기술적인 기사가 될 예정이니, 코드 스니펫이 많이 포함될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 따라오기 시작하기 위해 설정해야 할 사항\n\n시작하기 위해 몇 가지 구성 요소를 설정해 두었습니다:\n\nKafka 브로커: Docker Compose를 사용하여 Kafka와 Zookeeper 컨테이너를 실행했습니다. docker-compose.yml 파일에는 필요한 서비스와 구성이 정의되어 있습니다. 이에 대해 자세히 다루지는 않겠습니다. 이 파일은 어디에서든 다운로드할 수 있는 기본적인 docker-compose.yml입니다. 데이터 엔지니어링 팀이 Kafka 환경을 관리하는 것으로 간주하지 않겠습니다. 당신이 담당하고 있는 플랫폼 또는 데브옵스 팀이 그 역할을 맡고 있을 것이라고 가정하겠습니다.\n\n발행자: Python 스크립트인 publisher.py를 만들었습니다. 이 스크립트는 일련의 csv 파일에 저장된 샘플 데이터를 Kafka 주제에 발행합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n구독자님: 새로운 Python 스크립트인 subscriber.py를 만들었어요. 이 스크립트는 Kafka 토픽에서 메시지를 가져와 Polars를 사용하여 Delta 테이블에 쓰는 역할을 해요.\n\n질문: 추가적으로 한 가지 더, query.py라는 마지막 Python 스크립트를 만들었어요. 이 스크립트는 Delta 테이블에 포함된 데이터를 가져와 조인하고, 조인된 데이터를 포함한 데이터프레임을 화면에 출력합니다.\n\n매개변수: Python 스크립트 내에 설정 매개변수를 저장하는 대신 toml 파일을 사용했어요. 이렇게 하면 매개변수를 변경하고 싶어도 코드를 손대지 않아도 돼요.\n\n# 단순히 실행만 하려면\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n원하는 부분으로 건너뛰고 싶으세요? 알겠어요! 여기 실행하는 순서입니다:\n\n먼저 Kafka 브로커를 실행하려면 Docker가 설치되어 있어야 합니다. 메인 폴더 내에서 docker-compose up을 실행할 수 있어요. 먼저 몇 가지 파일을 다운로드해야 하며, 그 후에 프로세스들이 시작되면 화면에 많은 텍스트가 표시될 거예요:\n\n![이미지](/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_0.png)\n\n그 다음으로, publisher용 새 터미널 세션을 열고, subscriber용 또 다른 터미널 세션을 열어 보세요. Docker 컨테이너를 설정하지는 않았지만, 이들을 독립적인 Docker 컨테이너로 설정할 방법에 대해 알아보고 싶다면 이 기사를 확인해 보세요. 대신, 새로운 가상 Python 환경을 만들어서 그 안에 설치할 걸 권장드려요. python3 -m venv venv로 가상 환경을 생성한 다음 venv/bin/activate를 입력하여 새로운 가상 환경으로 전환하고, requirements.txt에 정의된 필수 패키지를 pip install -r로 설치하시면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 준비가 완료되었습니다. 먼저 터미널 창에서 subscriber.py를 실행한 후, 준비가 되면 publisher.py를 실행하세요. publisher에서 전송된 마이크로 배치를 볼 수 있으며, 동시에 subscriber가 실시간으로 수신하는 것을 볼 수 있을 겁니다. 그러나 subscriber와 publisher를 올바른 순서로 로드해야 합니다. subscriber가 준비되기 전에 publisher가 모두 보내버리는 일이 없도록 주의하세요. 이 경량 데모에서는 보관 기간을 설정하지 않았으니 주의해주세요.\n\n아래 스크린샷을 보면, 왼쪽에 publisher가 있고 오른쪽에 subscriber가 있는 분할 된 터미널이 있습니다. 왼쪽에서 전송되는 일괄처리된 데이터를 보고, 오른쪽에서는 개별 레코드가 처리되는 것을 볼 수 있습니다.\n\n![Publisher 및 Subscriber 스크린샷](/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_1.png)\n\n모든 레코드가 전송된 후에는 publisher가 연결을 종료할 것입니다. subscriber는 프로세스가 종료될 때까지 계속 수신 대기 상태에 머무를 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막 단계는 query.py 파일을 실행하여 다른 화면을 로드하고 쿼리 결과를 확인하는 것입니다. 화면에 DataFrame이 출력되는데, 이겇이 우리의 작업 결과입니다. 이러한 csv 파일 각각이 Kafka를 통해 Delta 테이블로 이동되었으며, 이제 올바른 데이터 유형과 필드 이름을 가진 단일 DataFrame으로 변환되었습니다. 필요하다면, 발행물을 시작하는 동시에 실행할 수 있으며, 여러 번 실행하면 데이터가 흐르는 것을 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_2.png)\n\n여기까지입니다! 몇 개의 csv 파일을 Kafka를 통해 마이크로 배치로 로드한 다음 이를 Delta 테이블로 다운스트림으로 스트리밍했습니다. 그 후 데이터를 쿼리하고 변환하여 직원, 부서, 고객, 판매 일자, 판매 지역 및 판매 금액을 모두 포함한 단일 DataFrame으로 통합했습니다.\n\n만약 궁금하시다면, 각 테이블의 기본 키를 기반으로 파일을 로드하기 위해 병합 프로세스를 사용했습니다. 그래서 데이터를 변경하고 다시로드하면 Delta 테이블에서 데이터를 우아하게 업데이트할 수 있습니다. 아래에서 csv에서 Finance 부서 레코드를 FinTech로 변경하고 두 번째로 실행했더니 어떻게 변경되는지 확인해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_3.png)\n\n계속 읽어 보면 어떻게 작동하는지 알 수 있어요...\n\n# 발행자\n\n발행자 스크립트는 데이터를 Kafka로 보내는 데 사용됩니다. 전체 파일은 여기에서 찾을 수 있어요. 일부 구성을 설정한 후, 파일을 시작하는 지점인 아래쪽에서 여정을 시작해요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nif __name__ == \"__main()\":\n    producer = create_producer(bootstrap_servers)\n    \n    try:\n        process_files_and_send(producer, topics, batch_size)\n    finally:\n        producer.close()\n```\n\n카프카 프로듀서를 producer로 인스턴스화하고 서버 세부 정보를 전달했습니다. 그런 다음 파일을 처리하려고 시도하고 완료되면 연결을 닫습니다. 간단하죠! 이제 파일의 맨 위로 돌아가서 각 함수를 하나씩 작업할 수 있습니다.\n\n## create_producer\n\n```js\ndef create_producer(bootstrap_servers):\n    return KafkaProducer(\n        bootstrap_servers=bootstrap_servers,\n        value_serializer=lambda v: json.dumps(v).encode(\"utf-8\")\n    )\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에는 그다지 많은 내용이 없어요. 저는 단순히 KafkaProducer를 함수로 래핑하여 제 개인적인 것으로 만들었어요. 서버 세부 정보를 전달하고, 매개변수인 v를 취하고 해당 매개변수로 전달된 내용을 JSON으로 변환하는 람다 함수를 사용했어요. 그 JSON은 UTF-8로 인코딩되어요. 많은 데이터 처리 함수가 문자열 대신 바이트 형식의 데이터를 예상하기 때문에 이것은 필수적입니다.\n\n## send_messages\n\n```js\ndef send_messages(producer, topic, messages):\n    try:\n        for message in messages:\n            producer.send(topic, value=message)\n        producer.flush()\n        logging.info(f\"Batch of messages sent to topic '{topic}'.\")\n    except Exception as e:\n        logging.error(f\"Failed to send messages to topic '{topic}'. Error: {e}\")\n```\n\n저는 아직 클래스를 사용하지 않았기 때문에 다음에 이것을 설정하고 있어요. 실제로 사용될 때 미리 로드되고 준비되어 있어야 해요. 여기서는 Kafka로 데이터를 전송하려고 노력해요. 각 메시지마다 Kafka Producer를 사용하고 메시지를 주제로 보내요. 그런 다음 보낸 것을 기록하거나 필요한 경우 발생한 오류를 기록해 내용이 잘못됐는지 조사할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## process_files_and_send\n\n```js\ndef process_files_and_send(producer, topics, batch_size):\n    for topic in topics:\n        try:\n            with open(f\"{raw_path}/{topic}.csv\", encoding=\"utf-8-sig\") as csvfile:\n                csvreader = csv.DictReader(csvfile)\n                batch = []\n\n                for rows in csvreader:\n                    batch.append(rows)\n                    if len(batch) \u003e= batch_size:\n                        send_messages(producer, topic, batch)\n                        batch = []\n\n                # Send any remaining messages in the last batch\n                if batch:\n                    send_messages(producer, topic, batch)\n\n        except FileNotFoundError:\n            logging.error(f\"File not found: {raw_path}/{topic}.csv\")\n        except Exception as e:\n            logging.error(f\"Error processing file for topic '{topic}': {e}\")\n```\n\n여기가 번잡한 부분이고, 데이터를 보내는 작업을 마치게 될 거야.\n\n제가 프로듀서를 맨 처음에 인스턴스화할 때 전달하고, 토픽들도 함께 전달해주는 함수를 만들었어요. 그런 다음 각 토픽을 순회하면서 처리해요. 각 토픽은 csv 파일과 관련이 있기 때문에, 먼저 파일을 열려고 시도하는 거죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n배치 크기를 입력 매개변수로 정의했다는 것을 알 수 있을 겁니다. 이건 정말 필수적인 것은 아니지만, csv 파일에서 데이터를 가져오는 대신에 웹페이지나 다른 스트리밍 서비스에서 가져오는 것이 아니기 때문에, 메시지를 배치로 묶어서 그룹으로 보내고 싶었습니다. 이렇게 하면 작업이 빨라집니다. 저는 toml 파일 내에서 배치 크기를 10으로 설정했는데, 이는 사실상 한 번에 csv 파일의 10줄에 해당합니다.\n\n그런 다음 각 행을 배치에 추가하면서 배치 한도에 도달할 때까지 작업을 수행한 후 데이터를 전송하고 배치를 비웁니다. 작업을 마치면 마지막 메시지로 배치를 정리합니다 (남은 레코드가 5개만 남았을 수 있지만, 그래도 모두 보내고 싶습니다).\n\n마지막으로, raw 파일을 찾을 수 없는 경우나 발생할 수 있는 기타 일반적인 오류에 대한 오류 처리가 있습니다.\n\n이것이 publisher.py 파일의 내용입니다. 이해가 되시겠나요? 이제 subscriber.py 파일로 넘어가 봅시다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 구독자\n\n구독자는 Kafka 주제를 청취하고, 새 레코드를 발견했을 때 특정 작업을 수행하는 데 사용됩니다. 이 경우, 해당 레코드의 내용을 가져와 Delta 테이블에 저장합니다. 여기서 전체 코드를 찾을 수 있는 코드를 통해 코드를 하나씩 살펴보겠습니다.\n\n```js\nif __name__ == \"__main__\":\n    consumer = create_consumer(topics, bootstrap_servers)\n    for message in consumer:\n        process_message(message.topic, message.value)\n```\n\n발행자와 비슷하게, 첫 번째로 하는 일은 주제 및 서버 세부 정보를 구성 변수로 제공하고, 이를 전달하여 소비자를 인스턴스화하는 것입니다. 그런 다음 소비한 각 메시지를 처리합니다. 간단하지요. 하지만 함수별로 좀 더 자세히 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 소비자 생성\n\n```js\ndef create_consumer(topics, bootstrap_servers):\n    return KafkaConsumer(\n        *topics,\n        bootstrap_servers = bootstrap_servers,\n        value_deserializer = lambda v: json.loads(v.decode(\"utf-8\"))\n```\n\n우리 Python의 진입점에서 첫 번째 줄은 소비자를 인스턴스화하는 것이었습니다. 이것은 기본적으로 KafkaConsumer의 래퍼일 뿐입니다. 퍼블리셔와 다른 것은 아무 것도 하지 않습니다.\n\n## 메시지 처리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\ndef process_message(topic, data):\n    df = pl.from_records([data])\n    delta_table_path = f\"{delta_path}/{topic}\"\n    if not os.path.exists(delta_table_path):\n        write_delta_table(df, delta_table_path, \"insert\")\n    else:\n        merge_into_delta_table(df, delta_table_path)\n``` \n\n메시지를 받을 때마다 그것을 처리하는 방법을 알아야 합니다. 저는 여기서 두 가지 방법을 선택했습니다. 먼저 Delta 테이블이 저장된 경로를 가져와 해당 경로가 존재하는지 확인합니다. 경로가 존재하지 않으면 새 레코드를 삽입하기 위해 insert 매개변수를 사용하여 write_delta_table 함수를 호출합니다. 그러나 경로가 이미 존재한다면, merge_into_delta_table 함수를 호출합니다. 이를 통해 데이터를 여러 번로드할 수 있게 하면서 단순히 테이블을 점점 더 크게 만들지 않습니다. 이미 변경된 기존 항목을 업데이트하고 새 레코드만 추가합니다.\n\n이러한 함수들을 좀 더 자세히 살펴봅시다.\n\n## write_delta_table\n  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\ndef write_delta_table(df, path, mode):\n    try:\n        df.write_delta(target=path, mode=mode)\n        logging.info(f\"{mode.capitalize()}ed message to Delta table: {df}\")\n    except Exception as e:\n        logging.error(f\"Failed to {mode} message to Delta table: {df}\")\n        logging.error(f\"Error: {e}\")\n```\n\n테이블 태그를 마크다운 형식으로 변경해주시기 바랍니다.\n\n여기서는 DataFrame, 주제 경로, 그리고 모드(삽입)를 간단히 전달하고 네이티브 Polars 기능을 사용하여 Delta 테이블에 작성합니다. 작업이 성공했음을 로그에 남기거나 실패했을 때 오류를 캡처하여 조사할 수 있도록 합니다.\n\n## merge_into_delta_table\n\n여기에는 조금 더 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\ndef merge_into_delta_table(df, path):\n    try:\n        df.write_delta(\n            target=path, mode=\"merge\",\n            delta_merge_options={\n                \"predicate\": \"s.id = t.id\",\n                \"source_alias\": \"s\",\n                \"target_alias\": \"t\",\n            }\n        ).when_matched_update_all().when_not_matched_insert_all().execute()\n        logging.info(f\"Merged message to Delta table: {df}\")\n    except Exception as e:\n        logging.error(f\"Failed to merge message to Delta table: {df}\")\n        logging.error(f\"Error: {e}\")\n```\n\n여기에서 모드를 전달하지 않아도 됩니다. 왜냐하면 모드가 \"merge\"로 설정될 것이라는 것을 알기 때문입니다. 제 모든 테이블에는 id라는 동일한 이름을 가진 기본 키가 있으므로 한 번 정의하고 이 함수를 완전히 재사용하기 쉽습니다. 일치하는 경우 데이터가 업데이트되고, 일치하지 않는 경우 데이터가 삽입됩니다. 이것이 기본적으로 upsert입니다. 성공과 실패를 여전히 기록했습니다.\n\n여기가 파이프라인의 전부입니다. 정말 간단합니다. 데이터를 게시하고 데이터를 구독하여 디스크에 저장합니다. 다음에는 해당 데이터를 쿼리하고 모든 것을 함께 가져오는 DataFrame을 가져오는 방법을 살펴볼 것입니다.\n\n# 쿼리\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 시점에서 Kafka는 더 이상 사용되지 않습니다. 모든 것이 Delta 테이블에 있으며 쿼리만 필요합니다. 전체 코드는 여기에 있습니다. Delta 테이블을 각각 데이터프레임 집합으로 불러오기 시작했습니다:\n\n```js\nclient = pl.read_delta(f\"{delta_path}/client\")\ndepartment = pl.read_delta(f\"{delta_path}/department\")\nemployee = pl.read_delta(f\"{delta_path}/employee\")\nsale = pl.read_delta(f\"{delta_path}/sale\")\n```\n\nclient와 employee 데이터프레임에는 first_name과 last_name 속성이 같습니다. 데이터프레임 이름 외에는 구별할 요소가 없습니다. 각각에 first_name과 last_name을 붙여 공백을 구분자로 사용한 새로운 속성을 추가하고 적절히 이름을 지었습니다. 이렇게 하면 두 데이터프레임을 하나의 데이터프레임으로 결합할 때 무엇이 무엇인지 알 수 있습니다:\n\n```js\nclient = client.with_columns(\n    pl.concat_str([\"first_name\", \"last_name\"], separator = \" \").alias(\"client_name\")\n    )\n\nemployee = employee.with_columns(\n    pl.concat_str([\"first_name\", \"last_name\"], separator = \" \").alias(\"employee_name\")\n    )\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n직원 DataFrame에는 department_id라는 추가 속성이 포함되어 있습니다. 이를 사용하여 직원과 부서를 함께 결합한 새 DataFrame을 생성할 수 있어요:\n\n```js\nemployee_dept = employee.join(\n        department, \n        left_on = \"department_id\", \n        right_on = \"id\", \n        how = \"inner\").select(\n                [\"id\", \"employee_name\", \"department_id\", \"department\"]\n                )\n```\n\n직원 DataFrame을 기반으로, 부서 DataFrame과 조인을 생성했는데, 직원 DataFrame의 department_id와 부서 DataFrame의 id를 일치하는 조인 조건으로 지정했어요. 모든 직원이 부서를 가져야 하기 때문에 INNER JOIN을 조인 유형으로 선택했고, 이후 유지할 속성을 선택했어요.\n\n마지막으로, 한 마지막 문장으로 모두 함께 결합할 수 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncomplete = sale.join(\n        employee_dept,\n        left_on = \"employee_id\", \n        right_on = \"id\", \n        ).join(\n                client, \n                left_on = \"client_id\", \n                right_on = \"id\", \n                how = \"inner\"\n                ).select(\n                        pl.col(\"id\").str.to_integer(),\n                        pl.col(\"employee_name\"), \n                        pl.col(\"department\"), \n                        pl.col(\"client_name\"), \n                        pl.col(\"date\").str.to_date(\"%d/%m/%Y\"), \n                        pl.col(\"region\"), \n                        pl.col(\"sale\").str.to_decimal(2),\n                        )\n```\n\n저는 sale DataFrame에서 시작하여 방금 생성한 employee_dept DataFrame에 조인을 수행합니다. 이제 이는 sale, employee 및 department를 결합하는 것입니다. 그런 다음 client DataFrame을 다시 조인한 다음 원하는 속성을 선택합니다. 그러나 이 경우 데이터 유형을 변경했습니다. 데이터는 csv를 통해 가져온 것이기 때문에 원래 데이터 유형이 없었습니다. 따라서 id는 정수이어야 한다고 지정했습니다. 날짜는 날짜 유형이어야 하며, 형식을 지정했으며, sale 속성이 두 자리 소수점(달러 및 센트)인 것을 지정했습니다.\n\n마지막 단계는 결과를 출력하는 것입니다:\n\n\u003cimg src=\"/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_4.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n본 글에서는 Kafka, Polars, 그리고 Delta Lake를 활용하여 실시간 데이터 파이프라인을 구축하는 방법을 살펴보았습니다. 메시지 스트리밍을 위해 Kafka를 활용하고, 데이터 처리를 위해 Polars를 사용하며, 안정적인 저장소로 Delta Lake를 활용하여 확장 가능하고 오류 허용성 있는 데이터 파이프라인을 만들 수 있습니다.\n\n저장소의 코드 샘플은 파이프라인의 기본 설정과 기능을 보여줍니다. 데이터 보존 정책 구성, S3 객체 저장소에 데이터 보관, 다른 시스템과 통합하는 등 특정 요구 사항에 맞게 코드를 확장하고 사용자화할 수 있습니다.\n\n이 아키텍처를 채택함으로써 기업은 실시간 데이터를 효율적으로 처리하고 분석하여 데이터 기반 결정을 내리고 신속하게 변화에 대응할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글이 유용했길 바랍니다. 만약 그렇다면 👏 한 번 눌러주시겠어요? 그리고 더 보고 싶으면 구독해주세요. 매주 한 두 편의 글을 업로드하고 있어요.","ogImage":{"url":"/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_0.png"},"coverImage":"/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_0.png","tag":["Tech"],"readingTime":13},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    h1: \"h1\",\n    img: \"img\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"카프카(Kafka), 폴라스(Polars), 델타 레이크(Delta Lake)를 활용한 실시간 분석\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"데이터 엔지니어라면 언젠가는 실시간 데이터에 대한 비즈니스 요구사항을 직면해야 할 것입니다. 이는 빨리 오겠다는 것이 확실합니다. 실시간 데이터 처리는 기업이 신속하게 정보 기반 결정을 내릴 수 있도록 필수적으로 중요해지고 있으며, 아파치 카프카는 확장 가능하고 오류 허용성 있는 실시간 데이터 파이프라인을 구축하기 위한 인기 있는 플랫폼으로 부상했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 기사에서는 카프카, 폴라스, 델타 레이크를 사용하여 실시간 데이터 파이프라인을 만드는 방법을 실제로 보여드리겠습니다. 그리 어렵지 않습니다! 자신도 이를 시도할 수 있는 코드는 여기에서 확인하실 수 있습니다. 유용하다고 느끼신다면 ⭐️을 주세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"기술적인 기사가 될 예정이니, 코드 스니펫이 많이 포함될 것입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"따라오기 시작하기 위해 설정해야 할 사항\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"시작하기 위해 몇 가지 구성 요소를 설정해 두었습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Kafka 브로커: Docker Compose를 사용하여 Kafka와 Zookeeper 컨테이너를 실행했습니다. docker-compose.yml 파일에는 필요한 서비스와 구성이 정의되어 있습니다. 이에 대해 자세히 다루지는 않겠습니다. 이 파일은 어디에서든 다운로드할 수 있는 기본적인 docker-compose.yml입니다. 데이터 엔지니어링 팀이 Kafka 환경을 관리하는 것으로 간주하지 않겠습니다. 당신이 담당하고 있는 플랫폼 또는 데브옵스 팀이 그 역할을 맡고 있을 것이라고 가정하겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"발행자: Python 스크립트인 publisher.py를 만들었습니다. 이 스크립트는 일련의 csv 파일에 저장된 샘플 데이터를 Kafka 주제에 발행합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"구독자님: 새로운 Python 스크립트인 subscriber.py를 만들었어요. 이 스크립트는 Kafka 토픽에서 메시지를 가져와 Polars를 사용하여 Delta 테이블에 쓰는 역할을 해요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"질문: 추가적으로 한 가지 더, query.py라는 마지막 Python 스크립트를 만들었어요. 이 스크립트는 Delta 테이블에 포함된 데이터를 가져와 조인하고, 조인된 데이터를 포함한 데이터프레임을 화면에 출력합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"매개변수: Python 스크립트 내에 설정 매개변수를 저장하는 대신 toml 파일을 사용했어요. 이렇게 하면 매개변수를 변경하고 싶어도 코드를 손대지 않아도 돼요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"단순히 실행만 하려면\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"원하는 부분으로 건너뛰고 싶으세요? 알겠어요! 여기 실행하는 순서입니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저 Kafka 브로커를 실행하려면 Docker가 설치되어 있어야 합니다. 메인 폴더 내에서 docker-compose up을 실행할 수 있어요. 먼저 몇 가지 파일을 다운로드해야 하며, 그 후에 프로세스들이 시작되면 화면에 많은 텍스트가 표시될 거예요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_0.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그 다음으로, publisher용 새 터미널 세션을 열고, subscriber용 또 다른 터미널 세션을 열어 보세요. Docker 컨테이너를 설정하지는 않았지만, 이들을 독립적인 Docker 컨테이너로 설정할 방법에 대해 알아보고 싶다면 이 기사를 확인해 보세요. 대신, 새로운 가상 Python 환경을 만들어서 그 안에 설치할 걸 권장드려요. python3 -m venv venv로 가상 환경을 생성한 다음 venv/bin/activate를 입력하여 새로운 가상 환경으로 전환하고, requirements.txt에 정의된 필수 패키지를 pip install -r로 설치하시면 됩니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"모든 준비가 완료되었습니다. 먼저 터미널 창에서 subscriber.py를 실행한 후, 준비가 되면 publisher.py를 실행하세요. publisher에서 전송된 마이크로 배치를 볼 수 있으며, 동시에 subscriber가 실시간으로 수신하는 것을 볼 수 있을 겁니다. 그러나 subscriber와 publisher를 올바른 순서로 로드해야 합니다. subscriber가 준비되기 전에 publisher가 모두 보내버리는 일이 없도록 주의하세요. 이 경량 데모에서는 보관 기간을 설정하지 않았으니 주의해주세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래 스크린샷을 보면, 왼쪽에 publisher가 있고 오른쪽에 subscriber가 있는 분할 된 터미널이 있습니다. 왼쪽에서 전송되는 일괄처리된 데이터를 보고, 오른쪽에서는 개별 레코드가 처리되는 것을 볼 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_1.png\",\n        alt: \"Publisher 및 Subscriber 스크린샷\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"모든 레코드가 전송된 후에는 publisher가 연결을 종료할 것입니다. subscriber는 프로세스가 종료될 때까지 계속 수신 대기 상태에 머무를 것입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막 단계는 query.py 파일을 실행하여 다른 화면을 로드하고 쿼리 결과를 확인하는 것입니다. 화면에 DataFrame이 출력되는데, 이겇이 우리의 작업 결과입니다. 이러한 csv 파일 각각이 Kafka를 통해 Delta 테이블로 이동되었으며, 이제 올바른 데이터 유형과 필드 이름을 가진 단일 DataFrame으로 변환되었습니다. 필요하다면, 발행물을 시작하는 동시에 실행할 수 있으며, 여러 번 실행하면 데이터가 흐르는 것을 확인할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_2.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기까지입니다! 몇 개의 csv 파일을 Kafka를 통해 마이크로 배치로 로드한 다음 이를 Delta 테이블로 다운스트림으로 스트리밍했습니다. 그 후 데이터를 쿼리하고 변환하여 직원, 부서, 고객, 판매 일자, 판매 지역 및 판매 금액을 모두 포함한 단일 DataFrame으로 통합했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"만약 궁금하시다면, 각 테이블의 기본 키를 기반으로 파일을 로드하기 위해 병합 프로세스를 사용했습니다. 그래서 데이터를 변경하고 다시로드하면 Delta 테이블에서 데이터를 우아하게 업데이트할 수 있습니다. 아래에서 csv에서 Finance 부서 레코드를 FinTech로 변경하고 두 번째로 실행했더니 어떻게 변경되는지 확인해보세요:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_3.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"계속 읽어 보면 어떻게 작동하는지 알 수 있어요...\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"발행자\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"발행자 스크립트는 데이터를 Kafka로 보내는 데 사용됩니다. 전체 파일은 여기에서 찾을 수 있어요. 일부 구성을 설정한 후, 파일을 시작하는 지점인 아래쪽에서 여정을 시작해요:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" __name__ == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"__main()\\\"\"\n        }), \":\\n    producer = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"create_producer\"\n        }), \"(bootstrap_servers)\\n    \\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"try\"\n        }), \":\\n        \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"process_files_and_send\"\n        }), \"(producer, topics, batch_size)\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"finally\"\n        }), \":\\n        producer.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"close\"\n        }), \"()\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"카프카 프로듀서를 producer로 인스턴스화하고 서버 세부 정보를 전달했습니다. 그런 다음 파일을 처리하려고 시도하고 완료되면 연결을 닫습니다. 간단하죠! 이제 파일의 맨 위로 돌아가서 각 함수를 하나씩 작업할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"create_producer\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"def \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"create_producer\"\n        }), \"(bootstrap_servers):\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"KafkaProducer\"\n        }), \"(\\n        bootstrap_servers=bootstrap_servers,\\n        value_serializer=lambda \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"v\"\n        }), \": json.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"dumps\"\n        }), \"(v).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"encode\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"utf-8\\\"\"\n        }), \")\\n    )\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기에는 그다지 많은 내용이 없어요. 저는 단순히 KafkaProducer를 함수로 래핑하여 제 개인적인 것으로 만들었어요. 서버 세부 정보를 전달하고, 매개변수인 v를 취하고 해당 매개변수로 전달된 내용을 JSON으로 변환하는 람다 함수를 사용했어요. 그 JSON은 UTF-8로 인코딩되어요. 많은 데이터 처리 함수가 문자열 대신 바이트 형식의 데이터를 예상하기 때문에 이것은 필수적입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"send_messages\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"def \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"send_messages\"\n        }), \"(producer, topic, messages):\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"try\"\n        }), \":\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" message \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"messages\"\n        }), \":\\n            producer.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"send\"\n        }), \"(topic, value=message)\\n        producer.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"flush\"\n        }), \"()\\n        logging.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"info\"\n        }), \"(f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Batch of messages sent to topic '{topic}'.\\\"\"\n        }), \")\\n    except \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Exception\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"e\"\n        }), \":\\n        logging.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"error\"\n        }), \"(f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Failed to send messages to topic '{topic}'. Error: {e}\\\"\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저는 아직 클래스를 사용하지 않았기 때문에 다음에 이것을 설정하고 있어요. 실제로 사용될 때 미리 로드되고 준비되어 있어야 해요. 여기서는 Kafka로 데이터를 전송하려고 노력해요. 각 메시지마다 Kafka Producer를 사용하고 메시지를 주제로 보내요. 그런 다음 보낸 것을 기록하거나 필요한 경우 발생한 오류를 기록해 내용이 잘못됐는지 조사할 수 있어요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"process_files_and_send\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"def \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"process_files_and_send\"\n        }), \"(producer, topics, batch_size):\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" topic \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"topics\"\n        }), \":\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"try\"\n        }), \":\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"open\"\n        }), \"(f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{raw_path}/{topic}.csv\\\"\"\n        }), \", encoding=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"utf-8-sig\\\"\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"csvfile\"\n        }), \":\\n                csvreader = csv.\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DictReader\"\n        }), \"(csvfile)\\n                batch = []\\n\\n                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" rows \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"csvreader\"\n        }), \":\\n                    batch.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"(rows)\\n                    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"len\"\n        }), \"(batch) \u003e= \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"batch_size\"\n        }), \":\\n                        \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"send_messages\"\n        }), \"(producer, topic, batch)\\n                        batch = []\\n\\n                # \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Send\"\n        }), \" any remaining messages \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" the last batch\\n                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"batch\"\n        }), \":\\n                    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"send_messages\"\n        }), \"(producer, topic, batch)\\n\\n        except \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FileNotFoundError\"\n        }), \":\\n            logging.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"error\"\n        }), \"(f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"File not found: {raw_path}/{topic}.csv\\\"\"\n        }), \")\\n        except \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Exception\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"e\"\n        }), \":\\n            logging.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"error\"\n        }), \"(f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Error processing file for topic '{topic}': {e}\\\"\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기가 번잡한 부분이고, 데이터를 보내는 작업을 마치게 될 거야.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제가 프로듀서를 맨 처음에 인스턴스화할 때 전달하고, 토픽들도 함께 전달해주는 함수를 만들었어요. 그런 다음 각 토픽을 순회하면서 처리해요. 각 토픽은 csv 파일과 관련이 있기 때문에, 먼저 파일을 열려고 시도하는 거죠.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"배치 크기를 입력 매개변수로 정의했다는 것을 알 수 있을 겁니다. 이건 정말 필수적인 것은 아니지만, csv 파일에서 데이터를 가져오는 대신에 웹페이지나 다른 스트리밍 서비스에서 가져오는 것이 아니기 때문에, 메시지를 배치로 묶어서 그룹으로 보내고 싶었습니다. 이렇게 하면 작업이 빨라집니다. 저는 toml 파일 내에서 배치 크기를 10으로 설정했는데, 이는 사실상 한 번에 csv 파일의 10줄에 해당합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그런 다음 각 행을 배치에 추가하면서 배치 한도에 도달할 때까지 작업을 수행한 후 데이터를 전송하고 배치를 비웁니다. 작업을 마치면 마지막 메시지로 배치를 정리합니다 (남은 레코드가 5개만 남았을 수 있지만, 그래도 모두 보내고 싶습니다).\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막으로, raw 파일을 찾을 수 없는 경우나 발생할 수 있는 기타 일반적인 오류에 대한 오류 처리가 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것이 publisher.py 파일의 내용입니다. 이해가 되시겠나요? 이제 subscriber.py 파일로 넘어가 봅시다!\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"구독자\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"구독자는 Kafka 주제를 청취하고, 새 레코드를 발견했을 때 특정 작업을 수행하는 데 사용됩니다. 이 경우, 해당 레코드의 내용을 가져와 Delta 테이블에 저장합니다. 여기서 전체 코드를 찾을 수 있는 코드를 통해 코드를 하나씩 살펴보겠습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" __name__ == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"__main__\\\"\"\n        }), \":\\n    consumer = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"create_consumer\"\n        }), \"(topics, bootstrap_servers)\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" message \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"consumer\"\n        }), \":\\n        \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"process_message\"\n        }), \"(message.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"topic\"\n        }), \", message.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"발행자와 비슷하게, 첫 번째로 하는 일은 주제 및 서버 세부 정보를 구성 변수로 제공하고, 이를 전달하여 소비자를 인스턴스화하는 것입니다. 그런 다음 소비한 각 메시지를 처리합니다. 간단하지요. 하지만 함수별로 좀 더 자세히 살펴보겠습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"소비자 생성\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"def \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"create_consumer\"\n        }), \"(topics, bootstrap_servers):\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"KafkaConsumer\"\n        }), \"(\\n        *topics,\\n        bootstrap_servers = bootstrap_servers,\\n        value_deserializer = lambda \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"v\"\n        }), \": json.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"loads\"\n        }), \"(v.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"decode\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"utf-8\\\"\"\n        }), \"))\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리 Python의 진입점에서 첫 번째 줄은 소비자를 인스턴스화하는 것이었습니다. 이것은 기본적으로 KafkaConsumer의 래퍼일 뿐입니다. 퍼블리셔와 다른 것은 아무 것도 하지 않습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"메시지 처리\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"process_message\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"topic, data\"\n        }), \"):\\n    df = pl.from_records([data])\\n    delta_table_path = \", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"f\\\"\", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"{delta_path}\"\n          }), \"/\", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"{topic}\"\n          }), \"\\\"\"]\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"not\"\n        }), \" os.path.exists(delta_table_path):\\n        write_delta_table(df, delta_table_path, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"insert\\\"\"\n        }), \")\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \":\\n        merge_into_delta_table(df, delta_table_path)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"메시지를 받을 때마다 그것을 처리하는 방법을 알아야 합니다. 저는 여기서 두 가지 방법을 선택했습니다. 먼저 Delta 테이블이 저장된 경로를 가져와 해당 경로가 존재하는지 확인합니다. 경로가 존재하지 않으면 새 레코드를 삽입하기 위해 insert 매개변수를 사용하여 write_delta_table 함수를 호출합니다. 그러나 경로가 이미 존재한다면, merge_into_delta_table 함수를 호출합니다. 이를 통해 데이터를 여러 번로드할 수 있게 하면서 단순히 테이블을 점점 더 크게 만들지 않습니다. 이미 변경된 기존 항목을 업데이트하고 새 레코드만 추가합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이러한 함수들을 좀 더 자세히 살펴봅시다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"write_delta_table\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"write_delta_table\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"df, path, mode\"\n        }), \"):\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"try\"\n        }), \":\\n        df.write_delta(target=path, mode=mode)\\n        logging.info(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"f\\\"\", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"{mode.capitalize()}\"\n          }), \"ed message to Delta table: \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"{df}\"\n          }), \"\\\"\"]\n        }), \")\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"except\"\n        }), \" Exception \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" e:\\n        logging.error(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"f\\\"Failed to \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"{mode}\"\n          }), \" message to Delta table: \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"{df}\"\n          }), \"\\\"\"]\n        }), \")\\n        logging.error(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"f\\\"Error: \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"{e}\"\n          }), \"\\\"\"]\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"테이블 태그를 마크다운 형식으로 변경해주시기 바랍니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서는 DataFrame, 주제 경로, 그리고 모드(삽입)를 간단히 전달하고 네이티브 Polars 기능을 사용하여 Delta 테이블에 작성합니다. 작업이 성공했음을 로그에 남기거나 실패했을 때 오류를 캡처하여 조사할 수 있도록 합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"merge_into_delta_table\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기에는 조금 더 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"merge_into_delta_table\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"df, path\"\n        }), \"):\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"try\"\n        }), \":\\n        df.write_delta(\\n            target=path, mode=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"merge\\\"\"\n        }), \",\\n            delta_merge_options={\\n                \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"predicate\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"s.id = t.id\\\"\"\n        }), \",\\n                \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"source_alias\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"s\\\"\"\n        }), \",\\n                \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"target_alias\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"t\\\"\"\n        }), \",\\n            }\\n        ).when_matched_update_all().when_not_matched_insert_all().execute()\\n        logging.info(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"f\\\"Merged message to Delta table: \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"{df}\"\n          }), \"\\\"\"]\n        }), \")\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"except\"\n        }), \" Exception \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" e:\\n        logging.error(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"f\\\"Failed to merge message to Delta table: \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"{df}\"\n          }), \"\\\"\"]\n        }), \")\\n        logging.error(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"f\\\"Error: \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"{e}\"\n          }), \"\\\"\"]\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기에서 모드를 전달하지 않아도 됩니다. 왜냐하면 모드가 \\\"merge\\\"로 설정될 것이라는 것을 알기 때문입니다. 제 모든 테이블에는 id라는 동일한 이름을 가진 기본 키가 있으므로 한 번 정의하고 이 함수를 완전히 재사용하기 쉽습니다. 일치하는 경우 데이터가 업데이트되고, 일치하지 않는 경우 데이터가 삽입됩니다. 이것이 기본적으로 upsert입니다. 성공과 실패를 여전히 기록했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기가 파이프라인의 전부입니다. 정말 간단합니다. 데이터를 게시하고 데이터를 구독하여 디스크에 저장합니다. 다음에는 해당 데이터를 쿼리하고 모든 것을 함께 가져오는 DataFrame을 가져오는 방법을 살펴볼 것입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"쿼리\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 시점에서 Kafka는 더 이상 사용되지 않습니다. 모든 것이 Delta 테이블에 있으며 쿼리만 필요합니다. 전체 코드는 여기에 있습니다. Delta 테이블을 각각 데이터프레임 집합으로 불러오기 시작했습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"client = pl.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"read_delta\"\n        }), \"(f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{delta_path}/client\\\"\"\n        }), \")\\ndepartment = pl.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"read_delta\"\n        }), \"(f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{delta_path}/department\\\"\"\n        }), \")\\nemployee = pl.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"read_delta\"\n        }), \"(f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{delta_path}/employee\\\"\"\n        }), \")\\nsale = pl.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"read_delta\"\n        }), \"(f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{delta_path}/sale\\\"\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"client와 employee 데이터프레임에는 first_name과 last_name 속성이 같습니다. 데이터프레임 이름 외에는 구별할 요소가 없습니다. 각각에 first_name과 last_name을 붙여 공백을 구분자로 사용한 새로운 속성을 추가하고 적절히 이름을 지었습니다. 이렇게 하면 두 데이터프레임을 하나의 데이터프레임으로 결합할 때 무엇이 무엇인지 알 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"client = client.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"with_columns\"\n        }), \"(\\n    pl.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"concat_str\"\n        }), \"([\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"first_name\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"last_name\\\"\"\n        }), \"], separator = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\" \\\"\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"alias\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"client_name\\\"\"\n        }), \")\\n    )\\n\\nemployee = employee.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"with_columns\"\n        }), \"(\\n    pl.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"concat_str\"\n        }), \"([\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"first_name\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"last_name\\\"\"\n        }), \"], separator = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\" \\\"\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"alias\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"employee_name\\\"\"\n        }), \")\\n    )\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"직원 DataFrame에는 department_id라는 추가 속성이 포함되어 있습니다. 이를 사용하여 직원과 부서를 함께 결합한 새 DataFrame을 생성할 수 있어요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"employee_dept = employee.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"join\"\n        }), \"(\\n        department, \\n        left_on = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"department_id\\\"\"\n        }), \", \\n        right_on = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"id\\\"\"\n        }), \", \\n        how = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"inner\\\"\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"select\"\n        }), \"(\\n                [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"id\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"employee_name\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"department_id\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"department\\\"\"\n        }), \"]\\n                )\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"직원 DataFrame을 기반으로, 부서 DataFrame과 조인을 생성했는데, 직원 DataFrame의 department_id와 부서 DataFrame의 id를 일치하는 조인 조건으로 지정했어요. 모든 직원이 부서를 가져야 하기 때문에 INNER JOIN을 조인 유형으로 선택했고, 이후 유지할 속성을 선택했어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막으로, 한 마지막 문장으로 모두 함께 결합할 수 있어요:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"complete = sale.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"join\"\n        }), \"(\\n        employee_dept,\\n        left_on = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"employee_id\\\"\"\n        }), \", \\n        right_on = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"id\\\"\"\n        }), \", \\n        ).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"join\"\n        }), \"(\\n                client, \\n                left_on = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"client_id\\\"\"\n        }), \", \\n                right_on = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"id\\\"\"\n        }), \", \\n                how = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"inner\\\"\"\n        }), \"\\n                ).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"select\"\n        }), \"(\\n                        pl.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"col\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"id\\\"\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"str\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_integer\"\n        }), \"(),\\n                        pl.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"col\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"employee_name\\\"\"\n        }), \"), \\n                        pl.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"col\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"department\\\"\"\n        }), \"), \\n                        pl.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"col\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"client_name\\\"\"\n        }), \"), \\n                        pl.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"col\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"date\\\"\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"str\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_date\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"%d/%m/%Y\\\"\"\n        }), \"), \\n                        pl.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"col\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"region\\\"\"\n        }), \"), \\n                        pl.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"col\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"sale\\\"\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"str\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_decimal\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \"),\\n                        )\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저는 sale DataFrame에서 시작하여 방금 생성한 employee_dept DataFrame에 조인을 수행합니다. 이제 이는 sale, employee 및 department를 결합하는 것입니다. 그런 다음 client DataFrame을 다시 조인한 다음 원하는 속성을 선택합니다. 그러나 이 경우 데이터 유형을 변경했습니다. 데이터는 csv를 통해 가져온 것이기 때문에 원래 데이터 유형이 없었습니다. 따라서 id는 정수이어야 한다고 지정했습니다. 날짜는 날짜 유형이어야 하며, 형식을 지정했으며, sale 속성이 두 자리 소수점(달러 및 센트)인 것을 지정했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막 단계는 결과를 출력하는 것입니다:\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_4.png\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"본 글에서는 Kafka, Polars, 그리고 Delta Lake를 활용하여 실시간 데이터 파이프라인을 구축하는 방법을 살펴보았습니다. 메시지 스트리밍을 위해 Kafka를 활용하고, 데이터 처리를 위해 Polars를 사용하며, 안정적인 저장소로 Delta Lake를 활용하여 확장 가능하고 오류 허용성 있는 데이터 파이프라인을 만들 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저장소의 코드 샘플은 파이프라인의 기본 설정과 기능을 보여줍니다. 데이터 보존 정책 구성, S3 객체 저장소에 데이터 보관, 다른 시스템과 통합하는 등 특정 요구 사항에 맞게 코드를 확장하고 사용자화할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 아키텍처를 채택함으로써 기업은 실시간 데이터를 효율적으로 처리하고 분석하여 데이터 기반 결정을 내리고 신속하게 변화에 대응할 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 글이 유용했길 바랍니다. 만약 그렇다면 👏 한 번 눌러주시겠어요? 그리고 더 보고 싶으면 구독해주세요. 매주 한 두 편의 글을 업로드하고 있어요.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-20-BuildingaReal-TimeDataPipeline"},"buildId":"R1x9p1CQYDDJESXyLXKOK","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>