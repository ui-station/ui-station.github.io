<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>자바 가상 스레드가 플랫폼 스레드보다 느린 이유는 무엇인가요 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="자바 가상 스레드가 플랫폼 스레드보다 느린 이유는 무엇인가요 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="자바 가상 스레드가 플랫폼 스레드보다 느린 이유는 무엇인가요 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads" data-gatsby-head="true"/><meta name="twitter:title" content="자바 가상 스레드가 플랫폼 스레드보다 느린 이유는 무엇인가요 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 21:54" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_buildManifest.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">자바 가상 스레드가 플랫폼 스레드보다 느린 이유는 무엇인가요</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="자바 가상 스레드가 플랫폼 스레드보다 느린 이유는 무엇인가요" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>혹시 팀 애플리케이션 서비스에 기능을 구현하려다가 예상대로 되지 않은 적이 있나요? 저도 정확히 그런 일이 발생했어요!</p>
<h1>제가 겪은 일을 설명하기 전에 가상 스레드를 살펴보죠</h1>
<p>"가상 스레드는 대량 처리 동시 응용 프로그램의 작성, 유지 관리 및 관찰 노력을 크게 줄이는 가벼운 스레드입니다."
— 참고: (<a href="https://openjdk.org/jeps/444" rel="nofollow" target="_blank">https://openjdk.org/jeps/444</a>)</p>
<p>플랫폼 스레드의 문제는 I/O 작업 완료를 기다리는 시간입니다. 해당 스레드가 다른 작업을 수행할 수 없어 기본적으로 아이들 상태가 됩니다. 이는 많은 동시 요청을 처리하는 응용 프로그램에게 특히 비효율적입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위의 사진에서 보여지는 시나리오에서 플랫폼 스레드가 두 번 블록되어 프로그램이 크게 느려질 수 있습니다. 이는 흔히 발생하는 일입니다. 그러나 이러한 상황을 해결하기 위해 리액티브 프레임워크라 불리는 비차단 솔루션이 등장했습니다.</p>
<p>Spring Boot은 Project Reactor를 기반으로 한 Spring WebFlux 스택을 제공합니다. Spring WebFlux를 사용하는 개발자들은 전체 개발 프로세스를 수정해야 합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>2017년, 자바 엔지니어들은 문제를 해결하기 위해 "프로젝트 룸"을 시작했습니다. 결국, 그들은 "가상 스레드"를 개발했습니다.</p>
<p><img src="/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_2.png" alt="이미지"></p>
<p>가상 스레드의 주요 개념은 단일 가상 스레드가 여러 플랫폼 스레드에 장착될 수 있다는 것입니다. 가상 스레드는 블로킹 I/O 작업에서 오류가 발생할 때 현재 플랫폼 스레드에서 해제됩니다. 이 절차는 가상 스레드가 I/O 작업이 완료될 때까지 대기하는 동안 플랫폼 스레드가 다른 작업을 처리할 수 있도록 합니다. I/O 작업이 완료되면, 가상 스레드는 새로운 사용 가능한 플랫폼 스레드에 장착되어 실행을 계속할 수 있습니다.</p>
<p><img src="/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_3.png" alt="이미지"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>한 팀원이 점심 시간에 (블로킹 I/O)다른 플랫폼 스레드로 이동하여 소포 트럭이 중단되지 않고 여정을 계속할 수 있도록 하는 택배 회사의 전략을 상상해 보세요. 이 방식은 물류 운영 시간을 단축시키고 생산성을 높이며 회사를 경쟁력이 더 뛰어나게 만들었습니다.</p>
<p>플랫폼 스레드 간으로 이동하여 마운트 및 언마운트함으로써 가상 스레드는 I/O 작업이 완료될 때까지 블록되지 않을 수 있습니다. 이는 플랫폼 스레드를 더 효율적으로 사용할 수 있게 하고 전반적인 대기 시간을 줄입니다.</p>
<p>간단히 말하면, 단 한 줄의 코드 변경으로 서비스 성능을 향상시킬 수 있는 가장 간단한 방법입니다.</p>
<p>Spring Boot에서 Java 가상 스레드를 활성화하려면 "application.properties"에 이 구성을 추가하면 됩니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">spring.<span class="hljs-property">threads</span>.<span class="hljs-property">virtual</span>.<span class="hljs-property">enabled</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 클릭 한 번으로 쉽게 설정 !!</span>
</code></pre>
<p>참고: 이 설정은 JDK 21 이상과 Spring Boot 3.2 이상을 필요로 합니다.</p>
<h1>성능 비교를 위한 테스트 API 빌드</h1>
<pre><code class="hljs language-js">@<span class="hljs-title class_">RestController</span>
public <span class="hljs-keyword">class</span> <span class="hljs-title class_">PerformanceTestController</span> {

    @<span class="hljs-title class_">GetMapping</span>(<span class="hljs-string">"/test"</span>)
    public <span class="hljs-title class_">ResponseEntity</span>&#x3C;<span class="hljs-title class_">String</span>> <span class="hljs-title function_">testPerformance</span>() throws <span class="hljs-title class_">InterruptedException</span> {

        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"Sleeping ..."</span>);
        <span class="hljs-comment">// CPU 바인드되지 않는 작업 시뮬레이션, 3초 동안 sleep</span>
        <span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">3000</span>);

        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ResponseEntity</span>.<span class="hljs-title function_">ok</span>(<span class="hljs-string">"테스트 완료"</span>);
    }

}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>Apache HTTP 서버 벤치마킹 도구를 사용하여 서비스 성능을 측정할 수 있어요</h1>
<p>다양한 부하로 테스트하고 결과를 분석하여 개선할 수 있어요.</p>
<p>여기 명령어에요.</p>
<pre><code class="hljs language-js">ab -c <span class="hljs-number">300</span> -n <span class="hljs-number">1000</span> -r “<span class="hljs-attr">http</span>:<span class="hljs-comment">//localhost:8443/test"</span>
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>-c 300: 동시 요청 수입니다. 이 경우에는 서버를 동시에 폭격하기 위해 가상 사용자 [300]명이 시뮬레이션됩니다.</li>
<li>-n 1000: 최종적으로 실행될 총 요청 수입니다 [1000].</li>
<li>-r “<a href="http://localhost:8443/test%E2%80%9D" rel="nofollow" target="_blank">http://localhost:8443/test”</a>: 벤치마크 테스트 대상 URL입니다.</li>
</ul>
<p>테스트를 시작합니다. 첫 번째는 기존 방식을 사용하고, 두 번째는 가상 스레드가 활성화됩니다.</p>
<p>가상 스레드 강력해요! 플랫폼 스레드보다 약 20% 빠른 속도로 동일한 작업을 완료합니다 (65.21 RPS 대 54.80 RPS). 그렇다면, 왜 제목에서 가상 스레드가 플랫폼 스레드보다 느리다고 말했을까요?</p>
<h1>실세계에서의 가상 스레드</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우리 팀의 API 분석</p>
<ul>
<li>GET 방식 사용 중</li>
<li>요청 방식 검증</li>
<li>데이터베이스에서 데이터 쿼리</li>
<li>RestClient를 통해 다른 서비스로 요청 보내기</li>
<li>데이터베이스에 데이터 업데이트/저장</li>
</ul>
<p>성능 테스트 결과</p>
<pre><code class="hljs language-js">플랫폼 스레드: <span class="hljs-number">587.24</span> <span class="hljs-variable constant_">TPS</span>, 평균 응답 시간은 <span class="hljs-number">56.</span>52ms
가상 스레드: <span class="hljs-number">502.80</span> <span class="hljs-variable constant_">TPS</span>, 평균 응답 시간은 <span class="hljs-number">66.</span>54ms
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>가상 스레드가 플랫폼 스레드보다 느리다고 테스트 결과에서 나왔다니, 무슨 실수를 한 걸까요?</p>
<h1>핀닝, 발동한 숨겨진 함정</h1>
<p><img src="/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_4.png" alt="이미지"></p>
<p>캐리어 스레드는 가상 스레드가 현재 실행 중인 플랫폼 스레드를 정의하는 또 다른 용어입니다. 핀닝은 가상 스레드가 플랫폼 스레드에 매핑되어 있는 상태를 말하며, 캐리어 스레드에 붙어서 떨어질 수 없는 상태를 묘사합니다. 이는 가상 스레드의 상태를 힙 메모리에 저장할 수 없기 때문에 발생합니다. 핀닝된 스레드는 다른 스레드가 동일한 플랫폼 스레드를 사용하는 것을 막습니다. 몇 가지 가능한 원인을 살펴봅시다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>동기화된 블록 또는 메서드: 한 번에 한 스레드만 들어갈 수 있습니다. 다른 스레드들은 현재(실행 중인) 스레드가 나갈 때까지 차단됩니다. 경합 조건을 방지하고 데이터의 정확한 상태를 유지하기 위해 공유 리소스에 중단되지 않은 액세스가 필요합니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> {
  public <span class="hljs-keyword">void</span> <span class="hljs-title function_">calculateFee</span>(<span class="hljs-params"></span>) {
    synchronized (<span class="hljs-variable language_">this</span>) {
      ...
    }
  }
}
</code></pre>
<ul>
<li>네이티브 메서드: 이 메서드를 사용하면 다른 언어의 코드(C 또는 C++ 등)를 Java 프로젝트에 통합할 수 있습니다. 네이티브 메서드는 Java 가상 머신 내에서 호출되지만 Java의 제어 범위 밖에서 실행됩니다.</li>
</ul>
<p>MyService.java</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
    System.out.println(calculateFee(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>));
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateFee</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;
  <span class="hljs-keyword">static</span> {
    <span class="hljs-comment">// Loads the native library from file named "nativemethod.c".</span>
    System.loadLibrary(<span class="hljs-string">"nativemethod"</span>);
  }
}
</code></pre>
<p>nativemethod.c</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;jni.h></span></span>

JNIEXPORT jint JNICALL <span class="hljs-title function_">Java_calculateFee</span> <span class="hljs-params">(JNIEnv *env, jobject obj, jint a, jint b)</span> {
  <span class="hljs-keyword">return</span> a * b;
}
</code></pre>
<ul>
<li>외부 함수: 다른 프로그래밍 언어로 작성된 함수로서, Foreign Function Interface (FFI)를 통해 가상 스레드에 노출된 함수입니다. FFIs는 다른 언어로 작성된 코드들이 함께 동작할 수 없는 상황에서 사용됩니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PythonFunctions</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Library</span> {
  <span class="hljs-comment">/**
   * 이 정적 final 필드는 `PythonFunctions` 인터페이스의 싱글톤 인스턴스를 생성합니다.
   * 이는 `Library.getInstance` 메서드에서 인스턴스를 검색하고 이 인터페이스 유형으로 캐스팅합니다.
   */</span>
  <span class="hljs-type">PythonFunctions</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> (PythonFunctions) Library.getInstance(<span class="hljs-string">"python_functions"</span>);
  doubled <span class="hljs-title function_">calculateFee</span><span class="hljs-params">(doubled a, doubled b)</span>;
}
</code></pre>
<h1>다음 JVM 매개변수를 옵션으로 사용하여 고정된 스레드를 추적하세요</h1>
<ul>
<li>-Djdk.tracePinnedThreads=full: 고정된 상태에서 스레드가 고정되어 있을 때 완전한 스택 추적을 출력하며, 네이티브 프레임과 모니터를 보유한 프레임을 강조합니다.</li>
<li>-Djdk.tracePinnedThreads=short: 문제가 있는 프레임만을 포함하여 출력을 제한합니다.</li>
</ul>
<p>로그에는 가상 스레드 내에서의 메서드 호출의 스택 추적이 표시됩니다. 이 스레드는 JDBC(Java Database Connectivity) 및 특히 MySQL 연결과 상호 작용하는 메서드를 실행합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>주목할 점은 이러한 메서드 호출 중 몇 가지가 <code>= monitors:1</code> 표기를 포함하고 있어서 가상 스레드가 이 코드 실행 블록 내에서 계속 고정되어 있는 것을 나타낸다.</p>
<h1>버그 #110512 기여: synchronized를 ReentrantLock으로 교체</h1>
<p>마침내 깨달았어요. 저는 사용 중인 MySQL Connector/J 버전 8에서 가상 스레드를 지원하지 않는다는 것을.</p>
<p>다음 단계로 나아가는 내 선택지입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>MySQL Connector/J 버전 9.0.0 이상으로 업그레이드하세요: 이 버전은 가상 스레드가 데이터베이스 상호 작용을 최적으로 수행하도록 합니다.</li>
<li>새 라이브러리 탐험: 새 라이브러리를 찾아 새로운 코드를 작성하고 테스트해 보세요. 도전적이며 상당한 노력이 필요할 수 있습니다.</li>
</ul>
<h1>한 발 물러서 두 발 앞으로!</h1>
<p>플랫폼 스레드에서 가상 스레드로의 전환을 통해 성능을 향상시키려는 시도는 "피닝"과 관련하여 예상치 못한 제약으로 인해 속도가 느려지는 문제가 발생했습니다. 결과적으로, 우리는 다시 플랫폼 스레드를 사용하도록 돌아갔습니다.</p>
<p>지금은 성능을 개선하기 위한 대안 전략을 탐색하면서 버전 9.0.0의 릴리스를 기다리고 있습니다. 이는 새로운 기술을 도입하는 데 따르는 도전을 강조하며, 실행 전 철저한 테스트의 중요성을 강조합니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"자바 가상 스레드가 플랫폼 스레드보다 느린 이유는 무엇인가요","description":"","date":"2024-06-19 21:54","slug":"2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads","content":"\n혹시 팀 애플리케이션 서비스에 기능을 구현하려다가 예상대로 되지 않은 적이 있나요? 저도 정확히 그런 일이 발생했어요!\n\n# 제가 겪은 일을 설명하기 전에 가상 스레드를 살펴보죠\n\n\"가상 스레드는 대량 처리 동시 응용 프로그램의 작성, 유지 관리 및 관찰 노력을 크게 줄이는 가벼운 스레드입니다.\"\n— 참고: (https://openjdk.org/jeps/444)\n\n플랫폼 스레드의 문제는 I/O 작업 완료를 기다리는 시간입니다. 해당 스레드가 다른 작업을 수행할 수 없어 기본적으로 아이들 상태가 됩니다. 이는 많은 동시 요청을 처리하는 응용 프로그램에게 특히 비효율적입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 사진에서 보여지는 시나리오에서 플랫폼 스레드가 두 번 블록되어 프로그램이 크게 느려질 수 있습니다. 이는 흔히 발생하는 일입니다. 그러나 이러한 상황을 해결하기 위해 리액티브 프레임워크라 불리는 비차단 솔루션이 등장했습니다.\n\nSpring Boot은 Project Reactor를 기반으로 한 Spring WebFlux 스택을 제공합니다. Spring WebFlux를 사용하는 개발자들은 전체 개발 프로세스를 수정해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2017년, 자바 엔지니어들은 문제를 해결하기 위해 \"프로젝트 룸\"을 시작했습니다. 결국, 그들은 \"가상 스레드\"를 개발했습니다.\n\n![이미지](/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_2.png)\n\n가상 스레드의 주요 개념은 단일 가상 스레드가 여러 플랫폼 스레드에 장착될 수 있다는 것입니다. 가상 스레드는 블로킹 I/O 작업에서 오류가 발생할 때 현재 플랫폼 스레드에서 해제됩니다. 이 절차는 가상 스레드가 I/O 작업이 완료될 때까지 대기하는 동안 플랫폼 스레드가 다른 작업을 처리할 수 있도록 합니다. I/O 작업이 완료되면, 가상 스레드는 새로운 사용 가능한 플랫폼 스레드에 장착되어 실행을 계속할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 팀원이 점심 시간에 (블로킹 I/O)다른 플랫폼 스레드로 이동하여 소포 트럭이 중단되지 않고 여정을 계속할 수 있도록 하는 택배 회사의 전략을 상상해 보세요. 이 방식은 물류 운영 시간을 단축시키고 생산성을 높이며 회사를 경쟁력이 더 뛰어나게 만들었습니다.\n\n플랫폼 스레드 간으로 이동하여 마운트 및 언마운트함으로써 가상 스레드는 I/O 작업이 완료될 때까지 블록되지 않을 수 있습니다. 이는 플랫폼 스레드를 더 효율적으로 사용할 수 있게 하고 전반적인 대기 시간을 줄입니다.\n\n간단히 말하면, 단 한 줄의 코드 변경으로 서비스 성능을 향상시킬 수 있는 가장 간단한 방법입니다.\n\nSpring Boot에서 Java 가상 스레드를 활성화하려면 \"application.properties\"에 이 구성을 추가하면 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nspring.threads.virtual.enabled = true; // 클릭 한 번으로 쉽게 설정 !!\n```\n\n참고: 이 설정은 JDK 21 이상과 Spring Boot 3.2 이상을 필요로 합니다.\n\n# 성능 비교를 위한 테스트 API 빌드\n\n```js\n@RestController\npublic class PerformanceTestController {\n\n    @GetMapping(\"/test\")\n    public ResponseEntity\u003cString\u003e testPerformance() throws InterruptedException {\n\n        System.out.println(\"Sleeping ...\");\n        // CPU 바인드되지 않는 작업 시뮬레이션, 3초 동안 sleep\n        Thread.sleep(3000);\n\n        return ResponseEntity.ok(\"테스트 완료\");\n    }\n\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Apache HTTP 서버 벤치마킹 도구를 사용하여 서비스 성능을 측정할 수 있어요\n\n다양한 부하로 테스트하고 결과를 분석하여 개선할 수 있어요.\n\n여기 명령어에요.\n\n```js\nab -c 300 -n 1000 -r “http://localhost:8443/test\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- -c 300: 동시 요청 수입니다. 이 경우에는 서버를 동시에 폭격하기 위해 가상 사용자 [300]명이 시뮬레이션됩니다.\n- -n 1000: 최종적으로 실행될 총 요청 수입니다 [1000].\n- -r “http://localhost:8443/test”: 벤치마크 테스트 대상 URL입니다.\n\n테스트를 시작합니다. 첫 번째는 기존 방식을 사용하고, 두 번째는 가상 스레드가 활성화됩니다.\n\n가상 스레드 강력해요! 플랫폼 스레드보다 약 20% 빠른 속도로 동일한 작업을 완료합니다 (65.21 RPS 대 54.80 RPS). 그렇다면, 왜 제목에서 가상 스레드가 플랫폼 스레드보다 느리다고 말했을까요?\n\n# 실세계에서의 가상 스레드\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 팀의 API 분석\n\n- GET 방식 사용 중\n- 요청 방식 검증\n- 데이터베이스에서 데이터 쿼리\n- RestClient를 통해 다른 서비스로 요청 보내기\n- 데이터베이스에 데이터 업데이트/저장\n\n성능 테스트 결과\n\n```js\n플랫폼 스레드: 587.24 TPS, 평균 응답 시간은 56.52ms\n가상 스레드: 502.80 TPS, 평균 응답 시간은 66.54ms\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가상 스레드가 플랫폼 스레드보다 느리다고 테스트 결과에서 나왔다니, 무슨 실수를 한 걸까요?\n\n# 핀닝, 발동한 숨겨진 함정\n\n![이미지](/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_4.png)\n\n캐리어 스레드는 가상 스레드가 현재 실행 중인 플랫폼 스레드를 정의하는 또 다른 용어입니다. 핀닝은 가상 스레드가 플랫폼 스레드에 매핑되어 있는 상태를 말하며, 캐리어 스레드에 붙어서 떨어질 수 없는 상태를 묘사합니다. 이는 가상 스레드의 상태를 힙 메모리에 저장할 수 없기 때문에 발생합니다. 핀닝된 스레드는 다른 스레드가 동일한 플랫폼 스레드를 사용하는 것을 막습니다. 몇 가지 가능한 원인을 살펴봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 동기화된 블록 또는 메서드: 한 번에 한 스레드만 들어갈 수 있습니다. 다른 스레드들은 현재(실행 중인) 스레드가 나갈 때까지 차단됩니다. 경합 조건을 방지하고 데이터의 정확한 상태를 유지하기 위해 공유 리소스에 중단되지 않은 액세스가 필요합니다.\n\n```js\nclass MyService {\n  public void calculateFee() {\n    synchronized (this) {\n      ...\n    }\n  }\n}\n```\n\n- 네이티브 메서드: 이 메서드를 사용하면 다른 언어의 코드(C 또는 C++ 등)를 Java 프로젝트에 통합할 수 있습니다. 네이티브 메서드는 Java 가상 머신 내에서 호출되지만 Java의 제어 범위 밖에서 실행됩니다.\n\nMyService.java\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic class MyService {\n  public static void main(String[] args) {\n    System.out.println(calculateFee(5, 3));\n  }\n  public static native int calculateFee(int a, int b);\n  static {\n    // Loads the native library from file named \"nativemethod.c\".\n    System.loadLibrary(\"nativemethod\");\n  }\n}\n```\n\nnativemethod.c\n\n```c\n#include \u003cjni.h\u003e\n\nJNIEXPORT jint JNICALL Java_calculateFee (JNIEnv *env, jobject obj, jint a, jint b) {\n  return a * b;\n}\n```\n\n- 외부 함수: 다른 프로그래밍 언어로 작성된 함수로서, Foreign Function Interface (FFI)를 통해 가상 스레드에 노출된 함수입니다. FFIs는 다른 언어로 작성된 코드들이 함께 동작할 수 없는 상황에서 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic interface PythonFunctions extends Library {\n  /**\n   * 이 정적 final 필드는 `PythonFunctions` 인터페이스의 싱글톤 인스턴스를 생성합니다.\n   * 이는 `Library.getInstance` 메서드에서 인스턴스를 검색하고 이 인터페이스 유형으로 캐스팅합니다.\n   */\n  PythonFunctions INSTANCE = (PythonFunctions) Library.getInstance(\"python_functions\");\n  doubled calculateFee(doubled a, doubled b);\n}\n```\n\n# 다음 JVM 매개변수를 옵션으로 사용하여 고정된 스레드를 추적하세요\n\n- -Djdk.tracePinnedThreads=full: 고정된 상태에서 스레드가 고정되어 있을 때 완전한 스택 추적을 출력하며, 네이티브 프레임과 모니터를 보유한 프레임을 강조합니다.\n- -Djdk.tracePinnedThreads=short: 문제가 있는 프레임만을 포함하여 출력을 제한합니다.\n\n로그에는 가상 스레드 내에서의 메서드 호출의 스택 추적이 표시됩니다. 이 스레드는 JDBC(Java Database Connectivity) 및 특히 MySQL 연결과 상호 작용하는 메서드를 실행합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n주목할 점은 이러한 메서드 호출 중 몇 가지가 `= monitors:1` 표기를 포함하고 있어서 가상 스레드가 이 코드 실행 블록 내에서 계속 고정되어 있는 것을 나타낸다.\n\n# 버그 #110512 기여: synchronized를 ReentrantLock으로 교체\n\n마침내 깨달았어요. 저는 사용 중인 MySQL Connector/J 버전 8에서 가상 스레드를 지원하지 않는다는 것을.\n\n다음 단계로 나아가는 내 선택지입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- MySQL Connector/J 버전 9.0.0 이상으로 업그레이드하세요: 이 버전은 가상 스레드가 데이터베이스 상호 작용을 최적으로 수행하도록 합니다.\n- 새 라이브러리 탐험: 새 라이브러리를 찾아 새로운 코드를 작성하고 테스트해 보세요. 도전적이며 상당한 노력이 필요할 수 있습니다.\n\n# 한 발 물러서 두 발 앞으로!\n\n플랫폼 스레드에서 가상 스레드로의 전환을 통해 성능을 향상시키려는 시도는 \"피닝\"과 관련하여 예상치 못한 제약으로 인해 속도가 느려지는 문제가 발생했습니다. 결과적으로, 우리는 다시 플랫폼 스레드를 사용하도록 돌아갔습니다.\n\n지금은 성능을 개선하기 위한 대안 전략을 탐색하면서 버전 9.0.0의 릴리스를 기다리고 있습니다. 이는 새로운 기술을 도입하는 데 따르는 도전을 강조하며, 실행 전 철저한 테스트의 중요성을 강조합니다.\n","ogImage":{"url":"/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_0.png"},"coverImage":"/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_0.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e혹시 팀 애플리케이션 서비스에 기능을 구현하려다가 예상대로 되지 않은 적이 있나요? 저도 정확히 그런 일이 발생했어요!\u003c/p\u003e\n\u003ch1\u003e제가 겪은 일을 설명하기 전에 가상 스레드를 살펴보죠\u003c/h1\u003e\n\u003cp\u003e\"가상 스레드는 대량 처리 동시 응용 프로그램의 작성, 유지 관리 및 관찰 노력을 크게 줄이는 가벼운 스레드입니다.\"\n— 참고: (\u003ca href=\"https://openjdk.org/jeps/444\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://openjdk.org/jeps/444\u003c/a\u003e)\u003c/p\u003e\n\u003cp\u003e플랫폼 스레드의 문제는 I/O 작업 완료를 기다리는 시간입니다. 해당 스레드가 다른 작업을 수행할 수 없어 기본적으로 아이들 상태가 됩니다. 이는 많은 동시 요청을 처리하는 응용 프로그램에게 특히 비효율적입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위의 사진에서 보여지는 시나리오에서 플랫폼 스레드가 두 번 블록되어 프로그램이 크게 느려질 수 있습니다. 이는 흔히 발생하는 일입니다. 그러나 이러한 상황을 해결하기 위해 리액티브 프레임워크라 불리는 비차단 솔루션이 등장했습니다.\u003c/p\u003e\n\u003cp\u003eSpring Boot은 Project Reactor를 기반으로 한 Spring WebFlux 스택을 제공합니다. Spring WebFlux를 사용하는 개발자들은 전체 개발 프로세스를 수정해야 합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e2017년, 자바 엔지니어들은 문제를 해결하기 위해 \"프로젝트 룸\"을 시작했습니다. 결국, 그들은 \"가상 스레드\"를 개발했습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e가상 스레드의 주요 개념은 단일 가상 스레드가 여러 플랫폼 스레드에 장착될 수 있다는 것입니다. 가상 스레드는 블로킹 I/O 작업에서 오류가 발생할 때 현재 플랫폼 스레드에서 해제됩니다. 이 절차는 가상 스레드가 I/O 작업이 완료될 때까지 대기하는 동안 플랫폼 스레드가 다른 작업을 처리할 수 있도록 합니다. I/O 작업이 완료되면, 가상 스레드는 새로운 사용 가능한 플랫폼 스레드에 장착되어 실행을 계속할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e한 팀원이 점심 시간에 (블로킹 I/O)다른 플랫폼 스레드로 이동하여 소포 트럭이 중단되지 않고 여정을 계속할 수 있도록 하는 택배 회사의 전략을 상상해 보세요. 이 방식은 물류 운영 시간을 단축시키고 생산성을 높이며 회사를 경쟁력이 더 뛰어나게 만들었습니다.\u003c/p\u003e\n\u003cp\u003e플랫폼 스레드 간으로 이동하여 마운트 및 언마운트함으로써 가상 스레드는 I/O 작업이 완료될 때까지 블록되지 않을 수 있습니다. 이는 플랫폼 스레드를 더 효율적으로 사용할 수 있게 하고 전반적인 대기 시간을 줄입니다.\u003c/p\u003e\n\u003cp\u003e간단히 말하면, 단 한 줄의 코드 변경으로 서비스 성능을 향상시킬 수 있는 가장 간단한 방법입니다.\u003c/p\u003e\n\u003cp\u003eSpring Boot에서 Java 가상 스레드를 활성화하려면 \"application.properties\"에 이 구성을 추가하면 됩니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003espring.\u003cspan class=\"hljs-property\"\u003ethreads\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003evirtual\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eenabled\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 클릭 한 번으로 쉽게 설정 !!\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e참고: 이 설정은 JDK 21 이상과 Spring Boot 3.2 이상을 필요로 합니다.\u003c/p\u003e\n\u003ch1\u003e성능 비교를 위한 테스트 API 빌드\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eRestController\u003c/span\u003e\npublic \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePerformanceTestController\u003c/span\u003e {\n\n    @\u003cspan class=\"hljs-title class_\"\u003eGetMapping\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/test\"\u003c/span\u003e)\n    public \u003cspan class=\"hljs-title class_\"\u003eResponseEntity\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003etestPerformance\u003c/span\u003e() throws \u003cspan class=\"hljs-title class_\"\u003eInterruptedException\u003c/span\u003e {\n\n        \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eout\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Sleeping ...\"\u003c/span\u003e);\n        \u003cspan class=\"hljs-comment\"\u003e// CPU 바인드되지 않는 작업 시뮬레이션, 3초 동안 sleep\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esleep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eResponseEntity\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eok\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"테스트 완료\"\u003c/span\u003e);\n    }\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eApache HTTP 서버 벤치마킹 도구를 사용하여 서비스 성능을 측정할 수 있어요\u003c/h1\u003e\n\u003cp\u003e다양한 부하로 테스트하고 결과를 분석하여 개선할 수 있어요.\u003c/p\u003e\n\u003cp\u003e여기 명령어에요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eab -c \u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e -n \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e -r “\u003cspan class=\"hljs-attr\"\u003ehttp\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//localhost:8443/test\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e-c 300: 동시 요청 수입니다. 이 경우에는 서버를 동시에 폭격하기 위해 가상 사용자 [300]명이 시뮬레이션됩니다.\u003c/li\u003e\n\u003cli\u003e-n 1000: 최종적으로 실행될 총 요청 수입니다 [1000].\u003c/li\u003e\n\u003cli\u003e-r “\u003ca href=\"http://localhost:8443/test%E2%80%9D\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://localhost:8443/test”\u003c/a\u003e: 벤치마크 테스트 대상 URL입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e테스트를 시작합니다. 첫 번째는 기존 방식을 사용하고, 두 번째는 가상 스레드가 활성화됩니다.\u003c/p\u003e\n\u003cp\u003e가상 스레드 강력해요! 플랫폼 스레드보다 약 20% 빠른 속도로 동일한 작업을 완료합니다 (65.21 RPS 대 54.80 RPS). 그렇다면, 왜 제목에서 가상 스레드가 플랫폼 스레드보다 느리다고 말했을까요?\u003c/p\u003e\n\u003ch1\u003e실세계에서의 가상 스레드\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우리 팀의 API 분석\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGET 방식 사용 중\u003c/li\u003e\n\u003cli\u003e요청 방식 검증\u003c/li\u003e\n\u003cli\u003e데이터베이스에서 데이터 쿼리\u003c/li\u003e\n\u003cli\u003eRestClient를 통해 다른 서비스로 요청 보내기\u003c/li\u003e\n\u003cli\u003e데이터베이스에 데이터 업데이트/저장\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e성능 테스트 결과\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e플랫폼 스레드: \u003cspan class=\"hljs-number\"\u003e587.24\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTPS\u003c/span\u003e, 평균 응답 시간은 \u003cspan class=\"hljs-number\"\u003e56.\u003c/span\u003e52ms\n가상 스레드: \u003cspan class=\"hljs-number\"\u003e502.80\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTPS\u003c/span\u003e, 평균 응답 시간은 \u003cspan class=\"hljs-number\"\u003e66.\u003c/span\u003e54ms\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e가상 스레드가 플랫폼 스레드보다 느리다고 테스트 결과에서 나왔다니, 무슨 실수를 한 걸까요?\u003c/p\u003e\n\u003ch1\u003e핀닝, 발동한 숨겨진 함정\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e캐리어 스레드는 가상 스레드가 현재 실행 중인 플랫폼 스레드를 정의하는 또 다른 용어입니다. 핀닝은 가상 스레드가 플랫폼 스레드에 매핑되어 있는 상태를 말하며, 캐리어 스레드에 붙어서 떨어질 수 없는 상태를 묘사합니다. 이는 가상 스레드의 상태를 힙 메모리에 저장할 수 없기 때문에 발생합니다. 핀닝된 스레드는 다른 스레드가 동일한 플랫폼 스레드를 사용하는 것을 막습니다. 몇 가지 가능한 원인을 살펴봅시다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e동기화된 블록 또는 메서드: 한 번에 한 스레드만 들어갈 수 있습니다. 다른 스레드들은 현재(실행 중인) 스레드가 나갈 때까지 차단됩니다. 경합 조건을 방지하고 데이터의 정확한 상태를 유지하기 위해 공유 리소스에 중단되지 않은 액세스가 필요합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyService\u003c/span\u003e {\n  public \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculateFee\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    synchronized (\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e) {\n      ...\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e네이티브 메서드: 이 메서드를 사용하면 다른 언어의 코드(C 또는 C++ 등)를 Java 프로젝트에 통합할 수 있습니다. 네이티브 메서드는 Java 가상 머신 내에서 호출되지만 Java의 제어 범위 밖에서 실행됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eMyService.java\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyService\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n    System.out.println(calculateFee(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e));\n  }\n  \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enative\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculateFee\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e a, \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e b)\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// Loads the native library from file named \"nativemethod.c\".\u003c/span\u003e\n    System.loadLibrary(\u003cspan class=\"hljs-string\"\u003e\"nativemethod\"\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003enativemethod.c\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-c\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;jni.h\u003e\u003c/span\u003e\u003c/span\u003e\n\nJNIEXPORT jint JNICALL \u003cspan class=\"hljs-title function_\"\u003eJava_calculateFee\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003e(JNIEnv *env, jobject obj, jint a, jint b)\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e a * b;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e외부 함수: 다른 프로그래밍 언어로 작성된 함수로서, Foreign Function Interface (FFI)를 통해 가상 스레드에 노출된 함수입니다. FFIs는 다른 언어로 작성된 코드들이 함께 동작할 수 없는 상황에서 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePythonFunctions\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLibrary\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e/**\n   * 이 정적 final 필드는 `PythonFunctions` 인터페이스의 싱글톤 인스턴스를 생성합니다.\n   * 이는 `Library.getInstance` 메서드에서 인스턴스를 검색하고 이 인터페이스 유형으로 캐스팅합니다.\n   */\u003c/span\u003e\n  \u003cspan class=\"hljs-type\"\u003ePythonFunctions\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eINSTANCE\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e (PythonFunctions) Library.getInstance(\u003cspan class=\"hljs-string\"\u003e\"python_functions\"\u003c/span\u003e);\n  doubled \u003cspan class=\"hljs-title function_\"\u003ecalculateFee\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(doubled a, doubled b)\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e다음 JVM 매개변수를 옵션으로 사용하여 고정된 스레드를 추적하세요\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e-Djdk.tracePinnedThreads=full: 고정된 상태에서 스레드가 고정되어 있을 때 완전한 스택 추적을 출력하며, 네이티브 프레임과 모니터를 보유한 프레임을 강조합니다.\u003c/li\u003e\n\u003cli\u003e-Djdk.tracePinnedThreads=short: 문제가 있는 프레임만을 포함하여 출력을 제한합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e로그에는 가상 스레드 내에서의 메서드 호출의 스택 추적이 표시됩니다. 이 스레드는 JDBC(Java Database Connectivity) 및 특히 MySQL 연결과 상호 작용하는 메서드를 실행합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e주목할 점은 이러한 메서드 호출 중 몇 가지가 \u003ccode\u003e= monitors:1\u003c/code\u003e 표기를 포함하고 있어서 가상 스레드가 이 코드 실행 블록 내에서 계속 고정되어 있는 것을 나타낸다.\u003c/p\u003e\n\u003ch1\u003e버그 #110512 기여: synchronized를 ReentrantLock으로 교체\u003c/h1\u003e\n\u003cp\u003e마침내 깨달았어요. 저는 사용 중인 MySQL Connector/J 버전 8에서 가상 스레드를 지원하지 않는다는 것을.\u003c/p\u003e\n\u003cp\u003e다음 단계로 나아가는 내 선택지입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003eMySQL Connector/J 버전 9.0.0 이상으로 업그레이드하세요: 이 버전은 가상 스레드가 데이터베이스 상호 작용을 최적으로 수행하도록 합니다.\u003c/li\u003e\n\u003cli\u003e새 라이브러리 탐험: 새 라이브러리를 찾아 새로운 코드를 작성하고 테스트해 보세요. 도전적이며 상당한 노력이 필요할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e한 발 물러서 두 발 앞으로!\u003c/h1\u003e\n\u003cp\u003e플랫폼 스레드에서 가상 스레드로의 전환을 통해 성능을 향상시키려는 시도는 \"피닝\"과 관련하여 예상치 못한 제약으로 인해 속도가 느려지는 문제가 발생했습니다. 결과적으로, 우리는 다시 플랫폼 스레드를 사용하도록 돌아갔습니다.\u003c/p\u003e\n\u003cp\u003e지금은 성능을 개선하기 위한 대안 전략을 탐색하면서 버전 9.0.0의 릴리스를 기다리고 있습니다. 이는 새로운 기술을 도입하는 데 따르는 도전을 강조하며, 실행 전 철저한 테스트의 중요성을 강조합니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads"},"buildId":"wfHLuDA3kTGBYfaM5IGXk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>