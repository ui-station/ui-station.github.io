<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>로봇에 모터 컨트롤러를 추가하는 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-17-HowToAddAMotorControllerToYourROSRobot" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="로봇에 모터 컨트롤러를 추가하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="로봇에 모터 컨트롤러를 추가하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-17-HowToAddAMotorControllerToYourROSRobot_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-17-HowToAddAMotorControllerToYourROSRobot" data-gatsby-head="true"/><meta name="twitter:title" content="로봇에 모터 컨트롤러를 추가하는 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-17-HowToAddAMotorControllerToYourROSRobot_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-17 19:25" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_buildManifest.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">로봇에 모터 컨트롤러를 추가하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="로봇에 모터 컨트롤러를 추가하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 17, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-17-HowToAddAMotorControllerToYourROSRobot&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>로봇에 직접주행 및 오도메트리 기능을 부여하세요!</p>
<p><img src="/assets/img/2024-05-17-HowToAddAMotorControllerToYourROSRobot_0.png" alt="이미지"></p>
<p>ROS/ROS2와 함께 사용할 모바일 로봇을 만들고 있다면, 먼저해야 할 일 중 하나는 모터 컨트롤러를 통합하는 것입니다. 모터 컨트롤러의 목적은 네비게이션 스택과 같은 상위 레벨 소프트웨어로부터 메시지를 수신하고, 이를 모터를 구동하는 신호로 변환하는 것입니다. 또한 모터의 인코더에서 정보를 받아 로봇의 속도와 위치를 계산할 수 있습니다. 추가로 배터리 전압이 변동하거나 지형이 다를 때에도 일관된 바퀴 제어를 얻을 수 있습니다. 흥미가 생겼나요? 전형적인 차이 드라이브 로봇을 위한 ROS 모터 컨트롤러를 만들기 위해 필요한 모든 것과 참고용으로 사용할 수 있는 작동하는 코드가 준비되어 있습니다!</p>
<p>이 프로젝트의 전체 코드는 GitHub 레포지토리에 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>배경</p>
<p>내가 전에 썼던 ROS가 유용한 이유, ROS가 하는 일, 그리고 물리적 로봇과 어떻게 통합되는지에 대한 개요에 대해 읽은 것으로 가정하겠습니다.</p>
<p>나는 아두이노, Pi Pico 또는 Teensy와 같은 일반적인 마이크로컨트롤러에 어느 정도 익숙하다고 가정합니다. 이 경우 Teensy를 사용할 것이지만, 다양한 마이크로컨트롤러 유형에 걸쳐 개념은 거의 동일합니다.</p>
<p>중요한 개념</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>모터 컨트롤러의 역할은 전형적으로 /cmd_vel과 같은 주제에 Twist 유형의 메시지를 받는 것입니다. 이 메시지는 두 구성 요소로 이루어져 있습니다. 첫째, 미터/초로 분할된 원하는 선형 속도를 정의합니다. 두 번째로는 원하는 각속도인 라디안/초의 회전 속도를 포함합니다.</p>
<p>예를 들어, 내비게이션 스택은 이 메시지를 보낼 수 있으며, 이 메시지는 로봇을 1m/s로 직진하면서 초당 0.1 라디안으로 회전하도록 모터 컨트롤러에 지시합니다. x 방향은 앞쪽으로, Z 방향은 지면과 직교한 상단 방향이고, y는 좌우입니다. 결과적으로 곡선 경로가 생성됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-attr">linear</span>: <span class="hljs-attr">x</span>: <span class="hljs-number">1.0</span>;
<span class="hljs-attr">y</span>: <span class="hljs-number">0.0</span>;
<span class="hljs-attr">z</span>: <span class="hljs-number">0.0</span>;
<span class="hljs-attr">angular</span>: <span class="hljs-attr">x</span>: <span class="hljs-number">0.0</span>;
<span class="hljs-attr">y</span>: <span class="hljs-number">0.0</span>;
<span class="hljs-attr">z</span>: <span class="hljs-number">0.1</span>;
</code></pre>
<p>평범한 미끄럼 방지 구동 방식의 로봇은 일반적으로 가로 이동하거나 직접 올라가는 능력이 없으므로 선형 구성 요소는 주로 x 값을 사용합니다. 마찬가지로, 이 유형의 대부분 로봇은 Z 축을 중심으로 명령된 각속도만 사용할 것입니다. 방향과 단위에 대한 ROS 규칙은 REP 103에서 찾을 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이것이 지나치게 복잡해 보일 수도 있어요. 메시지 유형이 로봇이 물리적으로 따를 수 없는 구성요소를 가지는 이유가 뭘까요? 메시지 유형은 여러 유형의 로봇에서 사용될 것이기 때문이에요. 홀로노믹 드라이브 로봇은 옆으로 이동해서 미끄러짐 없이 움직일 수 있어요. 쿼드콥터 로봇은 회전하지 않고 동시에 위, 옆, 앞으로 움직일 수 있어요. 이 메시지 유형은 다양한 종류의 로봇에서 사용할 수 있도록 설계되었어요.</p>
<p>각도 구성요소를 신경 써야 하는 이유가 뭘까요? 나중에 이것이 정말 유용해질 거에요. 직선으로 운전 중에 조금씩 벗어나기 시작할 경우에 코스 수정을 쉽게 보낼 수 있어요. 제자리에서 회전 명령을 쉽게 보낼 수 있어요. 우리가 아래에서 볼 때, 수학도 쉬워질 거에요.</p>
<p>그래서 모터 컨트롤러는 cmd_vel에서 특정 선형 및 각속도 혼합을 주문받고, 그것이 모터 속도로 어떤 의미인지 계산해야 해요. 여기가 멋진 곳이에요. 곧 수학으로 돌아올게요 - 무서워하지 마세요. 먼저, 모터 속도를 정확히 제어하는 법에 대해 이야기해야 해요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>간단한 로봇을 만들었다면, 아마도 DC 모터의 속도를 제어할 수 있다는 개념에 익숙할 것입니다. 전압을 펄스로 제어함으로써 DC 모터의 속도를 조절할 수 있다는 아이디어에 편안해지셨을 겁니다. 전압이 켜져 있는 비율이 높을수록 모터는 최고 속도까지 빨리 회전합니다. 이를 펄스 폭 변조(Pulse Width Modulation)이라고 하며, 단순한 로봇에서도 동작하지만 문제가 있습니다. 가장 큰 문제는 모터 속도가 배터리 전압에 따라 변경된다는 것입니다. 모터가 회전하는 속도는 적용된 전압의 함수이므로 배터리가 방전될수록, 주어진 속도를 유지하기 위해 더 높은 켜는 시간 비율이 필요합니다. 또 다른 문제는 주어진 전압에 대해 한 모터가 조금이라도 다른 모터보다 빨리 회전한다면 어떻게 될까요? 양쪽에 동일한 비율을 보낸다면 로봇은 곡선 형태로 이동합니다. 또한 지형에 의해 바퀴 중 하나가 부분적으로 막혀 있다면 특정 바퀴 속도를 달성하는 데 더 많은 전력이 필요합니다. 일정한 속도를 명령하고 실제로 그 속도를 얻고 싶다면 휠로부터 피드백을 받아야 합니다. 우리는 폐쇄 루프 시스템이 필요합니다.</p>
<p>운전 모터의 경우, 통합 자기 엔코더가 있는 모터를 사용하고 싶습니다. 홀 센서는 모터 축에있는 자석이 센서를 지날 때마다 펄스를 생성하는 데 사용됩니다. 이 펄스를 마이크로컨트롤러로 보내어 카운트하고 실제 바퀴 속도를 계산합니다. (이를 위해 기어 비율 및 기타 몇 가지 세부 정보가 필요합니다 — 나중에 자세히 살펴보겠습니다)</p>
<p>아래 이미지에서 각 모터의 뒤쪽에 엔코더가 달려 있는 것을 볼 수 있습니다.</p>
<p><img src="/assets/img/2024-05-17-HowToAddAMotorControllerToYourROSRobot_1.png" alt="image"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그래서 이제 마이크로컨트롤러는 PWM 펄스폭을 변화시킴으로써 모터의 속도를 제어하고, 샤프트의 실제 속도를 읽을 수 있게 되었습니다. 이는 배터리 전압, 지형, 또는 로봇의 왼쪽 구동 바퀴에 감겨있는 골든 리트리버 털과는 독립적으로 작동합니다. 우리는 이제 폐쇄 루프를 가지고 있으며 이제 어디론가 가고 있습니다. 그래서.. 우리가 원하는 바퀴 속도를 어떻게 얻을까요?</p>
<p>PID 제어</p>
<p>그것이 PID 제어 루프의 역할입니다. PID 루프는 다른 사람들에 의해 더 잘 이해되고 다뤄진 기사들에서 충분히 다루어졌기 때문에, 여기서는 다시 다루지 않겠습니다. 좋은 소개는 여기에 있고, 모터 제어에 좀 더 특화된 것은 여기에 있습니다. Youtube에도 좋은 비디오들이 있습니다. PID에 대해 배운 내용을 로봇에 매핑하는 방법을 요약하면 다음과 같습니다. 각 모터마다 한 개의 루프가 필요합니다. 인코더는 펄스 형태로 피드백을 제공하며, 이를 사용하여 바퀴 RPM을 계산합니다. 설정점은 선속도와 각속도에서 계산된 바퀴 속도입니다 (곧 설명될 것). 출력은 주로 0에서 255까지 변할 수 있는 펄스폭의 백분율입니다. 몇 초에 한 번씩 PID 루프는 설정점을 실제 바퀴 속도와 비교하고, 모터의 PWM 출력을 조정하여 배터리 전압, 부하 또는 다른 변수와 관계없이 목표치에 유지합니다. 이에는 나중에 다룰 튜닝 프로세스가 필요하며, 기사의 나중 부분에서도 이에 대해 논의할 것입니다. 지금은 바퀴 속도가 어떻게 계산되는지로 넘어갑시다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>모터 컨트롤러는 로봇이 주어진 선속도와 각속도로 동시에 이동하도록 요청받은 메시지를 받았어요. 바퀴가 해야 할 일을 어떻게 계산하는 걸까요?</p>
<p>여기 수학적 설명이 잘 나와 있어요. 거기서 이를 배웠어요. 이제 Twist 메시지가 선속도와 각속도를 따로 분리하는 이유가 분명해질 거예요.</p>
<p>먼저 선속도부터 시작해봅시다. 그것은 상당히 쉬워요. 우리는 특정 바퀴의 속도를 PID 컨트롤러를 사용하여 정확하게 설정하는 방법을 알아요. 직선 운동에서 두 바퀴는 같은 속도로 회전해야 하므로, 우리는 단순히 우리가 원하는 전진 속도를 만들어내기 위한 그 바퀴 속도가 무엇인지 계산하고 두 바퀴 모두 그 속도로 설정하면 되요. 주요 구동 바퀴의 반경을 알아야 하는데, 그것으로부터 바퀴 둘레를 계산할 수 있어요. 그것이 바퀴 한 바퀴 회전마다 로봇이 이동하는 거리를 의미하죠. 그 후, 구동 바퀴의 기어 비율과 바퀴 당 엔코더 틱 수를 알아야 해요. 그럼 필요한 모터 속도를 계산할 충분한 정보가 생기게 되요.</p>
<p>각속도를 계산하는 수학은 약간 복잡해요. 두 바퀴의 속도 차이를 도입해 로봇이 올바른 속도로 회전하도록 해야 해요. 우리는 바퀴베이스를 알아야 하는데, 이는 드라이브 바퀴 사이의 거리를 말해요. 처음에 내가 처음에 한 것처럼 각 바퀴의 안쪽 가장자리부터 측정하지 마세요. 회전 속도에 상당한 오차가 발생할 거에요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다음은 코드가 모이게 됩니다:</p>
<p>변수 data.linear.x는 요청된 속도의 x 구성 요소이고, data.angular.z는 로봇의 요청된 회전입니다. ROS 메시지가 이렇게 속도를 분리하여 제공하면 희망하는 바퀴 속도를 계산하기가 매우 간단해집니다. right_rpm과 left_rpm 변수는 각 모터에 대한 PID 루프의 세트 포인트입니다. 이것은 원하는 동작을 생성하기 위해 필요합니다.</p>
<p>오도메트리 계산</p>
<p>모터 속도를 올바르게 설정하는 것 외에도 모터 컨트롤러는 로봇의 위치와 방향을 데드 레커닝을 통해 추정해야 합니다. 로봇이 어디에 있고 어느 방향을 향해 있는지 추적하기 위해 모든 이동, 각도 및 선형 이동을 합산합니다. 완벽한 것은 아닙니다 — 바퀴 슬립과 누적 오차로 인해 오랜 시간과 거리에 걸쳐 부정확해지지만, 매우 유용한 도구입니다. 짧은 거리에서는 꽤 정확하며, SLAM 또는 GPS와 같은 다른 위치 결정 도구와 결합하면 개선된 전체 추정치를 얻을 수 있습니다. 위치의 다른 측정치를 결합하여 전반적인 위치 추정치를 더 정확하게 얻는 과정은 센서 퓨전의 예시이며, 일반적으로 칼만 필터를 통해 수행됩니다. 그렇다면 위치를 어떻게 계산할까요?</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>수학 부분이 잘 다루어졌네요. 저는 Andrew Kramer의 예제 코드를 수정하여 계산한 후, 결과로부터 odometry 메시지를 채웠어요.</p>
<p>내 로봇에서, 원래의 마이크로프로세서가 자원이 매우 부족했기 때문에, 나는 PID 루프를 마이크로컨트롤러에서만 실행하고 Raspberry Pi에서 Python 모터 컨트롤러 노드에서 odometry 계산을 수행하기로 선택했어요. 아래 코드 스니펫은 그 작동 방식을 보여줍니다.</p>
<p>Python 노드는 원하는 바퀴 회전 속도를 마이크로컨트롤러로 보내요. 마이크로컨트롤러는 각 모터의 실제 인코더 틱 수를 매 초 20회 응답해요. 아래의 l_tick_cb() 함수는 Python 스크립트에서, 좌측 모터 인코더 틱 수가 수신될 때마다 작동하는 함수에요. 우측 모터의 콜백은 이 코드 스니펫에서 제외되었어요.</p>
<p>실제 모터 틱 수가 수신될 때마다, 마지막 업데이트 이후에 주어진 쪽이 얼마나 이동했는지 계산되고, 로봇의 새로운 위치 추정 값이 계산돼요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>변수 theta는 로봇이 시작 방향에 대해 회전한 각도에 대한 현재 추정치입니다. 오도미트리 메시지를 완전히 채우려면 더 많은 정보가 필요합니다. 이 코드는 현재 속도를 계산하고 공분산 및 변환 필드를 채웁니다. 변환에 대해 자세한 내용은 다른 글에서 다루겠지만, 지금 당장 알아두실 점은 이 메시지에 대해 "odom" 및 "base_link" 자식 프레임으로 설정하는 것이 좋다는 것입니다. 이는 ROS 표준을 준수합니다. 곧 이에 대해 기사를 쓸 예정이지만, REP 105 및 최고 TF 설명은 이해를 시작하기에 좋은 자리입니다.</p>
<p>오도멧리 변환은 쿼터니언으로 브로드캐스트됩니다. 함수를 사용하여 엔코더 값 (theta)으로부터 쿼터니언을 생성하며, 롤/피치는 우리의 미분 구동 로봇에 대해 제로로 가정됩니다. 이 코드는 해당 토론에서 가져온 것입니다.</p>
<p>공분산은 주어진 측정치에 대한 예상 오차를 보고하는 메커니즘이며, 칼만 필터와 같은 센서 융합 중에 사용됩니다. 주어진 설정에 대한 계산 방법을 아직 이해하지 못하므로, 작은 미분 구동 로봇에 대해 찾은 전형적인 값들을 사용했습니다. 여기 개선할 수 있는 부분이 많이 있습니다.</p>
<p>이 코드는 Github 리포지토리에서 마이크로컨트롤러에서 실행됩니다. 이 코드는 왼쪽 및 오른쪽 바퀴 RPM을 설정값으로 받아들이고, 모터를 펄스 폭 변조 (PWM)를 통해 제어하는 PID 루프를 실행합니다. 또한 각 바퀴의 사이클 동안 카운트된 엔코더 틱 수를 보고하여 코드 상에서 실제 바퀴 회전수를 계산합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>어떤 하드웨어가 있는지 궁금하신가요?</p>
<p>여기 메인 구성 요소를 보여주는 블록 다이어그램이 있습니다.</p>
<p><img src="/assets/img/2024-05-17-HowToAddAMotorControllerToYourROSRobot_2.png" alt="하드웨어 블록 다이어그램"></p>
<p>보시다시피 Teensy는 모터 드라이버 모듈로 PWM 듀티 사이클을 출력하여 원하는 속도로 모터를 구동합니다. 모터 엔코더로부터 ticks를 받아 실제 속도를 계산하고 제어 루프를 닫습니다. 이들은 모터 PID 루프의 피드백입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 컨트롤러에서는 rosserial_arduino를 사용하여 원하는 바퀴 RPM 주제에 대해 구독하고 odometry/velocity 계산을 위해 각 바퀴의 실제 틱을 게시합니다.</p>
<p>내 컨트롤러는 전압 분배기를 통해 팩 전압을 측정하고 전류 센서의 출력을 사용합니다.</p>
<p>출력을 선택할 때는 모터 드라이버에 대해 PWM 출력을 사용해야 하며 엔코더 입력에 대해 일반 디지털 핀을 사용해야 합니다. Teensy에 대한 차트를 아래에서 볼 수 있습니다 — 다른 마이크로컨트롤러에 대한 유사한 차트도 있습니다.</p>
<p><img src="/assets/img/2024-05-17-HowToAddAMotorControllerToYourROSRobot_3.png" alt="Teensy 차트"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>PWM 출력은 모터 드라이버의 4개 입력으로 보내집니다. 내 로봇은 저전류 모터를 사용하므로 이와 같은 저렴한 LM298 듀얼 H-브리지 드라이버를 선택했습니다. 다양한 유형의 모터를 구동하는 다양한 보드가 많이 있습니다. 브러시리스 모터는 다른 유형의 컨트롤러를 사용하지만 많은 모터가 PWM 입력을 사용합니다. LM298 사용 방법에 대한 좋은 안내서가 여기 있습니다.</p>
<p><img src="/assets/img/2024-05-17-HowToAddAMotorControllerToYourROSRobot_4.png" alt="로봇의 전자 부품 덱"></p>
<p>여기에는 로봇의 전자 부품 덱이 있습니다. 라즈베리 파이 4 위에 앉은 쉴드 PCB에 Teensy가 보입니다.</p>
<p><img src="/assets/img/2024-05-17-HowToAddAMotorControllerToYourROSRobot_5.png" alt="로봇의 전자 부품 덱"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>마이크로컨트롤러 선택</p>
<p>처음에는 Arduino Uno용으로 이 코드를 작성했었는데, 주로 RAM이 부족해지는 문제가 발생했습니다. rosserial_arduino에는 보다 강력한 마이크로컨트롤러가 강력히 권장됩니다. 이 컨트롤러의 다음 버전은 ROS2용 Pi Pico를 사용하여 micro-ros로 만들 것입니다. 원칙적으로 이 코드는 rosserial_arduino에서 지원하는 모든 프로세서 상에서 작은 수정만으로도 실행되어야 합니다.</p>
<p>Teensy 버전은 매우 잘 실행되었고, 현재 모든 프로젝트를 ROS2로 마이그레이션 중이며, Pico가 더 저렴합니다. 작동이 준비된 경우 해당에 대해 기사를 게시할 예정입니다.</p>
<p>PID 튜닝</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>PID 루프를 조정해야 하는데, 이는 이 글의 범위를 벗어납니다. 웹 검색을 통해 표준 접근 방식을 찾을 수 있습니다. 마이크로컨트롤러 코드에는 ROS 주제 에코 명령을 통해 조정 가능한 P, I 및 D 값을 구독자로 활성화하는 모드가 포함되어 있습니다. 이는 rqt_graph를 사용하여 명령된 rpm 대 실제 rpm을 그래프로 표시하면 튜닝 속도가 크게 향상됩니다.</p>
<p>결론</p>
<p>이 글이 실제 작동 예제를 제시하고 모든 자원을 한 곳에 모아서 작성한 것에 도움이 되었기를 바라며, 여러분의 프로젝트에 유용한 출발점이 되었으면 좋겠습니다. 개선할 점이 있다면 알려주시고, 여러분에게 가치 있었다면 알려주세요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 프로젝트의 코드는 주로 저의 것이지만, 일부는 다른 소스들을 참고하거나 수정한 것입니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"로봇에 모터 컨트롤러를 추가하는 방법","description":"","date":"2024-05-17 19:25","slug":"2024-05-17-HowToAddAMotorControllerToYourROSRobot","content":"\n로봇에 직접주행 및 오도메트리 기능을 부여하세요!\n\n![이미지](/assets/img/2024-05-17-HowToAddAMotorControllerToYourROSRobot_0.png)\n\nROS/ROS2와 함께 사용할 모바일 로봇을 만들고 있다면, 먼저해야 할 일 중 하나는 모터 컨트롤러를 통합하는 것입니다. 모터 컨트롤러의 목적은 네비게이션 스택과 같은 상위 레벨 소프트웨어로부터 메시지를 수신하고, 이를 모터를 구동하는 신호로 변환하는 것입니다. 또한 모터의 인코더에서 정보를 받아 로봇의 속도와 위치를 계산할 수 있습니다. 추가로 배터리 전압이 변동하거나 지형이 다를 때에도 일관된 바퀴 제어를 얻을 수 있습니다. 흥미가 생겼나요? 전형적인 차이 드라이브 로봇을 위한 ROS 모터 컨트롤러를 만들기 위해 필요한 모든 것과 참고용으로 사용할 수 있는 작동하는 코드가 준비되어 있습니다!\n\n이 프로젝트의 전체 코드는 GitHub 레포지토리에 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n배경\n\n내가 전에 썼던 ROS가 유용한 이유, ROS가 하는 일, 그리고 물리적 로봇과 어떻게 통합되는지에 대한 개요에 대해 읽은 것으로 가정하겠습니다.\n\n나는 아두이노, Pi Pico 또는 Teensy와 같은 일반적인 마이크로컨트롤러에 어느 정도 익숙하다고 가정합니다. 이 경우 Teensy를 사용할 것이지만, 다양한 마이크로컨트롤러 유형에 걸쳐 개념은 거의 동일합니다.\n\n중요한 개념\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모터 컨트롤러의 역할은 전형적으로 /cmd_vel과 같은 주제에 Twist 유형의 메시지를 받는 것입니다. 이 메시지는 두 구성 요소로 이루어져 있습니다. 첫째, 미터/초로 분할된 원하는 선형 속도를 정의합니다. 두 번째로는 원하는 각속도인 라디안/초의 회전 속도를 포함합니다.\n\n예를 들어, 내비게이션 스택은 이 메시지를 보낼 수 있으며, 이 메시지는 로봇을 1m/s로 직진하면서 초당 0.1 라디안으로 회전하도록 모터 컨트롤러에 지시합니다. x 방향은 앞쪽으로, Z 방향은 지면과 직교한 상단 방향이고, y는 좌우입니다. 결과적으로 곡선 경로가 생성됩니다.\n\n```js\nlinear: x: 1.0;\ny: 0.0;\nz: 0.0;\nangular: x: 0.0;\ny: 0.0;\nz: 0.1;\n```\n\n평범한 미끄럼 방지 구동 방식의 로봇은 일반적으로 가로 이동하거나 직접 올라가는 능력이 없으므로 선형 구성 요소는 주로 x 값을 사용합니다. 마찬가지로, 이 유형의 대부분 로봇은 Z 축을 중심으로 명령된 각속도만 사용할 것입니다. 방향과 단위에 대한 ROS 규칙은 REP 103에서 찾을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것이 지나치게 복잡해 보일 수도 있어요. 메시지 유형이 로봇이 물리적으로 따를 수 없는 구성요소를 가지는 이유가 뭘까요? 메시지 유형은 여러 유형의 로봇에서 사용될 것이기 때문이에요. 홀로노믹 드라이브 로봇은 옆으로 이동해서 미끄러짐 없이 움직일 수 있어요. 쿼드콥터 로봇은 회전하지 않고 동시에 위, 옆, 앞으로 움직일 수 있어요. 이 메시지 유형은 다양한 종류의 로봇에서 사용할 수 있도록 설계되었어요.\n\n각도 구성요소를 신경 써야 하는 이유가 뭘까요? 나중에 이것이 정말 유용해질 거에요. 직선으로 운전 중에 조금씩 벗어나기 시작할 경우에 코스 수정을 쉽게 보낼 수 있어요. 제자리에서 회전 명령을 쉽게 보낼 수 있어요. 우리가 아래에서 볼 때, 수학도 쉬워질 거에요.\n\n그래서 모터 컨트롤러는 cmd_vel에서 특정 선형 및 각속도 혼합을 주문받고, 그것이 모터 속도로 어떤 의미인지 계산해야 해요. 여기가 멋진 곳이에요. 곧 수학으로 돌아올게요 - 무서워하지 마세요. 먼저, 모터 속도를 정확히 제어하는 법에 대해 이야기해야 해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단한 로봇을 만들었다면, 아마도 DC 모터의 속도를 제어할 수 있다는 개념에 익숙할 것입니다. 전압을 펄스로 제어함으로써 DC 모터의 속도를 조절할 수 있다는 아이디어에 편안해지셨을 겁니다. 전압이 켜져 있는 비율이 높을수록 모터는 최고 속도까지 빨리 회전합니다. 이를 펄스 폭 변조(Pulse Width Modulation)이라고 하며, 단순한 로봇에서도 동작하지만 문제가 있습니다. 가장 큰 문제는 모터 속도가 배터리 전압에 따라 변경된다는 것입니다. 모터가 회전하는 속도는 적용된 전압의 함수이므로 배터리가 방전될수록, 주어진 속도를 유지하기 위해 더 높은 켜는 시간 비율이 필요합니다. 또 다른 문제는 주어진 전압에 대해 한 모터가 조금이라도 다른 모터보다 빨리 회전한다면 어떻게 될까요? 양쪽에 동일한 비율을 보낸다면 로봇은 곡선 형태로 이동합니다. 또한 지형에 의해 바퀴 중 하나가 부분적으로 막혀 있다면 특정 바퀴 속도를 달성하는 데 더 많은 전력이 필요합니다. 일정한 속도를 명령하고 실제로 그 속도를 얻고 싶다면 휠로부터 피드백을 받아야 합니다. 우리는 폐쇄 루프 시스템이 필요합니다.\n\n운전 모터의 경우, 통합 자기 엔코더가 있는 모터를 사용하고 싶습니다. 홀 센서는 모터 축에있는 자석이 센서를 지날 때마다 펄스를 생성하는 데 사용됩니다. 이 펄스를 마이크로컨트롤러로 보내어 카운트하고 실제 바퀴 속도를 계산합니다. (이를 위해 기어 비율 및 기타 몇 가지 세부 정보가 필요합니다 — 나중에 자세히 살펴보겠습니다)\n\n아래 이미지에서 각 모터의 뒤쪽에 엔코더가 달려 있는 것을 볼 수 있습니다.\n\n![image](/assets/img/2024-05-17-HowToAddAMotorControllerToYourROSRobot_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래서 이제 마이크로컨트롤러는 PWM 펄스폭을 변화시킴으로써 모터의 속도를 제어하고, 샤프트의 실제 속도를 읽을 수 있게 되었습니다. 이는 배터리 전압, 지형, 또는 로봇의 왼쪽 구동 바퀴에 감겨있는 골든 리트리버 털과는 독립적으로 작동합니다. 우리는 이제 폐쇄 루프를 가지고 있으며 이제 어디론가 가고 있습니다. 그래서.. 우리가 원하는 바퀴 속도를 어떻게 얻을까요?\n\nPID 제어\n\n그것이 PID 제어 루프의 역할입니다. PID 루프는 다른 사람들에 의해 더 잘 이해되고 다뤄진 기사들에서 충분히 다루어졌기 때문에, 여기서는 다시 다루지 않겠습니다. 좋은 소개는 여기에 있고, 모터 제어에 좀 더 특화된 것은 여기에 있습니다. Youtube에도 좋은 비디오들이 있습니다. PID에 대해 배운 내용을 로봇에 매핑하는 방법을 요약하면 다음과 같습니다. 각 모터마다 한 개의 루프가 필요합니다. 인코더는 펄스 형태로 피드백을 제공하며, 이를 사용하여 바퀴 RPM을 계산합니다. 설정점은 선속도와 각속도에서 계산된 바퀴 속도입니다 (곧 설명될 것). 출력은 주로 0에서 255까지 변할 수 있는 펄스폭의 백분율입니다. 몇 초에 한 번씩 PID 루프는 설정점을 실제 바퀴 속도와 비교하고, 모터의 PWM 출력을 조정하여 배터리 전압, 부하 또는 다른 변수와 관계없이 목표치에 유지합니다. 이에는 나중에 다룰 튜닝 프로세스가 필요하며, 기사의 나중 부분에서도 이에 대해 논의할 것입니다. 지금은 바퀴 속도가 어떻게 계산되는지로 넘어갑시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모터 컨트롤러는 로봇이 주어진 선속도와 각속도로 동시에 이동하도록 요청받은 메시지를 받았어요. 바퀴가 해야 할 일을 어떻게 계산하는 걸까요?\n\n여기 수학적 설명이 잘 나와 있어요. 거기서 이를 배웠어요. 이제 Twist 메시지가 선속도와 각속도를 따로 분리하는 이유가 분명해질 거예요.\n\n먼저 선속도부터 시작해봅시다. 그것은 상당히 쉬워요. 우리는 특정 바퀴의 속도를 PID 컨트롤러를 사용하여 정확하게 설정하는 방법을 알아요. 직선 운동에서 두 바퀴는 같은 속도로 회전해야 하므로, 우리는 단순히 우리가 원하는 전진 속도를 만들어내기 위한 그 바퀴 속도가 무엇인지 계산하고 두 바퀴 모두 그 속도로 설정하면 되요. 주요 구동 바퀴의 반경을 알아야 하는데, 그것으로부터 바퀴 둘레를 계산할 수 있어요. 그것이 바퀴 한 바퀴 회전마다 로봇이 이동하는 거리를 의미하죠. 그 후, 구동 바퀴의 기어 비율과 바퀴 당 엔코더 틱 수를 알아야 해요. 그럼 필요한 모터 속도를 계산할 충분한 정보가 생기게 되요.\n\n각속도를 계산하는 수학은 약간 복잡해요. 두 바퀴의 속도 차이를 도입해 로봇이 올바른 속도로 회전하도록 해야 해요. 우리는 바퀴베이스를 알아야 하는데, 이는 드라이브 바퀴 사이의 거리를 말해요. 처음에 내가 처음에 한 것처럼 각 바퀴의 안쪽 가장자리부터 측정하지 마세요. 회전 속도에 상당한 오차가 발생할 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 코드가 모이게 됩니다:\n\n변수 data.linear.x는 요청된 속도의 x 구성 요소이고, data.angular.z는 로봇의 요청된 회전입니다. ROS 메시지가 이렇게 속도를 분리하여 제공하면 희망하는 바퀴 속도를 계산하기가 매우 간단해집니다. right_rpm과 left_rpm 변수는 각 모터에 대한 PID 루프의 세트 포인트입니다. 이것은 원하는 동작을 생성하기 위해 필요합니다.\n\n오도메트리 계산\n\n모터 속도를 올바르게 설정하는 것 외에도 모터 컨트롤러는 로봇의 위치와 방향을 데드 레커닝을 통해 추정해야 합니다. 로봇이 어디에 있고 어느 방향을 향해 있는지 추적하기 위해 모든 이동, 각도 및 선형 이동을 합산합니다. 완벽한 것은 아닙니다 — 바퀴 슬립과 누적 오차로 인해 오랜 시간과 거리에 걸쳐 부정확해지지만, 매우 유용한 도구입니다. 짧은 거리에서는 꽤 정확하며, SLAM 또는 GPS와 같은 다른 위치 결정 도구와 결합하면 개선된 전체 추정치를 얻을 수 있습니다. 위치의 다른 측정치를 결합하여 전반적인 위치 추정치를 더 정확하게 얻는 과정은 센서 퓨전의 예시이며, 일반적으로 칼만 필터를 통해 수행됩니다. 그렇다면 위치를 어떻게 계산할까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n수학 부분이 잘 다루어졌네요. 저는 Andrew Kramer의 예제 코드를 수정하여 계산한 후, 결과로부터 odometry 메시지를 채웠어요.\n\n내 로봇에서, 원래의 마이크로프로세서가 자원이 매우 부족했기 때문에, 나는 PID 루프를 마이크로컨트롤러에서만 실행하고 Raspberry Pi에서 Python 모터 컨트롤러 노드에서 odometry 계산을 수행하기로 선택했어요. 아래 코드 스니펫은 그 작동 방식을 보여줍니다.\n\nPython 노드는 원하는 바퀴 회전 속도를 마이크로컨트롤러로 보내요. 마이크로컨트롤러는 각 모터의 실제 인코더 틱 수를 매 초 20회 응답해요. 아래의 l_tick_cb() 함수는 Python 스크립트에서, 좌측 모터 인코더 틱 수가 수신될 때마다 작동하는 함수에요. 우측 모터의 콜백은 이 코드 스니펫에서 제외되었어요.\n\n실제 모터 틱 수가 수신될 때마다, 마지막 업데이트 이후에 주어진 쪽이 얼마나 이동했는지 계산되고, 로봇의 새로운 위치 추정 값이 계산돼요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n변수 theta는 로봇이 시작 방향에 대해 회전한 각도에 대한 현재 추정치입니다. 오도미트리 메시지를 완전히 채우려면 더 많은 정보가 필요합니다. 이 코드는 현재 속도를 계산하고 공분산 및 변환 필드를 채웁니다. 변환에 대해 자세한 내용은 다른 글에서 다루겠지만, 지금 당장 알아두실 점은 이 메시지에 대해 \"odom\" 및 \"base_link\" 자식 프레임으로 설정하는 것이 좋다는 것입니다. 이는 ROS 표준을 준수합니다. 곧 이에 대해 기사를 쓸 예정이지만, REP 105 및 최고 TF 설명은 이해를 시작하기에 좋은 자리입니다.\n\n오도멧리 변환은 쿼터니언으로 브로드캐스트됩니다. 함수를 사용하여 엔코더 값 (theta)으로부터 쿼터니언을 생성하며, 롤/피치는 우리의 미분 구동 로봇에 대해 제로로 가정됩니다. 이 코드는 해당 토론에서 가져온 것입니다.\n\n공분산은 주어진 측정치에 대한 예상 오차를 보고하는 메커니즘이며, 칼만 필터와 같은 센서 융합 중에 사용됩니다. 주어진 설정에 대한 계산 방법을 아직 이해하지 못하므로, 작은 미분 구동 로봇에 대해 찾은 전형적인 값들을 사용했습니다. 여기 개선할 수 있는 부분이 많이 있습니다.\n\n이 코드는 Github 리포지토리에서 마이크로컨트롤러에서 실행됩니다. 이 코드는 왼쪽 및 오른쪽 바퀴 RPM을 설정값으로 받아들이고, 모터를 펄스 폭 변조 (PWM)를 통해 제어하는 PID 루프를 실행합니다. 또한 각 바퀴의 사이클 동안 카운트된 엔코더 틱 수를 보고하여 코드 상에서 실제 바퀴 회전수를 계산합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어떤 하드웨어가 있는지 궁금하신가요?\n\n여기 메인 구성 요소를 보여주는 블록 다이어그램이 있습니다.\n\n![하드웨어 블록 다이어그램](/assets/img/2024-05-17-HowToAddAMotorControllerToYourROSRobot_2.png)\n\n보시다시피 Teensy는 모터 드라이버 모듈로 PWM 듀티 사이클을 출력하여 원하는 속도로 모터를 구동합니다. 모터 엔코더로부터 ticks를 받아 실제 속도를 계산하고 제어 루프를 닫습니다. 이들은 모터 PID 루프의 피드백입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 컨트롤러에서는 rosserial_arduino를 사용하여 원하는 바퀴 RPM 주제에 대해 구독하고 odometry/velocity 계산을 위해 각 바퀴의 실제 틱을 게시합니다.\n\n내 컨트롤러는 전압 분배기를 통해 팩 전압을 측정하고 전류 센서의 출력을 사용합니다.\n\n출력을 선택할 때는 모터 드라이버에 대해 PWM 출력을 사용해야 하며 엔코더 입력에 대해 일반 디지털 핀을 사용해야 합니다. Teensy에 대한 차트를 아래에서 볼 수 있습니다 — 다른 마이크로컨트롤러에 대한 유사한 차트도 있습니다.\n\n![Teensy 차트](/assets/img/2024-05-17-HowToAddAMotorControllerToYourROSRobot_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPWM 출력은 모터 드라이버의 4개 입력으로 보내집니다. 내 로봇은 저전류 모터를 사용하므로 이와 같은 저렴한 LM298 듀얼 H-브리지 드라이버를 선택했습니다. 다양한 유형의 모터를 구동하는 다양한 보드가 많이 있습니다. 브러시리스 모터는 다른 유형의 컨트롤러를 사용하지만 많은 모터가 PWM 입력을 사용합니다. LM298 사용 방법에 대한 좋은 안내서가 여기 있습니다.\n\n![로봇의 전자 부품 덱](/assets/img/2024-05-17-HowToAddAMotorControllerToYourROSRobot_4.png)\n\n여기에는 로봇의 전자 부품 덱이 있습니다. 라즈베리 파이 4 위에 앉은 쉴드 PCB에 Teensy가 보입니다.\n\n![로봇의 전자 부품 덱](/assets/img/2024-05-17-HowToAddAMotorControllerToYourROSRobot_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마이크로컨트롤러 선택\n\n처음에는 Arduino Uno용으로 이 코드를 작성했었는데, 주로 RAM이 부족해지는 문제가 발생했습니다. rosserial_arduino에는 보다 강력한 마이크로컨트롤러가 강력히 권장됩니다. 이 컨트롤러의 다음 버전은 ROS2용 Pi Pico를 사용하여 micro-ros로 만들 것입니다. 원칙적으로 이 코드는 rosserial_arduino에서 지원하는 모든 프로세서 상에서 작은 수정만으로도 실행되어야 합니다.\n\nTeensy 버전은 매우 잘 실행되었고, 현재 모든 프로젝트를 ROS2로 마이그레이션 중이며, Pico가 더 저렴합니다. 작동이 준비된 경우 해당에 대해 기사를 게시할 예정입니다.\n\nPID 튜닝\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPID 루프를 조정해야 하는데, 이는 이 글의 범위를 벗어납니다. 웹 검색을 통해 표준 접근 방식을 찾을 수 있습니다. 마이크로컨트롤러 코드에는 ROS 주제 에코 명령을 통해 조정 가능한 P, I 및 D 값을 구독자로 활성화하는 모드가 포함되어 있습니다. 이는 rqt_graph를 사용하여 명령된 rpm 대 실제 rpm을 그래프로 표시하면 튜닝 속도가 크게 향상됩니다.\n\n결론\n\n이 글이 실제 작동 예제를 제시하고 모든 자원을 한 곳에 모아서 작성한 것에 도움이 되었기를 바라며, 여러분의 프로젝트에 유용한 출발점이 되었으면 좋겠습니다. 개선할 점이 있다면 알려주시고, 여러분에게 가치 있었다면 알려주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 프로젝트의 코드는 주로 저의 것이지만, 일부는 다른 소스들을 참고하거나 수정한 것입니다.\n","ogImage":{"url":"/assets/img/2024-05-17-HowToAddAMotorControllerToYourROSRobot_0.png"},"coverImage":"/assets/img/2024-05-17-HowToAddAMotorControllerToYourROSRobot_0.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e로봇에 직접주행 및 오도메트리 기능을 부여하세요!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-HowToAddAMotorControllerToYourROSRobot_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eROS/ROS2와 함께 사용할 모바일 로봇을 만들고 있다면, 먼저해야 할 일 중 하나는 모터 컨트롤러를 통합하는 것입니다. 모터 컨트롤러의 목적은 네비게이션 스택과 같은 상위 레벨 소프트웨어로부터 메시지를 수신하고, 이를 모터를 구동하는 신호로 변환하는 것입니다. 또한 모터의 인코더에서 정보를 받아 로봇의 속도와 위치를 계산할 수 있습니다. 추가로 배터리 전압이 변동하거나 지형이 다를 때에도 일관된 바퀴 제어를 얻을 수 있습니다. 흥미가 생겼나요? 전형적인 차이 드라이브 로봇을 위한 ROS 모터 컨트롤러를 만들기 위해 필요한 모든 것과 참고용으로 사용할 수 있는 작동하는 코드가 준비되어 있습니다!\u003c/p\u003e\n\u003cp\u003e이 프로젝트의 전체 코드는 GitHub 레포지토리에 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e배경\u003c/p\u003e\n\u003cp\u003e내가 전에 썼던 ROS가 유용한 이유, ROS가 하는 일, 그리고 물리적 로봇과 어떻게 통합되는지에 대한 개요에 대해 읽은 것으로 가정하겠습니다.\u003c/p\u003e\n\u003cp\u003e나는 아두이노, Pi Pico 또는 Teensy와 같은 일반적인 마이크로컨트롤러에 어느 정도 익숙하다고 가정합니다. 이 경우 Teensy를 사용할 것이지만, 다양한 마이크로컨트롤러 유형에 걸쳐 개념은 거의 동일합니다.\u003c/p\u003e\n\u003cp\u003e중요한 개념\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e모터 컨트롤러의 역할은 전형적으로 /cmd_vel과 같은 주제에 Twist 유형의 메시지를 받는 것입니다. 이 메시지는 두 구성 요소로 이루어져 있습니다. 첫째, 미터/초로 분할된 원하는 선형 속도를 정의합니다. 두 번째로는 원하는 각속도인 라디안/초의 회전 속도를 포함합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 내비게이션 스택은 이 메시지를 보낼 수 있으며, 이 메시지는 로봇을 1m/s로 직진하면서 초당 0.1 라디안으로 회전하도록 모터 컨트롤러에 지시합니다. x 방향은 앞쪽으로, Z 방향은 지면과 직교한 상단 방향이고, y는 좌우입니다. 결과적으로 곡선 경로가 생성됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003elinear\u003c/span\u003e: \u003cspan class=\"hljs-attr\"\u003ex\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e;\n\u003cspan class=\"hljs-attr\"\u003ey\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e;\n\u003cspan class=\"hljs-attr\"\u003ez\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e;\n\u003cspan class=\"hljs-attr\"\u003eangular\u003c/span\u003e: \u003cspan class=\"hljs-attr\"\u003ex\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e;\n\u003cspan class=\"hljs-attr\"\u003ey\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e;\n\u003cspan class=\"hljs-attr\"\u003ez\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0.1\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e평범한 미끄럼 방지 구동 방식의 로봇은 일반적으로 가로 이동하거나 직접 올라가는 능력이 없으므로 선형 구성 요소는 주로 x 값을 사용합니다. 마찬가지로, 이 유형의 대부분 로봇은 Z 축을 중심으로 명령된 각속도만 사용할 것입니다. 방향과 단위에 대한 ROS 규칙은 REP 103에서 찾을 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이것이 지나치게 복잡해 보일 수도 있어요. 메시지 유형이 로봇이 물리적으로 따를 수 없는 구성요소를 가지는 이유가 뭘까요? 메시지 유형은 여러 유형의 로봇에서 사용될 것이기 때문이에요. 홀로노믹 드라이브 로봇은 옆으로 이동해서 미끄러짐 없이 움직일 수 있어요. 쿼드콥터 로봇은 회전하지 않고 동시에 위, 옆, 앞으로 움직일 수 있어요. 이 메시지 유형은 다양한 종류의 로봇에서 사용할 수 있도록 설계되었어요.\u003c/p\u003e\n\u003cp\u003e각도 구성요소를 신경 써야 하는 이유가 뭘까요? 나중에 이것이 정말 유용해질 거에요. 직선으로 운전 중에 조금씩 벗어나기 시작할 경우에 코스 수정을 쉽게 보낼 수 있어요. 제자리에서 회전 명령을 쉽게 보낼 수 있어요. 우리가 아래에서 볼 때, 수학도 쉬워질 거에요.\u003c/p\u003e\n\u003cp\u003e그래서 모터 컨트롤러는 cmd_vel에서 특정 선형 및 각속도 혼합을 주문받고, 그것이 모터 속도로 어떤 의미인지 계산해야 해요. 여기가 멋진 곳이에요. 곧 수학으로 돌아올게요 - 무서워하지 마세요. 먼저, 모터 속도를 정확히 제어하는 법에 대해 이야기해야 해요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e간단한 로봇을 만들었다면, 아마도 DC 모터의 속도를 제어할 수 있다는 개념에 익숙할 것입니다. 전압을 펄스로 제어함으로써 DC 모터의 속도를 조절할 수 있다는 아이디어에 편안해지셨을 겁니다. 전압이 켜져 있는 비율이 높을수록 모터는 최고 속도까지 빨리 회전합니다. 이를 펄스 폭 변조(Pulse Width Modulation)이라고 하며, 단순한 로봇에서도 동작하지만 문제가 있습니다. 가장 큰 문제는 모터 속도가 배터리 전압에 따라 변경된다는 것입니다. 모터가 회전하는 속도는 적용된 전압의 함수이므로 배터리가 방전될수록, 주어진 속도를 유지하기 위해 더 높은 켜는 시간 비율이 필요합니다. 또 다른 문제는 주어진 전압에 대해 한 모터가 조금이라도 다른 모터보다 빨리 회전한다면 어떻게 될까요? 양쪽에 동일한 비율을 보낸다면 로봇은 곡선 형태로 이동합니다. 또한 지형에 의해 바퀴 중 하나가 부분적으로 막혀 있다면 특정 바퀴 속도를 달성하는 데 더 많은 전력이 필요합니다. 일정한 속도를 명령하고 실제로 그 속도를 얻고 싶다면 휠로부터 피드백을 받아야 합니다. 우리는 폐쇄 루프 시스템이 필요합니다.\u003c/p\u003e\n\u003cp\u003e운전 모터의 경우, 통합 자기 엔코더가 있는 모터를 사용하고 싶습니다. 홀 센서는 모터 축에있는 자석이 센서를 지날 때마다 펄스를 생성하는 데 사용됩니다. 이 펄스를 마이크로컨트롤러로 보내어 카운트하고 실제 바퀴 속도를 계산합니다. (이를 위해 기어 비율 및 기타 몇 가지 세부 정보가 필요합니다 — 나중에 자세히 살펴보겠습니다)\u003c/p\u003e\n\u003cp\u003e아래 이미지에서 각 모터의 뒤쪽에 엔코더가 달려 있는 것을 볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-HowToAddAMotorControllerToYourROSRobot_1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그래서 이제 마이크로컨트롤러는 PWM 펄스폭을 변화시킴으로써 모터의 속도를 제어하고, 샤프트의 실제 속도를 읽을 수 있게 되었습니다. 이는 배터리 전압, 지형, 또는 로봇의 왼쪽 구동 바퀴에 감겨있는 골든 리트리버 털과는 독립적으로 작동합니다. 우리는 이제 폐쇄 루프를 가지고 있으며 이제 어디론가 가고 있습니다. 그래서.. 우리가 원하는 바퀴 속도를 어떻게 얻을까요?\u003c/p\u003e\n\u003cp\u003ePID 제어\u003c/p\u003e\n\u003cp\u003e그것이 PID 제어 루프의 역할입니다. PID 루프는 다른 사람들에 의해 더 잘 이해되고 다뤄진 기사들에서 충분히 다루어졌기 때문에, 여기서는 다시 다루지 않겠습니다. 좋은 소개는 여기에 있고, 모터 제어에 좀 더 특화된 것은 여기에 있습니다. Youtube에도 좋은 비디오들이 있습니다. PID에 대해 배운 내용을 로봇에 매핑하는 방법을 요약하면 다음과 같습니다. 각 모터마다 한 개의 루프가 필요합니다. 인코더는 펄스 형태로 피드백을 제공하며, 이를 사용하여 바퀴 RPM을 계산합니다. 설정점은 선속도와 각속도에서 계산된 바퀴 속도입니다 (곧 설명될 것). 출력은 주로 0에서 255까지 변할 수 있는 펄스폭의 백분율입니다. 몇 초에 한 번씩 PID 루프는 설정점을 실제 바퀴 속도와 비교하고, 모터의 PWM 출력을 조정하여 배터리 전압, 부하 또는 다른 변수와 관계없이 목표치에 유지합니다. 이에는 나중에 다룰 튜닝 프로세스가 필요하며, 기사의 나중 부분에서도 이에 대해 논의할 것입니다. 지금은 바퀴 속도가 어떻게 계산되는지로 넘어갑시다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e모터 컨트롤러는 로봇이 주어진 선속도와 각속도로 동시에 이동하도록 요청받은 메시지를 받았어요. 바퀴가 해야 할 일을 어떻게 계산하는 걸까요?\u003c/p\u003e\n\u003cp\u003e여기 수학적 설명이 잘 나와 있어요. 거기서 이를 배웠어요. 이제 Twist 메시지가 선속도와 각속도를 따로 분리하는 이유가 분명해질 거예요.\u003c/p\u003e\n\u003cp\u003e먼저 선속도부터 시작해봅시다. 그것은 상당히 쉬워요. 우리는 특정 바퀴의 속도를 PID 컨트롤러를 사용하여 정확하게 설정하는 방법을 알아요. 직선 운동에서 두 바퀴는 같은 속도로 회전해야 하므로, 우리는 단순히 우리가 원하는 전진 속도를 만들어내기 위한 그 바퀴 속도가 무엇인지 계산하고 두 바퀴 모두 그 속도로 설정하면 되요. 주요 구동 바퀴의 반경을 알아야 하는데, 그것으로부터 바퀴 둘레를 계산할 수 있어요. 그것이 바퀴 한 바퀴 회전마다 로봇이 이동하는 거리를 의미하죠. 그 후, 구동 바퀴의 기어 비율과 바퀴 당 엔코더 틱 수를 알아야 해요. 그럼 필요한 모터 속도를 계산할 충분한 정보가 생기게 되요.\u003c/p\u003e\n\u003cp\u003e각속도를 계산하는 수학은 약간 복잡해요. 두 바퀴의 속도 차이를 도입해 로봇이 올바른 속도로 회전하도록 해야 해요. 우리는 바퀴베이스를 알아야 하는데, 이는 드라이브 바퀴 사이의 거리를 말해요. 처음에 내가 처음에 한 것처럼 각 바퀴의 안쪽 가장자리부터 측정하지 마세요. 회전 속도에 상당한 오차가 발생할 거에요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다음은 코드가 모이게 됩니다:\u003c/p\u003e\n\u003cp\u003e변수 data.linear.x는 요청된 속도의 x 구성 요소이고, data.angular.z는 로봇의 요청된 회전입니다. ROS 메시지가 이렇게 속도를 분리하여 제공하면 희망하는 바퀴 속도를 계산하기가 매우 간단해집니다. right_rpm과 left_rpm 변수는 각 모터에 대한 PID 루프의 세트 포인트입니다. 이것은 원하는 동작을 생성하기 위해 필요합니다.\u003c/p\u003e\n\u003cp\u003e오도메트리 계산\u003c/p\u003e\n\u003cp\u003e모터 속도를 올바르게 설정하는 것 외에도 모터 컨트롤러는 로봇의 위치와 방향을 데드 레커닝을 통해 추정해야 합니다. 로봇이 어디에 있고 어느 방향을 향해 있는지 추적하기 위해 모든 이동, 각도 및 선형 이동을 합산합니다. 완벽한 것은 아닙니다 — 바퀴 슬립과 누적 오차로 인해 오랜 시간과 거리에 걸쳐 부정확해지지만, 매우 유용한 도구입니다. 짧은 거리에서는 꽤 정확하며, SLAM 또는 GPS와 같은 다른 위치 결정 도구와 결합하면 개선된 전체 추정치를 얻을 수 있습니다. 위치의 다른 측정치를 결합하여 전반적인 위치 추정치를 더 정확하게 얻는 과정은 센서 퓨전의 예시이며, 일반적으로 칼만 필터를 통해 수행됩니다. 그렇다면 위치를 어떻게 계산할까요?\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e수학 부분이 잘 다루어졌네요. 저는 Andrew Kramer의 예제 코드를 수정하여 계산한 후, 결과로부터 odometry 메시지를 채웠어요.\u003c/p\u003e\n\u003cp\u003e내 로봇에서, 원래의 마이크로프로세서가 자원이 매우 부족했기 때문에, 나는 PID 루프를 마이크로컨트롤러에서만 실행하고 Raspberry Pi에서 Python 모터 컨트롤러 노드에서 odometry 계산을 수행하기로 선택했어요. 아래 코드 스니펫은 그 작동 방식을 보여줍니다.\u003c/p\u003e\n\u003cp\u003ePython 노드는 원하는 바퀴 회전 속도를 마이크로컨트롤러로 보내요. 마이크로컨트롤러는 각 모터의 실제 인코더 틱 수를 매 초 20회 응답해요. 아래의 l_tick_cb() 함수는 Python 스크립트에서, 좌측 모터 인코더 틱 수가 수신될 때마다 작동하는 함수에요. 우측 모터의 콜백은 이 코드 스니펫에서 제외되었어요.\u003c/p\u003e\n\u003cp\u003e실제 모터 틱 수가 수신될 때마다, 마지막 업데이트 이후에 주어진 쪽이 얼마나 이동했는지 계산되고, 로봇의 새로운 위치 추정 값이 계산돼요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e변수 theta는 로봇이 시작 방향에 대해 회전한 각도에 대한 현재 추정치입니다. 오도미트리 메시지를 완전히 채우려면 더 많은 정보가 필요합니다. 이 코드는 현재 속도를 계산하고 공분산 및 변환 필드를 채웁니다. 변환에 대해 자세한 내용은 다른 글에서 다루겠지만, 지금 당장 알아두실 점은 이 메시지에 대해 \"odom\" 및 \"base_link\" 자식 프레임으로 설정하는 것이 좋다는 것입니다. 이는 ROS 표준을 준수합니다. 곧 이에 대해 기사를 쓸 예정이지만, REP 105 및 최고 TF 설명은 이해를 시작하기에 좋은 자리입니다.\u003c/p\u003e\n\u003cp\u003e오도멧리 변환은 쿼터니언으로 브로드캐스트됩니다. 함수를 사용하여 엔코더 값 (theta)으로부터 쿼터니언을 생성하며, 롤/피치는 우리의 미분 구동 로봇에 대해 제로로 가정됩니다. 이 코드는 해당 토론에서 가져온 것입니다.\u003c/p\u003e\n\u003cp\u003e공분산은 주어진 측정치에 대한 예상 오차를 보고하는 메커니즘이며, 칼만 필터와 같은 센서 융합 중에 사용됩니다. 주어진 설정에 대한 계산 방법을 아직 이해하지 못하므로, 작은 미분 구동 로봇에 대해 찾은 전형적인 값들을 사용했습니다. 여기 개선할 수 있는 부분이 많이 있습니다.\u003c/p\u003e\n\u003cp\u003e이 코드는 Github 리포지토리에서 마이크로컨트롤러에서 실행됩니다. 이 코드는 왼쪽 및 오른쪽 바퀴 RPM을 설정값으로 받아들이고, 모터를 펄스 폭 변조 (PWM)를 통해 제어하는 PID 루프를 실행합니다. 또한 각 바퀴의 사이클 동안 카운트된 엔코더 틱 수를 보고하여 코드 상에서 실제 바퀴 회전수를 계산합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e어떤 하드웨어가 있는지 궁금하신가요?\u003c/p\u003e\n\u003cp\u003e여기 메인 구성 요소를 보여주는 블록 다이어그램이 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-HowToAddAMotorControllerToYourROSRobot_2.png\" alt=\"하드웨어 블록 다이어그램\"\u003e\u003c/p\u003e\n\u003cp\u003e보시다시피 Teensy는 모터 드라이버 모듈로 PWM 듀티 사이클을 출력하여 원하는 속도로 모터를 구동합니다. 모터 엔코더로부터 ticks를 받아 실제 속도를 계산하고 제어 루프를 닫습니다. 이들은 모터 PID 루프의 피드백입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 컨트롤러에서는 rosserial_arduino를 사용하여 원하는 바퀴 RPM 주제에 대해 구독하고 odometry/velocity 계산을 위해 각 바퀴의 실제 틱을 게시합니다.\u003c/p\u003e\n\u003cp\u003e내 컨트롤러는 전압 분배기를 통해 팩 전압을 측정하고 전류 센서의 출력을 사용합니다.\u003c/p\u003e\n\u003cp\u003e출력을 선택할 때는 모터 드라이버에 대해 PWM 출력을 사용해야 하며 엔코더 입력에 대해 일반 디지털 핀을 사용해야 합니다. Teensy에 대한 차트를 아래에서 볼 수 있습니다 — 다른 마이크로컨트롤러에 대한 유사한 차트도 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-HowToAddAMotorControllerToYourROSRobot_3.png\" alt=\"Teensy 차트\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003ePWM 출력은 모터 드라이버의 4개 입력으로 보내집니다. 내 로봇은 저전류 모터를 사용하므로 이와 같은 저렴한 LM298 듀얼 H-브리지 드라이버를 선택했습니다. 다양한 유형의 모터를 구동하는 다양한 보드가 많이 있습니다. 브러시리스 모터는 다른 유형의 컨트롤러를 사용하지만 많은 모터가 PWM 입력을 사용합니다. LM298 사용 방법에 대한 좋은 안내서가 여기 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-HowToAddAMotorControllerToYourROSRobot_4.png\" alt=\"로봇의 전자 부품 덱\"\u003e\u003c/p\u003e\n\u003cp\u003e여기에는 로봇의 전자 부품 덱이 있습니다. 라즈베리 파이 4 위에 앉은 쉴드 PCB에 Teensy가 보입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-HowToAddAMotorControllerToYourROSRobot_5.png\" alt=\"로봇의 전자 부품 덱\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e마이크로컨트롤러 선택\u003c/p\u003e\n\u003cp\u003e처음에는 Arduino Uno용으로 이 코드를 작성했었는데, 주로 RAM이 부족해지는 문제가 발생했습니다. rosserial_arduino에는 보다 강력한 마이크로컨트롤러가 강력히 권장됩니다. 이 컨트롤러의 다음 버전은 ROS2용 Pi Pico를 사용하여 micro-ros로 만들 것입니다. 원칙적으로 이 코드는 rosserial_arduino에서 지원하는 모든 프로세서 상에서 작은 수정만으로도 실행되어야 합니다.\u003c/p\u003e\n\u003cp\u003eTeensy 버전은 매우 잘 실행되었고, 현재 모든 프로젝트를 ROS2로 마이그레이션 중이며, Pico가 더 저렴합니다. 작동이 준비된 경우 해당에 대해 기사를 게시할 예정입니다.\u003c/p\u003e\n\u003cp\u003ePID 튜닝\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003ePID 루프를 조정해야 하는데, 이는 이 글의 범위를 벗어납니다. 웹 검색을 통해 표준 접근 방식을 찾을 수 있습니다. 마이크로컨트롤러 코드에는 ROS 주제 에코 명령을 통해 조정 가능한 P, I 및 D 값을 구독자로 활성화하는 모드가 포함되어 있습니다. 이는 rqt_graph를 사용하여 명령된 rpm 대 실제 rpm을 그래프로 표시하면 튜닝 속도가 크게 향상됩니다.\u003c/p\u003e\n\u003cp\u003e결론\u003c/p\u003e\n\u003cp\u003e이 글이 실제 작동 예제를 제시하고 모든 자원을 한 곳에 모아서 작성한 것에 도움이 되었기를 바라며, 여러분의 프로젝트에 유용한 출발점이 되었으면 좋겠습니다. 개선할 점이 있다면 알려주시고, 여러분에게 가치 있었다면 알려주세요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 프로젝트의 코드는 주로 저의 것이지만, 일부는 다른 소스들을 참고하거나 수정한 것입니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-17-HowToAddAMotorControllerToYourROSRobot"},"buildId":"T_Nz0g9U1yttYMSEma95P","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>