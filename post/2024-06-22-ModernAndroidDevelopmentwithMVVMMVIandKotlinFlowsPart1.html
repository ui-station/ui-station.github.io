<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>MVVM, MVI 및 Kotlin Flows를 활용한 최신 안드로이드 개발  Part 1 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="MVVM, MVI 및 Kotlin Flows를 활용한 최신 안드로이드 개발  Part 1 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="MVVM, MVI 및 Kotlin Flows를 활용한 최신 안드로이드 개발  Part 1 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1" data-gatsby-head="true"/><meta name="twitter:title" content="MVVM, MVI 및 Kotlin Flows를 활용한 최신 안드로이드 개발  Part 1 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 22:37" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_buildManifest.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">MVVM, MVI 및 Kotlin Flows를 활용한 최신 안드로이드 개발  Part 1</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="MVVM, MVI 및 Kotlin Flows를 활용한 최신 안드로이드 개발  Part 1" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>안드로이드 MVI 아키텍처의 심층 탐구</h2>
<img src="/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_0.png">
<p>앱 개발 프로세스를 개선하고 스트림라인하는 방법을 찾느라 고심 중인 안드로이드 개발자이신가요? Kotlin flows를 사용하여 MVVM 및 MVI 아키텍처 패턴을 결합하는 것을 들어보았지만 그것이 어떻게 도움이 될 수 있는지 또는 어디서 시작해야 하는지 확실하지 않으신가요? 이 기사는 여러분을 위해 특별히 작성되었습니다.</p>
<p>안드로이드 개발에 있어서 올바른 아키텍처 패턴을 선택하는 것이 얼마나 중요한지 우리 모두 알고 있습니다. 이는 관리 가능한 프로젝트와 완전한 엉망인 프로젝트 사이의 차이를 의미할 수 있습니다. 이미 MVVM (Model-View-ViewModel) 및 MVI (Model-View-Intent) 패턴에 대해 알고 계실 것으로 생각됩니다. 각각에는 강점과 약점이 있습니다. MVVM은 데이터 바인딩과 표시 상태 관리에서 빛을 발하며, MVI는 단방향 데이터 흐름과 강력한 상태 관리로 빛을 발합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>하지만 이 두 강력한 패턴을 결합하여 안드로이드 개발에 더 강력한 접근 방식을 만들 수 있다고 말했다면 어떨까요? 바로 Kotlin flows를 사용하여 MVVM과 MVI 간의 원활한 통합을 제공하는 방법을 이 글에서 살펴보겠습니다.</p>
<h1>MVC 대 MVI</h1>
<p>결합된 방식에 대해 자세히 살펴보기 전에 먼저 MVC (Model-View-Controller)와 MVI의 핵심 원칙을 이해해 보겠습니다.</p>
<h2>MVC란 무엇인가요?</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>MVC 패턴에서 Model은 데이터와 비즈니스 로직을 나타내고, View는 UI를 렌더링하는 역할을 하며, Controller는 Model과 View 사이에서 중개자 역할을 하며, 사용자 입력을 처리하고 Model과 View를 업데이트합니다.</p>
<p><img src="/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_1.png" alt="Image"></p>
<p>다음은 안드로이드에서 Model-View-Controller (MVC) 아키텍처를 구현하는 예시입니다:</p>
<p>Model 파일 이름은 UserModel.kt:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-keyword">val</span> id: String, <span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> email: String)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserModel</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> users: MutableList&#x3C;User> = mutableListOf()

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addUser</span><span class="hljs-params">(user: <span class="hljs-type">User</span>)</span></span> {
        users.add(user)
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getUsers</span><span class="hljs-params">()</span></span>: List&#x3C;User> {
        <span class="hljs-keyword">return</span> users.toList()
    }
}
</code></pre>
<p>UserModel 클래스는 Model을 나타내며 사용자 목록을 관리합니다.</p>
<p>컨트롤러는 UserController.kt 입니다:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> userView: UserView) {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> userModel = UserModel()

    <span class="hljs-comment">// 모델 조작</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addUser</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, email: <span class="hljs-type">String</span>)</span></span> {
        <span class="hljs-keyword">val</span> user = User(UUID.randomUUID().toString(), name, email)
        userModel.addUser(user)

        <span class="hljs-keyword">val</span> users = userModel.getUsers()
        updateView(users)
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateView</span><span class="hljs-params">(users: <span class="hljs-type">List</span>&#x3C;<span class="hljs-type">User</span>>)</span></span> {
        <span class="hljs-comment">// 뷰에서 UI를 업데이트하는 적절한 메서드 호출</span>
        userView.displayUsers(users)
    }
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>The UserController 클래스는 Controller 역할을 하며 사용자 상호작용을 처리하고 Model을 업데이트합니다. 또한 Model의 변경 사항에 따라 UI를 업데이트하기 위해 View와 통신합니다.</p>
<p>뷰는 MvcActivity.kt에서 제공됩니다:</p>
<pre><code class="hljs language-js">interface <span class="hljs-title class_">UserView</span> {
    fun <span class="hljs-title function_">displayUsers</span>(<span class="hljs-attr">users</span>: <span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">User</span>>)
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcActivity</span> : <span class="hljs-title class_">AppCompatActivity</span>(), <span class="hljs-title class_">UserView</span> {
    private lateinit <span class="hljs-keyword">var</span> <span class="hljs-attr">userAdapter</span>: <span class="hljs-title class_">UserAdapter</span>
    private lateinit <span class="hljs-keyword">var</span> <span class="hljs-attr">binding</span>: <span class="hljs-title class_">ActivityMvcBinding</span>
    private lateinit <span class="hljs-keyword">var</span> <span class="hljs-attr">controller</span>: <span class="hljs-title class_">UserController</span>

    override fun <span class="hljs-title function_">onCreate</span>(<span class="hljs-params">savedInstanceState: Bundle?</span>) {
        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">onCreate</span>(savedInstanceState)
        binding = <span class="hljs-title class_">ActivityMvcBinding</span>.<span class="hljs-title function_">inflate</span>(layoutInflater)
        <span class="hljs-title function_">setContentView</span>(binding.<span class="hljs-property">root</span>)
        <span class="hljs-title function_">setupRecyclerView</span>()

        <span class="hljs-comment">// 컨트롤러 생성</span>
        controller = <span class="hljs-title class_">UserController</span>(<span class="hljs-variable language_">this</span>)

        binding.<span class="hljs-property">addUserButton</span>.<span class="hljs-property">setOnClickListener</span> {
            val name = binding.<span class="hljs-property">nameEditText</span>.<span class="hljs-property">text</span>.<span class="hljs-title function_">toString</span>()
            val email = binding.<span class="hljs-property">emailEditText</span>.<span class="hljs-property">text</span>.<span class="hljs-title function_">toString</span>()
            <span class="hljs-comment">// 사용자 입력 전송</span>
            controller.<span class="hljs-title function_">addUser</span>(name, email)
        }
    }

    override fun <span class="hljs-title function_">displayUsers</span>(<span class="hljs-params">users: List&#x3C;User></span>) {
        <span class="hljs-comment">// 사용자 목록을 표시하기 위해 UI 업데이트</span>
        userAdapter.<span class="hljs-title function_">setUsers</span>(users)
    }

    private fun <span class="hljs-title function_">setupRecyclerView</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">// 코드가 간결하게 유지될 수 있도록 주석 처리됨</span>
    }
}
</code></pre>
<p>MvcActivity 클래스는 View를 나타내며 UI를 표시하는 역할을 담당합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>MVI란 무엇인가요?</h2>
<p><img src="/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_2.png" alt="image"></p>
<p>MVI 패턴은 Model-View-Controller (MVC) 패턴의 변형으로 생각될 수 있습니다. Model-View-Intent (MVI)의 주요 아이디어는 사용자 인터페이스를 구축하기 위한 반응적이고 기능적 접근 방식을 제공하는 것입니다. 이는 Model-View-Controller (MVC) 아키텍처와 유사합니다.</p>
<h2>MVI는 어떻게 작동하나요?</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>MVI에서 기본 개념은 동일하지만 보다 반응적이고 기능적인 프로그래밍 스타일을 강조합니다. Model을 직접 변경하거나 View를 업데이트하는 대신, MVI는 사용자 의도를 불변의 데이터 구조 (Intents)로 캡처하고 단방향 데이터 흐름을 통해 이를 처리하는 데 초점을 맞춥니다. 이러한 흐름은 일반적으로 세 가지 주요 구성 요소로 구성됩니다:</p>
<ul>
<li>Model: 응용 프로그램의 현재 상태를 나타냅니다. Model은 변경할 수 없습니다. Model은 의도를 처리하고 Model의 새 버전을 생성함으로써 업데이트됩니다.</li>
<li>View: 현재 Model 상태를 기반으로 UI를 렌더링하는 역할을 합니다. View는 수동적이며 Model이 변경될 때마다 업데이트를 수신합니다.</li>
<li>Intent: 사용자 작업 또는 의도를 나타내며, View에서 Model을 업데이트하기 위해 전송됩니다. Intents는 사용자가 수행하려는 작업을 설명하는 일반적으로 간단한 데이터 구조입니다.</li>
</ul>
<p><img src="/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_3.png" alt="이미지"></p>
<p>MVI 패턴은 엄격한 단방향 데이터 흐름을 강제합니다. 데이터는 의도에서 모델로, 그리고 모델에서 뷰로 흐릅니다. 이렇게 하면 앱의 동작 및 상태에 대한 추론이 더 쉬워지며 구성 요소 간 부작용이나 종속성이 없기 때문에 유지보수가 쉽습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>MVC에서 MVI로 변환하기:</h2>
<p>위의 코드를 MVI 아키텍처로 어떻게 변경할 수 있는지 알아봅시다. 먼저 두 가지 추가 클래스를 추가해야 합니다. 뷰 내에서 사용자 관련 데이터의 현재 상태를 나타내는 UserViewState 클래스를 소개했습니다. UserIntent sealed 클래스는 사용자 의도를 나타내는 다양한 의도를 정의합니다. 예를 들어 사용자를 추가하는 것입니다.</p>
<pre><code class="hljs language-js">data <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserViewState</span>(val <span class="hljs-attr">users</span>: <span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">User</span>>)

sealed <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserIntent</span> {
    data <span class="hljs-keyword">class</span> <span class="hljs-title class_">AddUser</span>(val <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>, val <span class="hljs-attr">email</span>: <span class="hljs-title class_">String</span>) : <span class="hljs-title class_">UserIntent</span>()
    <span class="hljs-comment">// GetUsers와 같은 다른 사용자 의도도 추가할 수 있습니다.</span>
}
</code></pre>
<p>UserController와 UserView 인터페이스를 제거할 수 있습니다. 또한 UserModel 클래스를 변경하여 현재 뷰 상태를 유지하고 사용자 의도를 처리하며 사용자 상태를 업데이트할 수 있습니다. UserModel은 Kotlin Coroutines Flow를 사용하여 반응적일 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserModel</span> {
    <span class="hljs-comment">// 애플리케이션의 현재 뷰 상태를 유지합니다</span>
    private val <span class="hljs-attr">_userViewState</span>: <span class="hljs-title class_">MutableStateFlow</span>&#x3C;<span class="hljs-title class_">UserViewState</span>> = <span class="hljs-title class_">MutableStateFlow</span>(<span class="hljs-title class_">UserViewState</span>(<span class="hljs-title function_">emptyList</span>()))
    <span class="hljs-comment">// 다른 뷰들과 뷰 상태를 공유하여 핫 플로우로 제공합니다</span>
    val userViewState = _userViewState.<span class="hljs-title function_">asStateFlow</span>()

    <span class="hljs-comment">// processUserIntents에서 사용할 현재 뷰 상태를 얻습니다</span>
    private fun <span class="hljs-title function_">currentViewState</span>(): <span class="hljs-title class_">UserViewState</span> {
        <span class="hljs-keyword">return</span> _userViewState.<span class="hljs-property">value</span>
    }

    <span class="hljs-comment">// 뷰로부터 사용자 의도를 처리합니다</span>
    fun <span class="hljs-title function_">processUserIntents</span>(<span class="hljs-params">userIntent: UserIntent</span>) {
        when (userIntent) {
            is <span class="hljs-title class_">UserIntent</span>.<span class="hljs-property">AddUser</span> -> {
                val user = <span class="hljs-title class_">User</span>(<span class="hljs-variable constant_">UUID</span>.<span class="hljs-title function_">randomUUID</span>().<span class="hljs-title function_">toString</span>(), userIntent.<span class="hljs-property">name</span>, userIntent.<span class="hljs-property">email</span>)
                val newViewState = <span class="hljs-title function_">currentViewState</span>().<span class="hljs-title function_">copy</span>(users = <span class="hljs-title function_">currentViewState</span>().<span class="hljs-property">users</span> + user)
                _userViewState.<span class="hljs-property">value</span> = newViewState
            }
            <span class="hljs-comment">/*
            * 다른 사용자 의도(예: 사용자 목록 가져오기)도 여기서 처리할 수 있습니다
            * */</span>
        }
    }
}
</code></pre>
<p>userViewState는 사용자 뷰 상태를 핫 플로우로 공유합니다. 핫 플로우는 활성 구독자 여부와 관계없이 값을 방출합니다. 핫 플로우는 구독자 여부와 상관없이 계속 업데이트를 방출하는 공유 상태를 유지합니다. 새로운 구독자가 참여하면 최신 값 및 이후의 업데이트를 수신합니다. asStateFlow() 함수는 MutableSharedFlow를 StateFlow로 변환하며, 얻어진 StateFlow는 최신 값 유지 및 구독자 활동 여부에 관계없이 업데이트를 방출하는 핫 플로우로 간주될 수 있습니다.</p>
<p>그리고 View 부분에 대한 변경사항은 다음과 같습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MviActivity</span> : <span class="hljs-title class_">AppCompatActivity</span>() {
    private lateinit <span class="hljs-keyword">var</span> <span class="hljs-attr">userAdapter</span>: <span class="hljs-title class_">UserAdapter</span>
    private lateinit <span class="hljs-keyword">var</span> <span class="hljs-attr">binding</span>: <span class="hljs-title class_">ActivityMviBinding</span>
    private val model = <span class="hljs-title class_">UserModel</span>()

    override fun <span class="hljs-title function_">onCreate</span>(<span class="hljs-params">savedInstanceState: Bundle?</span>) {
        binding = <span class="hljs-title class_">ActivityMviBinding</span>.<span class="hljs-title function_">inflate</span>(layoutInflater)
        <span class="hljs-title function_">setContentView</span>(binding.<span class="hljs-property">root</span>)
        <span class="hljs-title function_">setupRecyclerView</span>()

        binding.<span class="hljs-property">addUserButton</span>.<span class="hljs-property">setOnClickListener</span> {
            val name = binding.<span class="hljs-property">nameEditText</span>.<span class="hljs-property">text</span>.<span class="hljs-title function_">toString</span>()
            val email = binding.<span class="hljs-property">emailEditText</span>.<span class="hljs-property">text</span>.<span class="hljs-title function_">toString</span>()

            <span class="hljs-comment">// 사용자 의도를 생성하고 모델에 전달합니다</span>
            val userIntent = <span class="hljs-title class_">UserIntent</span>.<span class="hljs-title class_">AddUser</span>(name, email)
            model.<span class="hljs-title function_">processUserIntents</span>(userIntent)
        }

        <span class="hljs-comment">// UI가 뷰 상태 변경을 관찰합니다</span>
        model.<span class="hljs-property">userViewState</span>
            .<span class="hljs-property">onEach</span> { userViewState ->
                <span class="hljs-title function_">renderUserViewState</span>(userViewState)
            }
            .<span class="hljs-title function_">launchIn</span>(lifecycleScope)
    }

    private fun <span class="hljs-title function_">renderUserViewState</span>(<span class="hljs-params">userViewState: UserViewState</span>) {
        <span class="hljs-comment">// 사용자 목록을 표시하기 위해 UI를 업데이트합니다</span>
        userAdapter.<span class="hljs-title function_">setUsers</span>(userViewState.<span class="hljs-property">users</span>)
    }
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>MviActivity에서는 onEach를 사용하여 상태 플로우를 관찰하고 renderUserViewState()를 호출하여 UI를 업데이트합니다.</p>
<p>수정된 코드로 다시 다이어그램을 살펴봅시다. 코드를 다이어그램의 각 부분에 매핑하는 방법을 살펴봅시다:</p>
<p><img src="/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_4.png" alt="Diagram"></p>
<p>위 다이어그램에서 사용자는 OnClick 등의 액션을 트리거할 수 있습니다. 이러한 액션들은 인텐트로 파싱되어 모델에 전달될 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>모델에서 processUserIntentsexecutes는 전달된 Intent에 기반한 로직을 실행하며, 이 경우 UserIntent.AddUser를 받아 새로운 상태를 생성합니다:</p>
<pre><code class="hljs language-js">val newViewState = <span class="hljs-title function_">currentViewState</span>().<span class="hljs-title function_">copy</span>(users = <span class="hljs-title function_">currentViewState</span>().<span class="hljs-property">users</span> + user)
_userViewState.<span class="hljs-property">value</span> = newViewState
</code></pre>
<p>copy()는 기존 객체와 동일한 속성을 가진 새 객체를 생성하는 Kotlin 함수입니다. 이 경우 currentViewState().copy()는 현재 뷰 상태와 동일한 속성을 가진 새 UserViewState 객체를 생성합니다.</p>
<p>users = currentViewState().users + user 부분은 새로운 뷰 상태의 users 속성을 업데이트해야 함을 명시합니다. 요약하자면, 이 두 줄의 코드는 현재 뷰 상태의 복사본을 만들어 사용자 목록에 새로운 사용자가 추가된 새로운 뷰 상태 객체를 생성합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>뷰 부분에서 새 상태가 생성될 때마다 MviActivity가 변경 사항을 observe합니다.</p>
<pre><code class="hljs language-js">model.<span class="hljs-property">userViewState</span>
  .<span class="hljs-property">onEach</span> { userViewState ->
      <span class="hljs-title function_">renderUserViewState</span>(userViewState)
  }
  .<span class="hljs-title function_">launchIn</span>(lifecycleScope)
</code></pre>
<p>그리고 renderUserViewState(userViewState)를 사용하여 사용자에게 상태를 표시합니다. 반응형 프로그래밍과 Kotlin Coroutine 플로우 덕분에 가능해졌습니다.</p>
<h1>다음은 무엇인가요?</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다음 시리즈에서는 MVVM 아키텍처를 MVI와 비교하고 이러한 아키텍처를 더 깊이 파헤쳐 양쪽에서 최상의 결과를 얻을 수 있는 방법에 대해 살펴볼 것입니다. 기대해주세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"MVVM, MVI 및 Kotlin Flows를 활용한 최신 안드로이드 개발  Part 1","description":"","date":"2024-06-22 22:37","slug":"2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1","content":"\n## 안드로이드 MVI 아키텍처의 심층 탐구\n\n\u003cimg src=\"/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_0.png\" /\u003e\n\n앱 개발 프로세스를 개선하고 스트림라인하는 방법을 찾느라 고심 중인 안드로이드 개발자이신가요? Kotlin flows를 사용하여 MVVM 및 MVI 아키텍처 패턴을 결합하는 것을 들어보았지만 그것이 어떻게 도움이 될 수 있는지 또는 어디서 시작해야 하는지 확실하지 않으신가요? 이 기사는 여러분을 위해 특별히 작성되었습니다.\n\n안드로이드 개발에 있어서 올바른 아키텍처 패턴을 선택하는 것이 얼마나 중요한지 우리 모두 알고 있습니다. 이는 관리 가능한 프로젝트와 완전한 엉망인 프로젝트 사이의 차이를 의미할 수 있습니다. 이미 MVVM (Model-View-ViewModel) 및 MVI (Model-View-Intent) 패턴에 대해 알고 계실 것으로 생각됩니다. 각각에는 강점과 약점이 있습니다. MVVM은 데이터 바인딩과 표시 상태 관리에서 빛을 발하며, MVI는 단방향 데이터 흐름과 강력한 상태 관리로 빛을 발합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 이 두 강력한 패턴을 결합하여 안드로이드 개발에 더 강력한 접근 방식을 만들 수 있다고 말했다면 어떨까요? 바로 Kotlin flows를 사용하여 MVVM과 MVI 간의 원활한 통합을 제공하는 방법을 이 글에서 살펴보겠습니다.\n\n# MVC 대 MVI\n\n결합된 방식에 대해 자세히 살펴보기 전에 먼저 MVC (Model-View-Controller)와 MVI의 핵심 원칙을 이해해 보겠습니다.\n\n## MVC란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMVC 패턴에서 Model은 데이터와 비즈니스 로직을 나타내고, View는 UI를 렌더링하는 역할을 하며, Controller는 Model과 View 사이에서 중개자 역할을 하며, 사용자 입력을 처리하고 Model과 View를 업데이트합니다.\n\n![Image](/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_1.png)\n\n다음은 안드로이드에서 Model-View-Controller (MVC) 아키텍처를 구현하는 예시입니다:\n\nModel 파일 이름은 UserModel.kt:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\ndata class User(val id: String, val name: String, val email: String)\n\nclass UserModel {\n    private val users: MutableList\u003cUser\u003e = mutableListOf()\n\n    fun addUser(user: User) {\n        users.add(user)\n    }\n\n    fun getUsers(): List\u003cUser\u003e {\n        return users.toList()\n    }\n}\n```\n\nUserModel 클래스는 Model을 나타내며 사용자 목록을 관리합니다.\n\n컨트롤러는 UserController.kt 입니다:\n\n```kotlin\nclass UserController(private val userView: UserView) {\n\n    private val userModel = UserModel()\n\n    // 모델 조작\n    fun addUser(name: String, email: String) {\n        val user = User(UUID.randomUUID().toString(), name, email)\n        userModel.addUser(user)\n\n        val users = userModel.getUsers()\n        updateView(users)\n    }\n\n    private fun updateView(users: List\u003cUser\u003e) {\n        // 뷰에서 UI를 업데이트하는 적절한 메서드 호출\n        userView.displayUsers(users)\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nThe UserController 클래스는 Controller 역할을 하며 사용자 상호작용을 처리하고 Model을 업데이트합니다. 또한 Model의 변경 사항에 따라 UI를 업데이트하기 위해 View와 통신합니다.\n\n뷰는 MvcActivity.kt에서 제공됩니다:\n\n```js\ninterface UserView {\n    fun displayUsers(users: List\u003cUser\u003e)\n}\n\nclass MvcActivity : AppCompatActivity(), UserView {\n    private lateinit var userAdapter: UserAdapter\n    private lateinit var binding: ActivityMvcBinding\n    private lateinit var controller: UserController\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMvcBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n        setupRecyclerView()\n\n        // 컨트롤러 생성\n        controller = UserController(this)\n\n        binding.addUserButton.setOnClickListener {\n            val name = binding.nameEditText.text.toString()\n            val email = binding.emailEditText.text.toString()\n            // 사용자 입력 전송\n            controller.addUser(name, email)\n        }\n    }\n\n    override fun displayUsers(users: List\u003cUser\u003e) {\n        // 사용자 목록을 표시하기 위해 UI 업데이트\n        userAdapter.setUsers(users)\n    }\n\n    private fun setupRecyclerView() {\n        // 코드가 간결하게 유지될 수 있도록 주석 처리됨\n    }\n}\n```\n\nMvcActivity 클래스는 View를 나타내며 UI를 표시하는 역할을 담당합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## MVI란 무엇인가요?\n\n![image](/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_2.png)\n\nMVI 패턴은 Model-View-Controller (MVC) 패턴의 변형으로 생각될 수 있습니다. Model-View-Intent (MVI)의 주요 아이디어는 사용자 인터페이스를 구축하기 위한 반응적이고 기능적 접근 방식을 제공하는 것입니다. 이는 Model-View-Controller (MVC) 아키텍처와 유사합니다.\n\n## MVI는 어떻게 작동하나요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMVI에서 기본 개념은 동일하지만 보다 반응적이고 기능적인 프로그래밍 스타일을 강조합니다. Model을 직접 변경하거나 View를 업데이트하는 대신, MVI는 사용자 의도를 불변의 데이터 구조 (Intents)로 캡처하고 단방향 데이터 흐름을 통해 이를 처리하는 데 초점을 맞춥니다. 이러한 흐름은 일반적으로 세 가지 주요 구성 요소로 구성됩니다:\n\n- Model: 응용 프로그램의 현재 상태를 나타냅니다. Model은 변경할 수 없습니다. Model은 의도를 처리하고 Model의 새 버전을 생성함으로써 업데이트됩니다.\n- View: 현재 Model 상태를 기반으로 UI를 렌더링하는 역할을 합니다. View는 수동적이며 Model이 변경될 때마다 업데이트를 수신합니다.\n- Intent: 사용자 작업 또는 의도를 나타내며, View에서 Model을 업데이트하기 위해 전송됩니다. Intents는 사용자가 수행하려는 작업을 설명하는 일반적으로 간단한 데이터 구조입니다.\n\n![이미지](/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_3.png)\n\nMVI 패턴은 엄격한 단방향 데이터 흐름을 강제합니다. 데이터는 의도에서 모델로, 그리고 모델에서 뷰로 흐릅니다. 이렇게 하면 앱의 동작 및 상태에 대한 추론이 더 쉬워지며 구성 요소 간 부작용이나 종속성이 없기 때문에 유지보수가 쉽습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## MVC에서 MVI로 변환하기:\n\n위의 코드를 MVI 아키텍처로 어떻게 변경할 수 있는지 알아봅시다. 먼저 두 가지 추가 클래스를 추가해야 합니다. 뷰 내에서 사용자 관련 데이터의 현재 상태를 나타내는 UserViewState 클래스를 소개했습니다. UserIntent sealed 클래스는 사용자 의도를 나타내는 다양한 의도를 정의합니다. 예를 들어 사용자를 추가하는 것입니다.\n\n```js\ndata class UserViewState(val users: List\u003cUser\u003e)\n\nsealed class UserIntent {\n    data class AddUser(val name: String, val email: String) : UserIntent()\n    // GetUsers와 같은 다른 사용자 의도도 추가할 수 있습니다.\n}\n```\n\nUserController와 UserView 인터페이스를 제거할 수 있습니다. 또한 UserModel 클래스를 변경하여 현재 뷰 상태를 유지하고 사용자 의도를 처리하며 사용자 상태를 업데이트할 수 있습니다. UserModel은 Kotlin Coroutines Flow를 사용하여 반응적일 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nclass UserModel {\n    // 애플리케이션의 현재 뷰 상태를 유지합니다\n    private val _userViewState: MutableStateFlow\u003cUserViewState\u003e = MutableStateFlow(UserViewState(emptyList()))\n    // 다른 뷰들과 뷰 상태를 공유하여 핫 플로우로 제공합니다\n    val userViewState = _userViewState.asStateFlow()\n\n    // processUserIntents에서 사용할 현재 뷰 상태를 얻습니다\n    private fun currentViewState(): UserViewState {\n        return _userViewState.value\n    }\n\n    // 뷰로부터 사용자 의도를 처리합니다\n    fun processUserIntents(userIntent: UserIntent) {\n        when (userIntent) {\n            is UserIntent.AddUser -\u003e {\n                val user = User(UUID.randomUUID().toString(), userIntent.name, userIntent.email)\n                val newViewState = currentViewState().copy(users = currentViewState().users + user)\n                _userViewState.value = newViewState\n            }\n            /*\n            * 다른 사용자 의도(예: 사용자 목록 가져오기)도 여기서 처리할 수 있습니다\n            * */\n        }\n    }\n}\n```\n\nuserViewState는 사용자 뷰 상태를 핫 플로우로 공유합니다. 핫 플로우는 활성 구독자 여부와 관계없이 값을 방출합니다. 핫 플로우는 구독자 여부와 상관없이 계속 업데이트를 방출하는 공유 상태를 유지합니다. 새로운 구독자가 참여하면 최신 값 및 이후의 업데이트를 수신합니다. asStateFlow() 함수는 MutableSharedFlow를 StateFlow로 변환하며, 얻어진 StateFlow는 최신 값 유지 및 구독자 활동 여부에 관계없이 업데이트를 방출하는 핫 플로우로 간주될 수 있습니다.\n\n그리고 View 부분에 대한 변경사항은 다음과 같습니다:\n\n```js\nclass MviActivity : AppCompatActivity() {\n    private lateinit var userAdapter: UserAdapter\n    private lateinit var binding: ActivityMviBinding\n    private val model = UserModel()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        binding = ActivityMviBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n        setupRecyclerView()\n\n        binding.addUserButton.setOnClickListener {\n            val name = binding.nameEditText.text.toString()\n            val email = binding.emailEditText.text.toString()\n\n            // 사용자 의도를 생성하고 모델에 전달합니다\n            val userIntent = UserIntent.AddUser(name, email)\n            model.processUserIntents(userIntent)\n        }\n\n        // UI가 뷰 상태 변경을 관찰합니다\n        model.userViewState\n            .onEach { userViewState -\u003e\n                renderUserViewState(userViewState)\n            }\n            .launchIn(lifecycleScope)\n    }\n\n    private fun renderUserViewState(userViewState: UserViewState) {\n        // 사용자 목록을 표시하기 위해 UI를 업데이트합니다\n        userAdapter.setUsers(userViewState.users)\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMviActivity에서는 onEach를 사용하여 상태 플로우를 관찰하고 renderUserViewState()를 호출하여 UI를 업데이트합니다.\n\n수정된 코드로 다시 다이어그램을 살펴봅시다. 코드를 다이어그램의 각 부분에 매핑하는 방법을 살펴봅시다:\n\n![Diagram](/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_4.png)\n\n위 다이어그램에서 사용자는 OnClick 등의 액션을 트리거할 수 있습니다. 이러한 액션들은 인텐트로 파싱되어 모델에 전달될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모델에서 processUserIntentsexecutes는 전달된 Intent에 기반한 로직을 실행하며, 이 경우 UserIntent.AddUser를 받아 새로운 상태를 생성합니다:\n\n```js\nval newViewState = currentViewState().copy(users = currentViewState().users + user)\n_userViewState.value = newViewState\n```\n\ncopy()는 기존 객체와 동일한 속성을 가진 새 객체를 생성하는 Kotlin 함수입니다. 이 경우 currentViewState().copy()는 현재 뷰 상태와 동일한 속성을 가진 새 UserViewState 객체를 생성합니다.\n\nusers = currentViewState().users + user 부분은 새로운 뷰 상태의 users 속성을 업데이트해야 함을 명시합니다. 요약하자면, 이 두 줄의 코드는 현재 뷰 상태의 복사본을 만들어 사용자 목록에 새로운 사용자가 추가된 새로운 뷰 상태 객체를 생성합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n뷰 부분에서 새 상태가 생성될 때마다 MviActivity가 변경 사항을 observe합니다.\n\n```js\nmodel.userViewState\n  .onEach { userViewState -\u003e\n      renderUserViewState(userViewState)\n  }\n  .launchIn(lifecycleScope)\n```\n\n그리고 renderUserViewState(userViewState)를 사용하여 사용자에게 상태를 표시합니다. 반응형 프로그래밍과 Kotlin Coroutine 플로우 덕분에 가능해졌습니다.\n\n# 다음은 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 시리즈에서는 MVVM 아키텍처를 MVI와 비교하고 이러한 아키텍처를 더 깊이 파헤쳐 양쪽에서 최상의 결과를 얻을 수 있는 방법에 대해 살펴볼 것입니다. 기대해주세요!\n","ogImage":{"url":"/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_0.png"},"coverImage":"/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_0.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e안드로이드 MVI 아키텍처의 심층 탐구\u003c/h2\u003e\n\u003cimg src=\"/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_0.png\"\u003e\n\u003cp\u003e앱 개발 프로세스를 개선하고 스트림라인하는 방법을 찾느라 고심 중인 안드로이드 개발자이신가요? Kotlin flows를 사용하여 MVVM 및 MVI 아키텍처 패턴을 결합하는 것을 들어보았지만 그것이 어떻게 도움이 될 수 있는지 또는 어디서 시작해야 하는지 확실하지 않으신가요? 이 기사는 여러분을 위해 특별히 작성되었습니다.\u003c/p\u003e\n\u003cp\u003e안드로이드 개발에 있어서 올바른 아키텍처 패턴을 선택하는 것이 얼마나 중요한지 우리 모두 알고 있습니다. 이는 관리 가능한 프로젝트와 완전한 엉망인 프로젝트 사이의 차이를 의미할 수 있습니다. 이미 MVVM (Model-View-ViewModel) 및 MVI (Model-View-Intent) 패턴에 대해 알고 계실 것으로 생각됩니다. 각각에는 강점과 약점이 있습니다. MVVM은 데이터 바인딩과 표시 상태 관리에서 빛을 발하며, MVI는 단방향 데이터 흐름과 강력한 상태 관리로 빛을 발합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e하지만 이 두 강력한 패턴을 결합하여 안드로이드 개발에 더 강력한 접근 방식을 만들 수 있다고 말했다면 어떨까요? 바로 Kotlin flows를 사용하여 MVVM과 MVI 간의 원활한 통합을 제공하는 방법을 이 글에서 살펴보겠습니다.\u003c/p\u003e\n\u003ch1\u003eMVC 대 MVI\u003c/h1\u003e\n\u003cp\u003e결합된 방식에 대해 자세히 살펴보기 전에 먼저 MVC (Model-View-Controller)와 MVI의 핵심 원칙을 이해해 보겠습니다.\u003c/p\u003e\n\u003ch2\u003eMVC란 무엇인가요?\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eMVC 패턴에서 Model은 데이터와 비즈니스 로직을 나타내고, View는 UI를 렌더링하는 역할을 하며, Controller는 Model과 View 사이에서 중개자 역할을 하며, 사용자 입력을 처리하고 Model과 View를 업데이트합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_1.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e다음은 안드로이드에서 Model-View-Controller (MVC) 아키텍처를 구현하는 예시입니다:\u003c/p\u003e\n\u003cp\u003eModel 파일 이름은 UserModel.kt:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-keyword\"\u003edata\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e id: String, \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e name: String, \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e email: String)\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserModel\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e users: MutableList\u0026#x3C;User\u003e = mutableListOf()\n\n    \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eaddUser\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(user: \u003cspan class=\"hljs-type\"\u003eUser\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e {\n        users.add(user)\n    }\n\n    \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003egetUsers\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e: List\u0026#x3C;User\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e users.toList()\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUserModel 클래스는 Model을 나타내며 사용자 목록을 관리합니다.\u003c/p\u003e\n\u003cp\u003e컨트롤러는 UserController.kt 입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserController\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e userView: UserView) {\n\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e userModel = UserModel()\n\n    \u003cspan class=\"hljs-comment\"\u003e// 모델 조작\u003c/span\u003e\n    \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eaddUser\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(name: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e, email: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e user = User(UUID.randomUUID().toString(), name, email)\n        userModel.addUser(user)\n\n        \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e users = userModel.getUsers()\n        updateView(users)\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eupdateView\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(users: \u003cspan class=\"hljs-type\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-type\"\u003eUser\u003c/span\u003e\u003e)\u003c/span\u003e\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// 뷰에서 UI를 업데이트하는 적절한 메서드 호출\u003c/span\u003e\n        userView.displayUsers(users)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eThe UserController 클래스는 Controller 역할을 하며 사용자 상호작용을 처리하고 Model을 업데이트합니다. 또한 Model의 변경 사항에 따라 UI를 업데이트하기 위해 View와 통신합니다.\u003c/p\u003e\n\u003cp\u003e뷰는 MvcActivity.kt에서 제공됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003einterface \u003cspan class=\"hljs-title class_\"\u003eUserView\u003c/span\u003e {\n    fun \u003cspan class=\"hljs-title function_\"\u003edisplayUsers\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eusers\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e\u003e)\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMvcActivity\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eAppCompatActivity\u003c/span\u003e(), \u003cspan class=\"hljs-title class_\"\u003eUserView\u003c/span\u003e {\n    private lateinit \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003euserAdapter\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUserAdapter\u003c/span\u003e\n    private lateinit \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebinding\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eActivityMvcBinding\u003c/span\u003e\n    private lateinit \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003econtroller\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUserController\u003c/span\u003e\n\n    override fun \u003cspan class=\"hljs-title function_\"\u003eonCreate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003esavedInstanceState: Bundle?\u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eonCreate\u003c/span\u003e(savedInstanceState)\n        binding = \u003cspan class=\"hljs-title class_\"\u003eActivityMvcBinding\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einflate\u003c/span\u003e(layoutInflater)\n        \u003cspan class=\"hljs-title function_\"\u003esetContentView\u003c/span\u003e(binding.\u003cspan class=\"hljs-property\"\u003eroot\u003c/span\u003e)\n        \u003cspan class=\"hljs-title function_\"\u003esetupRecyclerView\u003c/span\u003e()\n\n        \u003cspan class=\"hljs-comment\"\u003e// 컨트롤러 생성\u003c/span\u003e\n        controller = \u003cspan class=\"hljs-title class_\"\u003eUserController\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e)\n\n        binding.\u003cspan class=\"hljs-property\"\u003eaddUserButton\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esetOnClickListener\u003c/span\u003e {\n            val name = binding.\u003cspan class=\"hljs-property\"\u003enameEditText\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etext\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e()\n            val email = binding.\u003cspan class=\"hljs-property\"\u003eemailEditText\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etext\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e()\n            \u003cspan class=\"hljs-comment\"\u003e// 사용자 입력 전송\u003c/span\u003e\n            controller.\u003cspan class=\"hljs-title function_\"\u003eaddUser\u003c/span\u003e(name, email)\n        }\n    }\n\n    override fun \u003cspan class=\"hljs-title function_\"\u003edisplayUsers\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eusers: List\u0026#x3C;User\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-comment\"\u003e// 사용자 목록을 표시하기 위해 UI 업데이트\u003c/span\u003e\n        userAdapter.\u003cspan class=\"hljs-title function_\"\u003esetUsers\u003c/span\u003e(users)\n    }\n\n    private fun \u003cspan class=\"hljs-title function_\"\u003esetupRecyclerView\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-comment\"\u003e// 코드가 간결하게 유지될 수 있도록 주석 처리됨\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMvcActivity 클래스는 View를 나타내며 UI를 표시하는 역할을 담당합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003eMVI란 무엇인가요?\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_2.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eMVI 패턴은 Model-View-Controller (MVC) 패턴의 변형으로 생각될 수 있습니다. Model-View-Intent (MVI)의 주요 아이디어는 사용자 인터페이스를 구축하기 위한 반응적이고 기능적 접근 방식을 제공하는 것입니다. 이는 Model-View-Controller (MVC) 아키텍처와 유사합니다.\u003c/p\u003e\n\u003ch2\u003eMVI는 어떻게 작동하나요?\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eMVI에서 기본 개념은 동일하지만 보다 반응적이고 기능적인 프로그래밍 스타일을 강조합니다. Model을 직접 변경하거나 View를 업데이트하는 대신, MVI는 사용자 의도를 불변의 데이터 구조 (Intents)로 캡처하고 단방향 데이터 흐름을 통해 이를 처리하는 데 초점을 맞춥니다. 이러한 흐름은 일반적으로 세 가지 주요 구성 요소로 구성됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eModel: 응용 프로그램의 현재 상태를 나타냅니다. Model은 변경할 수 없습니다. Model은 의도를 처리하고 Model의 새 버전을 생성함으로써 업데이트됩니다.\u003c/li\u003e\n\u003cli\u003eView: 현재 Model 상태를 기반으로 UI를 렌더링하는 역할을 합니다. View는 수동적이며 Model이 변경될 때마다 업데이트를 수신합니다.\u003c/li\u003e\n\u003cli\u003eIntent: 사용자 작업 또는 의도를 나타내며, View에서 Model을 업데이트하기 위해 전송됩니다. Intents는 사용자가 수행하려는 작업을 설명하는 일반적으로 간단한 데이터 구조입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eMVI 패턴은 엄격한 단방향 데이터 흐름을 강제합니다. 데이터는 의도에서 모델로, 그리고 모델에서 뷰로 흐릅니다. 이렇게 하면 앱의 동작 및 상태에 대한 추론이 더 쉬워지며 구성 요소 간 부작용이나 종속성이 없기 때문에 유지보수가 쉽습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003eMVC에서 MVI로 변환하기:\u003c/h2\u003e\n\u003cp\u003e위의 코드를 MVI 아키텍처로 어떻게 변경할 수 있는지 알아봅시다. 먼저 두 가지 추가 클래스를 추가해야 합니다. 뷰 내에서 사용자 관련 데이터의 현재 상태를 나타내는 UserViewState 클래스를 소개했습니다. UserIntent sealed 클래스는 사용자 의도를 나타내는 다양한 의도를 정의합니다. 예를 들어 사용자를 추가하는 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edata \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserViewState\u003c/span\u003e(val \u003cspan class=\"hljs-attr\"\u003eusers\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e\u003e)\n\nsealed \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserIntent\u003c/span\u003e {\n    data \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAddUser\u003c/span\u003e(val \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e, val \u003cspan class=\"hljs-attr\"\u003eemail\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e) : \u003cspan class=\"hljs-title class_\"\u003eUserIntent\u003c/span\u003e()\n    \u003cspan class=\"hljs-comment\"\u003e// GetUsers와 같은 다른 사용자 의도도 추가할 수 있습니다.\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUserController와 UserView 인터페이스를 제거할 수 있습니다. 또한 UserModel 클래스를 변경하여 현재 뷰 상태를 유지하고 사용자 의도를 처리하며 사용자 상태를 업데이트할 수 있습니다. UserModel은 Kotlin Coroutines Flow를 사용하여 반응적일 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserModel\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 애플리케이션의 현재 뷰 상태를 유지합니다\u003c/span\u003e\n    private val \u003cspan class=\"hljs-attr\"\u003e_userViewState\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMutableStateFlow\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eUserViewState\u003c/span\u003e\u003e = \u003cspan class=\"hljs-title class_\"\u003eMutableStateFlow\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eUserViewState\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eemptyList\u003c/span\u003e()))\n    \u003cspan class=\"hljs-comment\"\u003e// 다른 뷰들과 뷰 상태를 공유하여 핫 플로우로 제공합니다\u003c/span\u003e\n    val userViewState = _userViewState.\u003cspan class=\"hljs-title function_\"\u003easStateFlow\u003c/span\u003e()\n\n    \u003cspan class=\"hljs-comment\"\u003e// processUserIntents에서 사용할 현재 뷰 상태를 얻습니다\u003c/span\u003e\n    private fun \u003cspan class=\"hljs-title function_\"\u003ecurrentViewState\u003c/span\u003e(): \u003cspan class=\"hljs-title class_\"\u003eUserViewState\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e _userViewState.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// 뷰로부터 사용자 의도를 처리합니다\u003c/span\u003e\n    fun \u003cspan class=\"hljs-title function_\"\u003eprocessUserIntents\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003euserIntent: UserIntent\u003c/span\u003e) {\n        when (userIntent) {\n            is \u003cspan class=\"hljs-title class_\"\u003eUserIntent\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eAddUser\u003c/span\u003e -\u003e {\n                val user = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eUUID\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandomUUID\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e(), userIntent.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e, userIntent.\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e)\n                val newViewState = \u003cspan class=\"hljs-title function_\"\u003ecurrentViewState\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ecopy\u003c/span\u003e(users = \u003cspan class=\"hljs-title function_\"\u003ecurrentViewState\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003eusers\u003c/span\u003e + user)\n                _userViewState.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e = newViewState\n            }\n            \u003cspan class=\"hljs-comment\"\u003e/*\n            * 다른 사용자 의도(예: 사용자 목록 가져오기)도 여기서 처리할 수 있습니다\n            * */\u003c/span\u003e\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003euserViewState는 사용자 뷰 상태를 핫 플로우로 공유합니다. 핫 플로우는 활성 구독자 여부와 관계없이 값을 방출합니다. 핫 플로우는 구독자 여부와 상관없이 계속 업데이트를 방출하는 공유 상태를 유지합니다. 새로운 구독자가 참여하면 최신 값 및 이후의 업데이트를 수신합니다. asStateFlow() 함수는 MutableSharedFlow를 StateFlow로 변환하며, 얻어진 StateFlow는 최신 값 유지 및 구독자 활동 여부에 관계없이 업데이트를 방출하는 핫 플로우로 간주될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그리고 View 부분에 대한 변경사항은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMviActivity\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eAppCompatActivity\u003c/span\u003e() {\n    private lateinit \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003euserAdapter\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUserAdapter\u003c/span\u003e\n    private lateinit \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebinding\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eActivityMviBinding\u003c/span\u003e\n    private val model = \u003cspan class=\"hljs-title class_\"\u003eUserModel\u003c/span\u003e()\n\n    override fun \u003cspan class=\"hljs-title function_\"\u003eonCreate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003esavedInstanceState: Bundle?\u003c/span\u003e) {\n        binding = \u003cspan class=\"hljs-title class_\"\u003eActivityMviBinding\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einflate\u003c/span\u003e(layoutInflater)\n        \u003cspan class=\"hljs-title function_\"\u003esetContentView\u003c/span\u003e(binding.\u003cspan class=\"hljs-property\"\u003eroot\u003c/span\u003e)\n        \u003cspan class=\"hljs-title function_\"\u003esetupRecyclerView\u003c/span\u003e()\n\n        binding.\u003cspan class=\"hljs-property\"\u003eaddUserButton\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esetOnClickListener\u003c/span\u003e {\n            val name = binding.\u003cspan class=\"hljs-property\"\u003enameEditText\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etext\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e()\n            val email = binding.\u003cspan class=\"hljs-property\"\u003eemailEditText\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etext\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e()\n\n            \u003cspan class=\"hljs-comment\"\u003e// 사용자 의도를 생성하고 모델에 전달합니다\u003c/span\u003e\n            val userIntent = \u003cspan class=\"hljs-title class_\"\u003eUserIntent\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eAddUser\u003c/span\u003e(name, email)\n            model.\u003cspan class=\"hljs-title function_\"\u003eprocessUserIntents\u003c/span\u003e(userIntent)\n        }\n\n        \u003cspan class=\"hljs-comment\"\u003e// UI가 뷰 상태 변경을 관찰합니다\u003c/span\u003e\n        model.\u003cspan class=\"hljs-property\"\u003euserViewState\u003c/span\u003e\n            .\u003cspan class=\"hljs-property\"\u003eonEach\u003c/span\u003e { userViewState -\u003e\n                \u003cspan class=\"hljs-title function_\"\u003erenderUserViewState\u003c/span\u003e(userViewState)\n            }\n            .\u003cspan class=\"hljs-title function_\"\u003elaunchIn\u003c/span\u003e(lifecycleScope)\n    }\n\n    private fun \u003cspan class=\"hljs-title function_\"\u003erenderUserViewState\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003euserViewState: UserViewState\u003c/span\u003e) {\n        \u003cspan class=\"hljs-comment\"\u003e// 사용자 목록을 표시하기 위해 UI를 업데이트합니다\u003c/span\u003e\n        userAdapter.\u003cspan class=\"hljs-title function_\"\u003esetUsers\u003c/span\u003e(userViewState.\u003cspan class=\"hljs-property\"\u003eusers\u003c/span\u003e)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eMviActivity에서는 onEach를 사용하여 상태 플로우를 관찰하고 renderUserViewState()를 호출하여 UI를 업데이트합니다.\u003c/p\u003e\n\u003cp\u003e수정된 코드로 다시 다이어그램을 살펴봅시다. 코드를 다이어그램의 각 부분에 매핑하는 방법을 살펴봅시다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_4.png\" alt=\"Diagram\"\u003e\u003c/p\u003e\n\u003cp\u003e위 다이어그램에서 사용자는 OnClick 등의 액션을 트리거할 수 있습니다. 이러한 액션들은 인텐트로 파싱되어 모델에 전달될 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e모델에서 processUserIntentsexecutes는 전달된 Intent에 기반한 로직을 실행하며, 이 경우 UserIntent.AddUser를 받아 새로운 상태를 생성합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eval newViewState = \u003cspan class=\"hljs-title function_\"\u003ecurrentViewState\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ecopy\u003c/span\u003e(users = \u003cspan class=\"hljs-title function_\"\u003ecurrentViewState\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003eusers\u003c/span\u003e + user)\n_userViewState.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e = newViewState\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecopy()는 기존 객체와 동일한 속성을 가진 새 객체를 생성하는 Kotlin 함수입니다. 이 경우 currentViewState().copy()는 현재 뷰 상태와 동일한 속성을 가진 새 UserViewState 객체를 생성합니다.\u003c/p\u003e\n\u003cp\u003eusers = currentViewState().users + user 부분은 새로운 뷰 상태의 users 속성을 업데이트해야 함을 명시합니다. 요약하자면, 이 두 줄의 코드는 현재 뷰 상태의 복사본을 만들어 사용자 목록에 새로운 사용자가 추가된 새로운 뷰 상태 객체를 생성합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e뷰 부분에서 새 상태가 생성될 때마다 MviActivity가 변경 사항을 observe합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003emodel.\u003cspan class=\"hljs-property\"\u003euserViewState\u003c/span\u003e\n  .\u003cspan class=\"hljs-property\"\u003eonEach\u003c/span\u003e { userViewState -\u003e\n      \u003cspan class=\"hljs-title function_\"\u003erenderUserViewState\u003c/span\u003e(userViewState)\n  }\n  .\u003cspan class=\"hljs-title function_\"\u003elaunchIn\u003c/span\u003e(lifecycleScope)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 renderUserViewState(userViewState)를 사용하여 사용자에게 상태를 표시합니다. 반응형 프로그래밍과 Kotlin Coroutine 플로우 덕분에 가능해졌습니다.\u003c/p\u003e\n\u003ch1\u003e다음은 무엇인가요?\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다음 시리즈에서는 MVVM 아키텍처를 MVI와 비교하고 이러한 아키텍처를 더 깊이 파헤쳐 양쪽에서 최상의 결과를 얻을 수 있는 방법에 대해 살펴볼 것입니다. 기대해주세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1"},"buildId":"wfHLuDA3kTGBYfaM5IGXk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>