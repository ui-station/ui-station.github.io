<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>SwiftUI에서 TextField를 전문가처럼 유효성 검사하는 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="SwiftUI에서 TextField를 전문가처럼 유효성 검사하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="SwiftUI에서 TextField를 전문가처럼 유효성 검사하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro" data-gatsby-head="true"/><meta name="twitter:title" content="SwiftUI에서 TextField를 전문가처럼 유효성 검사하는 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-23 13:19" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_buildManifest.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">SwiftUI에서 TextField를 전문가처럼 유효성 검사하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="SwiftUI에서 TextField를 전문가처럼 유효성 검사하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 23, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>안녕하세요! 오늘은 여러분께, 널리 확장된 로직을 사용하지 않고 모든 텍스트 필드를 한꺼번에 유효성을 검사하는 방법을 보여드리려고 합니다. 이번에는 텍스트 필드의 유효성을 검사하는 나쁜 방법과 좋은 방법을 구분하는 것을 목표로 하고 있어요.</p>
<p>먼저, 예제를 아주 간단하게 유지할 거에요.</p>
<p>세 개의 텍스트 필드와 사용자 입력을 저장하는 비밀번호를 위한 한 개의 보안 필드가 있는 화면이 있다고 가정해봅시다. 이 숫자는 간단히 유지하기 위한 것이며, 실제 상황에서는 10개가 될 수도 있습니다.</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> {
   @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> email : <span class="hljs-title class_">String</span> = <span class="hljs-string">""</span>
   @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> password : <span class="hljs-title class_">String</span> = <span class="hljs-string">""</span>
   @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> name : <span class="hljs-title class_">String</span> = <span class="hljs-string">""</span>
   @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> surname : <span class="hljs-title class_">String</span> = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span> {
          <span class="hljs-title class_">VStack</span> {
             <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"이메일"</span>, <span class="hljs-attr">text</span>: $email)
             <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"이름"</span>, <span class="hljs-attr">text</span>: $name)
             <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"성"</span>, <span class="hljs-attr">text</span>: $surname)
             <span class="hljs-title class_">SecureField</span>(<span class="hljs-string">"비밀번호"</span>, <span class="hljs-attr">text</span>: $password)
             <span class="hljs-title class_">Spacer</span>().<span class="hljs-title function_">frame</span>(<span class="hljs-attr">height</span>: <span class="hljs-number">300</span>)
             <span class="hljs-title class_">Button</span> {


             } <span class="hljs-attr">label</span>: {
                <span class="hljs-title class_">Text</span>(<span class="hljs-string">"여기를 눌러보세요!"</span>)
                   .<span class="hljs-title function_">padding</span>(.<span class="hljs-property">all</span>)
                   .<span class="hljs-title function_">background</span>(.<span class="hljs-property">red</span>)
                   .<span class="hljs-title function_">cornerRadius</span>(<span class="hljs-number">16</span>)
             }
          }
          .<span class="hljs-title function_">padding</span>()
       }
}
</code></pre>
<p>이제 나쁜 방식과 좋은 방식을 구분하여 느껴보겠습니다.</p>
<p>#나쁜 방식</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Button</span> {
    <span class="hljs-comment">// 먼저 원하는 방식으로 유효성을 확인합니다.</span>
    <span class="hljs-keyword">if</span> email.<span class="hljs-property">count</span> > <span class="hljs-number">6</span> &#x26;&#x26; password.<span class="hljs-property">count</span> > <span class="hljs-number">12</span>
            &#x26;&#x26; !name.<span class="hljs-property">isEmpty</span> &#x26;&#x26; !surname.<span class="hljs-property">isEmpty</span> {
        <span class="hljs-comment">// 네트워킹 호출 수행!</span>
        <span class="hljs-comment">// 이것은 영원히 계속됩니다.</span>
        <span class="hljs-comment">// 읽기가 어렵고 확장 가능하지 않으며 재사용 가능하지 않습니다.</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 얼럿 팝업 등을 표시합니다.</span>
    }

} <span class="hljs-attr">label</span>: {
    <span class="hljs-title class_">Text</span>(<span class="hljs-string">"여기를 탭하여 시도해보세요!"</span>)
        .<span class="hljs-title function_">padding</span>(.<span class="hljs-property">all</span>)
        .<span class="hljs-title function_">background</span>(.<span class="hljs-property">red</span>)
        .<span class="hljs-title function_">cornerRadius</span>(<span class="hljs-number">16</span>)
}
</code></pre>
<h1>좋은 방법</h1>
<p>이제 진짜 작업이 시작되었지만, 먼저 이 솔루션을 사용하기 위해 SwiftUI의 일부 주요 기능을 알아야 합니다.</p>
<p><strong>PreferenceKey</strong></p>
<p>PreferenceKey 유형은 자식 뷰에서 부모 뷰로 뷰 트리를 업데이트하는 데이터 흐름을 처리하는 솔루션인데, 어떤 종류의 위임이나 생성자 핸들러를 사용하지 않고도 작업할 수 있습니다. 제가 본 바로는 널리 사용되지 않지만, 정말 복잡하지는 않습니다. 어느 정도로 보면, @EnvironmentObject의 역이라고 할 수 있습니다.</p>
<p>PreferenceKey는 이미 NavigationView의 타이틀이나 TabViews 선택 및 자식의 id 등에 사용되고 있습니다.</p>
<p>우리가 어떻게 사용자 정의 preference key를 정의할 수 있는지 살펴봅시다.</p>
<pre><code class="hljs language-js">구조체 <span class="hljs-title class_">ValidationPreferenceKey</span> : <span class="hljs-title class_">PreferenceKey</span> {
   <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">defaultValue</span>: [<span class="hljs-title class_">Bool</span>] = []

   <span class="hljs-keyword">static</span> func <span class="hljs-title function_">reduce</span>(<span class="hljs-params">value: inout [Bool], nextValue: () -> [Bool]</span>) {
      value += <span class="hljs-title function_">nextValue</span>()
   }
}
</code></pre>
<p>이것은 사용자 지정 PreferenceKey를 정의하는 구문입니다. 이 특정 프로토콜을 준수하기 위해 두 가지를 구현해야 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">defaultValue</span>: [<span class="hljs-title class_">Bool</span>] = []
</code></pre>
<p>이 기본 값은 Equatable을 준수하는 한 어떤 것이든 될 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">static</span> func <span class="hljs-title function_">reduce</span>(<span class="hljs-params">value: inout [Bool], nextValue: () -> [Bool]</span>) {
      value += <span class="hljs-title function_">nextValue</span>()
   }
</code></pre>
<p>우리는 이 줄이 키가 등록된 키의 여러 반복에서 무엇을 해야 하는지를 정의하는 리덕션 함수를 구현해야 합니다.</p>
<p>예를 들어, TabView가 있고 그 안에 여러 개의 하위 뷰가 있고 모두 .id() 수정자를 가지고 있다고 하면, 이 reduce 함수는 모든 id 수정자 값에 사용됩니다.</p>
<p>TextField에서 이를 사용하려면 두 단계가 필요합니다</p>
<p>1- 뷰 수정자</p>
<p>2- 익스텐션</p>
<p>이제 이를 위해 ViewModifier를 어떻게 구현하는지 보여드릴게요</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">ValidationModifier</span> : <span class="hljs-title class_">ViewModifier</span>  {
   <span class="hljs-keyword">let</span> validation : () -> <span class="hljs-title class_">Bool</span>
   func <span class="hljs-title function_">body</span>(<span class="hljs-attr">content</span>: <span class="hljs-title class_">Content</span>) -> some <span class="hljs-title class_">View</span> {
         content
            .<span class="hljs-title function_">preference</span>(
               <span class="hljs-attr">key</span>: <span class="hljs-title class_">ValidationPreferenceKey</span>.<span class="hljs-property">self</span>,
               <span class="hljs-attr">value</span>: [<span class="hljs-title function_">validation</span>()]
            )
      }
   }
</code></pre>
<p>이 수정자는 그 특정 뷰에 해당하는 키를 등록합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> <span class="hljs-attr">validation</span>: () -> <span class="hljs-title class_">Bool</span>
</code></pre>
<p>이 변수는 우리가 유효성 검사에 사용할 로직을 보유할 것입니다.</p>
<p>그리고 이 확장은 이를 일부 특정 유형의 뷰에 대해서만 적용합니다. TextFields 및 SecureFields와 같은 뷰입니다.</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">TextField</span> {
   <span class="hljs-keyword">func</span> <span class="hljs-title function_">validate</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">flag</span>: <span class="hljs-keyword">@escaping</span> () -> <span class="hljs-type">Bool</span>) -> <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {
      <span class="hljs-keyword">self</span>
         .modifier(<span class="hljs-type">ValidationModifier</span>(validation: flag))
   }
}

<span class="hljs-keyword">extension</span> <span class="hljs-title class_">SecureField</span> {
   <span class="hljs-keyword">func</span> <span class="hljs-title function_">validate</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">flag</span>: <span class="hljs-keyword">@escaping</span> () -> <span class="hljs-type">Bool</span>) -> <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {
      <span class="hljs-keyword">self</span>
         .modifier(<span class="hljs-type">ValidationModifier</span>(validation: flag))
   }
}
</code></pre>
<p>여기서 중요한 두 가지 아쉬움이 있습니다. 첫째로, 우리는 TextFields 텍스트를 노출할 수 없습니다. 이것은 이니셜라이저에서만 사용 가능하며 Apple에 의해 노출되지 않습니다.</p>
<p>둘째로, TextField와 SecureField는 View가 아닌 동일한 형식에서 상속되지 않기 때문에 이것을 단일 확장으로 줄일 수 없습니다. 해결 방법이 있다면 알려주세요!</p>
<p>이 modifier를 다른 뷰에서 사용할 수 없도록 유지하려면 동일한 파일에서 modifier와 확장을 정의하고 modifier를 private으로 만들 수 있습니다.</p>
<p>마지막 부분 빼고는 설정이 완료되었어요.</p>
<p>마지막으로, 이 키의 업무를 처리할 뷰를 정의해야 해요.</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">TextFormView</span>&#x3C;<span class="hljs-title class_">Content</span> : <span class="hljs-title class_">View</span>> : <span class="hljs-title class_">View</span> {
   @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> validationSeeds : [<span class="hljs-title class_">Bool</span>] = []
   @<span class="hljs-title class_">ViewBuilder</span> <span class="hljs-keyword">var</span> content : (( @escaping () -> <span class="hljs-title class_">Bool</span>)) -> <span class="hljs-title class_">Content</span>
   <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span> {
         <span class="hljs-title function_">content</span>(validate)
         .<span class="hljs-title function_">onPreferenceChange</span>(<span class="hljs-params">ValidationPreferenceKey.self</span>) { value <span class="hljs-keyword">in</span>
            validationSeeds = value
         }
   }

   private func <span class="hljs-title function_">validate</span>() -> <span class="hljs-title class_">Bool</span> {
      <span class="hljs-keyword">for</span> seed <span class="hljs-keyword">in</span> validationSeeds {
         <span class="hljs-keyword">if</span> !seed { <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>}
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
   }
}
</code></pre>
<p>이 컨테이너 뷰는 이 키 타입에서 로직을 실행하고, Vstack 또는 TabView와 같은 뷰를 내부에 가져옵니다. .onPreferenChange 수정자를 본 적 있나요?</p>
<p>이 수정자는 이 키에서 자식 뷰 업데이트를 잡습니다.</p>
<p>그래서</p>
<pre><code class="hljs language-js">.<span class="hljs-title function_">preference</span>(
               <span class="hljs-attr">key</span>: <span class="hljs-title class_">ValidationPreferenceKey</span>.<span class="hljs-property">self</span>,
               <span class="hljs-attr">value</span>: [<span class="hljs-title function_">validation</span>()]
            )
</code></pre>
<p>이렇게 업데이트됩니다</p>
<pre><code class="hljs language-js">.<span class="hljs-title function_">onPreferenceChange</span>(<span class="hljs-params">ValidationPreferenceKey.self</span>) { value <span class="hljs-keyword">in</span>
  validationSeeds = value
}
</code></pre>
<p>각 자식 뷰의 키 값을 캐치해요. [Bool]가 아니라 Bool로 반환했던 것 기억하시죠? 이건 단지 validationSeeds 변수에 할당하기 위한 것이에요. 이 validationSeeds 변수는 .validate() 확장 ValidationPreferenceKey로 수정된 각 자식 뷰를 보유하고 있어요.</p>
<p>이제 모든 필드의 Key 값이 TextFormView에 있으니 이 데이터를 처리하고 무언가를 구축할 수 있어요.</p>
<pre><code class="hljs language-js">private func <span class="hljs-title function_">validate</span>() -> <span class="hljs-title class_">Bool</span> {
  <span class="hljs-keyword">for</span> seed <span class="hljs-keyword">in</span> validationSeeds {
    <span class="hljs-keyword">if</span> !seed { <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}
</code></pre>
<p>이 함수는 그냥 제가 생각해 낸 것일 뿐이에요. 필수적이지는 않지만 저는 좋아해요.</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">ViewBuilder</span> <span class="hljs-keyword">var</span> content : ((@escaping () -> <span class="hljs-title class_">Bool</span>)) -> <span class="hljs-title class_">Content</span>
                        <span class="hljs-comment">// (validate) -> Content 이게 무슨 뜻인지에요.</span>
</code></pre>
<p>우리는 그냥 이 TextFormView 바깥으로 이 validate 함수를 노출시키는 것 뿐이에요.</p>
<p>이제 이것을 우리 뷰에서 사용할 수 있고, 다음과 같이 될 거에요.</p>
<p>간단한 유효성 검사를 만들었지만, 실제 상황에서는 정규식과 다른 로직을 사용하여 유효성을 검사해야 합니다. 어쩌다 그렇게 했어요.</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> {
   <span class="hljs-meta">@State</span> <span class="hljs-keyword">var</span> email : <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">""</span>
   <span class="hljs-meta">@State</span> <span class="hljs-keyword">var</span> password : <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">""</span>
   <span class="hljs-meta">@State</span> <span class="hljs-keyword">var</span> name : <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">""</span>
   <span class="hljs-meta">@State</span> <span class="hljs-keyword">var</span> surname : <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">""</span>
   <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {

       <span class="hljs-type">TextFormView</span>  { validate  <span class="hljs-keyword">in</span> <span class="hljs-comment">// -> 이 부분이 바로 validate 함수에요</span>
          <span class="hljs-type">VStack</span> {
             <span class="hljs-type">TextField</span>(<span class="hljs-string">"Email"</span>, text: <span class="hljs-variable">$email</span>)
                .validate {
                   email.count <span class="hljs-operator">></span> <span class="hljs-number">6</span>
                }
             <span class="hljs-type">TextField</span>(<span class="hljs-string">"Name"</span>, text: <span class="hljs-variable">$name</span>)
                .validate {
                   <span class="hljs-operator">!</span>name.isEmpty
                }
             <span class="hljs-type">TextField</span>(<span class="hljs-string">"Surname"</span>, text: <span class="hljs-variable">$surname</span>)
                .validate {
                   <span class="hljs-operator">!</span>surname.isEmpty
                }
             <span class="hljs-type">SecureField</span>(<span class="hljs-string">"Password"</span>, text: <span class="hljs-variable">$password</span>)
                .validate {
                   password.count <span class="hljs-operator">></span> <span class="hljs-number">10</span>
                }
             <span class="hljs-type">Spacer</span>().frame(height: <span class="hljs-number">300</span>)
             <span class="hljs-type">Button</span> {
                <span class="hljs-keyword">if</span> <span class="hljs-operator">!</span>validate() {
                   <span class="hljs-keyword">return</span>
                }
                <span class="hljs-comment">// 네트워크 호출을 해주세요</span>
             } label: {
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Tap here to try!"</span>)
                   .padding(.all)
                   .background(.red)
                   .cornerRadius(<span class="hljs-number">16</span>)
             }
          }
       }
          .padding()
    }

}
</code></pre>
<p>미리 말씀드린 대로 이미지 삽입과 함께, 어떻게 동작하는지 보여주기 위해 validate()을 출력했어요. 모든 필드가 함께 유효성을 검사하는 모습이에요.</p>
<p>여기까지 읽어 주셔서 감사합니다.</p>
<p>이것은 시작에 불과하다는 것을 잊지 마세요. 이것을 사용하여 오류 메시지를 반환하거나 어떤 필드가 유효하지 않은지 선택할 수 있습니다. 나중에 이를 사용자 정의할 수도 있을 것 같네요.</p>
<p>어쨌든 나중에 뵙겠습니다! 즐거운 시간 보내세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"SwiftUI에서 TextField를 전문가처럼 유효성 검사하는 방법","description":"","date":"2024-05-23 13:19","slug":"2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro","content":"\n\u003cimg src=\"/assets/img/2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro_0.png\" /\u003e\n\n안녕하세요! 오늘은 여러분께, 널리 확장된 로직을 사용하지 않고 모든 텍스트 필드를 한꺼번에 유효성을 검사하는 방법을 보여드리려고 합니다. 이번에는 텍스트 필드의 유효성을 검사하는 나쁜 방법과 좋은 방법을 구분하는 것을 목표로 하고 있어요.\n\n먼저, 예제를 아주 간단하게 유지할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세 개의 텍스트 필드와 사용자 입력을 저장하는 비밀번호를 위한 한 개의 보안 필드가 있는 화면이 있다고 가정해봅시다. 이 숫자는 간단히 유지하기 위한 것이며, 실제 상황에서는 10개가 될 수도 있습니다.\n\n```js\nstruct ContentView: View {\n   @State var email : String = \"\"\n   @State var password : String = \"\"\n   @State var name : String = \"\"\n   @State var surname : String = \"\"\n    var body: some View {\n          VStack {\n             TextField(\"이메일\", text: $email)\n             TextField(\"이름\", text: $name)\n             TextField(\"성\", text: $surname)\n             SecureField(\"비밀번호\", text: $password)\n             Spacer().frame(height: 300)\n             Button {\n\n\n             } label: {\n                Text(\"여기를 눌러보세요!\")\n                   .padding(.all)\n                   .background(.red)\n                   .cornerRadius(16)\n             }\n          }\n          .padding()\n       }\n}\n```\n\n이제 나쁜 방식과 좋은 방식을 구분하여 느껴보겠습니다.\n\n#나쁜 방식\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nButton {\n    // 먼저 원하는 방식으로 유효성을 확인합니다.\n    if email.count \u003e 6 \u0026\u0026 password.count \u003e 12\n            \u0026\u0026 !name.isEmpty \u0026\u0026 !surname.isEmpty {\n        // 네트워킹 호출 수행!\n        // 이것은 영원히 계속됩니다.\n        // 읽기가 어렵고 확장 가능하지 않으며 재사용 가능하지 않습니다.\n    } else {\n        // 얼럿 팝업 등을 표시합니다.\n    }\n\n} label: {\n    Text(\"여기를 탭하여 시도해보세요!\")\n        .padding(.all)\n        .background(.red)\n        .cornerRadius(16)\n}\n```\n\n# 좋은 방법\n\n이제 진짜 작업이 시작되었지만, 먼저 이 솔루션을 사용하기 위해 SwiftUI의 일부 주요 기능을 알아야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**PreferenceKey**\n\nPreferenceKey 유형은 자식 뷰에서 부모 뷰로 뷰 트리를 업데이트하는 데이터 흐름을 처리하는 솔루션인데, 어떤 종류의 위임이나 생성자 핸들러를 사용하지 않고도 작업할 수 있습니다. 제가 본 바로는 널리 사용되지 않지만, 정말 복잡하지는 않습니다. 어느 정도로 보면, @EnvironmentObject의 역이라고 할 수 있습니다.\n\nPreferenceKey는 이미 NavigationView의 타이틀이나 TabViews 선택 및 자식의 id 등에 사용되고 있습니다.\n\n우리가 어떻게 사용자 정의 preference key를 정의할 수 있는지 살펴봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n구조체 ValidationPreferenceKey : PreferenceKey {\n   static var defaultValue: [Bool] = []\n\n   static func reduce(value: inout [Bool], nextValue: () -\u003e [Bool]) {\n      value += nextValue()\n   }\n}\n```\n\n이것은 사용자 지정 PreferenceKey를 정의하는 구문입니다. 이 특정 프로토콜을 준수하기 위해 두 가지를 구현해야 합니다.\n\n```js\nstatic var defaultValue: [Bool] = []\n```\n\n이 기본 값은 Equatable을 준수하는 한 어떤 것이든 될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nstatic func reduce(value: inout [Bool], nextValue: () -\u003e [Bool]) {\n      value += nextValue()\n   }\n```\n\n우리는 이 줄이 키가 등록된 키의 여러 반복에서 무엇을 해야 하는지를 정의하는 리덕션 함수를 구현해야 합니다.\n\n예를 들어, TabView가 있고 그 안에 여러 개의 하위 뷰가 있고 모두 .id() 수정자를 가지고 있다고 하면, 이 reduce 함수는 모든 id 수정자 값에 사용됩니다.\n\nTextField에서 이를 사용하려면 두 단계가 필요합니다\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1- 뷰 수정자\n\n2- 익스텐션\n\n이제 이를 위해 ViewModifier를 어떻게 구현하는지 보여드릴게요\n\n```js\nstruct ValidationModifier : ViewModifier  {\n   let validation : () -\u003e Bool\n   func body(content: Content) -\u003e some View {\n         content\n            .preference(\n               key: ValidationPreferenceKey.self,\n               value: [validation()]\n            )\n      }\n   }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 수정자는 그 특정 뷰에 해당하는 키를 등록합니다.\n\n```js\nlet validation: () -\u003e Bool\n```\n\n이 변수는 우리가 유효성 검사에 사용할 로직을 보유할 것입니다.\n\n그리고 이 확장은 이를 일부 특정 유형의 뷰에 대해서만 적용합니다. TextFields 및 SecureFields와 같은 뷰입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\nextension TextField {\n   func validate(_ flag: @escaping () -\u003e Bool) -\u003e some View {\n      self\n         .modifier(ValidationModifier(validation: flag))\n   }\n}\n\nextension SecureField {\n   func validate(_ flag: @escaping () -\u003e Bool) -\u003e some View {\n      self\n         .modifier(ValidationModifier(validation: flag))\n   }\n}\n```\n\n여기서 중요한 두 가지 아쉬움이 있습니다. 첫째로, 우리는 TextFields 텍스트를 노출할 수 없습니다. 이것은 이니셜라이저에서만 사용 가능하며 Apple에 의해 노출되지 않습니다.\n\n둘째로, TextField와 SecureField는 View가 아닌 동일한 형식에서 상속되지 않기 때문에 이것을 단일 확장으로 줄일 수 없습니다. 해결 방법이 있다면 알려주세요!\n\n이 modifier를 다른 뷰에서 사용할 수 없도록 유지하려면 동일한 파일에서 modifier와 확장을 정의하고 modifier를 private으로 만들 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막 부분 빼고는 설정이 완료되었어요.\n\n마지막으로, 이 키의 업무를 처리할 뷰를 정의해야 해요.\n\n```js\nstruct TextFormView\u003cContent : View\u003e : View {\n   @State var validationSeeds : [Bool] = []\n   @ViewBuilder var content : (( @escaping () -\u003e Bool)) -\u003e Content\n   var body: some View {\n         content(validate)\n         .onPreferenceChange(ValidationPreferenceKey.self) { value in\n            validationSeeds = value\n         }\n   }\n\n   private func validate() -\u003e Bool {\n      for seed in validationSeeds {\n         if !seed { return false}\n      }\n      return true\n   }\n}\n```\n\n이 컨테이너 뷰는 이 키 타입에서 로직을 실행하고, Vstack 또는 TabView와 같은 뷰를 내부에 가져옵니다. .onPreferenChange 수정자를 본 적 있나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 수정자는 이 키에서 자식 뷰 업데이트를 잡습니다.\n\n그래서\n\n```js\n.preference(\n               key: ValidationPreferenceKey.self,\n               value: [validation()]\n            )\n```\n\n이렇게 업데이트됩니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n.onPreferenceChange(ValidationPreferenceKey.self) { value in\n  validationSeeds = value\n}\n```\n\n각 자식 뷰의 키 값을 캐치해요. [Bool]가 아니라 Bool로 반환했던 것 기억하시죠? 이건 단지 validationSeeds 변수에 할당하기 위한 것이에요. 이 validationSeeds 변수는 .validate() 확장 ValidationPreferenceKey로 수정된 각 자식 뷰를 보유하고 있어요.\n\n이제 모든 필드의 Key 값이 TextFormView에 있으니 이 데이터를 처리하고 무언가를 구축할 수 있어요.\n\n```js\nprivate func validate() -\u003e Bool {\n  for seed in validationSeeds {\n    if !seed { return false }\n  }\n  return true\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 함수는 그냥 제가 생각해 낸 것일 뿐이에요. 필수적이지는 않지만 저는 좋아해요.\n\n```js\n@ViewBuilder var content : ((@escaping () -\u003e Bool)) -\u003e Content\n                        // (validate) -\u003e Content 이게 무슨 뜻인지에요.\n```\n\n우리는 그냥 이 TextFormView 바깥으로 이 validate 함수를 노출시키는 것 뿐이에요.\n\n이제 이것을 우리 뷰에서 사용할 수 있고, 다음과 같이 될 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 유효성 검사를 만들었지만, 실제 상황에서는 정규식과 다른 로직을 사용하여 유효성을 검사해야 합니다. 어쩌다 그렇게 했어요.\n\n```swift\nstruct ContentView: View {\n   @State var email : String = \"\"\n   @State var password : String = \"\"\n   @State var name : String = \"\"\n   @State var surname : String = \"\"\n   var body: some View {\n\n       TextFormView  { validate  in // -\u003e 이 부분이 바로 validate 함수에요\n          VStack {\n             TextField(\"Email\", text: $email)\n                .validate {\n                   email.count \u003e 6\n                }\n             TextField(\"Name\", text: $name)\n                .validate {\n                   !name.isEmpty\n                }\n             TextField(\"Surname\", text: $surname)\n                .validate {\n                   !surname.isEmpty\n                }\n             SecureField(\"Password\", text: $password)\n                .validate {\n                   password.count \u003e 10\n                }\n             Spacer().frame(height: 300)\n             Button {\n                if !validate() {\n                   return\n                }\n                // 네트워크 호출을 해주세요\n             } label: {\n                Text(\"Tap here to try!\")\n                   .padding(.all)\n                   .background(.red)\n                   .cornerRadius(16)\n             }\n          }\n       }\n          .padding()\n    }\n\n}\n```\n\n미리 말씀드린 대로 이미지 삽입과 함께, 어떻게 동작하는지 보여주기 위해 validate()을 출력했어요. 모든 필드가 함께 유효성을 검사하는 모습이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기까지 읽어 주셔서 감사합니다.\n\n이것은 시작에 불과하다는 것을 잊지 마세요. 이것을 사용하여 오류 메시지를 반환하거나 어떤 필드가 유효하지 않은지 선택할 수 있습니다. 나중에 이를 사용자 정의할 수도 있을 것 같네요.\n\n어쨌든 나중에 뵙겠습니다! 즐거운 시간 보내세요!\n","ogImage":{"url":"/assets/img/2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro_0.png"},"coverImage":"/assets/img/2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e안녕하세요! 오늘은 여러분께, 널리 확장된 로직을 사용하지 않고 모든 텍스트 필드를 한꺼번에 유효성을 검사하는 방법을 보여드리려고 합니다. 이번에는 텍스트 필드의 유효성을 검사하는 나쁜 방법과 좋은 방법을 구분하는 것을 목표로 하고 있어요.\u003c/p\u003e\n\u003cp\u003e먼저, 예제를 아주 간단하게 유지할 거에요.\u003c/p\u003e\n\u003cp\u003e세 개의 텍스트 필드와 사용자 입력을 저장하는 비밀번호를 위한 한 개의 보안 필드가 있는 화면이 있다고 가정해봅시다. 이 숫자는 간단히 유지하기 위한 것이며, 실제 상황에서는 10개가 될 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eContentView\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n   @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e email : \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n   @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e password : \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n   @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e name : \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n   @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e surname : \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n          \u003cspan class=\"hljs-title class_\"\u003eVStack\u003c/span\u003e {\n             \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이메일\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $email)\n             \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이름\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $name)\n             \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"성\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $surname)\n             \u003cspan class=\"hljs-title class_\"\u003eSecureField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"비밀번호\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $password)\n             \u003cspan class=\"hljs-title class_\"\u003eSpacer\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003eframe\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e)\n             \u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e {\n\n\n             } \u003cspan class=\"hljs-attr\"\u003elabel\u003c/span\u003e: {\n                \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"여기를 눌러보세요!\"\u003c/span\u003e)\n                   .\u003cspan class=\"hljs-title function_\"\u003epadding\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003eall\u003c/span\u003e)\n                   .\u003cspan class=\"hljs-title function_\"\u003ebackground\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003ered\u003c/span\u003e)\n                   .\u003cspan class=\"hljs-title function_\"\u003ecornerRadius\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e)\n             }\n          }\n          .\u003cspan class=\"hljs-title function_\"\u003epadding\u003c/span\u003e()\n       }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 나쁜 방식과 좋은 방식을 구분하여 느껴보겠습니다.\u003c/p\u003e\n\u003cp\u003e#나쁜 방식\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 먼저 원하는 방식으로 유효성을 확인합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e email.\u003cspan class=\"hljs-property\"\u003ecount\u003c/span\u003e \u003e \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e \u0026#x26;\u0026#x26; password.\u003cspan class=\"hljs-property\"\u003ecount\u003c/span\u003e \u003e \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e\n            \u0026#x26;\u0026#x26; !name.\u003cspan class=\"hljs-property\"\u003eisEmpty\u003c/span\u003e \u0026#x26;\u0026#x26; !surname.\u003cspan class=\"hljs-property\"\u003eisEmpty\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// 네트워킹 호출 수행!\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// 이것은 영원히 계속됩니다.\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// 읽기가 어렵고 확장 가능하지 않으며 재사용 가능하지 않습니다.\u003c/span\u003e\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// 얼럿 팝업 등을 표시합니다.\u003c/span\u003e\n    }\n\n} \u003cspan class=\"hljs-attr\"\u003elabel\u003c/span\u003e: {\n    \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"여기를 탭하여 시도해보세요!\"\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003epadding\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003eall\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003ebackground\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003ered\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003ecornerRadius\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e좋은 방법\u003c/h1\u003e\n\u003cp\u003e이제 진짜 작업이 시작되었지만, 먼저 이 솔루션을 사용하기 위해 SwiftUI의 일부 주요 기능을 알아야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePreferenceKey\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003ePreferenceKey 유형은 자식 뷰에서 부모 뷰로 뷰 트리를 업데이트하는 데이터 흐름을 처리하는 솔루션인데, 어떤 종류의 위임이나 생성자 핸들러를 사용하지 않고도 작업할 수 있습니다. 제가 본 바로는 널리 사용되지 않지만, 정말 복잡하지는 않습니다. 어느 정도로 보면, @EnvironmentObject의 역이라고 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003ePreferenceKey는 이미 NavigationView의 타이틀이나 TabViews 선택 및 자식의 id 등에 사용되고 있습니다.\u003c/p\u003e\n\u003cp\u003e우리가 어떻게 사용자 정의 preference key를 정의할 수 있는지 살펴봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e구조체 \u003cspan class=\"hljs-title class_\"\u003eValidationPreferenceKey\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003ePreferenceKey\u003c/span\u003e {\n   \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edefaultValue\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eBool\u003c/span\u003e] = []\n\n   \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e func \u003cspan class=\"hljs-title function_\"\u003ereduce\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003evalue: inout [Bool], nextValue: () -\u003e [Bool]\u003c/span\u003e) {\n      value += \u003cspan class=\"hljs-title function_\"\u003enextValue\u003c/span\u003e()\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 사용자 지정 PreferenceKey를 정의하는 구문입니다. 이 특정 프로토콜을 준수하기 위해 두 가지를 구현해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edefaultValue\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eBool\u003c/span\u003e] = []\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 기본 값은 Equatable을 준수하는 한 어떤 것이든 될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e func \u003cspan class=\"hljs-title function_\"\u003ereduce\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003evalue: inout [Bool], nextValue: () -\u003e [Bool]\u003c/span\u003e) {\n      value += \u003cspan class=\"hljs-title function_\"\u003enextValue\u003c/span\u003e()\n   }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 이 줄이 키가 등록된 키의 여러 반복에서 무엇을 해야 하는지를 정의하는 리덕션 함수를 구현해야 합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, TabView가 있고 그 안에 여러 개의 하위 뷰가 있고 모두 .id() 수정자를 가지고 있다고 하면, 이 reduce 함수는 모든 id 수정자 값에 사용됩니다.\u003c/p\u003e\n\u003cp\u003eTextField에서 이를 사용하려면 두 단계가 필요합니다\u003c/p\u003e\n\u003cp\u003e1- 뷰 수정자\u003c/p\u003e\n\u003cp\u003e2- 익스텐션\u003c/p\u003e\n\u003cp\u003e이제 이를 위해 ViewModifier를 어떻게 구현하는지 보여드릴게요\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eValidationModifier\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eViewModifier\u003c/span\u003e  {\n   \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e validation : () -\u003e \u003cspan class=\"hljs-title class_\"\u003eBool\u003c/span\u003e\n   func \u003cspan class=\"hljs-title function_\"\u003ebody\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eContent\u003c/span\u003e) -\u003e some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n         content\n            .\u003cspan class=\"hljs-title function_\"\u003epreference\u003c/span\u003e(\n               \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eValidationPreferenceKey\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eself\u003c/span\u003e,\n               \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: [\u003cspan class=\"hljs-title function_\"\u003evalidation\u003c/span\u003e()]\n            )\n      }\n   }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 수정자는 그 특정 뷰에 해당하는 키를 등록합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalidation\u003c/span\u003e: () -\u003e \u003cspan class=\"hljs-title class_\"\u003eBool\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 변수는 우리가 유효성 검사에 사용할 로직을 보유할 것입니다.\u003c/p\u003e\n\u003cp\u003e그리고 이 확장은 이를 일부 특정 유형의 뷰에 대해서만 적용합니다. TextFields 및 SecureFields와 같은 뷰입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003eextension\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e {\n   \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003evalidate\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003eflag\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003e@escaping\u003c/span\u003e () -\u003e \u003cspan class=\"hljs-type\"\u003eBool\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-keyword\"\u003esome\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eView\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e\n         .modifier(\u003cspan class=\"hljs-type\"\u003eValidationModifier\u003c/span\u003e(validation: flag))\n   }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eextension\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSecureField\u003c/span\u003e {\n   \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003evalidate\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003eflag\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003e@escaping\u003c/span\u003e () -\u003e \u003cspan class=\"hljs-type\"\u003eBool\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-keyword\"\u003esome\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eView\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e\n         .modifier(\u003cspan class=\"hljs-type\"\u003eValidationModifier\u003c/span\u003e(validation: flag))\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 중요한 두 가지 아쉬움이 있습니다. 첫째로, 우리는 TextFields 텍스트를 노출할 수 없습니다. 이것은 이니셜라이저에서만 사용 가능하며 Apple에 의해 노출되지 않습니다.\u003c/p\u003e\n\u003cp\u003e둘째로, TextField와 SecureField는 View가 아닌 동일한 형식에서 상속되지 않기 때문에 이것을 단일 확장으로 줄일 수 없습니다. 해결 방법이 있다면 알려주세요!\u003c/p\u003e\n\u003cp\u003e이 modifier를 다른 뷰에서 사용할 수 없도록 유지하려면 동일한 파일에서 modifier와 확장을 정의하고 modifier를 private으로 만들 수 있습니다.\u003c/p\u003e\n\u003cp\u003e마지막 부분 빼고는 설정이 완료되었어요.\u003c/p\u003e\n\u003cp\u003e마지막으로, 이 키의 업무를 처리할 뷰를 정의해야 해요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eTextFormView\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eContent\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e\u003e : \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n   @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e validationSeeds : [\u003cspan class=\"hljs-title class_\"\u003eBool\u003c/span\u003e] = []\n   @\u003cspan class=\"hljs-title class_\"\u003eViewBuilder\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e content : (( @escaping () -\u003e \u003cspan class=\"hljs-title class_\"\u003eBool\u003c/span\u003e)) -\u003e \u003cspan class=\"hljs-title class_\"\u003eContent\u003c/span\u003e\n   \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n         \u003cspan class=\"hljs-title function_\"\u003econtent\u003c/span\u003e(validate)\n         .\u003cspan class=\"hljs-title function_\"\u003eonPreferenceChange\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eValidationPreferenceKey.self\u003c/span\u003e) { value \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n            validationSeeds = value\n         }\n   }\n\n   private func \u003cspan class=\"hljs-title function_\"\u003evalidate\u003c/span\u003e() -\u003e \u003cspan class=\"hljs-title class_\"\u003eBool\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e seed \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e validationSeeds {\n         \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e !seed { \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e}\n      }\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 컨테이너 뷰는 이 키 타입에서 로직을 실행하고, Vstack 또는 TabView와 같은 뷰를 내부에 가져옵니다. .onPreferenChange 수정자를 본 적 있나요?\u003c/p\u003e\n\u003cp\u003e이 수정자는 이 키에서 자식 뷰 업데이트를 잡습니다.\u003c/p\u003e\n\u003cp\u003e그래서\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e.\u003cspan class=\"hljs-title function_\"\u003epreference\u003c/span\u003e(\n               \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eValidationPreferenceKey\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eself\u003c/span\u003e,\n               \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: [\u003cspan class=\"hljs-title function_\"\u003evalidation\u003c/span\u003e()]\n            )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 업데이트됩니다\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e.\u003cspan class=\"hljs-title function_\"\u003eonPreferenceChange\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eValidationPreferenceKey.self\u003c/span\u003e) { value \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n  validationSeeds = value\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e각 자식 뷰의 키 값을 캐치해요. [Bool]가 아니라 Bool로 반환했던 것 기억하시죠? 이건 단지 validationSeeds 변수에 할당하기 위한 것이에요. 이 validationSeeds 변수는 .validate() 확장 ValidationPreferenceKey로 수정된 각 자식 뷰를 보유하고 있어요.\u003c/p\u003e\n\u003cp\u003e이제 모든 필드의 Key 값이 TextFormView에 있으니 이 데이터를 처리하고 무언가를 구축할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eprivate func \u003cspan class=\"hljs-title function_\"\u003evalidate\u003c/span\u003e() -\u003e \u003cspan class=\"hljs-title class_\"\u003eBool\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e seed \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e validationSeeds {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e !seed { \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 함수는 그냥 제가 생각해 낸 것일 뿐이에요. 필수적이지는 않지만 저는 좋아해요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eViewBuilder\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e content : ((@escaping () -\u003e \u003cspan class=\"hljs-title class_\"\u003eBool\u003c/span\u003e)) -\u003e \u003cspan class=\"hljs-title class_\"\u003eContent\u003c/span\u003e\n                        \u003cspan class=\"hljs-comment\"\u003e// (validate) -\u003e Content 이게 무슨 뜻인지에요.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 그냥 이 TextFormView 바깥으로 이 validate 함수를 노출시키는 것 뿐이에요.\u003c/p\u003e\n\u003cp\u003e이제 이것을 우리 뷰에서 사용할 수 있고, 다음과 같이 될 거에요.\u003c/p\u003e\n\u003cp\u003e간단한 유효성 검사를 만들었지만, 실제 상황에서는 정규식과 다른 로직을 사용하여 유효성을 검사해야 합니다. 어쩌다 그렇게 했어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eContentView\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n   \u003cspan class=\"hljs-meta\"\u003e@State\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e email : \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n   \u003cspan class=\"hljs-meta\"\u003e@State\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e password : \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n   \u003cspan class=\"hljs-meta\"\u003e@State\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e name : \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n   \u003cspan class=\"hljs-meta\"\u003e@State\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e surname : \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n   \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e body: \u003cspan class=\"hljs-keyword\"\u003esome\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eView\u003c/span\u003e {\n\n       \u003cspan class=\"hljs-type\"\u003eTextFormView\u003c/span\u003e  { validate  \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// -\u003e 이 부분이 바로 validate 함수에요\u003c/span\u003e\n          \u003cspan class=\"hljs-type\"\u003eVStack\u003c/span\u003e {\n             \u003cspan class=\"hljs-type\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Email\"\u003c/span\u003e, text: \u003cspan class=\"hljs-variable\"\u003e$email\u003c/span\u003e)\n                .validate {\n                   email.count \u003cspan class=\"hljs-operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e\n                }\n             \u003cspan class=\"hljs-type\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Name\"\u003c/span\u003e, text: \u003cspan class=\"hljs-variable\"\u003e$name\u003c/span\u003e)\n                .validate {\n                   \u003cspan class=\"hljs-operator\"\u003e!\u003c/span\u003ename.isEmpty\n                }\n             \u003cspan class=\"hljs-type\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Surname\"\u003c/span\u003e, text: \u003cspan class=\"hljs-variable\"\u003e$surname\u003c/span\u003e)\n                .validate {\n                   \u003cspan class=\"hljs-operator\"\u003e!\u003c/span\u003esurname.isEmpty\n                }\n             \u003cspan class=\"hljs-type\"\u003eSecureField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Password\"\u003c/span\u003e, text: \u003cspan class=\"hljs-variable\"\u003e$password\u003c/span\u003e)\n                .validate {\n                   password.count \u003cspan class=\"hljs-operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e\n                }\n             \u003cspan class=\"hljs-type\"\u003eSpacer\u003c/span\u003e().frame(height: \u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e)\n             \u003cspan class=\"hljs-type\"\u003eButton\u003c/span\u003e {\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e!\u003c/span\u003evalidate() {\n                   \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\n                }\n                \u003cspan class=\"hljs-comment\"\u003e// 네트워크 호출을 해주세요\u003c/span\u003e\n             } label: {\n                \u003cspan class=\"hljs-type\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Tap here to try!\"\u003c/span\u003e)\n                   .padding(.all)\n                   .background(.red)\n                   .cornerRadius(\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e)\n             }\n          }\n       }\n          .padding()\n    }\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e미리 말씀드린 대로 이미지 삽입과 함께, 어떻게 동작하는지 보여주기 위해 validate()을 출력했어요. 모든 필드가 함께 유효성을 검사하는 모습이에요.\u003c/p\u003e\n\u003cp\u003e여기까지 읽어 주셔서 감사합니다.\u003c/p\u003e\n\u003cp\u003e이것은 시작에 불과하다는 것을 잊지 마세요. 이것을 사용하여 오류 메시지를 반환하거나 어떤 필드가 유효하지 않은지 선택할 수 있습니다. 나중에 이를 사용자 정의할 수도 있을 것 같네요.\u003c/p\u003e\n\u003cp\u003e어쨌든 나중에 뵙겠습니다! 즐거운 시간 보내세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro"},"buildId":"o1YmnmSuZvAX2O4TI9r41","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>