<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>리눅스의 단일 용도 철학이 실패할 때 NFS | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="리눅스의 단일 용도 철학이 실패할 때 NFS | ui-station" data-gatsby-head="true"/><meta property="og:title" content="리눅스의 단일 용도 철학이 실패할 때 NFS | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS" data-gatsby-head="true"/><meta name="twitter:title" content="리눅스의 단일 용도 철학이 실패할 때 NFS | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-20 17:54" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-561ae49ab5aab7f5.js" defer=""></script><script src="/_next/static/R1x9p1CQYDDJESXyLXKOK/_buildManifest.js" defer=""></script><script src="/_next/static/R1x9p1CQYDDJESXyLXKOK/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">리눅스의 단일 용도 철학이 실패할 때 NFS</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="리눅스의 단일 용도 철학이 실패할 때 NFS" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 20, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p><img src="/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_0.png" alt="2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_0"/></p>
<p>오픈 소스 세계에는 오랜 역사를 가진 도전할 수 없는 공리가 있습니다: 최고의 애플리케이션은 작고 하나의 목적을 가지고 있어야 합니다. 사진에서 배경을 제거하는 도구가 필요하다면, 사진을 받아 배경이 없는 사진을 출력하는 간단한 터미널 프로그램이 있어야 합니다. 파일 이름을 변경하여 타임 스탬프를 추가하고 싶다면, 파일을 받아 이름이 변경된 파일을 출력하는 작은 터미널 프로그램이 있어야 합니다. 이렇게 하면 배경을 제거하고 사진에 타임 스탬프를 추가하려면 프로그램을 연결하여 Linux 셸에서 새로운 도구를 만들 수 있습니다.</p>
<p>다양한 도구로 이루어진 도구상자를 받아 작업을 완료하는 데 사용할 수 있습니다. 작업은 매우 복잡할 수 있어도 도구상자에 있는 어떤 도구 하나만으로는 해결할 수 없을 수도 있습니다. 도구들은 심지어 그것을 다루기 위해 설계되지 않았을 수도 있습니다. 그러나 결합하면 도구를 만든 사람들이 생각하지 못한 새로운 것을 얻을 수 있습니다. 조금의 창의력을 발휘하여 복잡한 작업을 처리할 수 있게 됩니다. 이것이 Linux의 단일 목적 철학입니다.</p>
<p>또 다른 유명한 Linux 철학은 모든 것은 파일이라는 것입니다. 이들은 함께 가기 때문에 만약 모든 것이 파일이라면, 파일에 일반적으로 적용되는 모든 도구를 모든 것에 적용할 수 있습니다. 네트워크 리소스는 파일 명령을 사용하여 읽고, 프로세스 간 통신은 파일로 처리되며, Linux 프로세스에는 고유한 가상 파일 시스템이 있으며, 네트워크 공유도 물리적 파일 시스템처럼 마운트됩니다.</p>
<div class="content-ad"></div>
<h2>맞게 했나요?</h2>
<img src="/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_1.png"/>
<p>이것은 작고 사소한 도구를 쌓고 결합하여 얼마나 멀리 갈 수 있는지를 보여줍니다. 단순한 파일 읽기 프로그램을 만들고, 그것을 어디에나 적용합니다. 모든 극단을 도전함으로써, 전체 세계에 걸쳐 단일 물리적 입력 및 출력을 가진 통합 분산 운영 체제를 만들어낼 수도 있습니다.</p>
<p>이겪어보기에는 멋져 보이지만, 개발자는 작고 간단한 범용 파일 읽기 프로그램을 작성했으니 일이 끝났다고 생각하며 스스로를 칭찬할 수 있겠지만, 지나치게 나아가면 또 다른 철학, 이번에는 원치 않는 철학으로 전환될 수 있습니다: 모든 것이 모두로 가듯이. 나는 공구상자를 열고 렌치, 망치, 작은 삽, 가위를 찾아내어 생각합니다. “많은 못이 있으니 망치가 최선일 것입니다”. 정원에 꽃들에 물을 주어야 한다는 사실을 무시하더라도, 망치 위에 물을 들어올리며 균형을 맞춰주어 모은 물방울이 떨어지지 않도록 조심스럽게 운반할 것입니다.</p>
<div class="content-ad"></div>
<p>리눅스 세계에서는 이런 일반화로 많은 헷갈림을 일으키기도 했죠. 모든 사람들을 위해 모든 것을 되게 하려다 보니 복잡한 파일 구조가 나타나고, 최신 기능을 계속 지원하다 보니 90년대에 처음 설계된 파일에 잘 매치되지 않는 기능이 포함되었죠.</p>
<p>예를 들어, 파일 공유에 대해 알아보겠습니다.</p>
<p><img src="/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_2.png" alt="이미지"/></p>
<p>리눅스 시스템에서 네이티브 파일 공유는 NFS(Network File System)로 이루어집니다. 목적은 무엇일까요? 간단하고 독특합니다: 네트워크에서 파일을 공유하는 것. 구현 방식은 어떨까요? 개별적인 목적을 가졌습니다: 오로지 공유만. 이는 네트워크를 통해 공유 폴더를 다른 컴퓨터의 로컬 파일 시스템으로 마운트할 수 있도록 합니다. 이후에는 로컬 리눅스가 다른 파일과 마찬가지로 공유를 관리합니다. 그때에는 이 정도면 충분했죠.</p>
<div class="content-ad"></div>
<p>구현? 믿기 힘들지만, 여기에 있습니다. NFS는 마운트 가능한 형식으로 공유물을 게시하는 것만 다루게 됩니다. 내 서버에 당신이 필요로 하는 파일이 있으므로, 나는 NFS를 구성하여 그것을 게시하고 당신은 마운트 명령을 사용하여 그것을 당신의 끝에 로드할 수 있게 될 것입니다. 모든 것이 쉬워 보이고 사소해 보입니다.</p>
<p>하지만 파일들은 중요한 소유자 및 권한과 같은 메타 정보를 지니고 있습니다. 내 서버의 파일에게 일련의 사용자에 응답하도록 구성되어 있는데, 그것이 해당 컴퓨터에서 찾는 다른 사용자 집합과도 작동해야 한다고 말하는 것은 어떻게 해야 할까요? 보통 그렇게 하지 않습니다. 파일을 공유할 때, 작동할 사용자도 함께 공유합니다. 그러나 NFS의 경우는 그렇지 않습니다. NFS의 경우, 한 컴퓨터가 다른 컴퓨터에서 파일을 마운트할 수 있도록 허용하는 것이 유일한 목적이었습니다. 사용자는 다른 사람의 문제입니다.</p>
<h2>사용자를 어떻게 다루는가요?</h2>
<p><img src="/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_3.png" alt="이미지"/></p>
<div class="content-ad"></div>
<p>파일이 정확히 동일한 권한으로 내 컴퓨터로 이동했습니다. 파일 소유자는 사용자 1000입니다? 당신의 컴퓨터에서도 동일할 것입니다. 내 컴퓨터에서 소유자가 1000인가 radu? 그럼 당신 컴퓨터에서는 소유자 1000이 누구인가요? 잘 모르겠어요. 그리고 NFS는 신경 쓰지 않았죠. 이것은 내가 자신의 사용자 1000을 만들고 다른 컴퓨터에서 공유를 마운트하고 그 파일에 대해 마치 내 파일인 것처럼 조작할 수 있다는 것을 의미합니다. 이것은 주요 보안 취약성이며 쉽게 악용할 수 있는 문제이며 중요한 결과를 초래할 수 있는 것입니다.</p>
<p>단순성은 문제를 만들었습니다. 두 가지 해결책이 있는 문제: 전체 네트워크의 모든 사용자를 제어하거나(인터넷이 종종 전체 네트워크인 때가 있으므로 항상 할 수 없을 수도 있음) 사용자를 &quot;매핑&quot;함으로써 복잡성을 회피할 수 있습니다. 사용자 매핑이란 원격 액세스를 로컬 시스템의 기존 및 잘 구성된 사용자로 간주하는 것을 의미합니다. 예를 들어, 사용자 1000이 특정 공유를 마운트하면 그들의 모든 요청을 파일에 대한 잘 알려진 권한을 갖는 로컬 사용자 2000에서 오는 것으로 해석합니다.</p>
<p>파일 공유 도구를 번거롭게 하고 싶지 않습니다. 그냥 파일을 공유하려고 하는 것뿐입니다. 사용자는 상관없어야 합니다. 사용자는 운영 체제에 의해 처리되어야하며 나에 의해 처리되어서는 안 됩니다. 그래서 나는 사용자에 대해 거짓말을 하고 다른 것으로 만들어버립니다. 나는 무능함을 다른 문제로 대체하고 있는지 궁금해하지 않습니다. 모든 것이 망치인데, 망치가 필요합니다. 아직 망치를 다루고 있는지 궁금해할까요? 아니요, 그냥 망치를 사용하고 싶어합니다. 그래서 새로운 종류의 망치로 작업하기 위해 망치를 보강합니다.</p>
<p>로컬 파일은 로컬 사용자와 같지 않기 때문에 네트워크 파일도 같지 않습니다. 네트워크 파일은 많은 질문에 대답하는 객체입니다. 이 파일은 무엇이며, 내용은 무엇이며, 작업 권한은 무엇이며, 로컬 컴퓨터에서 파일이 얼마나 떨어져 있는지, 현재 파일에 작업 중인 협업자가 있는지, 서버에서 파일 편집을 위해 파일이 잠기는 사람은 누군지, 이 파일을 누구에게 제공할 수 있는지, 공유 만료일이 언제인지 등의 질문에 답하게 됩니다. 모든 이러한 정보는 일반 파일 메타데이터에 기록되지 않습니다. 이 모든 것이 파일 공유 시스템인 이 경우 NFS의 역할입니다. 그러나 NFS는 이 모든 것을 할 수 없었습니다. 이는 파일이 불충분하다는 의미는 아니지만 확실히 NFS를 만들어 냈습니다.</p>
<div class="content-ad"></div>
<h2>NFS와 SMB 비교</h2>
<p><img src="/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_4.png" alt="이미지"/></p>
<p>한편에선, Windows 세계에서 Microsoft는 자체 공유 시스템인 SMB를 구현했습니다. 물론, 이것은 모든 Linux 사용자들에게 혐오를 사랑하는 NFS에 &#x27;야만인&#x27;으로 여겨졌습니다. 그러나 SMB는 단일 목적의 유틸리티로 설계되지 않았습니다. 사용자, 잠금, 충돌 해결 및 협업까지 주의 깊게 고려되었습니다. Windows에는 파일이 아닌 객체으로 실용적이고 유용한 계층적 설명을 가진 모든 필요한 정보를 포착하는 공유물이었습니다.</p>
<p>SMB에는 각자의 사용자 집합이 있었습니다. 파일을 얻고 싶다면, 적절한 자격 증명으로 SMB 서버에 로그인해야 했습니다. 이 자격 증명은 정확히 본인이 어떤 액세스 권한을 갖고 어디까지 갈 수 있는지를 정의했습니다. 그리고 네트워크 전체에서 통일된 사용자 시스템이 필요하지 않았습니다. 물론 가능하다면 Active Directory 서버로 사용할 수도 있었지만, 필수는 아니었습니다.</p>
<div class="content-ad"></div>
<p>하지만 통합 사용자 시스템에 대해 조금 이야기해 봅시다. NFS가 사용자를 공유하기 위한 의미 있게 사용하려면 왜 네트워크에 구현하지 않을까요? 네트워크에서 동일한 사용자 집합을 가지려면 식별 서버가 필요합니다. 네트워크에서 Linux 로그인을 대신하는 간단한 LDAP 구현을 사용하거나 각 Linux 시스템에 수동으로 구성해야 하지만 Windows 또는 Mac과 호환되지 않는 LDAP 구현을 사용할 수 있습니다. 또는 모든 것을 포함하지만 로그인 프로세스 전체를 대신하는 무거운 시스템을 사용하여 모든 디바이스 및 사용자를 등록할 수 있습니다.</p>
<p>이 두 가지는 가정용 네트워크에 대한 지나치게 과도한 해결책으로, 항상 사용할 수 없는 전문 시스템 관리자가 필요합니다. 그리고 관리만이 아니라 사용자들도 무엇을 할 수 있는지와 로그인 서버에서 관리되는 것에 대해 학습해야 합니다. 파일을 공유하려는 가정용 네트워크에는 극도로 복잡합니다. 그리고 LDAP 솔루션이 핸드폰에서도 작동하지 않는다는 점을 언급해야 합니다. 클라우드 플랫폼과도 작동하지 않습니다. 다시 말해, 클라우드 플랫폼은 자체 공유 및 로그인 시스템을 구현하기 때문입니다.</p>
<p>같은 단일 용도 철학으로부터 고통 받은 것이 뭘까요? FTP입니다. 다시 인터넷을 통해 파일을 공유하는데 보안이나 인증이 전혀 없었습니다. 아시다시피, FTP는 실패하고 더 이상 사용되지 않습니다. 이를 여러 다른 파일 공유 시스템으로 대체되었는데, 가장 쉬운 것이 SSHFS이며, SSH의 파일 액세스 엔진입니다. SSHFS가 할 수 있는 다른 것이 뭘까요? 안전하고 보안된 로컬 네트워크 파일 공유입니다. 그런데 어떻게 하죠? SMB와 마찬가지로 서버 구성 사용자로 네트워크 서버에 로그인하여 실행합니다.</p>
<p>이 기사를 읽어 주셔서 감사합니다. 맨 위에 면책 조항을 추가하고 싶었는데, 저는 Linux이나 단일 용도 철학에 아무런 문제가 없다는 것을 알려드리고 싶었습니다. 그것은 가능한 곳에 적용될 때 좋은 것입니다. 그러나 잘 맞지 않는 작업에 도구를 재해석하면 기회를 놓치게 됩니다. 오늘날에도 Linux에서 선호되는 공유 시스템은 주로 경험이 부족한 사용자를 위해 SMB입니다. 읽어 주셔서 감사하고 다음에 또 방문해 주시기를 바랍니다!</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"리눅스의 단일 용도 철학이 실패할 때 NFS","description":"","date":"2024-05-20 17:54","slug":"2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS","content":"\n\n![2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_0](/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_0.png)\n\n오픈 소스 세계에는 오랜 역사를 가진 도전할 수 없는 공리가 있습니다: 최고의 애플리케이션은 작고 하나의 목적을 가지고 있어야 합니다. 사진에서 배경을 제거하는 도구가 필요하다면, 사진을 받아 배경이 없는 사진을 출력하는 간단한 터미널 프로그램이 있어야 합니다. 파일 이름을 변경하여 타임 스탬프를 추가하고 싶다면, 파일을 받아 이름이 변경된 파일을 출력하는 작은 터미널 프로그램이 있어야 합니다. 이렇게 하면 배경을 제거하고 사진에 타임 스탬프를 추가하려면 프로그램을 연결하여 Linux 셸에서 새로운 도구를 만들 수 있습니다.\n\n다양한 도구로 이루어진 도구상자를 받아 작업을 완료하는 데 사용할 수 있습니다. 작업은 매우 복잡할 수 있어도 도구상자에 있는 어떤 도구 하나만으로는 해결할 수 없을 수도 있습니다. 도구들은 심지어 그것을 다루기 위해 설계되지 않았을 수도 있습니다. 그러나 결합하면 도구를 만든 사람들이 생각하지 못한 새로운 것을 얻을 수 있습니다. 조금의 창의력을 발휘하여 복잡한 작업을 처리할 수 있게 됩니다. 이것이 Linux의 단일 목적 철학입니다.\n\n또 다른 유명한 Linux 철학은 모든 것은 파일이라는 것입니다. 이들은 함께 가기 때문에 만약 모든 것이 파일이라면, 파일에 일반적으로 적용되는 모든 도구를 모든 것에 적용할 수 있습니다. 네트워크 리소스는 파일 명령을 사용하여 읽고, 프로세스 간 통신은 파일로 처리되며, Linux 프로세스에는 고유한 가상 파일 시스템이 있으며, 네트워크 공유도 물리적 파일 시스템처럼 마운트됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 맞게 했나요?\n\n\u003cimg src=\"/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_1.png\" /\u003e\n\n이것은 작고 사소한 도구를 쌓고 결합하여 얼마나 멀리 갈 수 있는지를 보여줍니다. 단순한 파일 읽기 프로그램을 만들고, 그것을 어디에나 적용합니다. 모든 극단을 도전함으로써, 전체 세계에 걸쳐 단일 물리적 입력 및 출력을 가진 통합 분산 운영 체제를 만들어낼 수도 있습니다.\n\n이겪어보기에는 멋져 보이지만, 개발자는 작고 간단한 범용 파일 읽기 프로그램을 작성했으니 일이 끝났다고 생각하며 스스로를 칭찬할 수 있겠지만, 지나치게 나아가면 또 다른 철학, 이번에는 원치 않는 철학으로 전환될 수 있습니다: 모든 것이 모두로 가듯이. 나는 공구상자를 열고 렌치, 망치, 작은 삽, 가위를 찾아내어 생각합니다. “많은 못이 있으니 망치가 최선일 것입니다”. 정원에 꽃들에 물을 주어야 한다는 사실을 무시하더라도, 망치 위에 물을 들어올리며 균형을 맞춰주어 모은 물방울이 떨어지지 않도록 조심스럽게 운반할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리눅스 세계에서는 이런 일반화로 많은 헷갈림을 일으키기도 했죠. 모든 사람들을 위해 모든 것을 되게 하려다 보니 복잡한 파일 구조가 나타나고, 최신 기능을 계속 지원하다 보니 90년대에 처음 설계된 파일에 잘 매치되지 않는 기능이 포함되었죠.\n\n예를 들어, 파일 공유에 대해 알아보겠습니다.\n\n![이미지](/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_2.png)\n\n리눅스 시스템에서 네이티브 파일 공유는 NFS(Network File System)로 이루어집니다. 목적은 무엇일까요? 간단하고 독특합니다: 네트워크에서 파일을 공유하는 것. 구현 방식은 어떨까요? 개별적인 목적을 가졌습니다: 오로지 공유만. 이는 네트워크를 통해 공유 폴더를 다른 컴퓨터의 로컬 파일 시스템으로 마운트할 수 있도록 합니다. 이후에는 로컬 리눅스가 다른 파일과 마찬가지로 공유를 관리합니다. 그때에는 이 정도면 충분했죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n구현? 믿기 힘들지만, 여기에 있습니다. NFS는 마운트 가능한 형식으로 공유물을 게시하는 것만 다루게 됩니다. 내 서버에 당신이 필요로 하는 파일이 있으므로, 나는 NFS를 구성하여 그것을 게시하고 당신은 마운트 명령을 사용하여 그것을 당신의 끝에 로드할 수 있게 될 것입니다. 모든 것이 쉬워 보이고 사소해 보입니다.\n\n하지만 파일들은 중요한 소유자 및 권한과 같은 메타 정보를 지니고 있습니다. 내 서버의 파일에게 일련의 사용자에 응답하도록 구성되어 있는데, 그것이 해당 컴퓨터에서 찾는 다른 사용자 집합과도 작동해야 한다고 말하는 것은 어떻게 해야 할까요? 보통 그렇게 하지 않습니다. 파일을 공유할 때, 작동할 사용자도 함께 공유합니다. 그러나 NFS의 경우는 그렇지 않습니다. NFS의 경우, 한 컴퓨터가 다른 컴퓨터에서 파일을 마운트할 수 있도록 허용하는 것이 유일한 목적이었습니다. 사용자는 다른 사람의 문제입니다.\n\n## 사용자를 어떻게 다루는가요?\n\n![이미지](/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파일이 정확히 동일한 권한으로 내 컴퓨터로 이동했습니다. 파일 소유자는 사용자 1000입니다? 당신의 컴퓨터에서도 동일할 것입니다. 내 컴퓨터에서 소유자가 1000인가 radu? 그럼 당신 컴퓨터에서는 소유자 1000이 누구인가요? 잘 모르겠어요. 그리고 NFS는 신경 쓰지 않았죠. 이것은 내가 자신의 사용자 1000을 만들고 다른 컴퓨터에서 공유를 마운트하고 그 파일에 대해 마치 내 파일인 것처럼 조작할 수 있다는 것을 의미합니다. 이것은 주요 보안 취약성이며 쉽게 악용할 수 있는 문제이며 중요한 결과를 초래할 수 있는 것입니다. \n\n단순성은 문제를 만들었습니다. 두 가지 해결책이 있는 문제: 전체 네트워크의 모든 사용자를 제어하거나(인터넷이 종종 전체 네트워크인 때가 있으므로 항상 할 수 없을 수도 있음) 사용자를 \"매핑\"함으로써 복잡성을 회피할 수 있습니다. 사용자 매핑이란 원격 액세스를 로컬 시스템의 기존 및 잘 구성된 사용자로 간주하는 것을 의미합니다. 예를 들어, 사용자 1000이 특정 공유를 마운트하면 그들의 모든 요청을 파일에 대한 잘 알려진 권한을 갖는 로컬 사용자 2000에서 오는 것으로 해석합니다.\n\n파일 공유 도구를 번거롭게 하고 싶지 않습니다. 그냥 파일을 공유하려고 하는 것뿐입니다. 사용자는 상관없어야 합니다. 사용자는 운영 체제에 의해 처리되어야하며 나에 의해 처리되어서는 안 됩니다. 그래서 나는 사용자에 대해 거짓말을 하고 다른 것으로 만들어버립니다. 나는 무능함을 다른 문제로 대체하고 있는지 궁금해하지 않습니다. 모든 것이 망치인데, 망치가 필요합니다. 아직 망치를 다루고 있는지 궁금해할까요? 아니요, 그냥 망치를 사용하고 싶어합니다. 그래서 새로운 종류의 망치로 작업하기 위해 망치를 보강합니다. \n\n로컬 파일은 로컬 사용자와 같지 않기 때문에 네트워크 파일도 같지 않습니다. 네트워크 파일은 많은 질문에 대답하는 객체입니다. 이 파일은 무엇이며, 내용은 무엇이며, 작업 권한은 무엇이며, 로컬 컴퓨터에서 파일이 얼마나 떨어져 있는지, 현재 파일에 작업 중인 협업자가 있는지, 서버에서 파일 편집을 위해 파일이 잠기는 사람은 누군지, 이 파일을 누구에게 제공할 수 있는지, 공유 만료일이 언제인지 등의 질문에 답하게 됩니다. 모든 이러한 정보는 일반 파일 메타데이터에 기록되지 않습니다. 이 모든 것이 파일 공유 시스템인 이 경우 NFS의 역할입니다. 그러나 NFS는 이 모든 것을 할 수 없었습니다. 이는 파일이 불충분하다는 의미는 아니지만 확실히 NFS를 만들어 냈습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## NFS와 SMB 비교\n\n![이미지](/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_4.png)\n\n한편에선, Windows 세계에서 Microsoft는 자체 공유 시스템인 SMB를 구현했습니다. 물론, 이것은 모든 Linux 사용자들에게 혐오를 사랑하는 NFS에 '야만인'으로 여겨졌습니다. 그러나 SMB는 단일 목적의 유틸리티로 설계되지 않았습니다. 사용자, 잠금, 충돌 해결 및 협업까지 주의 깊게 고려되었습니다. Windows에는 파일이 아닌 객체으로 실용적이고 유용한 계층적 설명을 가진 모든 필요한 정보를 포착하는 공유물이었습니다.\n\nSMB에는 각자의 사용자 집합이 있었습니다. 파일을 얻고 싶다면, 적절한 자격 증명으로 SMB 서버에 로그인해야 했습니다. 이 자격 증명은 정확히 본인이 어떤 액세스 권한을 갖고 어디까지 갈 수 있는지를 정의했습니다. 그리고 네트워크 전체에서 통일된 사용자 시스템이 필요하지 않았습니다. 물론 가능하다면 Active Directory 서버로 사용할 수도 있었지만, 필수는 아니었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 통합 사용자 시스템에 대해 조금 이야기해 봅시다. NFS가 사용자를 공유하기 위한 의미 있게 사용하려면 왜 네트워크에 구현하지 않을까요? 네트워크에서 동일한 사용자 집합을 가지려면 식별 서버가 필요합니다. 네트워크에서 Linux 로그인을 대신하는 간단한 LDAP 구현을 사용하거나 각 Linux 시스템에 수동으로 구성해야 하지만 Windows 또는 Mac과 호환되지 않는 LDAP 구현을 사용할 수 있습니다. 또는 모든 것을 포함하지만 로그인 프로세스 전체를 대신하는 무거운 시스템을 사용하여 모든 디바이스 및 사용자를 등록할 수 있습니다.\n\n이 두 가지는 가정용 네트워크에 대한 지나치게 과도한 해결책으로, 항상 사용할 수 없는 전문 시스템 관리자가 필요합니다. 그리고 관리만이 아니라 사용자들도 무엇을 할 수 있는지와 로그인 서버에서 관리되는 것에 대해 학습해야 합니다. 파일을 공유하려는 가정용 네트워크에는 극도로 복잡합니다. 그리고 LDAP 솔루션이 핸드폰에서도 작동하지 않는다는 점을 언급해야 합니다. 클라우드 플랫폼과도 작동하지 않습니다. 다시 말해, 클라우드 플랫폼은 자체 공유 및 로그인 시스템을 구현하기 때문입니다.\n\n같은 단일 용도 철학으로부터 고통 받은 것이 뭘까요? FTP입니다. 다시 인터넷을 통해 파일을 공유하는데 보안이나 인증이 전혀 없었습니다. 아시다시피, FTP는 실패하고 더 이상 사용되지 않습니다. 이를 여러 다른 파일 공유 시스템으로 대체되었는데, 가장 쉬운 것이 SSHFS이며, SSH의 파일 액세스 엔진입니다. SSHFS가 할 수 있는 다른 것이 뭘까요? 안전하고 보안된 로컬 네트워크 파일 공유입니다. 그런데 어떻게 하죠? SMB와 마찬가지로 서버 구성 사용자로 네트워크 서버에 로그인하여 실행합니다.\n\n이 기사를 읽어 주셔서 감사합니다. 맨 위에 면책 조항을 추가하고 싶었는데, 저는 Linux이나 단일 용도 철학에 아무런 문제가 없다는 것을 알려드리고 싶었습니다. 그것은 가능한 곳에 적용될 때 좋은 것입니다. 그러나 잘 맞지 않는 작업에 도구를 재해석하면 기회를 놓치게 됩니다. 오늘날에도 Linux에서 선호되는 공유 시스템은 주로 경험이 부족한 사용자를 위해 SMB입니다. 읽어 주셔서 감사하고 다음에 또 방문해 주시기를 바랍니다!","ogImage":{"url":"/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_0.png"},"coverImage":"/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_0.png","tag":["Tech"],"readingTime":6},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h2: \"h2\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_0.png\",\n        alt: \"2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_0\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"오픈 소스 세계에는 오랜 역사를 가진 도전할 수 없는 공리가 있습니다: 최고의 애플리케이션은 작고 하나의 목적을 가지고 있어야 합니다. 사진에서 배경을 제거하는 도구가 필요하다면, 사진을 받아 배경이 없는 사진을 출력하는 간단한 터미널 프로그램이 있어야 합니다. 파일 이름을 변경하여 타임 스탬프를 추가하고 싶다면, 파일을 받아 이름이 변경된 파일을 출력하는 작은 터미널 프로그램이 있어야 합니다. 이렇게 하면 배경을 제거하고 사진에 타임 스탬프를 추가하려면 프로그램을 연결하여 Linux 셸에서 새로운 도구를 만들 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다양한 도구로 이루어진 도구상자를 받아 작업을 완료하는 데 사용할 수 있습니다. 작업은 매우 복잡할 수 있어도 도구상자에 있는 어떤 도구 하나만으로는 해결할 수 없을 수도 있습니다. 도구들은 심지어 그것을 다루기 위해 설계되지 않았을 수도 있습니다. 그러나 결합하면 도구를 만든 사람들이 생각하지 못한 새로운 것을 얻을 수 있습니다. 조금의 창의력을 발휘하여 복잡한 작업을 처리할 수 있게 됩니다. 이것이 Linux의 단일 목적 철학입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"또 다른 유명한 Linux 철학은 모든 것은 파일이라는 것입니다. 이들은 함께 가기 때문에 만약 모든 것이 파일이라면, 파일에 일반적으로 적용되는 모든 도구를 모든 것에 적용할 수 있습니다. 네트워크 리소스는 파일 명령을 사용하여 읽고, 프로세스 간 통신은 파일로 처리되며, Linux 프로세스에는 고유한 가상 파일 시스템이 있으며, 네트워크 공유도 물리적 파일 시스템처럼 마운트됩니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"맞게 했나요?\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_1.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것은 작고 사소한 도구를 쌓고 결합하여 얼마나 멀리 갈 수 있는지를 보여줍니다. 단순한 파일 읽기 프로그램을 만들고, 그것을 어디에나 적용합니다. 모든 극단을 도전함으로써, 전체 세계에 걸쳐 단일 물리적 입력 및 출력을 가진 통합 분산 운영 체제를 만들어낼 수도 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이겪어보기에는 멋져 보이지만, 개발자는 작고 간단한 범용 파일 읽기 프로그램을 작성했으니 일이 끝났다고 생각하며 스스로를 칭찬할 수 있겠지만, 지나치게 나아가면 또 다른 철학, 이번에는 원치 않는 철학으로 전환될 수 있습니다: 모든 것이 모두로 가듯이. 나는 공구상자를 열고 렌치, 망치, 작은 삽, 가위를 찾아내어 생각합니다. “많은 못이 있으니 망치가 최선일 것입니다”. 정원에 꽃들에 물을 주어야 한다는 사실을 무시하더라도, 망치 위에 물을 들어올리며 균형을 맞춰주어 모은 물방울이 떨어지지 않도록 조심스럽게 운반할 것입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"리눅스 세계에서는 이런 일반화로 많은 헷갈림을 일으키기도 했죠. 모든 사람들을 위해 모든 것을 되게 하려다 보니 복잡한 파일 구조가 나타나고, 최신 기능을 계속 지원하다 보니 90년대에 처음 설계된 파일에 잘 매치되지 않는 기능이 포함되었죠.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어, 파일 공유에 대해 알아보겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_2.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"리눅스 시스템에서 네이티브 파일 공유는 NFS(Network File System)로 이루어집니다. 목적은 무엇일까요? 간단하고 독특합니다: 네트워크에서 파일을 공유하는 것. 구현 방식은 어떨까요? 개별적인 목적을 가졌습니다: 오로지 공유만. 이는 네트워크를 통해 공유 폴더를 다른 컴퓨터의 로컬 파일 시스템으로 마운트할 수 있도록 합니다. 이후에는 로컬 리눅스가 다른 파일과 마찬가지로 공유를 관리합니다. 그때에는 이 정도면 충분했죠.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"구현? 믿기 힘들지만, 여기에 있습니다. NFS는 마운트 가능한 형식으로 공유물을 게시하는 것만 다루게 됩니다. 내 서버에 당신이 필요로 하는 파일이 있으므로, 나는 NFS를 구성하여 그것을 게시하고 당신은 마운트 명령을 사용하여 그것을 당신의 끝에 로드할 수 있게 될 것입니다. 모든 것이 쉬워 보이고 사소해 보입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 파일들은 중요한 소유자 및 권한과 같은 메타 정보를 지니고 있습니다. 내 서버의 파일에게 일련의 사용자에 응답하도록 구성되어 있는데, 그것이 해당 컴퓨터에서 찾는 다른 사용자 집합과도 작동해야 한다고 말하는 것은 어떻게 해야 할까요? 보통 그렇게 하지 않습니다. 파일을 공유할 때, 작동할 사용자도 함께 공유합니다. 그러나 NFS의 경우는 그렇지 않습니다. NFS의 경우, 한 컴퓨터가 다른 컴퓨터에서 파일을 마운트할 수 있도록 허용하는 것이 유일한 목적이었습니다. 사용자는 다른 사람의 문제입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"사용자를 어떻게 다루는가요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_3.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"파일이 정확히 동일한 권한으로 내 컴퓨터로 이동했습니다. 파일 소유자는 사용자 1000입니다? 당신의 컴퓨터에서도 동일할 것입니다. 내 컴퓨터에서 소유자가 1000인가 radu? 그럼 당신 컴퓨터에서는 소유자 1000이 누구인가요? 잘 모르겠어요. 그리고 NFS는 신경 쓰지 않았죠. 이것은 내가 자신의 사용자 1000을 만들고 다른 컴퓨터에서 공유를 마운트하고 그 파일에 대해 마치 내 파일인 것처럼 조작할 수 있다는 것을 의미합니다. 이것은 주요 보안 취약성이며 쉽게 악용할 수 있는 문제이며 중요한 결과를 초래할 수 있는 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"단순성은 문제를 만들었습니다. 두 가지 해결책이 있는 문제: 전체 네트워크의 모든 사용자를 제어하거나(인터넷이 종종 전체 네트워크인 때가 있으므로 항상 할 수 없을 수도 있음) 사용자를 \\\"매핑\\\"함으로써 복잡성을 회피할 수 있습니다. 사용자 매핑이란 원격 액세스를 로컬 시스템의 기존 및 잘 구성된 사용자로 간주하는 것을 의미합니다. 예를 들어, 사용자 1000이 특정 공유를 마운트하면 그들의 모든 요청을 파일에 대한 잘 알려진 권한을 갖는 로컬 사용자 2000에서 오는 것으로 해석합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"파일 공유 도구를 번거롭게 하고 싶지 않습니다. 그냥 파일을 공유하려고 하는 것뿐입니다. 사용자는 상관없어야 합니다. 사용자는 운영 체제에 의해 처리되어야하며 나에 의해 처리되어서는 안 됩니다. 그래서 나는 사용자에 대해 거짓말을 하고 다른 것으로 만들어버립니다. 나는 무능함을 다른 문제로 대체하고 있는지 궁금해하지 않습니다. 모든 것이 망치인데, 망치가 필요합니다. 아직 망치를 다루고 있는지 궁금해할까요? 아니요, 그냥 망치를 사용하고 싶어합니다. 그래서 새로운 종류의 망치로 작업하기 위해 망치를 보강합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"로컬 파일은 로컬 사용자와 같지 않기 때문에 네트워크 파일도 같지 않습니다. 네트워크 파일은 많은 질문에 대답하는 객체입니다. 이 파일은 무엇이며, 내용은 무엇이며, 작업 권한은 무엇이며, 로컬 컴퓨터에서 파일이 얼마나 떨어져 있는지, 현재 파일에 작업 중인 협업자가 있는지, 서버에서 파일 편집을 위해 파일이 잠기는 사람은 누군지, 이 파일을 누구에게 제공할 수 있는지, 공유 만료일이 언제인지 등의 질문에 답하게 됩니다. 모든 이러한 정보는 일반 파일 메타데이터에 기록되지 않습니다. 이 모든 것이 파일 공유 시스템인 이 경우 NFS의 역할입니다. 그러나 NFS는 이 모든 것을 할 수 없었습니다. 이는 파일이 불충분하다는 의미는 아니지만 확실히 NFS를 만들어 냈습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"NFS와 SMB 비교\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_4.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"한편에선, Windows 세계에서 Microsoft는 자체 공유 시스템인 SMB를 구현했습니다. 물론, 이것은 모든 Linux 사용자들에게 혐오를 사랑하는 NFS에 '야만인'으로 여겨졌습니다. 그러나 SMB는 단일 목적의 유틸리티로 설계되지 않았습니다. 사용자, 잠금, 충돌 해결 및 협업까지 주의 깊게 고려되었습니다. Windows에는 파일이 아닌 객체으로 실용적이고 유용한 계층적 설명을 가진 모든 필요한 정보를 포착하는 공유물이었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"SMB에는 각자의 사용자 집합이 있었습니다. 파일을 얻고 싶다면, 적절한 자격 증명으로 SMB 서버에 로그인해야 했습니다. 이 자격 증명은 정확히 본인이 어떤 액세스 권한을 갖고 어디까지 갈 수 있는지를 정의했습니다. 그리고 네트워크 전체에서 통일된 사용자 시스템이 필요하지 않았습니다. 물론 가능하다면 Active Directory 서버로 사용할 수도 있었지만, 필수는 아니었습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 통합 사용자 시스템에 대해 조금 이야기해 봅시다. NFS가 사용자를 공유하기 위한 의미 있게 사용하려면 왜 네트워크에 구현하지 않을까요? 네트워크에서 동일한 사용자 집합을 가지려면 식별 서버가 필요합니다. 네트워크에서 Linux 로그인을 대신하는 간단한 LDAP 구현을 사용하거나 각 Linux 시스템에 수동으로 구성해야 하지만 Windows 또는 Mac과 호환되지 않는 LDAP 구현을 사용할 수 있습니다. 또는 모든 것을 포함하지만 로그인 프로세스 전체를 대신하는 무거운 시스템을 사용하여 모든 디바이스 및 사용자를 등록할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 두 가지는 가정용 네트워크에 대한 지나치게 과도한 해결책으로, 항상 사용할 수 없는 전문 시스템 관리자가 필요합니다. 그리고 관리만이 아니라 사용자들도 무엇을 할 수 있는지와 로그인 서버에서 관리되는 것에 대해 학습해야 합니다. 파일을 공유하려는 가정용 네트워크에는 극도로 복잡합니다. 그리고 LDAP 솔루션이 핸드폰에서도 작동하지 않는다는 점을 언급해야 합니다. 클라우드 플랫폼과도 작동하지 않습니다. 다시 말해, 클라우드 플랫폼은 자체 공유 및 로그인 시스템을 구현하기 때문입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"같은 단일 용도 철학으로부터 고통 받은 것이 뭘까요? FTP입니다. 다시 인터넷을 통해 파일을 공유하는데 보안이나 인증이 전혀 없었습니다. 아시다시피, FTP는 실패하고 더 이상 사용되지 않습니다. 이를 여러 다른 파일 공유 시스템으로 대체되었는데, 가장 쉬운 것이 SSHFS이며, SSH의 파일 액세스 엔진입니다. SSHFS가 할 수 있는 다른 것이 뭘까요? 안전하고 보안된 로컬 네트워크 파일 공유입니다. 그런데 어떻게 하죠? SMB와 마찬가지로 서버 구성 사용자로 네트워크 서버에 로그인하여 실행합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 기사를 읽어 주셔서 감사합니다. 맨 위에 면책 조항을 추가하고 싶었는데, 저는 Linux이나 단일 용도 철학에 아무런 문제가 없다는 것을 알려드리고 싶었습니다. 그것은 가능한 곳에 적용될 때 좋은 것입니다. 그러나 잘 맞지 않는 작업에 도구를 재해석하면 기회를 놓치게 됩니다. 오늘날에도 Linux에서 선호되는 공유 시스템은 주로 경험이 부족한 사용자를 위해 SMB입니다. 읽어 주셔서 감사하고 다음에 또 방문해 주시기를 바랍니다!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS"},"buildId":"R1x9p1CQYDDJESXyLXKOK","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>