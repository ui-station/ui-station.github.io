<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Unity 아키텍처 GameObject 컴포넌트 패턴 이해하기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-23-UnityArchitectureGameObjectComponentPattern" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Unity 아키텍처 GameObject 컴포넌트 패턴 이해하기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Unity 아키텍처 GameObject 컴포넌트 패턴 이해하기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-23-UnityArchitectureGameObjectComponentPattern" data-gatsby-head="true"/><meta name="twitter:title" content="Unity 아키텍처 GameObject 컴포넌트 패턴 이해하기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 22:21" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_buildManifest.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Unity 아키텍처 GameObject 컴포넌트 패턴 이해하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Unity 아키텍처 GameObject 컴포넌트 패턴 이해하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">14<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-UnityArchitectureGameObjectComponentPattern&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>지난 블로그 글에서는 "스파게티 패턴"에 대해 살펴보았습니다. 이는 아무런 패턴이 없는 게임을 묘사하기 위해 사용되는 농담적인 용어입니다.</p>
<p>많은 신규 개발자들이 이를 선택하는 이유는 게임을 빠르고 쉽게 제작할 수 있다는 점 때문입니다. 하지만 이후에 자신의 지식을 확장하지 못하는 경우가 많습니다.</p>
<p>프로토타입을 만드는 데 뛰어난 장점이 있지만, 코드가 엉망으로 변하여 어수선하고 복잡한 코드 구조로 이어질 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그러한 코드베이스는 긴, 엉킨 메소드, 싱글톤 게임 매니저와 같은 "God Objects"에 지나치게 의존하며, 각 새로운 기능이 추가될 때마다 증가하는 끝없는 버그 나열로 악명높습니다.</p>
<p>다행히도, 이러한 문제 중 많은 것을 해결해 줄 수 있는 패턴 중 하나는 GameObject-Component Pattern이며, 이는 Unity의 원래 비전이자 Unity Editor의 공식 프레임워크입니다.</p>
<p>이 패턴은 큰 "God Objects"를 더 작고 모듈식 컴포넌트로 분해함으로써 이런 문제들을 해결합니다. 이렇게 하면 새 코드를 작성하지 않고도 GameObject에서 컴포넌트를 쉽게 추가, 수정 또는 제거할 수 있습니다. 본 이론에 따르면, 더 유연하고 유지 보수가 쉬운 코드베이스로 이끌어줄 것입니다.</p>
<p><img src="/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_0.png" alt="Unity Architecture GameObject Component Pattern"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그래서, 이 패턴이 정말 멋져 보인다면 왜 아무도 사용하지 않는 것 같은걸까요? 심지어 Unity조차 이를 버리고 Scriptable Objects와 ECS를 선호합니다.</p>
<p>나는 '스파게티 프로토타입'을 50시간 이상 리팩토링하여 GameObject Component를 모든 면에서 완전히 활용하고, 그 장점과 약점을 발견했습니다.</p>
<h1>시간 0 — 게임 매니저의 종말</h1>
<p>내 게시물을 따라오신다면 게임 매니저에 대한 절규를 들어볼 수 있을 텐데, 그들은 종종 스파게티 코드베이스에 대한 징후라는 점입니다. 그러므로 그것이 필요 없다는 것을 증명하기 위해 우리는 그것을 삭제할 겁니다.</p>
<p><img src="/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_1.png" alt="이미지"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그러나 매니저가 객체들에게 무엇을 해야 하는지 말하지 않고 게임의 흐름을 어떻게 제어할까요?</p>
<p>우리는 새로운 코딩 개념을 소개해야 합니다. 이벤트입니다.</p>
<p>이벤트는 응용 프로그램에서 제어 흐름의 방향을 반대로 전환할 수 있습니다. 다른 객체들에게 매니저가 지시하는 대신, 이러한 객체들은 매니저의 변화에 반응하는 방식으로 동작합니다.</p>
<p><img src="/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_2.png" alt="Unity Architecture"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이벤트를 사용하면 게임 매니저에서 모든 종속성을 제거하여 대부분의 기능을 제거할 수 있습니다. 그럼으로써, 남은 데이터를 몇 가지 간단한 구성 요소로 분해할 수 있습니다. 예를 들어, 게임 상태와 같은 핵심 이벤트를 담는 컨테이너입니다.</p>
<p><img src="/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_3.png" alt="이미지"></p>
<h1>2시간 — 캡슐화</h1>
<p>이러한 경향을 이어가며, 코드를 깨끗하게 유지하기 위해 클래스가 적절하게 캡슐화되어야 한다는 것이 중요하다는 것을 알았습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우리 코드를 개선하는 가장 간단한 방법은 serialize field 속성을 사용하는 것입니다. 이렇게 함으로써 클래스가 자신의 데이터에 대한 단일 권한 출처로 유지되도록 할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 나쁨. 캡슐화 깨짐.</span>
public int currentHealth;

<span class="hljs-comment">// 좋음. 캡슐화 유지.</span>
[<span class="hljs-title class_">SerializeField</span>]
private int currentHealth;

<span class="hljs-comment">// 좋음. 읽기 전용 액세스 제공하면서 캡슐화 유지.</span>
[<span class="hljs-attr">field</span>:<span class="hljs-title class_">SerializeField</span>]
public int currentHealth { get; private set; }
</code></pre>
<p>유니티 이벤트는 또 다른 중요한 도구로, 에디터에 깊게 내장되어 있으며, 컴포넌트들 간의 결합을 느슨하게 할 수 있습니다.</p>
<p>예를 들어, 플레이어와 적이 동일한 Death Handler 컴포넌트를 사용하지만 전혀 새로운 코드 없이 새로운 동작을 만들어낼 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_4.png">
<p>그러나 이 코드 의존성 부족은 두날날날날 모낫날剌몫몿 때날이카. Unity Events를 과도하게 사용하면 성능 문제가 발생할 수 있으며 에디터에서 시간이 오래 걸리는 수동 설정으로 이어질 수 있습니다.</p>
<p>이러한 이유로, 자주 발생하거나 중요한 게임 이벤트에 대해 고전적인 C# 동작을 사용했습니다.</p>
<p>마지막으로, Gold와 Achievements와 같은 구성 요소는 싱글톤 계정 관리자에 의존하는 대신 자체 저장 데이터를 처리하도록 했습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>리팩토링은 튼튼한 시작을 했어요.</p>
<h1>7시간 - 성능</h1>
<p>대규모 게임에 대한 확장성과 유지 관리성이 중요하지만 성능도 그렇습니다. GameObject-Component 자체는 스파게티보다 빠르지 않습니다 (사실 느릴 수도 있음), 그러나 리팩토링의 정신에 따라 이러한 문제를 해결해야 합니다.</p>
<p>가장 중요한 기술은 Object Pooling의 사용입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>총알, 체력 팩, 입자 및 적을 생성하고 제거하는 과정으로 인해 Garbage Collector가 엄청난 스트레스를 받고 fps에 영향을 줍니다.</p>
<p>그렇기 때문에 이러한 객체들을 파괴하는 대신 재활용하는 것이 해결책입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 컴포넌트는 풀에서 객체를 '빌려오고' 작업을 마치면 돌려놓을 수 있음.
   현재 사용 중인 객체가 없는 경우에만 새 객체가 생성됨. */</span>
public <span class="hljs-keyword">class</span> <span class="hljs-title class_">GameObjectPool</span> : <span class="hljs-title class_">MonoBehaviour</span>
{
  [<span class="hljs-title class_">SerializeField</span>] private <span class="hljs-title class_">GameObject</span> prefab;
  private readonly <span class="hljs-title class_">Queue</span>&#x3C;<span class="hljs-title class_">GameObject</span>> _inactivePool = <span class="hljs-title function_">new</span>();

  public <span class="hljs-title class_">GameObject</span> <span class="hljs-title class_">Get</span>()
  {
    <span class="hljs-keyword">return</span> _inactivePool.<span class="hljs-property">Count</span> > <span class="hljs-number">0</span> ?
           _inactivePool.<span class="hljs-title class_">Dequeue</span>() :
           <span class="hljs-title class_">Instantiate</span>(prefab, <span class="hljs-literal">null</span>);
  }

  public <span class="hljs-keyword">void</span> <span class="hljs-title class_">Return</span>(<span class="hljs-title class_">GameObject</span> item)
  {
    item.<span class="hljs-title class_">SetActive</span>(<span class="hljs-literal">false</span>);
    _inactivePool.<span class="hljs-title class_">Enqueue</span>(item);
  }
}
</code></pre>
<p>이 기술은 발사체, 적, 입자 효과, 오디오 소스 및 모든 UI 요소(피해 수치와 같은)를 단일 캔버스로 통합함으로써 성능을 향상시켰습니다. 제어된 스트레스 테스트로 60FPS에서 100FPS로 최대 66%의 성능 향상을 달성했습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>시간 10 — 의존성 그래프 수정하기.</h1>
<p>스파게티 패턴에 대한 내 정의 중 하나는 구성 요소 사이에 교차하는 선들의 웹을 만들지 않고는 시각화할 수없는 의존성 그래프였습니다.</p>
<p>이러한 문제를 피하는 간단한 묘수는 구상 대신 구체적인 참조에 의존하는 대신 추상화에 의존하는 것입니다. 특히 이 경우에서는 상속을 사용하여.</p>
<p><img src="/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_5.png" alt="Unity Architecture Game Object Component Pattern"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>게임 상태에 의존하는 구성 요소가 모두 GamePlayComponent 클래스에서 상속되도록 보장하면 이러한 동작을 체크하고도 직접적으로 참조하지 않고도 무차별적인 상태 관리를 할 수 있습니다.</p>
<p>이 기술은 사용자 인터페이스를 분리하는 데 다시 사용되었습니다. 스파게티 코드에서 흔한 문제는 게임이 올바르게 작동하려면 UI에 대한 강력한 의존성이 필요하다는 것입니다. 개발자로서 UI 없이도 스크립트, 콘솔 명령 또는 API를 통해 게임의 어떤 상태든 액세스할 수 있어야 합니다.</p>
<p><img src="/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_6.png" alt="이미지"></p>
<p><img src="/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_7.png" alt="이미지"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>20시간 — 싱글턴 제거하기</h1>
<p>안녕하세요! 싱글턴은 악이 아니지만, 많은 개발자들이 과도하게 의존하고 있습니다. 대안을 제대로 탐색하기 위해 이 리팩토링에서는 싱글턴을 삭제하기로 결정했습니다.</p>
<p>이것은 씬에 직렬화된 객체에 대해서는 쉽게 할 수 있습니다. 그러나 동적으로 생성된 프리팹들은 도전을 제공합니다. 프리팹은 씬 객체를 참조할 수 없습니다. 이 문제를 해결하기 위해 팩토리 패턴을 사용해야 합니다.</p>
<p><img src="/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_8.png" alt="이미지"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>공장은 생성될 때 프리팹의 종속성을 주입합니다. 이는 새로운 오브젝트 풀과 잘 작동합니다. 이로 인해 싱글톤이 필요 없어졌지만, 코드에 복잡성과 보일러플레이트가 추가되었습니다.</p>
<p><img src="/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_9.png" alt="이미지"></p>
<p>특히 게임이 여러 씬을 사용하는 경우 이 문제가 악화됩니다. 여러 씬 간의 참조를 해결해야하기 때문에 DontDestroyOnLoad(), 코루틴 및 FindObjectOfType<code>T</code>를 결합하여 사용해야 합니다.</p>
<p>이 추가된 복잡성은 구성 기반 아키텍처의 복잡성과 결합되어 많은 예측할 수 없는 버그를 발생시켰습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*3BLCk1jFCCHxxns9MfhzHQ.gif" alt="image"></p>
<p>GameObject Component는 컴포넌트 간 상호 작용에서 행동이 발생하도록 설계되었습니다. 불행하게도 버그도 발생합니다.</p>
<p>스파게티 패턴과는 달리, 매니저 클래스를 따라가면서 문제를 찾을 수 없습니다. 버그는 특정한 코드 줄에서 발생하는 것이 아니라, 컴포넌트들의 상호 작용에 이상이 있어서 발생하는 것입니다.</p>
<p>문제를 해결하려고 10시간 동안 노력한 후에도 전혀 진전이 없는 것 같았습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*mXQ-sSlR0wSAtb5KPmrJQA.gif" alt="Image"></p>
<h1>30시간째 — 절망의 구렁이와 마주치다</h1>
<p>알게 된 대로, 게임 오브젝트 컴포넌트는 스파게티 코드에 비해 많은 초기 비용이 필요하다. 스파게티 코드로는 게임이 선형적으로 진행되어 경험이 매우 보상적인 결과를 가져온다.</p>
<p>반면, 게임 오브젝트 컴포넌트는 모든 필요한 구성 요소가 실제로 테스트될 수 있을 때까지 존재해야 한다. 'Health.cs' 스크립트가 충분한지 여부를 알기 어렵다. 그 외의 모든 구성 요소와 함께 사용될 때까지는.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 모든 일은 동적으로 생성된 오브젝트를 다루고, 컴포넌트를 풀링하고 재활용하면서 함께 작동하도록 시도하다 보니 결과를 보지 못하는 등 너무 압도되었어요.</p>
<p>그렇게 해서 2개월 동안 개발을 중단했죠.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>게임을 조각조각 다듬는 내 계획은 망가졌어요. 그래서 다른 일들로 넘어가고 게임 오브젝트 컴포넌트는 쓴맛을 남겼어요.</p>
<h1>시간 40 —조합 이해하기</h1>
<p>두 달 동안의 휴식 후, 깨달음이 찾아왔을 때 프로젝트를 끝내려는 결심을 내렸어요. 스파게티 코드 사용을 그만 두었지만, 여전히 스파게티 브레인을 사용하고 있었어요.</p>
<p>게임오브젝트-컴포넌트의 본질은 컴포넌트를 공유하는 데 있어요. '플레이어'와 '적'을 구분하는 것은 이 아키텍처의 정신을 위반해요. 그래서 플레이어와 적이 동일한 컴포넌트에 의존하도록 확실히 했어요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_12.png" alt="이미지"></p>
<p>이전에 '플레이어 이동'과 '적 체력'이 있었습니다. 목표는 구성 요소를 단순화하여 '식별성'이 없어도 존재할 수 있도록하는 것입니다.</p>
<p><img src="/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_13.png" alt="이미지"></p>
<p>10시간의 개발을 버리고 합성 마인드셋으로 리팩토링을 시작했습니다. 이것은 아키텍처에 대한 점점 쌓이는 경험과 결합되어 이 어려움을 극복하고 핵심 게임을 다시 작동시킬 수 있었습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>50시간째 — 보상</h1>
<p>게임을 리팩토링하는 데 처음부터 만드는 시간보다 더 오랜 시간이 걸렸어요. 코드는 더 깔끔해졌지만 정말 그만한 가치가 있었을까요?</p>
<p><img src="/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_14.png" alt="이미지"></p>
<p>지난 포스트에서 언급했듯이 프로젝트 막바지에 진행 상황 바를 구현하는 데 5시간이 걸렸는데, 이번에는 단 25분만에 완료했어요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>테이블 태그를 마크다운 형식으로 변경했습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>게임 오브젝트-컴포넌트는 처음에는 개발 속도가 느렸지만, 유지보수성과 확장성에서 그 가치를 입증합니다. 유니티 에디터와의 원활한 통합과 코드의 내재적 "깔끔함"은 부정할 수 없는 장점입니다.</p>
<p><img src="/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_15.png" alt="GameObject-Component"></p>
<p>그렇다면 최고의 아키텍처인가요?</p>
<p>아니요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 패턴은 주의 깊은 계획, Unity에 대한 심층적인 이해 및 정교한 종속성 관리를 필요로 합니다. 짜증나는 버그 발생과 혜택 대비 비용이 높다는 이유 때문에 많은 개발자들이 이를 사용하지 않는 것일 수 있습니다.</p>
<p>그렇지만, 이 패턴에서 요소들을 통합하면 스파게티 코드 기반 프로젝트를 크게 향상시킬 수 있으며, 최종적인 리팩터링이 덜 괴로운 경험을 할 수 있습니다.</p>
<p>만약 해당 하이브리드의 예시를 보고 싶다면, 게임 SoulStone Survivors의 역컴파일을 확인해보세요.</p>
<p>또는 해당 패턴과 스파게티 패턴의 전체 소스 코드를 github에서 확인할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그것에 대해 더 나은 해결책이 존재하는지에 대해 고민하게 만듭니다.</p>
<p>Scriptable Object Pattern에 대하여 자세히 살펴보고 리팩터링할 때 발견할 것입니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Unity 아키텍처 GameObject 컴포넌트 패턴 이해하기","description":"","date":"2024-06-23 22:21","slug":"2024-06-23-UnityArchitectureGameObjectComponentPattern","content":"\n지난 블로그 글에서는 \"스파게티 패턴\"에 대해 살펴보았습니다. 이는 아무런 패턴이 없는 게임을 묘사하기 위해 사용되는 농담적인 용어입니다.\n\n많은 신규 개발자들이 이를 선택하는 이유는 게임을 빠르고 쉽게 제작할 수 있다는 점 때문입니다. 하지만 이후에 자신의 지식을 확장하지 못하는 경우가 많습니다.\n\n프로토타입을 만드는 데 뛰어난 장점이 있지만, 코드가 엉망으로 변하여 어수선하고 복잡한 코드 구조로 이어질 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러한 코드베이스는 긴, 엉킨 메소드, 싱글톤 게임 매니저와 같은 \"God Objects\"에 지나치게 의존하며, 각 새로운 기능이 추가될 때마다 증가하는 끝없는 버그 나열로 악명높습니다.\n\n다행히도, 이러한 문제 중 많은 것을 해결해 줄 수 있는 패턴 중 하나는 GameObject-Component Pattern이며, 이는 Unity의 원래 비전이자 Unity Editor의 공식 프레임워크입니다.\n\n이 패턴은 큰 \"God Objects\"를 더 작고 모듈식 컴포넌트로 분해함으로써 이런 문제들을 해결합니다. 이렇게 하면 새 코드를 작성하지 않고도 GameObject에서 컴포넌트를 쉽게 추가, 수정 또는 제거할 수 있습니다. 본 이론에 따르면, 더 유연하고 유지 보수가 쉬운 코드베이스로 이끌어줄 것입니다.\n\n![Unity Architecture GameObject Component Pattern](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래서, 이 패턴이 정말 멋져 보인다면 왜 아무도 사용하지 않는 것 같은걸까요? 심지어 Unity조차 이를 버리고 Scriptable Objects와 ECS를 선호합니다.\n\n나는 '스파게티 프로토타입'을 50시간 이상 리팩토링하여 GameObject Component를 모든 면에서 완전히 활용하고, 그 장점과 약점을 발견했습니다.\n\n# 시간 0 — 게임 매니저의 종말\n\n내 게시물을 따라오신다면 게임 매니저에 대한 절규를 들어볼 수 있을 텐데, 그들은 종종 스파게티 코드베이스에 대한 징후라는 점입니다. 그러므로 그것이 필요 없다는 것을 증명하기 위해 우리는 그것을 삭제할 겁니다.\n\n![이미지](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 매니저가 객체들에게 무엇을 해야 하는지 말하지 않고 게임의 흐름을 어떻게 제어할까요?\n\n우리는 새로운 코딩 개념을 소개해야 합니다. 이벤트입니다.\n\n이벤트는 응용 프로그램에서 제어 흐름의 방향을 반대로 전환할 수 있습니다. 다른 객체들에게 매니저가 지시하는 대신, 이러한 객체들은 매니저의 변화에 반응하는 방식으로 동작합니다.\n\n![Unity Architecture](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이벤트를 사용하면 게임 매니저에서 모든 종속성을 제거하여 대부분의 기능을 제거할 수 있습니다. 그럼으로써, 남은 데이터를 몇 가지 간단한 구성 요소로 분해할 수 있습니다. 예를 들어, 게임 상태와 같은 핵심 이벤트를 담는 컨테이너입니다.\n\n![이미지](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_3.png)\n\n# 2시간 — 캡슐화\n\n이러한 경향을 이어가며, 코드를 깨끗하게 유지하기 위해 클래스가 적절하게 캡슐화되어야 한다는 것이 중요하다는 것을 알았습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 코드를 개선하는 가장 간단한 방법은 serialize field 속성을 사용하는 것입니다. 이렇게 함으로써 클래스가 자신의 데이터에 대한 단일 권한 출처로 유지되도록 할 수 있습니다.\n\n```js\n// 나쁨. 캡슐화 깨짐.\npublic int currentHealth;\n\n// 좋음. 캡슐화 유지.\n[SerializeField]\nprivate int currentHealth;\n\n// 좋음. 읽기 전용 액세스 제공하면서 캡슐화 유지.\n[field:SerializeField]\npublic int currentHealth { get; private set; }\n```\n\n유니티 이벤트는 또 다른 중요한 도구로, 에디터에 깊게 내장되어 있으며, 컴포넌트들 간의 결합을 느슨하게 할 수 있습니다.\n\n예를 들어, 플레이어와 적이 동일한 Death Handler 컴포넌트를 사용하지만 전혀 새로운 코드 없이 새로운 동작을 만들어낼 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_4.png\" /\u003e\n\n그러나 이 코드 의존성 부족은 두날날날날 모낫날剌몫몿 때날이카. Unity Events를 과도하게 사용하면 성능 문제가 발생할 수 있으며 에디터에서 시간이 오래 걸리는 수동 설정으로 이어질 수 있습니다.\n\n이러한 이유로, 자주 발생하거나 중요한 게임 이벤트에 대해 고전적인 C# 동작을 사용했습니다.\n\n마지막으로, Gold와 Achievements와 같은 구성 요소는 싱글톤 계정 관리자에 의존하는 대신 자체 저장 데이터를 처리하도록 했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n리팩토링은 튼튼한 시작을 했어요.\n\n# 7시간 - 성능\n\n대규모 게임에 대한 확장성과 유지 관리성이 중요하지만 성능도 그렇습니다. GameObject-Component 자체는 스파게티보다 빠르지 않습니다 (사실 느릴 수도 있음), 그러나 리팩토링의 정신에 따라 이러한 문제를 해결해야 합니다.\n\n가장 중요한 기술은 Object Pooling의 사용입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n총알, 체력 팩, 입자 및 적을 생성하고 제거하는 과정으로 인해 Garbage Collector가 엄청난 스트레스를 받고 fps에 영향을 줍니다.\n\n그렇기 때문에 이러한 객체들을 파괴하는 대신 재활용하는 것이 해결책입니다.\n\n```js\n/* 컴포넌트는 풀에서 객체를 '빌려오고' 작업을 마치면 돌려놓을 수 있음.\n   현재 사용 중인 객체가 없는 경우에만 새 객체가 생성됨. */\npublic class GameObjectPool : MonoBehaviour\n{\n  [SerializeField] private GameObject prefab;\n  private readonly Queue\u003cGameObject\u003e _inactivePool = new();\n\n  public GameObject Get()\n  {\n    return _inactivePool.Count \u003e 0 ?\n           _inactivePool.Dequeue() :\n           Instantiate(prefab, null);\n  }\n\n  public void Return(GameObject item)\n  {\n    item.SetActive(false);\n    _inactivePool.Enqueue(item);\n  }\n}\n```\n\n이 기술은 발사체, 적, 입자 효과, 오디오 소스 및 모든 UI 요소(피해 수치와 같은)를 단일 캔버스로 통합함으로써 성능을 향상시켰습니다. 제어된 스트레스 테스트로 60FPS에서 100FPS로 최대 66%의 성능 향상을 달성했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 시간 10 — 의존성 그래프 수정하기.\n\n스파게티 패턴에 대한 내 정의 중 하나는 구성 요소 사이에 교차하는 선들의 웹을 만들지 않고는 시각화할 수없는 의존성 그래프였습니다.\n\n이러한 문제를 피하는 간단한 묘수는 구상 대신 구체적인 참조에 의존하는 대신 추상화에 의존하는 것입니다. 특히 이 경우에서는 상속을 사용하여.\n\n![Unity Architecture Game Object Component Pattern](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n게임 상태에 의존하는 구성 요소가 모두 GamePlayComponent 클래스에서 상속되도록 보장하면 이러한 동작을 체크하고도 직접적으로 참조하지 않고도 무차별적인 상태 관리를 할 수 있습니다.\n\n이 기술은 사용자 인터페이스를 분리하는 데 다시 사용되었습니다. 스파게티 코드에서 흔한 문제는 게임이 올바르게 작동하려면 UI에 대한 강력한 의존성이 필요하다는 것입니다. 개발자로서 UI 없이도 스크립트, 콘솔 명령 또는 API를 통해 게임의 어떤 상태든 액세스할 수 있어야 합니다.\n\n![이미지](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_6.png)\n\n![이미지](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_7.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 20시간 — 싱글턴 제거하기\n\n안녕하세요! 싱글턴은 악이 아니지만, 많은 개발자들이 과도하게 의존하고 있습니다. 대안을 제대로 탐색하기 위해 이 리팩토링에서는 싱글턴을 삭제하기로 결정했습니다.\n\n이것은 씬에 직렬화된 객체에 대해서는 쉽게 할 수 있습니다. 그러나 동적으로 생성된 프리팹들은 도전을 제공합니다. 프리팹은 씬 객체를 참조할 수 없습니다. 이 문제를 해결하기 위해 팩토리 패턴을 사용해야 합니다.\n\n![이미지](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_8.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n공장은 생성될 때 프리팹의 종속성을 주입합니다. 이는 새로운 오브젝트 풀과 잘 작동합니다. 이로 인해 싱글톤이 필요 없어졌지만, 코드에 복잡성과 보일러플레이트가 추가되었습니다.\n\n![이미지](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_9.png)\n\n특히 게임이 여러 씬을 사용하는 경우 이 문제가 악화됩니다. 여러 씬 간의 참조를 해결해야하기 때문에 DontDestroyOnLoad(), 코루틴 및 FindObjectOfType`T`를 결합하여 사용해야 합니다.\n\n이 추가된 복잡성은 구성 기반 아키텍처의 복잡성과 결합되어 많은 예측할 수 없는 버그를 발생시켰습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*3BLCk1jFCCHxxns9MfhzHQ.gif)\n\nGameObject Component는 컴포넌트 간 상호 작용에서 행동이 발생하도록 설계되었습니다. 불행하게도 버그도 발생합니다.\n\n스파게티 패턴과는 달리, 매니저 클래스를 따라가면서 문제를 찾을 수 없습니다. 버그는 특정한 코드 줄에서 발생하는 것이 아니라, 컴포넌트들의 상호 작용에 이상이 있어서 발생하는 것입니다.\n\n문제를 해결하려고 10시간 동안 노력한 후에도 전혀 진전이 없는 것 같았습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*mXQ-sSlR0wSAtb5KPmrJQA.gif)\n\n# 30시간째 — 절망의 구렁이와 마주치다\n\n알게 된 대로, 게임 오브젝트 컴포넌트는 스파게티 코드에 비해 많은 초기 비용이 필요하다. 스파게티 코드로는 게임이 선형적으로 진행되어 경험이 매우 보상적인 결과를 가져온다.\n\n반면, 게임 오브젝트 컴포넌트는 모든 필요한 구성 요소가 실제로 테스트될 수 있을 때까지 존재해야 한다. 'Health.cs' 스크립트가 충분한지 여부를 알기 어렵다. 그 외의 모든 구성 요소와 함께 사용될 때까지는.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 모든 일은 동적으로 생성된 오브젝트를 다루고, 컴포넌트를 풀링하고 재활용하면서 함께 작동하도록 시도하다 보니 결과를 보지 못하는 등 너무 압도되었어요.\n\n그렇게 해서 2개월 동안 개발을 중단했죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n게임을 조각조각 다듬는 내 계획은 망가졌어요. 그래서 다른 일들로 넘어가고 게임 오브젝트 컴포넌트는 쓴맛을 남겼어요.\n\n# 시간 40 —조합 이해하기\n\n두 달 동안의 휴식 후, 깨달음이 찾아왔을 때 프로젝트를 끝내려는 결심을 내렸어요. 스파게티 코드 사용을 그만 두었지만, 여전히 스파게티 브레인을 사용하고 있었어요.\n\n게임오브젝트-컴포넌트의 본질은 컴포넌트를 공유하는 데 있어요. '플레이어'와 '적'을 구분하는 것은 이 아키텍처의 정신을 위반해요. 그래서 플레이어와 적이 동일한 컴포넌트에 의존하도록 확실히 했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_12.png)\n\n이전에 '플레이어 이동'과 '적 체력'이 있었습니다. 목표는 구성 요소를 단순화하여 '식별성'이 없어도 존재할 수 있도록하는 것입니다.\n\n![이미지](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_13.png)\n\n10시간의 개발을 버리고 합성 마인드셋으로 리팩토링을 시작했습니다. 이것은 아키텍처에 대한 점점 쌓이는 경험과 결합되어 이 어려움을 극복하고 핵심 게임을 다시 작동시킬 수 있었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 50시간째 — 보상\n\n게임을 리팩토링하는 데 처음부터 만드는 시간보다 더 오랜 시간이 걸렸어요. 코드는 더 깔끔해졌지만 정말 그만한 가치가 있었을까요?\n\n![이미지](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_14.png)\n\n지난 포스트에서 언급했듯이 프로젝트 막바지에 진행 상황 바를 구현하는 데 5시간이 걸렸는데, 이번에는 단 25분만에 완료했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n게임 오브젝트-컴포넌트는 처음에는 개발 속도가 느렸지만, 유지보수성과 확장성에서 그 가치를 입증합니다. 유니티 에디터와의 원활한 통합과 코드의 내재적 \"깔끔함\"은 부정할 수 없는 장점입니다.\n\n![GameObject-Component](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_15.png)\n\n그렇다면 최고의 아키텍처인가요?\n\n아니요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 패턴은 주의 깊은 계획, Unity에 대한 심층적인 이해 및 정교한 종속성 관리를 필요로 합니다. 짜증나는 버그 발생과 혜택 대비 비용이 높다는 이유 때문에 많은 개발자들이 이를 사용하지 않는 것일 수 있습니다.\n\n그렇지만, 이 패턴에서 요소들을 통합하면 스파게티 코드 기반 프로젝트를 크게 향상시킬 수 있으며, 최종적인 리팩터링이 덜 괴로운 경험을 할 수 있습니다.\n\n만약 해당 하이브리드의 예시를 보고 싶다면, 게임 SoulStone Survivors의 역컴파일을 확인해보세요.\n\n또는 해당 패턴과 스파게티 패턴의 전체 소스 코드를 github에서 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그것에 대해 더 나은 해결책이 존재하는지에 대해 고민하게 만듭니다.\n\nScriptable Object Pattern에 대하여 자세히 살펴보고 리팩터링할 때 발견할 것입니다.\n","ogImage":{"url":"/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_0.png"},"coverImage":"/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_0.png","tag":["Tech"],"readingTime":14},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e지난 블로그 글에서는 \"스파게티 패턴\"에 대해 살펴보았습니다. 이는 아무런 패턴이 없는 게임을 묘사하기 위해 사용되는 농담적인 용어입니다.\u003c/p\u003e\n\u003cp\u003e많은 신규 개발자들이 이를 선택하는 이유는 게임을 빠르고 쉽게 제작할 수 있다는 점 때문입니다. 하지만 이후에 자신의 지식을 확장하지 못하는 경우가 많습니다.\u003c/p\u003e\n\u003cp\u003e프로토타입을 만드는 데 뛰어난 장점이 있지만, 코드가 엉망으로 변하여 어수선하고 복잡한 코드 구조로 이어질 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그러한 코드베이스는 긴, 엉킨 메소드, 싱글톤 게임 매니저와 같은 \"God Objects\"에 지나치게 의존하며, 각 새로운 기능이 추가될 때마다 증가하는 끝없는 버그 나열로 악명높습니다.\u003c/p\u003e\n\u003cp\u003e다행히도, 이러한 문제 중 많은 것을 해결해 줄 수 있는 패턴 중 하나는 GameObject-Component Pattern이며, 이는 Unity의 원래 비전이자 Unity Editor의 공식 프레임워크입니다.\u003c/p\u003e\n\u003cp\u003e이 패턴은 큰 \"God Objects\"를 더 작고 모듈식 컴포넌트로 분해함으로써 이런 문제들을 해결합니다. 이렇게 하면 새 코드를 작성하지 않고도 GameObject에서 컴포넌트를 쉽게 추가, 수정 또는 제거할 수 있습니다. 본 이론에 따르면, 더 유연하고 유지 보수가 쉬운 코드베이스로 이끌어줄 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_0.png\" alt=\"Unity Architecture GameObject Component Pattern\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그래서, 이 패턴이 정말 멋져 보인다면 왜 아무도 사용하지 않는 것 같은걸까요? 심지어 Unity조차 이를 버리고 Scriptable Objects와 ECS를 선호합니다.\u003c/p\u003e\n\u003cp\u003e나는 '스파게티 프로토타입'을 50시간 이상 리팩토링하여 GameObject Component를 모든 면에서 완전히 활용하고, 그 장점과 약점을 발견했습니다.\u003c/p\u003e\n\u003ch1\u003e시간 0 — 게임 매니저의 종말\u003c/h1\u003e\n\u003cp\u003e내 게시물을 따라오신다면 게임 매니저에 대한 절규를 들어볼 수 있을 텐데, 그들은 종종 스파게티 코드베이스에 대한 징후라는 점입니다. 그러므로 그것이 필요 없다는 것을 증명하기 위해 우리는 그것을 삭제할 겁니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그러나 매니저가 객체들에게 무엇을 해야 하는지 말하지 않고 게임의 흐름을 어떻게 제어할까요?\u003c/p\u003e\n\u003cp\u003e우리는 새로운 코딩 개념을 소개해야 합니다. 이벤트입니다.\u003c/p\u003e\n\u003cp\u003e이벤트는 응용 프로그램에서 제어 흐름의 방향을 반대로 전환할 수 있습니다. 다른 객체들에게 매니저가 지시하는 대신, 이러한 객체들은 매니저의 변화에 반응하는 방식으로 동작합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_2.png\" alt=\"Unity Architecture\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이벤트를 사용하면 게임 매니저에서 모든 종속성을 제거하여 대부분의 기능을 제거할 수 있습니다. 그럼으로써, 남은 데이터를 몇 가지 간단한 구성 요소로 분해할 수 있습니다. 예를 들어, 게임 상태와 같은 핵심 이벤트를 담는 컨테이너입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e2시간 — 캡슐화\u003c/h1\u003e\n\u003cp\u003e이러한 경향을 이어가며, 코드를 깨끗하게 유지하기 위해 클래스가 적절하게 캡슐화되어야 한다는 것이 중요하다는 것을 알았습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우리 코드를 개선하는 가장 간단한 방법은 serialize field 속성을 사용하는 것입니다. 이렇게 함으로써 클래스가 자신의 데이터에 대한 단일 권한 출처로 유지되도록 할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 나쁨. 캡슐화 깨짐.\u003c/span\u003e\npublic int currentHealth;\n\n\u003cspan class=\"hljs-comment\"\u003e// 좋음. 캡슐화 유지.\u003c/span\u003e\n[\u003cspan class=\"hljs-title class_\"\u003eSerializeField\u003c/span\u003e]\nprivate int currentHealth;\n\n\u003cspan class=\"hljs-comment\"\u003e// 좋음. 읽기 전용 액세스 제공하면서 캡슐화 유지.\u003c/span\u003e\n[\u003cspan class=\"hljs-attr\"\u003efield\u003c/span\u003e:\u003cspan class=\"hljs-title class_\"\u003eSerializeField\u003c/span\u003e]\npublic int currentHealth { get; private set; }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e유니티 이벤트는 또 다른 중요한 도구로, 에디터에 깊게 내장되어 있으며, 컴포넌트들 간의 결합을 느슨하게 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 플레이어와 적이 동일한 Death Handler 컴포넌트를 사용하지만 전혀 새로운 코드 없이 새로운 동작을 만들어낼 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_4.png\"\u003e\n\u003cp\u003e그러나 이 코드 의존성 부족은 두날날날날 모낫날剌몫몿 때날이카. Unity Events를 과도하게 사용하면 성능 문제가 발생할 수 있으며 에디터에서 시간이 오래 걸리는 수동 설정으로 이어질 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이러한 이유로, 자주 발생하거나 중요한 게임 이벤트에 대해 고전적인 C# 동작을 사용했습니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, Gold와 Achievements와 같은 구성 요소는 싱글톤 계정 관리자에 의존하는 대신 자체 저장 데이터를 처리하도록 했습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e리팩토링은 튼튼한 시작을 했어요.\u003c/p\u003e\n\u003ch1\u003e7시간 - 성능\u003c/h1\u003e\n\u003cp\u003e대규모 게임에 대한 확장성과 유지 관리성이 중요하지만 성능도 그렇습니다. GameObject-Component 자체는 스파게티보다 빠르지 않습니다 (사실 느릴 수도 있음), 그러나 리팩토링의 정신에 따라 이러한 문제를 해결해야 합니다.\u003c/p\u003e\n\u003cp\u003e가장 중요한 기술은 Object Pooling의 사용입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e총알, 체력 팩, 입자 및 적을 생성하고 제거하는 과정으로 인해 Garbage Collector가 엄청난 스트레스를 받고 fps에 영향을 줍니다.\u003c/p\u003e\n\u003cp\u003e그렇기 때문에 이러한 객체들을 파괴하는 대신 재활용하는 것이 해결책입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* 컴포넌트는 풀에서 객체를 '빌려오고' 작업을 마치면 돌려놓을 수 있음.\n   현재 사용 중인 객체가 없는 경우에만 새 객체가 생성됨. */\u003c/span\u003e\npublic \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGameObjectPool\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eMonoBehaviour\u003c/span\u003e\n{\n  [\u003cspan class=\"hljs-title class_\"\u003eSerializeField\u003c/span\u003e] private \u003cspan class=\"hljs-title class_\"\u003eGameObject\u003c/span\u003e prefab;\n  private readonly \u003cspan class=\"hljs-title class_\"\u003eQueue\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eGameObject\u003c/span\u003e\u003e _inactivePool = \u003cspan class=\"hljs-title function_\"\u003enew\u003c/span\u003e();\n\n  public \u003cspan class=\"hljs-title class_\"\u003eGameObject\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGet\u003c/span\u003e()\n  {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e _inactivePool.\u003cspan class=\"hljs-property\"\u003eCount\u003c/span\u003e \u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e ?\n           _inactivePool.\u003cspan class=\"hljs-title class_\"\u003eDequeue\u003c/span\u003e() :\n           \u003cspan class=\"hljs-title class_\"\u003eInstantiate\u003c/span\u003e(prefab, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n  }\n\n  public \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReturn\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eGameObject\u003c/span\u003e item)\n  {\n    item.\u003cspan class=\"hljs-title class_\"\u003eSetActive\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n    _inactivePool.\u003cspan class=\"hljs-title class_\"\u003eEnqueue\u003c/span\u003e(item);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 기술은 발사체, 적, 입자 효과, 오디오 소스 및 모든 UI 요소(피해 수치와 같은)를 단일 캔버스로 통합함으로써 성능을 향상시켰습니다. 제어된 스트레스 테스트로 60FPS에서 100FPS로 최대 66%의 성능 향상을 달성했습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e시간 10 — 의존성 그래프 수정하기.\u003c/h1\u003e\n\u003cp\u003e스파게티 패턴에 대한 내 정의 중 하나는 구성 요소 사이에 교차하는 선들의 웹을 만들지 않고는 시각화할 수없는 의존성 그래프였습니다.\u003c/p\u003e\n\u003cp\u003e이러한 문제를 피하는 간단한 묘수는 구상 대신 구체적인 참조에 의존하는 대신 추상화에 의존하는 것입니다. 특히 이 경우에서는 상속을 사용하여.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_5.png\" alt=\"Unity Architecture Game Object Component Pattern\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e게임 상태에 의존하는 구성 요소가 모두 GamePlayComponent 클래스에서 상속되도록 보장하면 이러한 동작을 체크하고도 직접적으로 참조하지 않고도 무차별적인 상태 관리를 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 기술은 사용자 인터페이스를 분리하는 데 다시 사용되었습니다. 스파게티 코드에서 흔한 문제는 게임이 올바르게 작동하려면 UI에 대한 강력한 의존성이 필요하다는 것입니다. 개발자로서 UI 없이도 스크립트, 콘솔 명령 또는 API를 통해 게임의 어떤 상태든 액세스할 수 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_7.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e20시간 — 싱글턴 제거하기\u003c/h1\u003e\n\u003cp\u003e안녕하세요! 싱글턴은 악이 아니지만, 많은 개발자들이 과도하게 의존하고 있습니다. 대안을 제대로 탐색하기 위해 이 리팩토링에서는 싱글턴을 삭제하기로 결정했습니다.\u003c/p\u003e\n\u003cp\u003e이것은 씬에 직렬화된 객체에 대해서는 쉽게 할 수 있습니다. 그러나 동적으로 생성된 프리팹들은 도전을 제공합니다. 프리팹은 씬 객체를 참조할 수 없습니다. 이 문제를 해결하기 위해 팩토리 패턴을 사용해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_8.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e공장은 생성될 때 프리팹의 종속성을 주입합니다. 이는 새로운 오브젝트 풀과 잘 작동합니다. 이로 인해 싱글톤이 필요 없어졌지만, 코드에 복잡성과 보일러플레이트가 추가되었습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_9.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e특히 게임이 여러 씬을 사용하는 경우 이 문제가 악화됩니다. 여러 씬 간의 참조를 해결해야하기 때문에 DontDestroyOnLoad(), 코루틴 및 FindObjectOfType\u003ccode\u003eT\u003c/code\u003e를 결합하여 사용해야 합니다.\u003c/p\u003e\n\u003cp\u003e이 추가된 복잡성은 구성 기반 아키텍처의 복잡성과 결합되어 많은 예측할 수 없는 버그를 발생시켰습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*3BLCk1jFCCHxxns9MfhzHQ.gif\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eGameObject Component는 컴포넌트 간 상호 작용에서 행동이 발생하도록 설계되었습니다. 불행하게도 버그도 발생합니다.\u003c/p\u003e\n\u003cp\u003e스파게티 패턴과는 달리, 매니저 클래스를 따라가면서 문제를 찾을 수 없습니다. 버그는 특정한 코드 줄에서 발생하는 것이 아니라, 컴포넌트들의 상호 작용에 이상이 있어서 발생하는 것입니다.\u003c/p\u003e\n\u003cp\u003e문제를 해결하려고 10시간 동안 노력한 후에도 전혀 진전이 없는 것 같았습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*mXQ-sSlR0wSAtb5KPmrJQA.gif\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003ch1\u003e30시간째 — 절망의 구렁이와 마주치다\u003c/h1\u003e\n\u003cp\u003e알게 된 대로, 게임 오브젝트 컴포넌트는 스파게티 코드에 비해 많은 초기 비용이 필요하다. 스파게티 코드로는 게임이 선형적으로 진행되어 경험이 매우 보상적인 결과를 가져온다.\u003c/p\u003e\n\u003cp\u003e반면, 게임 오브젝트 컴포넌트는 모든 필요한 구성 요소가 실제로 테스트될 수 있을 때까지 존재해야 한다. 'Health.cs' 스크립트가 충분한지 여부를 알기 어렵다. 그 외의 모든 구성 요소와 함께 사용될 때까지는.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 모든 일은 동적으로 생성된 오브젝트를 다루고, 컴포넌트를 풀링하고 재활용하면서 함께 작동하도록 시도하다 보니 결과를 보지 못하는 등 너무 압도되었어요.\u003c/p\u003e\n\u003cp\u003e그렇게 해서 2개월 동안 개발을 중단했죠.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e게임을 조각조각 다듬는 내 계획은 망가졌어요. 그래서 다른 일들로 넘어가고 게임 오브젝트 컴포넌트는 쓴맛을 남겼어요.\u003c/p\u003e\n\u003ch1\u003e시간 40 —조합 이해하기\u003c/h1\u003e\n\u003cp\u003e두 달 동안의 휴식 후, 깨달음이 찾아왔을 때 프로젝트를 끝내려는 결심을 내렸어요. 스파게티 코드 사용을 그만 두었지만, 여전히 스파게티 브레인을 사용하고 있었어요.\u003c/p\u003e\n\u003cp\u003e게임오브젝트-컴포넌트의 본질은 컴포넌트를 공유하는 데 있어요. '플레이어'와 '적'을 구분하는 것은 이 아키텍처의 정신을 위반해요. 그래서 플레이어와 적이 동일한 컴포넌트에 의존하도록 확실히 했어요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_12.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이전에 '플레이어 이동'과 '적 체력'이 있었습니다. 목표는 구성 요소를 단순화하여 '식별성'이 없어도 존재할 수 있도록하는 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_13.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e10시간의 개발을 버리고 합성 마인드셋으로 리팩토링을 시작했습니다. 이것은 아키텍처에 대한 점점 쌓이는 경험과 결합되어 이 어려움을 극복하고 핵심 게임을 다시 작동시킬 수 있었습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e50시간째 — 보상\u003c/h1\u003e\n\u003cp\u003e게임을 리팩토링하는 데 처음부터 만드는 시간보다 더 오랜 시간이 걸렸어요. 코드는 더 깔끔해졌지만 정말 그만한 가치가 있었을까요?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_14.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e지난 포스트에서 언급했듯이 프로젝트 막바지에 진행 상황 바를 구현하는 데 5시간이 걸렸는데, 이번에는 단 25분만에 완료했어요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e테이블 태그를 마크다운 형식으로 변경했습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e게임 오브젝트-컴포넌트는 처음에는 개발 속도가 느렸지만, 유지보수성과 확장성에서 그 가치를 입증합니다. 유니티 에디터와의 원활한 통합과 코드의 내재적 \"깔끔함\"은 부정할 수 없는 장점입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_15.png\" alt=\"GameObject-Component\"\u003e\u003c/p\u003e\n\u003cp\u003e그렇다면 최고의 아키텍처인가요?\u003c/p\u003e\n\u003cp\u003e아니요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 패턴은 주의 깊은 계획, Unity에 대한 심층적인 이해 및 정교한 종속성 관리를 필요로 합니다. 짜증나는 버그 발생과 혜택 대비 비용이 높다는 이유 때문에 많은 개발자들이 이를 사용하지 않는 것일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그렇지만, 이 패턴에서 요소들을 통합하면 스파게티 코드 기반 프로젝트를 크게 향상시킬 수 있으며, 최종적인 리팩터링이 덜 괴로운 경험을 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e만약 해당 하이브리드의 예시를 보고 싶다면, 게임 SoulStone Survivors의 역컴파일을 확인해보세요.\u003c/p\u003e\n\u003cp\u003e또는 해당 패턴과 스파게티 패턴의 전체 소스 코드를 github에서 확인할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그것에 대해 더 나은 해결책이 존재하는지에 대해 고민하게 만듭니다.\u003c/p\u003e\n\u003cp\u003eScriptable Object Pattern에 대하여 자세히 살펴보고 리팩터링할 때 발견할 것입니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-UnityArchitectureGameObjectComponentPattern"},"buildId":"T_Nz0g9U1yttYMSEma95P","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>