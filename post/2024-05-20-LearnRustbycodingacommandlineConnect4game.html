<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Rust로 코딩하는 커맨드 라인 Connect 4 게임 배우기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-20-LearnRustbycodingacommandlineConnect4game" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Rust로 코딩하는 커맨드 라인 Connect 4 게임 배우기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Rust로 코딩하는 커맨드 라인 Connect 4 게임 배우기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-20-LearnRustbycodingacommandlineConnect4game" data-gatsby-head="true"/><meta name="twitter:title" content="Rust로 코딩하는 커맨드 라인 Connect 4 게임 배우기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-20 16:00" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-561ae49ab5aab7f5.js" defer=""></script><script src="/_next/static/0asLlD6on3tm8cIfzBaxd/_buildManifest.js" defer=""></script><script src="/_next/static/0asLlD6on3tm8cIfzBaxd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Rust로 코딩하는 커맨드 라인 Connect 4 게임 배우기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Rust로 코딩하는 커맨드 라인 Connect 4 게임 배우기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 20, 2024</span><span class="posts_reading_time__f7YPP">18<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-20-LearnRustbycodingacommandlineConnect4game&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p><img src="/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png" alt="Rust Connect 4"/></p>
<p>안녕하세요! 이번 글에서는 Rust가 어떻게 우리가 Connect 4의 간단한 버전을 만들며 명령줄 응용 프로그램을 작성하는 데 도움이 되는지 살펴볼 거에요.</p>
<p>최근 Rust를 배우는 도전에 도전했고, 제 자신의 조언을 따르기 위해 개인 프로젝트에서 Rust를 사용해 손을 더럽히며 배운 것을 정리하려고 노력하고 있어요. Connect 4는 아주 좋은 도전 과제에요. 오후 하루 동안 코딩할 수 있는 것은 간단하지만 잘 하려면 약간의 생각이 필요한 복잡한 문제이죠.</p>
<p>여기 제 마지막 결과물이 포함된 Rust 플레이그라운드가 있어요. 아래에서는 거기에 이르기까지 취한 정확한 단계를 살펴볼 거에요. 따라오고 싶으시면 Rust가 설치되어 있는지 확인한 후 터미널에서 <code>cargo new rust_connect_4_tutorial</code>을 실행해서 프로젝트를 열고 좋아하는 편집기에서 src/main.rs로 이동해서 시작해봐요!</p>
<div class="content-ad"></div>
<p>혹은 비디오를 통해 학습하는 것을 선호한다면, 해당 튜토리얼의 비디오 버전을 확인해보세요:</p>
<h1>우리의 타입 정의하기</h1>
<p>Rust에서 시작하는 가장 좋은 방법 중 하나는 종종 우리의 타입을 정의하는 것이므로, 우리는 정확히 그것을 할 것입니다!</p>
<p>먼저, 게임에 사용할 보드를 정의해 보겠습니다. Connect 4의 클래식 버전은 7개의 슬롯이 가로로 있고 6개의 슬롯이 세로로 있기 때문에, 이들 정수를 상수로 저장하고, 그 상수를 사용하여 두 차원 배열의 길이를 정의하는 데 사용할 수 있습니다. Board 타입으로 정의합니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-rust"><span class="hljs-keyword">const</span> BOARD_WIDTH: <span class="hljs-type">usize</span> = <span class="hljs-number">7</span>;
<span class="hljs-keyword">const</span> BOARD_HEIGHT: <span class="hljs-type">usize</span> = <span class="hljs-number">6</span>;

<span class="hljs-keyword">type</span> <span class="hljs-title class_">Board</span> = [[<span class="hljs-type">u8</span>; BOARD_WIDTH]; BOARD_HEIGHT];
</code></pre>
<p>플레이어를 추적할 방법이 필요할 것입니다. 이를 enum으로 구현할 수 있습니다. 우리는 두 명의 플레이어만 지원하지만, 한 명의 피스가 없는 슬롯을 나타내는 None 변형과 게임이 무승부로 끝날 때 처리하는 데 유용할 것입니다.</p>
<pre><code class="hljs language-rust"><span class="hljs-meta">#[derive(Clone, Copy, Debug, PartialEq)]</span>
<span class="hljs-meta">#[repr(u8)]</span>
<span class="hljs-keyword">enum</span> <span class="hljs-title class_">Player</span> {
    One = <span class="hljs-number">1</span>,
    Two = <span class="hljs-number">2</span>,
    <span class="hljs-literal">None</span> = <span class="hljs-number">0</span>,
}
</code></pre>
<p>위에서는 나중에 유용할 몇 가지 트레잇을 구현하기 위해 derive를 사용하고, enum의 메모리 레이아웃을 제어하기 위해 repr을 사용했습니다. 가능한 모든 값을 알기 때문에 u8로 제한할 수 있습니다.```</p>
<div class="content-ad"></div>
<p>다음으로, 우리는 게임을 나타내는 struct를 만들 것입니다. 여기에는 추적해야 할 모든 상태가 포함될 것입니다.</p>
<pre><code class="hljs language-javascript">struct <span class="hljs-title class_">Game</span> {
    <span class="hljs-attr">current_move</span>: u8,
    <span class="hljs-attr">current_player</span>: <span class="hljs-title class_">Player</span>,
    <span class="hljs-attr">board</span>: <span class="hljs-title class_">Board</span>,
    <span class="hljs-attr">is_finished</span>: bool,
    <span class="hljs-attr">winner</span>: <span class="hljs-title class_">Player</span>,
}
</code></pre>
<p>current_move는 플레이어가 선택한 열을 나타내는 정수입니다. 우리에게는 승자 필드가 있지만, 게임이 비김으로 끝날 때 별도로 is_finished 부울도 유용할 것입니다!</p>
<p>마지막으로, Game에 대한 기본 함수를 구현할 것입니다. 이 함수에는 초기 상태가 포함될 것입니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Game</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">default</span>() <span class="hljs-punctuation">-&gt;</span> Game {
        Game {
            current_move: <span class="hljs-number">0</span>,
            current_player: Player::One,
            board: [
                [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
                [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
                [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
                [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
                [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
                [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
            ],
            is_finished: <span class="hljs-literal">false</span>,
            winner: Player::<span class="hljs-literal">None</span>,
        }
    }
}
</code></pre>
<p>보드에 대해 조금 이야기해 봅시다. 여기서 0은 빈 칸을 나타내며, 1은 Player One이 차지한 칸을 나타내고, 2는 Player Two가 차지한 칸을 나타냅니다.</p>
<p>BOARD_WIDTH와 BOARD_HEIGHT를 사용하여 동적으로 생성할 수도 있었지만, 코드를 작성하는 동안 전체 배열을 보는 것이 도움이 되는 시각적 도구라는 것을 발견했습니다. 같은 이유로, 정수가 아닌 Player 열거형을 사용하지 않았습니다. 텍스트가 더 많아지면 코드를 한눈에 이해하기 어려워지기 때문입니다.</p>
<p>이 방법의 (약간의) 단점은 나중에 정수를 Player로 변환해야 한다는 것입니다. 하지만 Player에 from_int 함수를 구현함으로써 쉽게 해결할 수 있습니다.```</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">구현 <span class="hljs-title class_">Player</span> {
    fn <span class="hljs-title function_">from_int</span>(<span class="hljs-attr">int</span>: u8) -&gt; <span class="hljs-title class_">Player</span> {
        match int {
            <span class="hljs-number">1</span> =&gt; <span class="hljs-title class_">Player</span>::<span class="hljs-title class_">One</span>,
            <span class="hljs-number">2</span> =&gt; <span class="hljs-title class_">Player</span>::<span class="hljs-title class_">Two</span>,
            <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-title class_">Player</span>::<span class="hljs-title class_">None</span>,
        }
    }
}
</code></pre>
<h1>보드 표시</h1>
<p>디버깅을 위해, 보드를 시각화하는 좋은 방법을 빠르게 코드화하는 것이 도움이 될 것입니다. 명령줄에 출력하기 위해 크레이트를 사용하는 대신에 간단한 색을 나타내기 위해 16진수 이스케이프 문자열을 사용할 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-attr">RESET</span>: &amp;str = <span class="hljs-string">&quot;\x1b[0m&quot;</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">ORANGE</span>: &amp;str = <span class="hljs-string">&quot;\x1b[93m&quot;</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">RED</span>: &amp;str = <span class="hljs-string">&quot;\x1b[0;31m&quot;</span>;
</code></pre>
<div class="content-ad"></div>
<p>아래의 코드에서는 맵을 사용하여 Connect 4 토큰과 유사한 이모지로 슬롯을 변환할 것입니다. 게임이 종료되면 우승자를 발표하는 좋은 장소로 보입니다.</p>
<pre><code class="hljs language-js">impl <span class="hljs-title class_">Game</span> {
    <span class="hljs-comment">// 다른 함수들</span>

    fn <span class="hljs-title function_">display_board</span>(<span class="hljs-params">&amp;self</span>) {
        println!(<span class="hljs-string">&quot;{}--------------------{}&quot;</span>, <span class="hljs-variable constant_">ORANGE</span>, <span class="hljs-variable constant_">RESET</span>);
        println!(<span class="hljs-string">&quot;{}CONNECT 4 (Move {}){}&quot;</span>, <span class="hljs-variable constant_">ORANGE</span>, self.<span class="hljs-property">current_move</span>, <span class="hljs-variable constant_">RESET</span>);
        println!(<span class="hljs-string">&quot;{}--------------------{}&quot;</span>, <span class="hljs-variable constant_">ORANGE</span>, <span class="hljs-variable constant_">RESET</span>);

        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> self.<span class="hljs-property">board</span> {
            <span class="hljs-keyword">let</span> <span class="hljs-attr">row_str</span>: <span class="hljs-title class_">String</span> = row
                .<span class="hljs-title function_">iter</span>()
                .<span class="hljs-title function_">map</span>(|&amp;cell| match cell {
                    <span class="hljs-number">1</span> =&gt; <span class="hljs-string">&quot;🔴&quot;</span>,
                    <span class="hljs-number">2</span> =&gt; <span class="hljs-string">&quot;🟡&quot;</span>,
                    <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-string">&quot;⚫&quot;</span>,
                })
                .<span class="hljs-property">collect</span>::&lt;<span class="hljs-title class_">Vec</span>&lt;&amp;str&gt;&gt;()
                .<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot; &quot;</span>);

            println!(<span class="hljs-string">&quot;{}&quot;</span>, row_str);
        }

        println!(<span class="hljs-string">&quot;{}--------------------{}&quot;</span>, <span class="hljs-variable constant_">ORANGE</span>, <span class="hljs-variable constant_">RESET</span>);

        <span class="hljs-keyword">if</span> self.<span class="hljs-property">is_finished</span> {
            match self.<span class="hljs-property">winner</span> {
                <span class="hljs-title class_">Player</span>::<span class="hljs-function"><span class="hljs-params">One</span> =&gt;</span> println!(<span class="hljs-string">&quot;{}🔴 Player 1이 승리했습니다!{}&quot;</span>, <span class="hljs-variable constant_">ORANGE</span>, <span class="hljs-variable constant_">RESET</span>),
                <span class="hljs-title class_">Player</span>::<span class="hljs-function"><span class="hljs-params">Two</span> =&gt;</span> println!(<span class="hljs-string">&quot;{}🟡 Player 2가 승리했습니다!{}&quot;</span>, <span class="hljs-variable constant_">ORANGE</span>, <span class="hljs-variable constant_">RESET</span>),
                <span class="hljs-title class_">Player</span>::<span class="hljs-function"><span class="hljs-params">None</span> =&gt;</span> println!(<span class="hljs-string">&quot;{}무승부입니다!{}&quot;</span>, <span class="hljs-variable constant_">ORANGE</span>, <span class="hljs-variable constant_">RESET</span>),
            }

            println!(<span class="hljs-string">&quot;{}--------------------{}&quot;</span>, <span class="hljs-variable constant_">ORANGE</span>, <span class="hljs-variable constant_">RESET</span>);
        }
    }
}
</code></pre>
<p>우리는 이것을 언제든지 메인 함수 내에서 호출하여 보드의 상태를 확인할 수 있습니다.</p>
<pre><code class="hljs language-js">fn <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> mut game = <span class="hljs-title class_">Game</span>::<span class="hljs-title function_">default</span>();
    game.<span class="hljs-title function_">display_board</span>();
}
</code></pre>
<div class="content-ad"></div>
<p>조금 지루하지만 수를 두지 않고는 재미가 없죠. 그래서 이제 수를 두는 방법을 프로그래밍해 봅시다!</p>
<h1>수 두기</h1>
<p>우리의 play_move 함수를 첫 번째로 살펴보면, 이 함수는 이차원 배열에서 올바른 항목을 변경하고, 수를 증가시킨 다음 현재 플레이어를 변경해야 합니다.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Game</span> {
    <span class="hljs-comment">// other functions</span>

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">play_move</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, column: <span class="hljs-type">usize</span>) {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(row) = (<span class="hljs-number">0</span>..BOARD_HEIGHT)
            .<span class="hljs-title function_ invoke__">rev</span>()
            .<span class="hljs-title function_ invoke__">find</span>(|&amp;row| <span class="hljs-keyword">self</span>.board[row][column] == <span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">self</span>.board[row][column] = <span class="hljs-keyword">self</span>.current_player <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>;

            <span class="hljs-keyword">self</span>.current_move += <span class="hljs-number">1</span>;

            <span class="hljs-keyword">self</span>.current_player = <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.current_player {
                Player::One =&gt; Player::Two,
                _ =&gt; Player::One,
            };
        }
    }
}
</code></pre>
<div class="content-ad"></div>
<p>위의 if let 코드에서는 열의 맨 아래부터 시작하여 하나씩 올라가면서 빈 칸을 찾을 때까지 진행합니다. 빈 칸을 찾으면 그 위치에 현재 플레이어를 나타내는 정수로 변경하고, 현재 이동을 증가시킨 후 match 표현식을 사용하여 플레이어를 변경합니다.</p>
<p>이 시점에서 코드를 통해 움직임을 실행하고 터미널에서 결과를 확인할 수 있습니다:</p>
<pre><code class="hljs language-js">fn <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> mut game = <span class="hljs-title class_">Game</span>::<span class="hljs-title function_">default</span>();
    
    game.<span class="hljs-title function_">play_move</span>(<span class="hljs-number">3</span>);
    game.<span class="hljs-title function_">play_move</span>(<span class="hljs-number">3</span>);
    game.<span class="hljs-title function_">play_move</span>(<span class="hljs-number">4</span>);
    game.<span class="hljs-title function_">play_move</span>(<span class="hljs-number">3</span>);

    game.<span class="hljs-title function_">display_board</span>();
}
</code></pre>
<h1>오류 처리</h1>
<div class="content-ad"></div>
<p>지금까지 우리는 보드 바깥으로 이동을 시도하는 잠재적인 오류를 처리하지 않고 있습니다. 따라서 세 가지 가능한 오류를 처리해 봅시다:</p>
<ul>
<li>제공된 열이 허용 범위를 벗어납니다.</li>
<li>제공된 열이 이미 가득 찼습니다.</li>
<li>게임이 끝났습니다.</li>
</ul>
<p>(사용자 입력을 받기 시작하면 추가적인 오류 처리가 필요할 것입니다. 나중에 처리하겠습니다.)</p>
<p>세 가지 오류 유형을 포함한 enum을 만들어 봅시다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">enum <span class="hljs-title class_">MoveError</span> {
    <span class="hljs-title class_">GameFinished</span>,
    <span class="hljs-title class_">InvalidColumn</span>,
    <span class="hljs-title class_">ColumnFull</span>,
}
</code></pre>
<p>우리는 에러를 명령줄에 출력하기를 원하기 때문에, 우리의 에러 메시지를 포함하는 사용자 정의 Display 트레이트를 구현해야 합니다. 예를 들어:</p>
<pre><code class="hljs language-js">impl <span class="hljs-attr">std</span>::<span class="hljs-attr">fmt</span>::<span class="hljs-title class_">Display</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MoveError</span> {
    fn <span class="hljs-title function_">fmt</span>(&amp;self, <span class="hljs-attr">f</span>: &amp;mut <span class="hljs-attr">std</span>::<span class="hljs-attr">fmt</span>::<span class="hljs-title class_">Formatter</span>&lt;<span class="hljs-string">&#x27;_&gt;) -&gt; std::fmt::Result {
        match self {
            MoveError::ColumnFull =&gt; write!(f, &quot;column is full&quot;),
            MoveError::InvalidColumn =&gt; write!(f, &quot;column must be between 1 and 7&quot;),
            MoveError::GameFinished =&gt; write!(f, &quot;game is already finished&quot;),
        }
    }
}
</span></code></pre>
<p>이제 이를 사용하여 play_move 함수를 수정할 수 있습니다. 이제 우리는 움직임이 성공적이면 아무것도 반환하지만, 그렇지 않은 경우 에러가 반환되는 Result enum을 반환합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Game</span> {
    <span class="hljs-comment">// 다른 함수들</span>

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">play_move</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, column: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), MoveError&gt; {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.is_finished {
            <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(MoveError::GameFinished);
        }

        <span class="hljs-keyword">if</span> column &gt;= BOARD_WIDTH {
            <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(MoveError::InvalidColumn);
        }

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(row) = (<span class="hljs-number">0</span>..BOARD_HEIGHT)
            .<span class="hljs-title function_ invoke__">rev</span>()
            .<span class="hljs-title function_ invoke__">find</span>(|&amp;row| <span class="hljs-keyword">self</span>.board[row][column] == <span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">self</span>.board[row][column] = <span class="hljs-keyword">self</span>.current_player <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(MoveError::ColumnFull);
        }

        <span class="hljs-keyword">self</span>.current_move += <span class="hljs-number">1</span>;

        <span class="hljs-keyword">self</span>.current_player = <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.current_player {
            Player::One =&gt; Player::Two,
            _ =&gt; Player::One,
        };

        <span class="hljs-title function_ invoke__">Ok</span>(())
    }
}
</code></pre>
<p>디버깅을 위해 이제 play_move의 결과를 인쇄할 수 있으며, 예상치 못한 입력이 있는 경우 enum으로부터 에러를 볼 수 있습니다.</p>
<p>우리가 여기에 있는 동안, 명령줄에 에러 메시지를 인쇄하는 도우미 함수를 추가해 봅시다.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Game</span> {
    <span class="hljs-comment">// 다른 함수들</span>

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">display_error</span>(&amp;<span class="hljs-keyword">self</span>, error: <span class="hljs-type">String</span>) {
        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">display_board</span>();
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}에러: {}{}&quot;</span>, RED, error, RESET);
    }
}
</code></pre>
<div class="content-ad"></div>
<h1>게임에서 승리했는지 계산하기</h1>
<p>누군가가 이겼는지 확인하기 위해 2차원 배열을 여러 방향으로 탐색해야 합니다. 이 Leetcode 스타일 문제는 재미있는 도전이었고, 결과물을 얻기까지 몇 번 시도해야 했어요.</p>
<p>누군가가 4칸을 연달아 얻을 수 있는 네 가지 방향이 있어요:</p>
<ul>
<li>수평,</li>
<li>수직,</li>
<li>역 슬래시 대각선 (왼쪽 위에서 오른쪽 아래로),</li>
<li>순방향 슬래시 대각선 (왼쪽 아래에서 오른쪽 위로).</li>
</ul>
<div class="content-ad"></div>
<p>게시판의 모든 슬롯을 반복하여 네 방향 중 하나에서 테스트할 수 있습니다. (게시판이 작기 때문에 무차별 대입 방식을 사용하는 것이 부담이 되지 않습니다. 그러나 더 나은 방법이 있는지 궁금합니다!)</p>
<p>게시판의 주어진 슬롯에서 시작합니다. 플레이어의 토큰이 들어있는 경우, 첫 번째 방향으로 한 단계 이동합니다. 이 새로운 슬롯도 같은 토큰을 포함하는 경우, 이 방향으로 또 다른 단계를 이동합니다. 이를 반복하여 같은 토큰이 있는 네 개의 슬롯을 찾을 때까지 진행합니다. 그렇지 않으면 다른 방향으로 이동합니다.</p>
<p>각 방향은 정수들의 튜플로 나타낼 수 있습니다 - 행당 거리에 대한 값과 열당 거리에 대한 값 하나씩 - 이 정보를 배열에 저장할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> directions = [
    (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>),  <span class="hljs-comment">// 가로</span>
    (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),  <span class="hljs-comment">// 세로</span>
    (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>),  <span class="hljs-comment">// 대각선 (왼쪽 위에서 오른쪽 아래)</span>
    (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), <span class="hljs-comment">// 대각선 (왼쪽 아래에서 오른쪽 위)</span>
];
</code></pre>
<div class="content-ad"></div>
<p>이 튜플들이 무엇을 나타내는지 알려드릴게요:</p>
<ul>
<li>수평으로 이동하려면 행은 변하지 않고(0), 열만 변해야 합니다(1).</li>
<li>수직으로 이동하려면 행이 변해야 하고(1), 열은 변하지 않아야 합니다(0).</li>
<li>역 슬래시 대각선으로 이동하려면 행과 열이 둘 다 증가해야 합니다(1, 1).</li>
<li>마지막으로, 슬래시 대각선으로 이동하려면 열은 증가하고 행은 감소해야 합니다(-1, 1).</li>
</ul>
<p>각 방향의 모든 슬롯을 테스트하려면 아래와 같이 세 개의 루프가 필요합니다.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Game</span> {
    <span class="hljs-comment">// 다른 함수들</span>

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_winner</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Player {
        <span class="hljs-keyword">for</span> <span class="hljs-variable">row</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..BOARD_HEIGHT {
            <span class="hljs-keyword">for</span> <span class="hljs-variable">col</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..BOARD_WIDTH {
                <span class="hljs-keyword">let</span> <span class="hljs-variable">cell</span> = <span class="hljs-keyword">self</span>.board[row][col];

                <span class="hljs-keyword">if</span> cell != <span class="hljs-number">0</span> {
                    <span class="hljs-keyword">let</span> <span class="hljs-variable">directions</span> = [
                        (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>),  <span class="hljs-comment">// 수평</span>
                        (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),  <span class="hljs-comment">// 수직</span>
                        (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>),  <span class="hljs-comment">// 대각선 (왼쪽 위에서 오른쪽 아래로)</span>
                        (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), <span class="hljs-comment">// 대각선 (왼쪽 아래에서 오른쪽 위로)</span>
                    ];

                    <span class="hljs-title function_ invoke__">for</span> (row_step, col_step) <span class="hljs-keyword">in</span> directions {
                        <span class="hljs-comment">// TODO - 주어진 방향으로 보드를 탐색하고</span>
                        <span class="hljs-comment">// 승자를 찾았다면 해당 플레이어를 반환하세요</span>
                    }
                }
            }
        }
        Player::<span class="hljs-literal">None</span>
    }
}
</code></pre>
<div class="content-ad"></div>
<p>우리는 연속 카운트를 유지하고 — 4에 도달하면 승자가 나온 것을 알 수 있습니다.</p>
<p>그럼, 최종 중첩된 루프에서는 시작 토큰부터 슬롯별로 이동을 시도할 것입니다. 그때까지…</p>
<ul>
<li>시작 토큰과 다른 토큰을 만날 때 (그러한 경우 루프를 종료합니다);</li>
<li>보드의 가장자리에 도달할 때 (그러한 경우 루프를 종료합니다);</li>
<li>동일한 토큰의 4연속을 만날 때 (그러한 경우 게임을 종료하고 승자를 지정합니다).</li>
</ul>
<pre><code class="hljs language-js">impl <span class="hljs-title class_">Game</span> {
    <span class="hljs-comment">// 다른 함수들</span>

    fn <span class="hljs-title function_">calculate_winner</span>(&amp;mut self) -&gt; <span class="hljs-title class_">Player</span> {
        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.<span class="hljs-property">BOARD_HEIGHT</span> {
            <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.<span class="hljs-property">BOARD_WIDTH</span> {
                <span class="hljs-keyword">let</span> cell = self.<span class="hljs-property">board</span>[row][col];

                <span class="hljs-keyword">if</span> cell != <span class="hljs-number">0</span> {
                    <span class="hljs-keyword">let</span> directions = [
                        (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>),  <span class="hljs-comment">// 가로</span>
                        (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),  <span class="hljs-comment">// 세로</span>
                        (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>),  <span class="hljs-comment">// 대각선 (왼쪽 위에서 오른쪽 아래로)</span>
                        (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), <span class="hljs-comment">// 대각선 (왼쪽 아래에서 오른쪽 위로)</span>
                    ];

                    <span class="hljs-keyword">for</span> (row_step, col_step) <span class="hljs-keyword">in</span> directions {
                        <span class="hljs-keyword">let</span> mut consecutive_count = <span class="hljs-number">1</span>;
                        <span class="hljs-keyword">let</span> mut r = row <span class="hljs-keyword">as</span> isize + row_step;
                        <span class="hljs-keyword">let</span> mut c = col <span class="hljs-keyword">as</span> isize + col_step;

                        <span class="hljs-keyword">while</span> r &gt;= <span class="hljs-number">0</span>
                            &amp;&amp; r &lt; <span class="hljs-variable constant_">BOARD_HEIGHT</span> <span class="hljs-keyword">as</span> isize
                            &amp;&amp; c &gt;= <span class="hljs-number">0</span>
                            &amp;&amp; c &lt; <span class="hljs-variable constant_">BOARD_WIDTH</span> <span class="hljs-keyword">as</span> isize
                        {
                            <span class="hljs-keyword">if</span> self.<span class="hljs-property">board</span>[r <span class="hljs-keyword">as</span> usize][c <span class="hljs-keyword">as</span> usize] == cell {
                                consecutive_count += <span class="hljs-number">1</span>;

                                <span class="hljs-keyword">if</span> consecutive_count == <span class="hljs-number">4</span> {
                                    self.<span class="hljs-property">is_finished</span> = <span class="hljs-literal">true</span>;
                                    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Player</span>::<span class="hljs-title function_">from_int</span>(cell);
                                }
                            } <span class="hljs-keyword">else</span> {
                                <span class="hljs-keyword">break</span>;
                            }
                            r += row_step;
                            c += col_step;
                        }
                    }
                }
            }
        }

        <span class="hljs-title class_">Player</span>::<span class="hljs-title class_">None</span>
    }
}
</code></pre>
<div class="content-ad"></div>
<p>우리는 이동 횟수가 일곱 미만인 경우 이러한 확인 작업을 수행하지 않고 최적화를 조금 추가할 수 있습니다. 그때까지는 게임에서 이기는 것이 불가능하기 때문입니다. 그래서 함수 맨 위에 이를 추가해 봅시다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> self.<span class="hljs-property">current_move</span> &lt; <span class="hljs-number">7</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Player</span>::<span class="hljs-title class_">None</span>;
}
</code></pre>
<p>그리고 보드가 가득 찼지만 승자가 없는 경우(즉, 무승부인 경우)에 게임을 종료로 표시해야 합니다. 이를 반환문 위에 추가해 줍시다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> self.<span class="hljs-property">current_move</span> &gt;= <span class="hljs-variable constant_">BOARD_HEIGHT</span> <span class="hljs-keyword">as</span> u8 * <span class="hljs-variable constant_">BOARD_WIDTH</span> <span class="hljs-keyword">as</span> u8 {
    self.<span class="hljs-property">is_finished</span> = <span class="hljs-literal">true</span>;
}
</code></pre>
<div class="content-ad"></div>
<p>마지막으로, 새로운 calculate_winner 함수를 play_move 함수에 추가할 수 있습니다. 이번에는 아무것도 반환하는 대신, 성공인 Result enum을 반환하거나 실패인 경우에는 오류를 반환합니다.</p>
<pre><code class="hljs language-js">impl <span class="hljs-title class_">Game</span> {
    <span class="hljs-comment">// 다른 함수들</span>

    fn <span class="hljs-title function_">play_move</span>(&amp;mut self, <span class="hljs-attr">column</span>: usize) -&gt; <span class="hljs-title class_">Result</span>&lt;(), <span class="hljs-title class_">MoveError</span>&gt; {
        <span class="hljs-keyword">if</span> self.<span class="hljs-property">is_finished</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Err</span>(<span class="hljs-title class_">MoveError</span>::<span class="hljs-title class_">GameFinished</span>);
        }

        <span class="hljs-keyword">if</span> column &gt;= <span class="hljs-variable constant_">BOARD_WIDTH</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Err</span>(<span class="hljs-title class_">MoveError</span>::<span class="hljs-title class_">InvalidColumn</span>);
        }

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-title class_">Some</span>(row) = (<span class="hljs-number">0.</span>.<span class="hljs-property">BOARD_HEIGHT</span>)
            .<span class="hljs-title function_">rev</span>()
            .<span class="hljs-title function_">find</span>(<span class="hljs-params">|&amp;row| self.board[row][column] == <span class="hljs-number">0</span></span>)
        {
            self.<span class="hljs-property">board</span>[row][column] = self.<span class="hljs-property">current_player</span> <span class="hljs-keyword">as</span> u8;
            self.<span class="hljs-property">current_move</span> += <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Err</span>(<span class="hljs-title class_">MoveError</span>::<span class="hljs-title class_">ColumnFull</span>);
        }

        <span class="hljs-keyword">let</span> calculated_winner = self.<span class="hljs-title function_">calculate_winner</span>();

        <span class="hljs-keyword">if</span> calculated_winner != <span class="hljs-title class_">Player</span>::<span class="hljs-title class_">None</span> {
            self.<span class="hljs-property">winner</span> = calculated_winner;
        } <span class="hljs-keyword">else</span> {
            self.<span class="hljs-property">current_player</span> = match self.<span class="hljs-property">current_player</span> {
                <span class="hljs-title class_">Player</span>::<span class="hljs-function"><span class="hljs-params">One</span> =&gt;</span> <span class="hljs-title class_">Player</span>::<span class="hljs-title class_">Two</span>,
                <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-title class_">Player</span>::<span class="hljs-title class_">One</span>,
            };
        }

        <span class="hljs-title class_">Ok</span>(())
    }
}
</code></pre>
<p>우리의 Connect 4 게임 엔진이 완성되었습니다! 사용자로부터 입력을 받는 방법만 남았습니다...</p>
<h1>사용자 입력 받기</h1>
<div class="content-ad"></div>
<p>우리 명령 줄 게임의 마지막 부분에서는 주 함수로 돌아가 사용자 입력을 읽을 수 있도록 할 것입니다.</p>
<p>먼저, Rust의 표준 I/O 라이브러리를 가져오겠습니다.</p>
<pre><code class="hljs language-js">use <span class="hljs-attr">std</span>::io;
</code></pre>
<p>사용자 입력을 읽는 논리는 다음과 같이 보일 수 있습니다. 여기서는 컴퓨터와 달리 0이 아닌 1부터 시작하여 카운트하게 됩니다!</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> mut user_move = <span class="hljs-title class_">String</span>::<span class="hljs-title function_">new</span>();

<span class="hljs-attr">io</span>::<span class="hljs-title function_">stdin</span>()
    .<span class="hljs-title function_">read_line</span>(&amp;mut user_move)
    .<span class="hljs-title function_">expect</span>(<span class="hljs-string">&quot;Failed to read line&quot;</span>);

<span class="hljs-keyword">let</span> <span class="hljs-attr">user_move</span>: usize = match user_move.<span class="hljs-title function_">trim</span>().<span class="hljs-title function_">parse</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title class_">Ok</span>(num) =&gt; {
        <span class="hljs-keyword">if</span> num &lt; <span class="hljs-number">1</span> || num &gt; <span class="hljs-variable constant_">BOARD_WIDTH</span> <span class="hljs-keyword">as</span> u8 {
            game.<span class="hljs-title function_">display_error</span>(<span class="hljs-title class_">MoveError</span>::<span class="hljs-title class_">InvalidColumn</span>.<span class="hljs-title function_">to_string</span>());
            <span class="hljs-keyword">continue</span>;
        } <span class="hljs-keyword">else</span> {
            num
        }
    }
    <span class="hljs-title class_">Err</span>(err) =&gt; {
        game.<span class="hljs-title function_">display_error</span>(err.<span class="hljs-title function_">to_string</span>());
        <span class="hljs-keyword">continue</span>;
    }
};

match game.<span class="hljs-title function_">play_move</span>(<span class="hljs-params">user_move - <span class="hljs-number">1</span></span>) {
    <span class="hljs-title class_">Ok</span>(_) =&gt; {
        game.<span class="hljs-title function_">display_board</span>();
    }
    <span class="hljs-title class_">Err</span>(err) =&gt; {
        game.<span class="hljs-title function_">display_error</span>(err.<span class="hljs-title function_">to_string</span>());
    }
}
</code></pre>
<p>먼저, 우리는 빈 문자열을 정의한 뒤 사용자로부터 텍스트를 받기 위해 stdin 메소드를 사용합니다.</p>
<p>다음으로 이 입력을 구문 분석을 시도합니다. 다음 중 하나라도 해당하는 경우 오류를 표시합니다:</p>
<ul>
<li>구문 분석이 실패하는 경우 (예: 입력이 숫자가 아닌 경우).</li>
<li>구문 분석이 성공하지만 숫자가 원하는 범위를 벗어난 경우.```</li>
</ul>
<div class="content-ad"></div>
<p>만약 오류가 표시되지 않는다면, 우리는 선택한 수를 둘 것입니다. 그러나 해당 시나리오에서 오류가 발생할 수도 있으므로, 그런 경우에는 오류를 표시할 것입니다.</p>
<p>그러나 위의 코드는 한 번만 실행됩니다. 게임이 끝날 때까지 루프를 실행해야 합니다. 아래는 그 반복문을 추가한 main 함수와 사용자를 도와줄 몇 가지 유용한 메시지입니다:</p>
<pre><code class="hljs language-js">fn <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> mut game = <span class="hljs-title class_">Game</span>::<span class="hljs-title function_">default</span>();
    game.<span class="hljs-title function_">display_board</span>();

    <span class="hljs-keyword">while</span> !game.<span class="hljs-property">is_finished</span> {
        println!(<span class="hljs-string">&quot;\n&quot;</span>);

        match game.<span class="hljs-property">current_player</span> {
            <span class="hljs-title class_">Player</span>::<span class="hljs-function"><span class="hljs-params">One</span> =&gt;</span> println!(<span class="hljs-string">&quot;플레이어 1&quot;</span>),
            <span class="hljs-title class_">Player</span>::<span class="hljs-function"><span class="hljs-params">Two</span> =&gt;</span> println!(<span class="hljs-string">&quot;플레이어 2&quot;</span>),
            <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> (),
        };

        println!(<span class="hljs-string">&quot;1부터 7 사이의 열을 입력하세요:&quot;</span>);

        <span class="hljs-keyword">let</span> mut user_move = <span class="hljs-title class_">String</span>::<span class="hljs-title function_">new</span>();
        <span class="hljs-attr">io</span>::<span class="hljs-title function_">stdin</span>()
            .<span class="hljs-title function_">read_line</span>(&amp;mut user_move)
            .<span class="hljs-title function_">expect</span>(<span class="hljs-string">&quot;라인을 읽는 데 실패했습니다&quot;</span>);

        <span class="hljs-keyword">let</span> <span class="hljs-attr">user_move</span>: usize = match user_move.<span class="hljs-title function_">trim</span>().<span class="hljs-title function_">parse</span>(<span class="hljs-params"></span>) {
            <span class="hljs-title class_">Ok</span>(num) =&gt; {
                <span class="hljs-keyword">if</span> num &lt; <span class="hljs-number">1</span> || num &gt; <span class="hljs-number">7</span> {
                    game.<span class="hljs-title function_">display_error</span>(<span class="hljs-title class_">MoveError</span>::<span class="hljs-title class_">InvalidColumn</span>.<span class="hljs-title function_">to_string</span>());
                    <span class="hljs-keyword">continue</span>;
                } <span class="hljs-keyword">else</span> {
                    num
                }
            }
            <span class="hljs-title class_">Err</span>(err) =&gt; {
                game.<span class="hljs-title function_">display_error</span>(err.<span class="hljs-title function_">to_string</span>());
                <span class="hljs-keyword">continue</span>;
            }
        };

        match game.<span class="hljs-title function_">play_move</span>(<span class="hljs-params">user_move - <span class="hljs-number">1</span></span>) {
            <span class="hljs-title class_">Ok</span>(_) =&gt; {
                game.<span class="hljs-title function_">display_board</span>();
            }
            <span class="hljs-title class_">Err</span>(err) =&gt; {
                game.<span class="hljs-title function_">display_error</span>(err.<span class="hljs-title function_">to_string</span>());
            }
        }
    }
}
</code></pre>
<h1>여러 판을 플레이하기</h1>
<div class="content-ad"></div>
<p>마지막으로, 사용자가 게임을 끝내면 게임을 다시 시작할 수 있도록 추가 코드를 추가하고 싶어요. 매번 실행 파일을 다시 시작해야 하는 번거로움은 피하고 싶으니까요!</p>
<p>이를 위해 새로운 루프를 만들 것입니다. 이전과 동일한 방법을 사용하여 사용자의 입력을 읽을 수 있습니다. &quot;R&quot;을 누르면 새 게임을 시작하고, &quot;Q&quot;를 누르면 루프를 중단하고 코드를 끝까지 실행합니다.</p>
<pre><code class="hljs language-js">fn <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> mut game = <span class="hljs-title class_">Game</span>::<span class="hljs-title function_">default</span>();
    game.<span class="hljs-title function_">display_board</span>();

    loop {
        <span class="hljs-keyword">while</span> !game.<span class="hljs-property">is_finished</span> {
            <span class="hljs-comment">// 코드 변경 없음</span>
        }

        println!(<span class="hljs-string">&quot;Press &#x27;R&#x27; to restart or &#x27;Q&#x27; to quit the game.&quot;</span>);

        <span class="hljs-keyword">let</span> mut user_input = <span class="hljs-title class_">String</span>::<span class="hljs-title function_">new</span>();

        <span class="hljs-attr">io</span>::<span class="hljs-title function_">stdin</span>()
            .<span class="hljs-title function_">read_line</span>(&amp;mut user_input)
            .<span class="hljs-title function_">expect</span>(<span class="hljs-string">&quot;Failed to read line&quot;</span>);

        match user_input.<span class="hljs-title function_">trim</span>(<span class="hljs-params"></span>) {
            <span class="hljs-string">&quot;R&quot;</span> | <span class="hljs-string">&quot;r&quot;</span> =&gt; {
                game = <span class="hljs-title class_">Game</span>::<span class="hljs-title function_">default</span>();
                game.<span class="hljs-title function_">display_board</span>();
            }
            <span class="hljs-string">&quot;Q&quot;</span> | <span class="hljs-string">&quot;q&quot;</span> =&gt; {
                println!(<span class="hljs-string">&quot;Quitting...&quot;</span>);
                <span class="hljs-keyword">break</span>;
            }
            _ =&gt; game.<span class="hljs-title function_">display_error</span>(<span class="hljs-string">&quot;잘못된 입력&quot;</span>.<span class="hljs-title function_">to_string</span>()),
        }
    }
}
</code></pre>
<p>마지막으로, 차례 사이에 터미널을 지우기 위한 ASCII 이스케이프 코드를 사용할 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">fn <span class="hljs-title function_">clear_screen</span>(<span class="hljs-params">&amp;self</span>) {
    print!(<span class="hljs-string">&quot;{}[2J&quot;</span>, <span class="hljs-number">27</span> <span class="hljs-keyword">as</span> char);
}
</code></pre>
<p>게임 보드를 표시할 때마다 이 작업을 수행할 수 있습니다.</p>
<pre><code class="hljs language-js">fn <span class="hljs-title function_">display_board</span>(<span class="hljs-params">&amp;self</span>) {
    self.<span class="hljs-title function_">clear_screen</span>();

    <span class="hljs-comment">// 코드 변경 없음</span>
}
</code></pre>
<h1>모두 함께 가져오기</h1>
<div class="content-ad"></div>
<p>그것이 커넥트 4의 간단한 명령줄 게임을 위해 필요한 모든 것입니다! 이 작업 중인 파일을 사용하는 작동 버전을 시험하려면 Rust 플레이그라운드를 확인해보세요.</p>
<p>우리가 지금까지 만든 전체 파일은 아래와 같습니다:</p>
<pre><code class="hljs language-js">use <span class="hljs-attr">std</span>::io;

<span class="hljs-keyword">const</span> <span class="hljs-attr">RESET</span>: &amp;str = <span class="hljs-string">&quot;\x1b[0m&quot;</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">ORANGE</span>: &amp;str = <span class="hljs-string">&quot;\x1b[93m&quot;</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">RED</span>: &amp;str = <span class="hljs-string">&quot;\x1b[0;31m&quot;</span>;

<span class="hljs-keyword">const</span> <span class="hljs-attr">BOARD_WIDTH</span>: usize = <span class="hljs-number">7</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">BOARD_HEIGHT</span>: usize = <span class="hljs-number">6</span>;

type <span class="hljs-title class_">Board</span> = [[u8; <span class="hljs-variable constant_">BOARD_WIDTH</span>]; <span class="hljs-variable constant_">BOARD_HEIGHT</span>];

#[<span class="hljs-title function_">derive</span>(<span class="hljs-title class_">Clone</span>, <span class="hljs-title class_">Copy</span>, <span class="hljs-title class_">Debug</span>, <span class="hljs-title class_">PartialEq</span>)]
#[<span class="hljs-title function_">repr</span>(u8)]
enum <span class="hljs-title class_">Player</span> {
    <span class="hljs-title class_">One</span> = <span class="hljs-number">1</span>,
    <span class="hljs-title class_">Two</span> = <span class="hljs-number">2</span>,
    <span class="hljs-title class_">None</span> = <span class="hljs-number">0</span>,
}

impl <span class="hljs-title class_">Player</span> {
    fn <span class="hljs-title function_">from_int</span>(<span class="hljs-attr">int</span>: u8) -&gt; <span class="hljs-title class_">Player</span> {
        match int {
            <span class="hljs-number">1</span> =&gt; <span class="hljs-title class_">Player</span>::<span class="hljs-title class_">One</span>,
            <span class="hljs-number">2</span> =&gt; <span class="hljs-title class_">Player</span>::<span class="hljs-title class_">Two</span>,
            <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-title class_">Player</span>::<span class="hljs-title class_">None</span>,
        }
    }
}

#[...]

# 결론

&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;content-ad&quot;</span>&gt;&lt;/div&gt;

지금까지 따라오셨다면 프로젝트를 더 나아가고 싶을 것입니다. 여러 게임을 거치면서 승리를 추적해 볼 수도 있고, 어떨까요? 어플리케이션을 웹 서버로 전환하여 웹사이트가 <span class="hljs-variable constant_">HTTP</span>를 통해 <span class="hljs-title class_">Connect</span> <span class="hljs-number">4</span>를 플레이할 수 있게끔 만들어 보는 것은 어떤가요?

이번 명령줄 어플리케이션을 <span class="hljs-title class_">Rust</span>로 개발하는 방법에 대한 유용하고 재미있는 통찰력으로 여기시길 바랍니다. 아직 <span class="hljs-title class_">Rust</span> 여행을 시작한 지 얼마 되지 않았기 때문에, 어떠한 비평이나 더 많은 <span class="hljs-title class_">Rust</span> 다운 방식으로 어플리케이션을 작성하는 아이디어가 있다면 꼭 알려주세요. 함께 고민해보고 싶습니다.
</code></pre></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Rust로 코딩하는 커맨드 라인 Connect 4 게임 배우기","description":"","date":"2024-05-20 16:00","slug":"2024-05-20-LearnRustbycodingacommandlineConnect4game","content":"\n\n![Rust Connect 4](/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png)\n\n안녕하세요! 이번 글에서는 Rust가 어떻게 우리가 Connect 4의 간단한 버전을 만들며 명령줄 응용 프로그램을 작성하는 데 도움이 되는지 살펴볼 거에요.\n\n최근 Rust를 배우는 도전에 도전했고, 제 자신의 조언을 따르기 위해 개인 프로젝트에서 Rust를 사용해 손을 더럽히며 배운 것을 정리하려고 노력하고 있어요. Connect 4는 아주 좋은 도전 과제에요. 오후 하루 동안 코딩할 수 있는 것은 간단하지만 잘 하려면 약간의 생각이 필요한 복잡한 문제이죠.\n\n여기 제 마지막 결과물이 포함된 Rust 플레이그라운드가 있어요. 아래에서는 거기에 이르기까지 취한 정확한 단계를 살펴볼 거에요. 따라오고 싶으시면 Rust가 설치되어 있는지 확인한 후 터미널에서 `cargo new rust_connect_4_tutorial`을 실행해서 프로젝트를 열고 좋아하는 편집기에서 src/main.rs로 이동해서 시작해봐요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n혹은 비디오를 통해 학습하는 것을 선호한다면, 해당 튜토리얼의 비디오 버전을 확인해보세요:\n\n# 우리의 타입 정의하기\n\nRust에서 시작하는 가장 좋은 방법 중 하나는 종종 우리의 타입을 정의하는 것이므로, 우리는 정확히 그것을 할 것입니다!\n\n먼저, 게임에 사용할 보드를 정의해 보겠습니다. Connect 4의 클래식 버전은 7개의 슬롯이 가로로 있고 6개의 슬롯이 세로로 있기 때문에, 이들 정수를 상수로 저장하고, 그 상수를 사용하여 두 차원 배열의 길이를 정의하는 데 사용할 수 있습니다. Board 타입으로 정의합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\nconst BOARD_WIDTH: usize = 7;\nconst BOARD_HEIGHT: usize = 6;\n\ntype Board = [[u8; BOARD_WIDTH]; BOARD_HEIGHT];\n```\n\n플레이어를 추적할 방법이 필요할 것입니다. 이를 enum으로 구현할 수 있습니다. 우리는 두 명의 플레이어만 지원하지만, 한 명의 피스가 없는 슬롯을 나타내는 None 변형과 게임이 무승부로 끝날 때 처리하는 데 유용할 것입니다.\n\n```rust\n#[derive(Clone, Copy, Debug, PartialEq)]\n#[repr(u8)]\nenum Player {\n    One = 1,\n    Two = 2,\n    None = 0,\n}\n```\n\n위에서는 나중에 유용할 몇 가지 트레잇을 구현하기 위해 derive를 사용하고, enum의 메모리 레이아웃을 제어하기 위해 repr을 사용했습니다. 가능한 모든 값을 알기 때문에 u8로 제한할 수 있습니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, 우리는 게임을 나타내는 struct를 만들 것입니다. 여기에는 추적해야 할 모든 상태가 포함될 것입니다.\n\n```javascript\nstruct Game {\n    current_move: u8,\n    current_player: Player,\n    board: Board,\n    is_finished: bool,\n    winner: Player,\n}\n```\n\ncurrent_move는 플레이어가 선택한 열을 나타내는 정수입니다. 우리에게는 승자 필드가 있지만, 게임이 비김으로 끝날 때 별도로 is_finished 부울도 유용할 것입니다!\n\n마지막으로, Game에 대한 기본 함수를 구현할 것입니다. 이 함수에는 초기 상태가 포함될 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\nimpl Game {\n    fn default() -\u003e Game {\n        Game {\n            current_move: 0,\n            current_player: Player::One,\n            board: [\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n            ],\n            is_finished: false,\n            winner: Player::None,\n        }\n    }\n}\n```\n\n보드에 대해 조금 이야기해 봅시다. 여기서 0은 빈 칸을 나타내며, 1은 Player One이 차지한 칸을 나타내고, 2는 Player Two가 차지한 칸을 나타냅니다.\n\nBOARD_WIDTH와 BOARD_HEIGHT를 사용하여 동적으로 생성할 수도 있었지만, 코드를 작성하는 동안 전체 배열을 보는 것이 도움이 되는 시각적 도구라는 것을 발견했습니다. 같은 이유로, 정수가 아닌 Player 열거형을 사용하지 않았습니다. 텍스트가 더 많아지면 코드를 한눈에 이해하기 어려워지기 때문입니다.\n\n이 방법의 (약간의) 단점은 나중에 정수를 Player로 변환해야 한다는 것입니다. 하지만 Player에 from_int 함수를 구현함으로써 쉽게 해결할 수 있습니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n구현 Player {\n    fn from_int(int: u8) -\u003e Player {\n        match int {\n            1 =\u003e Player::One,\n            2 =\u003e Player::Two,\n            _ =\u003e Player::None,\n        }\n    }\n}\n```\n\n# 보드 표시\n\n디버깅을 위해, 보드를 시각화하는 좋은 방법을 빠르게 코드화하는 것이 도움이 될 것입니다. 명령줄에 출력하기 위해 크레이트를 사용하는 대신에 간단한 색을 나타내기 위해 16진수 이스케이프 문자열을 사용할 것입니다.\n\n```js\nconst RESET: \u0026str = \"\\x1b[0m\";\nconst ORANGE: \u0026str = \"\\x1b[93m\";\nconst RED: \u0026str = \"\\x1b[0;31m\";\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래의 코드에서는 맵을 사용하여 Connect 4 토큰과 유사한 이모지로 슬롯을 변환할 것입니다. 게임이 종료되면 우승자를 발표하는 좋은 장소로 보입니다.\n\n```js\nimpl Game {\n    // 다른 함수들\n\n    fn display_board(\u0026self) {\n        println!(\"{}--------------------{}\", ORANGE, RESET);\n        println!(\"{}CONNECT 4 (Move {}){}\", ORANGE, self.current_move, RESET);\n        println!(\"{}--------------------{}\", ORANGE, RESET);\n\n        for row in self.board {\n            let row_str: String = row\n                .iter()\n                .map(|\u0026cell| match cell {\n                    1 =\u003e \"🔴\",\n                    2 =\u003e \"🟡\",\n                    _ =\u003e \"⚫\",\n                })\n                .collect::\u003cVec\u003c\u0026str\u003e\u003e()\n                .join(\" \");\n\n            println!(\"{}\", row_str);\n        }\n\n        println!(\"{}--------------------{}\", ORANGE, RESET);\n\n        if self.is_finished {\n            match self.winner {\n                Player::One =\u003e println!(\"{}🔴 Player 1이 승리했습니다!{}\", ORANGE, RESET),\n                Player::Two =\u003e println!(\"{}🟡 Player 2가 승리했습니다!{}\", ORANGE, RESET),\n                Player::None =\u003e println!(\"{}무승부입니다!{}\", ORANGE, RESET),\n            }\n\n            println!(\"{}--------------------{}\", ORANGE, RESET);\n        }\n    }\n}\n```\n\n우리는 이것을 언제든지 메인 함수 내에서 호출하여 보드의 상태를 확인할 수 있습니다.\n\n```js\nfn main() {\n    let mut game = Game::default();\n    game.display_board();\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n조금 지루하지만 수를 두지 않고는 재미가 없죠. 그래서 이제 수를 두는 방법을 프로그래밍해 봅시다!\n\n# 수 두기\n\n우리의 play_move 함수를 첫 번째로 살펴보면, 이 함수는 이차원 배열에서 올바른 항목을 변경하고, 수를 증가시킨 다음 현재 플레이어를 변경해야 합니다.\n\n```rust\nimpl Game {\n    // other functions\n\n    fn play_move(\u0026mut self, column: usize) {\n        if let Some(row) = (0..BOARD_HEIGHT)\n            .rev()\n            .find(|\u0026row| self.board[row][column] == 0)\n        {\n            self.board[row][column] = self.current_player as u8;\n\n            self.current_move += 1;\n\n            self.current_player = match self.current_player {\n                Player::One =\u003e Player::Two,\n                _ =\u003e Player::One,\n            };\n        }\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 if let 코드에서는 열의 맨 아래부터 시작하여 하나씩 올라가면서 빈 칸을 찾을 때까지 진행합니다. 빈 칸을 찾으면 그 위치에 현재 플레이어를 나타내는 정수로 변경하고, 현재 이동을 증가시킨 후 match 표현식을 사용하여 플레이어를 변경합니다.\n\n이 시점에서 코드를 통해 움직임을 실행하고 터미널에서 결과를 확인할 수 있습니다:\n\n```js\nfn main() {\n    let mut game = Game::default();\n    \n    game.play_move(3);\n    game.play_move(3);\n    game.play_move(4);\n    game.play_move(3);\n\n    game.display_board();\n}\n```\n\n# 오류 처리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금까지 우리는 보드 바깥으로 이동을 시도하는 잠재적인 오류를 처리하지 않고 있습니다. 따라서 세 가지 가능한 오류를 처리해 봅시다:\n\n- 제공된 열이 허용 범위를 벗어납니다.\n- 제공된 열이 이미 가득 찼습니다.\n- 게임이 끝났습니다.\n\n(사용자 입력을 받기 시작하면 추가적인 오류 처리가 필요할 것입니다. 나중에 처리하겠습니다.)\n\n세 가지 오류 유형을 포함한 enum을 만들어 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nenum MoveError {\n    GameFinished,\n    InvalidColumn,\n    ColumnFull,\n}\n```\n\n우리는 에러를 명령줄에 출력하기를 원하기 때문에, 우리의 에러 메시지를 포함하는 사용자 정의 Display 트레이트를 구현해야 합니다. 예를 들어:\n\n```js\nimpl std::fmt::Display for MoveError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            MoveError::ColumnFull =\u003e write!(f, \"column is full\"),\n            MoveError::InvalidColumn =\u003e write!(f, \"column must be between 1 and 7\"),\n            MoveError::GameFinished =\u003e write!(f, \"game is already finished\"),\n        }\n    }\n}\n```\n\n이제 이를 사용하여 play_move 함수를 수정할 수 있습니다. 이제 우리는 움직임이 성공적이면 아무것도 반환하지만, 그렇지 않은 경우 에러가 반환되는 Result enum을 반환합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\nimpl Game {\n    // 다른 함수들\n\n    fn play_move(\u0026mut self, column: usize) -\u003e Result\u003c(), MoveError\u003e {\n        if self.is_finished {\n            return Err(MoveError::GameFinished);\n        }\n\n        if column \u003e= BOARD_WIDTH {\n            return Err(MoveError::InvalidColumn);\n        }\n\n        if let Some(row) = (0..BOARD_HEIGHT)\n            .rev()\n            .find(|\u0026row| self.board[row][column] == 0)\n        {\n            self.board[row][column] = self.current_player as u8;\n        } else {\n            return Err(MoveError::ColumnFull);\n        }\n\n        self.current_move += 1;\n\n        self.current_player = match self.current_player {\n            Player::One =\u003e Player::Two,\n            _ =\u003e Player::One,\n        };\n\n        Ok(())\n    }\n}\n```\n\n디버깅을 위해 이제 play_move의 결과를 인쇄할 수 있으며, 예상치 못한 입력이 있는 경우 enum으로부터 에러를 볼 수 있습니다. \n\n우리가 여기에 있는 동안, 명령줄에 에러 메시지를 인쇄하는 도우미 함수를 추가해 봅시다.\n\n```rust\nimpl Game {\n    // 다른 함수들\n\n    fn display_error(\u0026self, error: String) {\n        self.display_board();\n        println!(\"{}에러: {}{}\", RED, error, RESET);\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 게임에서 승리했는지 계산하기\n\n누군가가 이겼는지 확인하기 위해 2차원 배열을 여러 방향으로 탐색해야 합니다. 이 Leetcode 스타일 문제는 재미있는 도전이었고, 결과물을 얻기까지 몇 번 시도해야 했어요.\n\n누군가가 4칸을 연달아 얻을 수 있는 네 가지 방향이 있어요:\n\n- 수평,\n- 수직,\n- 역 슬래시 대각선 (왼쪽 위에서 오른쪽 아래로),\n- 순방향 슬래시 대각선 (왼쪽 아래에서 오른쪽 위로).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n게시판의 모든 슬롯을 반복하여 네 방향 중 하나에서 테스트할 수 있습니다. (게시판이 작기 때문에 무차별 대입 방식을 사용하는 것이 부담이 되지 않습니다. 그러나 더 나은 방법이 있는지 궁금합니다!)\n\n게시판의 주어진 슬롯에서 시작합니다. 플레이어의 토큰이 들어있는 경우, 첫 번째 방향으로 한 단계 이동합니다. 이 새로운 슬롯도 같은 토큰을 포함하는 경우, 이 방향으로 또 다른 단계를 이동합니다. 이를 반복하여 같은 토큰이 있는 네 개의 슬롯을 찾을 때까지 진행합니다. 그렇지 않으면 다른 방향으로 이동합니다.\n\n각 방향은 정수들의 튜플로 나타낼 수 있습니다 - 행당 거리에 대한 값과 열당 거리에 대한 값 하나씩 - 이 정보를 배열에 저장할 수 있습니다.\n\n```js\nlet directions = [\n    (0, 1),  // 가로\n    (1, 0),  // 세로\n    (1, 1),  // 대각선 (왼쪽 위에서 오른쪽 아래)\n    (-1, 1), // 대각선 (왼쪽 아래에서 오른쪽 위)\n];\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 튜플들이 무엇을 나타내는지 알려드릴게요:\n\n- 수평으로 이동하려면 행은 변하지 않고(0), 열만 변해야 합니다(1).\n- 수직으로 이동하려면 행이 변해야 하고(1), 열은 변하지 않아야 합니다(0).\n- 역 슬래시 대각선으로 이동하려면 행과 열이 둘 다 증가해야 합니다(1, 1).\n- 마지막으로, 슬래시 대각선으로 이동하려면 열은 증가하고 행은 감소해야 합니다(-1, 1).\n\n각 방향의 모든 슬롯을 테스트하려면 아래와 같이 세 개의 루프가 필요합니다.\n\n```rust\nimpl Game {\n    // 다른 함수들\n\n    fn calculate_winner(\u0026mut self) -\u003e Player {\n        for row in 0..BOARD_HEIGHT {\n            for col in 0..BOARD_WIDTH {\n                let cell = self.board[row][col];\n\n                if cell != 0 {\n                    let directions = [\n                        (0, 1),  // 수평\n                        (1, 0),  // 수직\n                        (1, 1),  // 대각선 (왼쪽 위에서 오른쪽 아래로)\n                        (-1, 1), // 대각선 (왼쪽 아래에서 오른쪽 위로)\n                    ];\n\n                    for (row_step, col_step) in directions {\n                        // TODO - 주어진 방향으로 보드를 탐색하고\n                        // 승자를 찾았다면 해당 플레이어를 반환하세요\n                    }\n                }\n            }\n        }\n        Player::None\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 연속 카운트를 유지하고 — 4에 도달하면 승자가 나온 것을 알 수 있습니다.\n\n그럼, 최종 중첩된 루프에서는 시작 토큰부터 슬롯별로 이동을 시도할 것입니다. 그때까지…\n\n- 시작 토큰과 다른 토큰을 만날 때 (그러한 경우 루프를 종료합니다);\n- 보드의 가장자리에 도달할 때 (그러한 경우 루프를 종료합니다);\n- 동일한 토큰의 4연속을 만날 때 (그러한 경우 게임을 종료하고 승자를 지정합니다).\n\n```js\nimpl Game {\n    // 다른 함수들\n\n    fn calculate_winner(\u0026mut self) -\u003e Player {\n        for row in 0..BOARD_HEIGHT {\n            for col in 0..BOARD_WIDTH {\n                let cell = self.board[row][col];\n\n                if cell != 0 {\n                    let directions = [\n                        (0, 1),  // 가로\n                        (1, 0),  // 세로\n                        (1, 1),  // 대각선 (왼쪽 위에서 오른쪽 아래로)\n                        (-1, 1), // 대각선 (왼쪽 아래에서 오른쪽 위로)\n                    ];\n\n                    for (row_step, col_step) in directions {\n                        let mut consecutive_count = 1;\n                        let mut r = row as isize + row_step;\n                        let mut c = col as isize + col_step;\n\n                        while r \u003e= 0\n                            \u0026\u0026 r \u003c BOARD_HEIGHT as isize\n                            \u0026\u0026 c \u003e= 0\n                            \u0026\u0026 c \u003c BOARD_WIDTH as isize\n                        {\n                            if self.board[r as usize][c as usize] == cell {\n                                consecutive_count += 1;\n\n                                if consecutive_count == 4 {\n                                    self.is_finished = true;\n                                    return Player::from_int(cell);\n                                }\n                            } else {\n                                break;\n                            }\n                            r += row_step;\n                            c += col_step;\n                        }\n                    }\n                }\n            }\n        }\n\n        Player::None\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 이동 횟수가 일곱 미만인 경우 이러한 확인 작업을 수행하지 않고 최적화를 조금 추가할 수 있습니다. 그때까지는 게임에서 이기는 것이 불가능하기 때문입니다. 그래서 함수 맨 위에 이를 추가해 봅시다:\n\n```js\nif self.current_move \u003c 7 {\n    return Player::None;\n}\n```\n\n그리고 보드가 가득 찼지만 승자가 없는 경우(즉, 무승부인 경우)에 게임을 종료로 표시해야 합니다. 이를 반환문 위에 추가해 줍시다:\n\n```js\nif self.current_move \u003e= BOARD_HEIGHT as u8 * BOARD_WIDTH as u8 {\n    self.is_finished = true;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, 새로운 calculate_winner 함수를 play_move 함수에 추가할 수 있습니다. 이번에는 아무것도 반환하는 대신, 성공인 Result enum을 반환하거나 실패인 경우에는 오류를 반환합니다.\n\n```js\nimpl Game {\n    // 다른 함수들\n\n    fn play_move(\u0026mut self, column: usize) -\u003e Result\u003c(), MoveError\u003e {\n        if self.is_finished {\n            return Err(MoveError::GameFinished);\n        }\n\n        if column \u003e= BOARD_WIDTH {\n            return Err(MoveError::InvalidColumn);\n        }\n\n        if let Some(row) = (0..BOARD_HEIGHT)\n            .rev()\n            .find(|\u0026row| self.board[row][column] == 0)\n        {\n            self.board[row][column] = self.current_player as u8;\n            self.current_move += 1;\n        } else {\n            return Err(MoveError::ColumnFull);\n        }\n\n        let calculated_winner = self.calculate_winner();\n\n        if calculated_winner != Player::None {\n            self.winner = calculated_winner;\n        } else {\n            self.current_player = match self.current_player {\n                Player::One =\u003e Player::Two,\n                _ =\u003e Player::One,\n            };\n        }\n\n        Ok(())\n    }\n}\n```\n\n우리의 Connect 4 게임 엔진이 완성되었습니다! 사용자로부터 입력을 받는 방법만 남았습니다...\n\n# 사용자 입력 받기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 명령 줄 게임의 마지막 부분에서는 주 함수로 돌아가 사용자 입력을 읽을 수 있도록 할 것입니다.\n\n먼저, Rust의 표준 I/O 라이브러리를 가져오겠습니다.\n\n```js\nuse std::io;\n```\n\n사용자 입력을 읽는 논리는 다음과 같이 보일 수 있습니다. 여기서는 컴퓨터와 달리 0이 아닌 1부터 시작하여 카운트하게 됩니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet mut user_move = String::new();\n\nio::stdin()\n    .read_line(\u0026mut user_move)\n    .expect(\"Failed to read line\");\n\nlet user_move: usize = match user_move.trim().parse() {\n    Ok(num) =\u003e {\n        if num \u003c 1 || num \u003e BOARD_WIDTH as u8 {\n            game.display_error(MoveError::InvalidColumn.to_string());\n            continue;\n        } else {\n            num\n        }\n    }\n    Err(err) =\u003e {\n        game.display_error(err.to_string());\n        continue;\n    }\n};\n\nmatch game.play_move(user_move - 1) {\n    Ok(_) =\u003e {\n        game.display_board();\n    }\n    Err(err) =\u003e {\n        game.display_error(err.to_string());\n    }\n}\n```\n\n먼저, 우리는 빈 문자열을 정의한 뒤 사용자로부터 텍스트를 받기 위해 stdin 메소드를 사용합니다.\n\n다음으로 이 입력을 구문 분석을 시도합니다. 다음 중 하나라도 해당하는 경우 오류를 표시합니다:\n\n- 구문 분석이 실패하는 경우 (예: 입력이 숫자가 아닌 경우).\n- 구문 분석이 성공하지만 숫자가 원하는 범위를 벗어난 경우.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 오류가 표시되지 않는다면, 우리는 선택한 수를 둘 것입니다. 그러나 해당 시나리오에서 오류가 발생할 수도 있으므로, 그런 경우에는 오류를 표시할 것입니다.\n\n그러나 위의 코드는 한 번만 실행됩니다. 게임이 끝날 때까지 루프를 실행해야 합니다. 아래는 그 반복문을 추가한 main 함수와 사용자를 도와줄 몇 가지 유용한 메시지입니다:\n\n```js\nfn main() {\n    let mut game = Game::default();\n    game.display_board();\n\n    while !game.is_finished {\n        println!(\"\\n\");\n\n        match game.current_player {\n            Player::One =\u003e println!(\"플레이어 1\"),\n            Player::Two =\u003e println!(\"플레이어 2\"),\n            _ =\u003e (),\n        };\n\n        println!(\"1부터 7 사이의 열을 입력하세요:\");\n\n        let mut user_move = String::new();\n        io::stdin()\n            .read_line(\u0026mut user_move)\n            .expect(\"라인을 읽는 데 실패했습니다\");\n\n        let user_move: usize = match user_move.trim().parse() {\n            Ok(num) =\u003e {\n                if num \u003c 1 || num \u003e 7 {\n                    game.display_error(MoveError::InvalidColumn.to_string());\n                    continue;\n                } else {\n                    num\n                }\n            }\n            Err(err) =\u003e {\n                game.display_error(err.to_string());\n                continue;\n            }\n        };\n\n        match game.play_move(user_move - 1) {\n            Ok(_) =\u003e {\n                game.display_board();\n            }\n            Err(err) =\u003e {\n                game.display_error(err.to_string());\n            }\n        }\n    }\n}\n```\n\n# 여러 판을 플레이하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, 사용자가 게임을 끝내면 게임을 다시 시작할 수 있도록 추가 코드를 추가하고 싶어요. 매번 실행 파일을 다시 시작해야 하는 번거로움은 피하고 싶으니까요!\n\n이를 위해 새로운 루프를 만들 것입니다. 이전과 동일한 방법을 사용하여 사용자의 입력을 읽을 수 있습니다. \"R\"을 누르면 새 게임을 시작하고, \"Q\"를 누르면 루프를 중단하고 코드를 끝까지 실행합니다.\n\n```js\nfn main() {\n    let mut game = Game::default();\n    game.display_board();\n\n    loop {\n        while !game.is_finished {\n            // 코드 변경 없음\n        }\n\n        println!(\"Press 'R' to restart or 'Q' to quit the game.\");\n\n        let mut user_input = String::new();\n\n        io::stdin()\n            .read_line(\u0026mut user_input)\n            .expect(\"Failed to read line\");\n\n        match user_input.trim() {\n            \"R\" | \"r\" =\u003e {\n                game = Game::default();\n                game.display_board();\n            }\n            \"Q\" | \"q\" =\u003e {\n                println!(\"Quitting...\");\n                break;\n            }\n            _ =\u003e game.display_error(\"잘못된 입력\".to_string()),\n        }\n    }\n}\n```\n\n마지막으로, 차례 사이에 터미널을 지우기 위한 ASCII 이스케이프 코드를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfn clear_screen(\u0026self) {\n    print!(\"{}[2J\", 27 as char);\n}\n```\n\n게임 보드를 표시할 때마다 이 작업을 수행할 수 있습니다.\n\n```js\nfn display_board(\u0026self) {\n    self.clear_screen();\n\n    // 코드 변경 없음\n}\n```\n\n# 모두 함께 가져오기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그것이 커넥트 4의 간단한 명령줄 게임을 위해 필요한 모든 것입니다! 이 작업 중인 파일을 사용하는 작동 버전을 시험하려면 Rust 플레이그라운드를 확인해보세요.\n\n우리가 지금까지 만든 전체 파일은 아래와 같습니다:\n\n```js\nuse std::io;\n\nconst RESET: \u0026str = \"\\x1b[0m\";\nconst ORANGE: \u0026str = \"\\x1b[93m\";\nconst RED: \u0026str = \"\\x1b[0;31m\";\n\nconst BOARD_WIDTH: usize = 7;\nconst BOARD_HEIGHT: usize = 6;\n\ntype Board = [[u8; BOARD_WIDTH]; BOARD_HEIGHT];\n\n#[derive(Clone, Copy, Debug, PartialEq)]\n#[repr(u8)]\nenum Player {\n    One = 1,\n    Two = 2,\n    None = 0,\n}\n\nimpl Player {\n    fn from_int(int: u8) -\u003e Player {\n        match int {\n            1 =\u003e Player::One,\n            2 =\u003e Player::Two,\n            _ =\u003e Player::None,\n        }\n    }\n}\n\n#[...]\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금까지 따라오셨다면 프로젝트를 더 나아가고 싶을 것입니다. 여러 게임을 거치면서 승리를 추적해 볼 수도 있고, 어떨까요? 어플리케이션을 웹 서버로 전환하여 웹사이트가 HTTP를 통해 Connect 4를 플레이할 수 있게끔 만들어 보는 것은 어떤가요?\n\n이번 명령줄 어플리케이션을 Rust로 개발하는 방법에 대한 유용하고 재미있는 통찰력으로 여기시길 바랍니다. 아직 Rust 여행을 시작한 지 얼마 되지 않았기 때문에, 어떠한 비평이나 더 많은 Rust 다운 방식으로 어플리케이션을 작성하는 아이디어가 있다면 꼭 알려주세요. 함께 고민해보고 싶습니다.","ogImage":{"url":"/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png"},"coverImage":"/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png","tag":["Tech"],"readingTime":18},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    code: \"code\",\n    h1: \"h1\",\n    pre: \"pre\",\n    span: \"span\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png\",\n        alt: \"Rust Connect 4\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"안녕하세요! 이번 글에서는 Rust가 어떻게 우리가 Connect 4의 간단한 버전을 만들며 명령줄 응용 프로그램을 작성하는 데 도움이 되는지 살펴볼 거에요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"최근 Rust를 배우는 도전에 도전했고, 제 자신의 조언을 따르기 위해 개인 프로젝트에서 Rust를 사용해 손을 더럽히며 배운 것을 정리하려고 노력하고 있어요. Connect 4는 아주 좋은 도전 과제에요. 오후 하루 동안 코딩할 수 있는 것은 간단하지만 잘 하려면 약간의 생각이 필요한 복잡한 문제이죠.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"여기 제 마지막 결과물이 포함된 Rust 플레이그라운드가 있어요. 아래에서는 거기에 이르기까지 취한 정확한 단계를 살펴볼 거에요. 따라오고 싶으시면 Rust가 설치되어 있는지 확인한 후 터미널에서 \", _jsx(_components.code, {\n        children: \"cargo new rust_connect_4_tutorial\"\n      }), \"을 실행해서 프로젝트를 열고 좋아하는 편집기에서 src/main.rs로 이동해서 시작해봐요!\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"혹은 비디오를 통해 학습하는 것을 선호한다면, 해당 튜토리얼의 비디오 버전을 확인해보세요:\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"우리의 타입 정의하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Rust에서 시작하는 가장 좋은 방법 중 하나는 종종 우리의 타입을 정의하는 것이므로, 우리는 정확히 그것을 할 것입니다!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저, 게임에 사용할 보드를 정의해 보겠습니다. Connect 4의 클래식 버전은 7개의 슬롯이 가로로 있고 6개의 슬롯이 세로로 있기 때문에, 이들 정수를 상수로 저장하고, 그 상수를 사용하여 두 차원 배열의 길이를 정의하는 데 사용할 수 있습니다. Board 타입으로 정의합니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" BOARD_WIDTH: \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"usize\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"7\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" BOARD_HEIGHT: \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"usize\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Board\"\n        }), \" = [[\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"u8\"\n        }), \"; BOARD_WIDTH]; BOARD_HEIGHT];\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"플레이어를 추적할 방법이 필요할 것입니다. 이를 enum으로 구현할 수 있습니다. 우리는 두 명의 플레이어만 지원하지만, 한 명의 피스가 없는 슬롯을 나타내는 None 변형과 게임이 무승부로 끝날 때 처리하는 데 유용할 것입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"#[derive(Clone, Copy, Debug, PartialEq)]\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"#[repr(u8)]\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"enum\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \" {\\n    One = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \",\\n    Two = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"None\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \",\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위에서는 나중에 유용할 몇 가지 트레잇을 구현하기 위해 derive를 사용하고, enum의 메모리 레이아웃을 제어하기 위해 repr을 사용했습니다. 가능한 모든 값을 알기 때문에 u8로 제한할 수 있습니다.```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음으로, 우리는 게임을 나타내는 struct를 만들 것입니다. 여기에는 추적해야 할 모든 상태가 포함될 것입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-javascript\",\n        children: [\"struct \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"current_move\"\n        }), \": u8,\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"current_player\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"board\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Board\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"is_finished\"\n        }), \": bool,\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"winner\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \",\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"current_move는 플레이어가 선택한 열을 나타내는 정수입니다. 우리에게는 승자 필드가 있지만, 게임이 비김으로 끝날 때 별도로 is_finished 부울도 유용할 것입니다!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막으로, Game에 대한 기본 함수를 구현할 것입니다. 이 함수에는 초기 상태가 포함될 것입니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"impl\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"default\"\n        }), \"() \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"-\u003e\"\n        }), \" Game {\\n        Game {\\n            current_move: \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \",\\n            current_player: Player::One,\\n            board: [\\n                [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"],\\n                [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"],\\n                [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"],\\n                [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"],\\n                [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"],\\n                [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"],\\n            ],\\n            is_finished: \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \",\\n            winner: Player::\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"None\"\n        }), \",\\n        }\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"보드에 대해 조금 이야기해 봅시다. 여기서 0은 빈 칸을 나타내며, 1은 Player One이 차지한 칸을 나타내고, 2는 Player Two가 차지한 칸을 나타냅니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"BOARD_WIDTH와 BOARD_HEIGHT를 사용하여 동적으로 생성할 수도 있었지만, 코드를 작성하는 동안 전체 배열을 보는 것이 도움이 되는 시각적 도구라는 것을 발견했습니다. 같은 이유로, 정수가 아닌 Player 열거형을 사용하지 않았습니다. 텍스트가 더 많아지면 코드를 한눈에 이해하기 어려워지기 때문입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 방법의 (약간의) 단점은 나중에 정수를 Player로 변환해야 한다는 것입니다. 하지만 Player에 from_int 함수를 구현함으로써 쉽게 해결할 수 있습니다.```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"구현 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \" {\\n    fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"from_int\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"int\"\n        }), \": u8) -\u003e \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \" {\\n        match int {\\n            \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" =\u003e \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"One\"\n        }), \",\\n            \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \" =\u003e \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Two\"\n        }), \",\\n            \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"_\"\n          }), \" =\u003e\"]\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"None\"\n        }), \",\\n        }\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"보드 표시\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"디버깅을 위해, 보드를 시각화하는 좋은 방법을 빠르게 코드화하는 것이 도움이 될 것입니다. 명령줄에 출력하기 위해 크레이트를 사용하는 대신에 간단한 색을 나타내기 위해 16진수 이스케이프 문자열을 사용할 것입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"RESET\"\n        }), \": \u0026str = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\\x1b[0m\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"ORANGE\"\n        }), \": \u0026str = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\\x1b[93m\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"RED\"\n        }), \": \u0026str = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\\x1b[0;31m\\\"\"\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래의 코드에서는 맵을 사용하여 Connect 4 토큰과 유사한 이모지로 슬롯을 변환할 것입니다. 게임이 종료되면 우승자를 발표하는 좋은 장소로 보입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"impl \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 다른 함수들\"\n        }), \"\\n\\n    fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_board\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"\u0026self\"\n        }), \") {\\n        println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}--------------------{}\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ORANGE\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"RESET\"\n        }), \");\\n        println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}CONNECT 4 (Move {}){}\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ORANGE\"\n        }), \", self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"current_move\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"RESET\"\n        }), \");\\n        println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}--------------------{}\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ORANGE\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"RESET\"\n        }), \");\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" row \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"board\"\n        }), \" {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"row_str\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \" = row\\n                .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"iter\"\n        }), \"()\\n                .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"map\"\n        }), \"(|\u0026cell| match cell {\\n                    \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" =\u003e \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"🔴\\\"\"\n        }), \",\\n                    \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \" =\u003e \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"🟡\\\"\"\n        }), \",\\n                    \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"_\"\n          }), \" =\u003e\"]\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"⚫\\\"\"\n        }), \",\\n                })\\n                .\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"collect\"\n        }), \"::\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Vec\"\n        }), \"\u003c\u0026str\u003e\u003e()\\n                .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"join\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\" \\\"\"\n        }), \");\\n\\n            println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}\\\"\"\n        }), \", row_str);\\n        }\\n\\n        println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}--------------------{}\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ORANGE\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"RESET\"\n        }), \");\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"is_finished\"\n        }), \" {\\n            match self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"winner\"\n        }), \" {\\n                \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"One\"\n          }), \" =\u003e\"]\n        }), \" println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}🔴 Player 1이 승리했습니다!{}\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ORANGE\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"RESET\"\n        }), \"),\\n                \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"Two\"\n          }), \" =\u003e\"]\n        }), \" println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}🟡 Player 2가 승리했습니다!{}\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ORANGE\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"RESET\"\n        }), \"),\\n                \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"None\"\n          }), \" =\u003e\"]\n        }), \" println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}무승부입니다!{}\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ORANGE\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"RESET\"\n        }), \"),\\n            }\\n\\n            println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}--------------------{}\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ORANGE\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"RESET\"\n        }), \");\\n        }\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 이것을 언제든지 메인 함수 내에서 호출하여 보드의 상태를 확인할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" mut game = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"default\"\n        }), \"();\\n    game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_board\"\n        }), \"();\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"조금 지루하지만 수를 두지 않고는 재미가 없죠. 그래서 이제 수를 두는 방법을 프로그래밍해 봅시다!\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"수 두기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리의 play_move 함수를 첫 번째로 살펴보면, 이 함수는 이차원 배열에서 올바른 항목을 변경하고, 수를 증가시킨 다음 현재 플레이어를 변경해야 합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"impl\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// other functions\"\n        }), \"\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"play_move\"\n        }), \"(\u0026\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"mut\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \", column: \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"usize\"\n        }), \") {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"Some\"\n        }), \"(row) = (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"..BOARD_HEIGHT)\\n            .\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"rev\"\n        }), \"()\\n            .\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"find\"\n        }), \"(|\u0026row| \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".board[row][column] == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \")\\n        {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".board[row][column] = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".current_player \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"u8\"\n        }), \";\\n\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".current_move += \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".current_player = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"match\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".current_player {\\n                Player::One =\u003e Player::Two,\\n                _ =\u003e Player::One,\\n            };\\n        }\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 if let 코드에서는 열의 맨 아래부터 시작하여 하나씩 올라가면서 빈 칸을 찾을 때까지 진행합니다. 빈 칸을 찾으면 그 위치에 현재 플레이어를 나타내는 정수로 변경하고, 현재 이동을 증가시킨 후 match 표현식을 사용하여 플레이어를 변경합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 시점에서 코드를 통해 움직임을 실행하고 터미널에서 결과를 확인할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" mut game = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"default\"\n        }), \"();\\n    \\n    game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"play_move\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \");\\n    game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"play_move\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \");\\n    game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"play_move\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \");\\n    game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"play_move\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \");\\n\\n    game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_board\"\n        }), \"();\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"오류 처리\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금까지 우리는 보드 바깥으로 이동을 시도하는 잠재적인 오류를 처리하지 않고 있습니다. 따라서 세 가지 가능한 오류를 처리해 봅시다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"제공된 열이 허용 범위를 벗어납니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"제공된 열이 이미 가득 찼습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"게임이 끝났습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(사용자 입력을 받기 시작하면 추가적인 오류 처리가 필요할 것입니다. 나중에 처리하겠습니다.)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"세 가지 오류 유형을 포함한 enum을 만들어 봅시다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"enum \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MoveError\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"GameFinished\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"InvalidColumn\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ColumnFull\"\n        }), \",\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 에러를 명령줄에 출력하기를 원하기 때문에, 우리의 에러 메시지를 포함하는 사용자 정의 Display 트레이트를 구현해야 합니다. 예를 들어:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"impl \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"std\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"fmt\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Display\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MoveError\"\n        }), \" {\\n    fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fmt\"\n        }), \"(\u0026self, \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"f\"\n        }), \": \u0026mut \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"std\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"fmt\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Formatter\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'_\u003e) -\u003e std::fmt::Result {\\n        match self {\\n            MoveError::ColumnFull =\u003e write!(f, \\\"column is full\\\"),\\n            MoveError::InvalidColumn =\u003e write!(f, \\\"column must be between 1 and 7\\\"),\\n            MoveError::GameFinished =\u003e write!(f, \\\"game is already finished\\\"),\\n        }\\n    }\\n}\\n\"\n        })]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 이를 사용하여 play_move 함수를 수정할 수 있습니다. 이제 우리는 움직임이 성공적이면 아무것도 반환하지만, 그렇지 않은 경우 에러가 반환되는 Result enum을 반환합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"impl\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 다른 함수들\"\n        }), \"\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"play_move\"\n        }), \"(\u0026\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"mut\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \", column: \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"usize\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"-\u003e\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Result\"\n        }), \"\u003c(), MoveError\u003e {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".is_finished {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"Err\"\n        }), \"(MoveError::GameFinished);\\n        }\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" column \u003e= BOARD_WIDTH {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"Err\"\n        }), \"(MoveError::InvalidColumn);\\n        }\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"Some\"\n        }), \"(row) = (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"..BOARD_HEIGHT)\\n            .\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"rev\"\n        }), \"()\\n            .\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"find\"\n        }), \"(|\u0026row| \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".board[row][column] == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \")\\n        {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".board[row][column] = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".current_player \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"u8\"\n        }), \";\\n        } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"Err\"\n        }), \"(MoveError::ColumnFull);\\n        }\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".current_move += \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".current_player = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"match\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".current_player {\\n            Player::One =\u003e Player::Two,\\n            _ =\u003e Player::One,\\n        };\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"Ok\"\n        }), \"(())\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"디버깅을 위해 이제 play_move의 결과를 인쇄할 수 있으며, 예상치 못한 입력이 있는 경우 enum으로부터 에러를 볼 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리가 여기에 있는 동안, 명령줄에 에러 메시지를 인쇄하는 도우미 함수를 추가해 봅시다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"impl\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 다른 함수들\"\n        }), \"\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_error\"\n        }), \"(\u0026\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \", error: \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"String\"\n        }), \") {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"display_board\"\n        }), \"();\\n        \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"println!\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}에러: {}{}\\\"\"\n        }), \", RED, error, RESET);\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"게임에서 승리했는지 계산하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"누군가가 이겼는지 확인하기 위해 2차원 배열을 여러 방향으로 탐색해야 합니다. 이 Leetcode 스타일 문제는 재미있는 도전이었고, 결과물을 얻기까지 몇 번 시도해야 했어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"누군가가 4칸을 연달아 얻을 수 있는 네 가지 방향이 있어요:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"수평,\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"수직,\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"역 슬래시 대각선 (왼쪽 위에서 오른쪽 아래로),\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"순방향 슬래시 대각선 (왼쪽 아래에서 오른쪽 위로).\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"게시판의 모든 슬롯을 반복하여 네 방향 중 하나에서 테스트할 수 있습니다. (게시판이 작기 때문에 무차별 대입 방식을 사용하는 것이 부담이 되지 않습니다. 그러나 더 나은 방법이 있는지 궁금합니다!)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"게시판의 주어진 슬롯에서 시작합니다. 플레이어의 토큰이 들어있는 경우, 첫 번째 방향으로 한 단계 이동합니다. 이 새로운 슬롯도 같은 토큰을 포함하는 경우, 이 방향으로 또 다른 단계를 이동합니다. 이를 반복하여 같은 토큰이 있는 네 개의 슬롯을 찾을 때까지 진행합니다. 그렇지 않으면 다른 방향으로 이동합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"각 방향은 정수들의 튜플로 나타낼 수 있습니다 - 행당 거리에 대한 값과 열당 거리에 대한 값 하나씩 - 이 정보를 배열에 저장할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" directions = [\\n    (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"),  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 가로\"\n        }), \"\\n    (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"),  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 세로\"\n        }), \"\\n    (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"),  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 대각선 (왼쪽 위에서 오른쪽 아래)\"\n        }), \"\\n    (-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"), \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 대각선 (왼쪽 아래에서 오른쪽 위)\"\n        }), \"\\n];\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 튜플들이 무엇을 나타내는지 알려드릴게요:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"수평으로 이동하려면 행은 변하지 않고(0), 열만 변해야 합니다(1).\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"수직으로 이동하려면 행이 변해야 하고(1), 열은 변하지 않아야 합니다(0).\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"역 슬래시 대각선으로 이동하려면 행과 열이 둘 다 증가해야 합니다(1, 1).\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"마지막으로, 슬래시 대각선으로 이동하려면 열은 증가하고 행은 감소해야 합니다(-1, 1).\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"각 방향의 모든 슬롯을 테스트하려면 아래와 같이 세 개의 루프가 필요합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"impl\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 다른 함수들\"\n        }), \"\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"calculate_winner\"\n        }), \"(\u0026\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"mut\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"-\u003e\"\n        }), \" Player {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"row\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"..BOARD_HEIGHT {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"col\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"..BOARD_WIDTH {\\n                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"cell\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".board[row][col];\\n\\n                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" cell != \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" {\\n                    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"directions\"\n        }), \" = [\\n                        (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"),  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 수평\"\n        }), \"\\n                        (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"),  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 수직\"\n        }), \"\\n                        (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"),  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 대각선 (왼쪽 위에서 오른쪽 아래로)\"\n        }), \"\\n                        (-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"), \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 대각선 (왼쪽 아래에서 오른쪽 위로)\"\n        }), \"\\n                    ];\\n\\n                    \", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"for\"\n        }), \" (row_step, col_step) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" directions {\\n                        \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// TODO - 주어진 방향으로 보드를 탐색하고\"\n        }), \"\\n                        \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 승자를 찾았다면 해당 플레이어를 반환하세요\"\n        }), \"\\n                    }\\n                }\\n            }\\n        }\\n        Player::\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"None\"\n        }), \"\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 연속 카운트를 유지하고 — 4에 도달하면 승자가 나온 것을 알 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그럼, 최종 중첩된 루프에서는 시작 토큰부터 슬롯별로 이동을 시도할 것입니다. 그때까지…\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"시작 토큰과 다른 토큰을 만날 때 (그러한 경우 루프를 종료합니다);\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"보드의 가장자리에 도달할 때 (그러한 경우 루프를 종료합니다);\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"동일한 토큰의 4연속을 만날 때 (그러한 경우 게임을 종료하고 승자를 지정합니다).\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"impl \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 다른 함수들\"\n        }), \"\\n\\n    fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"calculate_winner\"\n        }), \"(\u0026mut self) -\u003e \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" row \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"BOARD_HEIGHT\"\n        }), \" {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" col \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"BOARD_WIDTH\"\n        }), \" {\\n                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" cell = self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"board\"\n        }), \"[row][col];\\n\\n                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" cell != \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" {\\n                    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" directions = [\\n                        (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"),  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 가로\"\n        }), \"\\n                        (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"),  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 세로\"\n        }), \"\\n                        (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"),  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 대각선 (왼쪽 위에서 오른쪽 아래로)\"\n        }), \"\\n                        (-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"), \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 대각선 (왼쪽 아래에서 오른쪽 위로)\"\n        }), \"\\n                    ];\\n\\n                    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (row_step, col_step) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" directions {\\n                        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" mut consecutive_count = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n                        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" mut r = row \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" isize + row_step;\\n                        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" mut c = col \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" isize + col_step;\\n\\n                        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" r \u003e= \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\n                            \u0026\u0026 r \u003c \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BOARD_HEIGHT\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" isize\\n                            \u0026\u0026 c \u003e= \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\n                            \u0026\u0026 c \u003c \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BOARD_WIDTH\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" isize\\n                        {\\n                            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"board\"\n        }), \"[r \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" usize][c \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" usize] == cell {\\n                                consecutive_count += \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n\\n                                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" consecutive_count == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \" {\\n                                    self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"is_finished\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \";\\n                                    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"from_int\"\n        }), \"(cell);\\n                                }\\n                            } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n                                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"break\"\n        }), \";\\n                            }\\n                            r += row_step;\\n                            c += col_step;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"None\"\n        }), \"\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 이동 횟수가 일곱 미만인 경우 이러한 확인 작업을 수행하지 않고 최적화를 조금 추가할 수 있습니다. 그때까지는 게임에서 이기는 것이 불가능하기 때문입니다. 그래서 함수 맨 위에 이를 추가해 봅시다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"current_move\"\n        }), \" \u003c \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"7\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"None\"\n        }), \";\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 보드가 가득 찼지만 승자가 없는 경우(즉, 무승부인 경우)에 게임을 종료로 표시해야 합니다. 이를 반환문 위에 추가해 줍시다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"current_move\"\n        }), \" \u003e= \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BOARD_HEIGHT\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" u8 * \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BOARD_WIDTH\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" u8 {\\n    self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"is_finished\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \";\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막으로, 새로운 calculate_winner 함수를 play_move 함수에 추가할 수 있습니다. 이번에는 아무것도 반환하는 대신, 성공인 Result enum을 반환하거나 실패인 경우에는 오류를 반환합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"impl \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 다른 함수들\"\n        }), \"\\n\\n    fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"play_move\"\n        }), \"(\u0026mut self, \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"column\"\n        }), \": usize) -\u003e \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Result\"\n        }), \"\u003c(), \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MoveError\"\n        }), \"\u003e {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"is_finished\"\n        }), \" {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Err\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MoveError\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"GameFinished\"\n        }), \");\\n        }\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" column \u003e= \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BOARD_WIDTH\"\n        }), \" {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Err\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MoveError\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"InvalidColumn\"\n        }), \");\\n        }\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Some\"\n        }), \"(row) = (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"BOARD_HEIGHT\"\n        }), \")\\n            .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"rev\"\n        }), \"()\\n            .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"find\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"|\u0026row| self.board[row][column] == \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          })]\n        }), \")\\n        {\\n            self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"board\"\n        }), \"[row][column] = self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"current_player\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" u8;\\n            self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"current_move\"\n        }), \" += \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n        } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Err\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MoveError\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ColumnFull\"\n        }), \");\\n        }\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" calculated_winner = self.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"calculate_winner\"\n        }), \"();\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" calculated_winner != \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"None\"\n        }), \" {\\n            self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"winner\"\n        }), \" = calculated_winner;\\n        } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n            self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"current_player\"\n        }), \" = match self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"current_player\"\n        }), \" {\\n                \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"One\"\n          }), \" =\u003e\"]\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Two\"\n        }), \",\\n                \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"_\"\n          }), \" =\u003e\"]\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"One\"\n        }), \",\\n            };\\n        }\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Ok\"\n        }), \"(())\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리의 Connect 4 게임 엔진이 완성되었습니다! 사용자로부터 입력을 받는 방법만 남았습니다...\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"사용자 입력 받기\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리 명령 줄 게임의 마지막 부분에서는 주 함수로 돌아가 사용자 입력을 읽을 수 있도록 할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저, Rust의 표준 I/O 라이브러리를 가져오겠습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"use \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"std\"\n        }), \"::io;\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사용자 입력을 읽는 논리는 다음과 같이 보일 수 있습니다. 여기서는 컴퓨터와 달리 0이 아닌 1부터 시작하여 카운트하게 됩니다!\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" mut user_move = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"new\"\n        }), \"();\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"io\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"stdin\"\n        }), \"()\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"read_line\"\n        }), \"(\u0026mut user_move)\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"expect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Failed to read line\\\"\"\n        }), \");\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"user_move\"\n        }), \": usize = match user_move.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"trim\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"parse\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Ok\"\n        }), \"(num) =\u003e {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" num \u003c \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" || num \u003e \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BOARD_WIDTH\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" u8 {\\n            game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_error\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MoveError\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"InvalidColumn\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"());\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"continue\"\n        }), \";\\n        } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n            num\\n        }\\n    }\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Err\"\n        }), \"(err) =\u003e {\\n        game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_error\"\n        }), \"(err.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"());\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"continue\"\n        }), \";\\n    }\\n};\\n\\nmatch game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"play_move\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"user_move - \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          })]\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Ok\"\n        }), \"(_) =\u003e {\\n        game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_board\"\n        }), \"();\\n    }\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Err\"\n        }), \"(err) =\u003e {\\n        game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_error\"\n        }), \"(err.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"());\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저, 우리는 빈 문자열을 정의한 뒤 사용자로부터 텍스트를 받기 위해 stdin 메소드를 사용합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음으로 이 입력을 구문 분석을 시도합니다. 다음 중 하나라도 해당하는 경우 오류를 표시합니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"구문 분석이 실패하는 경우 (예: 입력이 숫자가 아닌 경우).\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"구문 분석이 성공하지만 숫자가 원하는 범위를 벗어난 경우.```\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"만약 오류가 표시되지 않는다면, 우리는 선택한 수를 둘 것입니다. 그러나 해당 시나리오에서 오류가 발생할 수도 있으므로, 그런 경우에는 오류를 표시할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그러나 위의 코드는 한 번만 실행됩니다. 게임이 끝날 때까지 루프를 실행해야 합니다. 아래는 그 반복문을 추가한 main 함수와 사용자를 도와줄 몇 가지 유용한 메시지입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" mut game = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"default\"\n        }), \"();\\n    game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_board\"\n        }), \"();\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" !game.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"is_finished\"\n        }), \" {\\n        println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\\n\\\"\"\n        }), \");\\n\\n        match game.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"current_player\"\n        }), \" {\\n            \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"One\"\n          }), \" =\u003e\"]\n        }), \" println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"플레이어 1\\\"\"\n        }), \"),\\n            \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"Two\"\n          }), \" =\u003e\"]\n        }), \" println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"플레이어 2\\\"\"\n        }), \"),\\n            \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"_\"\n          }), \" =\u003e\"]\n        }), \" (),\\n        };\\n\\n        println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"1부터 7 사이의 열을 입력하세요:\\\"\"\n        }), \");\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" mut user_move = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"new\"\n        }), \"();\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"io\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"stdin\"\n        }), \"()\\n            .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"read_line\"\n        }), \"(\u0026mut user_move)\\n            .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"expect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"라인을 읽는 데 실패했습니다\\\"\"\n        }), \");\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"user_move\"\n        }), \": usize = match user_move.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"trim\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"parse\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n            \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Ok\"\n        }), \"(num) =\u003e {\\n                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" num \u003c \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" || num \u003e \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"7\"\n        }), \" {\\n                    game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_error\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MoveError\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"InvalidColumn\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"());\\n                    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"continue\"\n        }), \";\\n                } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n                    num\\n                }\\n            }\\n            \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Err\"\n        }), \"(err) =\u003e {\\n                game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_error\"\n        }), \"(err.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"());\\n                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"continue\"\n        }), \";\\n            }\\n        };\\n\\n        match game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"play_move\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"user_move - \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          })]\n        }), \") {\\n            \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Ok\"\n        }), \"(_) =\u003e {\\n                game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_board\"\n        }), \"();\\n            }\\n            \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Err\"\n        }), \"(err) =\u003e {\\n                game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_error\"\n        }), \"(err.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"());\\n            }\\n        }\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"여러 판을 플레이하기\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막으로, 사용자가 게임을 끝내면 게임을 다시 시작할 수 있도록 추가 코드를 추가하고 싶어요. 매번 실행 파일을 다시 시작해야 하는 번거로움은 피하고 싶으니까요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이를 위해 새로운 루프를 만들 것입니다. 이전과 동일한 방법을 사용하여 사용자의 입력을 읽을 수 있습니다. \\\"R\\\"을 누르면 새 게임을 시작하고, \\\"Q\\\"를 누르면 루프를 중단하고 코드를 끝까지 실행합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" mut game = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"default\"\n        }), \"();\\n    game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_board\"\n        }), \"();\\n\\n    loop {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" !game.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"is_finished\"\n        }), \" {\\n            \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 코드 변경 없음\"\n        }), \"\\n        }\\n\\n        println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Press 'R' to restart or 'Q' to quit the game.\\\"\"\n        }), \");\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" mut user_input = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"new\"\n        }), \"();\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"io\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"stdin\"\n        }), \"()\\n            .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"read_line\"\n        }), \"(\u0026mut user_input)\\n            .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"expect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Failed to read line\\\"\"\n        }), \");\\n\\n        match user_input.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"trim\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n            \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"R\\\"\"\n        }), \" | \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"r\\\"\"\n        }), \" =\u003e {\\n                game = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"default\"\n        }), \"();\\n                game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_board\"\n        }), \"();\\n            }\\n            \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Q\\\"\"\n        }), \" | \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"q\\\"\"\n        }), \" =\u003e {\\n                println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Quitting...\\\"\"\n        }), \");\\n                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"break\"\n        }), \";\\n            }\\n            _ =\u003e game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_error\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"잘못된 입력\\\"\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"()),\\n        }\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막으로, 차례 사이에 터미널을 지우기 위한 ASCII 이스케이프 코드를 사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clear_screen\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"\u0026self\"\n        }), \") {\\n    print!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}[2J\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"27\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" char);\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"게임 보드를 표시할 때마다 이 작업을 수행할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_board\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"\u0026self\"\n        }), \") {\\n    self.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clear_screen\"\n        }), \"();\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 코드 변경 없음\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"모두 함께 가져오기\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그것이 커넥트 4의 간단한 명령줄 게임을 위해 필요한 모든 것입니다! 이 작업 중인 파일을 사용하는 작동 버전을 시험하려면 Rust 플레이그라운드를 확인해보세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리가 지금까지 만든 전체 파일은 아래와 같습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"use \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"std\"\n        }), \"::io;\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"RESET\"\n        }), \": \u0026str = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\\x1b[0m\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"ORANGE\"\n        }), \": \u0026str = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\\x1b[93m\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"RED\"\n        }), \": \u0026str = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\\x1b[0;31m\\\"\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"BOARD_WIDTH\"\n        }), \": usize = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"7\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"BOARD_HEIGHT\"\n        }), \": usize = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \";\\n\\ntype \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Board\"\n        }), \" = [[u8; \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BOARD_WIDTH\"\n        }), \"]; \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BOARD_HEIGHT\"\n        }), \"];\\n\\n#[\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"derive\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Clone\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Copy\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Debug\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PartialEq\"\n        }), \")]\\n#[\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"repr\"\n        }), \"(u8)]\\nenum \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"One\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Two\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"None\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \",\\n}\\n\\nimpl \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \" {\\n    fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"from_int\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"int\"\n        }), \": u8) -\u003e \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \" {\\n        match int {\\n            \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" =\u003e \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"One\"\n        }), \",\\n            \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \" =\u003e \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Two\"\n        }), \",\\n            \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"_\"\n          }), \" =\u003e\"]\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"None\"\n        }), \",\\n        }\\n    }\\n}\\n\\n#[...]\\n\\n# 결론\\n\\n\u003cdiv \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \"=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"content-ad\\\"\"\n        }), \"\u003e\u003c/div\u003e\\n\\n지금까지 따라오셨다면 프로젝트를 더 나아가고 싶을 것입니다. 여러 게임을 거치면서 승리를 추적해 볼 수도 있고, 어떨까요? 어플리케이션을 웹 서버로 전환하여 웹사이트가 \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"HTTP\"\n        }), \"를 통해 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Connect\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \"를 플레이할 수 있게끔 만들어 보는 것은 어떤가요?\\n\\n이번 명령줄 어플리케이션을 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Rust\"\n        }), \"로 개발하는 방법에 대한 유용하고 재미있는 통찰력으로 여기시길 바랍니다. 아직 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Rust\"\n        }), \" 여행을 시작한 지 얼마 되지 않았기 때문에, 어떠한 비평이나 더 많은 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Rust\"\n        }), \" 다운 방식으로 어플리케이션을 작성하는 아이디어가 있다면 꼭 알려주세요. 함께 고민해보고 싶습니다.\\n\"]\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-20-LearnRustbycodingacommandlineConnect4game"},"buildId":"0asLlD6on3tm8cIfzBaxd","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>