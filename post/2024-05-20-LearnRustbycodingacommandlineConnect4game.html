<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Rust로 코딩하는 커맨드 라인 Connect 4 게임 배우기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-20-LearnRustbycodingacommandlineConnect4game" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Rust로 코딩하는 커맨드 라인 Connect 4 게임 배우기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Rust로 코딩하는 커맨드 라인 Connect 4 게임 배우기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-20-LearnRustbycodingacommandlineConnect4game" data-gatsby-head="true"/><meta name="twitter:title" content="Rust로 코딩하는 커맨드 라인 Connect 4 게임 배우기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-20 16:00" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_buildManifest.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Rust로 코딩하는 커맨드 라인 Connect 4 게임 배우기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Rust로 코딩하는 커맨드 라인 Connect 4 게임 배우기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 20, 2024</span><span class="posts_reading_time__f7YPP">24<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-20-LearnRustbycodingacommandlineConnect4game&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png" alt="Rust Connect 4"></p>
<p>안녕하세요! 이번 글에서는 Rust가 어떻게 우리가 Connect 4의 간단한 버전을 만들며 명령줄 응용 프로그램을 작성하는 데 도움이 되는지 살펴볼 거에요.</p>
<p>최근 Rust를 배우는 도전에 도전했고, 제 자신의 조언을 따르기 위해 개인 프로젝트에서 Rust를 사용해 손을 더럽히며 배운 것을 정리하려고 노력하고 있어요. Connect 4는 아주 좋은 도전 과제에요. 오후 하루 동안 코딩할 수 있는 것은 간단하지만 잘 하려면 약간의 생각이 필요한 복잡한 문제이죠.</p>
<p>여기 제 마지막 결과물이 포함된 Rust 플레이그라운드가 있어요. 아래에서는 거기에 이르기까지 취한 정확한 단계를 살펴볼 거에요. 따라오고 싶으시면 Rust가 설치되어 있는지 확인한 후 터미널에서 <code>cargo new rust_connect_4_tutorial</code>을 실행해서 프로젝트를 열고 좋아하는 편집기에서 src/main.rs로 이동해서 시작해봐요!</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>혹은 비디오를 통해 학습하는 것을 선호한다면, 해당 튜토리얼의 비디오 버전을 확인해보세요:</p>
<h1>우리의 타입 정의하기</h1>
<p>Rust에서 시작하는 가장 좋은 방법 중 하나는 종종 우리의 타입을 정의하는 것이므로, 우리는 정확히 그것을 할 것입니다!</p>
<p>먼저, 게임에 사용할 보드를 정의해 보겠습니다. Connect 4의 클래식 버전은 7개의 슬롯이 가로로 있고 6개의 슬롯이 세로로 있기 때문에, 이들 정수를 상수로 저장하고, 그 상수를 사용하여 두 차원 배열의 길이를 정의하는 데 사용할 수 있습니다. Board 타입으로 정의합니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-rust"><span class="hljs-keyword">const</span> BOARD_WIDTH: <span class="hljs-type">usize</span> = <span class="hljs-number">7</span>;
<span class="hljs-keyword">const</span> BOARD_HEIGHT: <span class="hljs-type">usize</span> = <span class="hljs-number">6</span>;

<span class="hljs-keyword">type</span> <span class="hljs-title class_">Board</span> = [[<span class="hljs-type">u8</span>; BOARD_WIDTH]; BOARD_HEIGHT];
</code></pre>
<p>플레이어를 추적할 방법이 필요할 것입니다. 이를 enum으로 구현할 수 있습니다. 우리는 두 명의 플레이어만 지원하지만, 한 명의 피스가 없는 슬롯을 나타내는 None 변형과 게임이 무승부로 끝날 때 처리하는 데 유용할 것입니다.</p>
<pre><code class="hljs language-rust"><span class="hljs-meta">#[derive(Clone, Copy, Debug, PartialEq)]</span>
<span class="hljs-meta">#[repr(u8)]</span>
<span class="hljs-keyword">enum</span> <span class="hljs-title class_">Player</span> {
    One = <span class="hljs-number">1</span>,
    Two = <span class="hljs-number">2</span>,
    <span class="hljs-literal">None</span> = <span class="hljs-number">0</span>,
}
</code></pre>
<p>위에서는 나중에 유용할 몇 가지 트레잇을 구현하기 위해 derive를 사용하고, enum의 메모리 레이아웃을 제어하기 위해 repr을 사용했습니다. 가능한 모든 값을 알기 때문에 u8로 제한할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다음으로, 우리는 게임을 나타내는 struct를 만들 것입니다. 여기에는 추적해야 할 모든 상태가 포함될 것입니다.</p>
<pre><code class="hljs language-javascript">struct <span class="hljs-title class_">Game</span> {
    <span class="hljs-attr">current_move</span>: u8,
    <span class="hljs-attr">current_player</span>: <span class="hljs-title class_">Player</span>,
    <span class="hljs-attr">board</span>: <span class="hljs-title class_">Board</span>,
    <span class="hljs-attr">is_finished</span>: bool,
    <span class="hljs-attr">winner</span>: <span class="hljs-title class_">Player</span>,
}
</code></pre>
<p>current_move는 플레이어가 선택한 열을 나타내는 정수입니다. 우리에게는 승자 필드가 있지만, 게임이 비김으로 끝날 때 별도로 is_finished 부울도 유용할 것입니다!</p>
<p>마지막으로, Game에 대한 기본 함수를 구현할 것입니다. 이 함수에는 초기 상태가 포함될 것입니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Game</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">default</span>() <span class="hljs-punctuation">-></span> Game {
        Game {
            current_move: <span class="hljs-number">0</span>,
            current_player: Player::One,
            board: [
                [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
                [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
                [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
                [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
                [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
                [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
            ],
            is_finished: <span class="hljs-literal">false</span>,
            winner: Player::<span class="hljs-literal">None</span>,
        }
    }
}
</code></pre>
<p>보드에 대해 조금 이야기해 봅시다. 여기서 0은 빈 칸을 나타내며, 1은 Player One이 차지한 칸을 나타내고, 2는 Player Two가 차지한 칸을 나타냅니다.</p>
<p>BOARD_WIDTH와 BOARD_HEIGHT를 사용하여 동적으로 생성할 수도 있었지만, 코드를 작성하는 동안 전체 배열을 보는 것이 도움이 되는 시각적 도구라는 것을 발견했습니다. 같은 이유로, 정수가 아닌 Player 열거형을 사용하지 않았습니다. 텍스트가 더 많아지면 코드를 한눈에 이해하기 어려워지기 때문입니다.</p>
<p>이 방법의 (약간의) 단점은 나중에 정수를 Player로 변환해야 한다는 것입니다. 하지만 Player에 from_int 함수를 구현함으로써 쉽게 해결할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">구현 <span class="hljs-title class_">Player</span> {
    fn <span class="hljs-title function_">from_int</span>(<span class="hljs-attr">int</span>: u8) -> <span class="hljs-title class_">Player</span> {
        match int {
            <span class="hljs-number">1</span> => <span class="hljs-title class_">Player</span>::<span class="hljs-title class_">One</span>,
            <span class="hljs-number">2</span> => <span class="hljs-title class_">Player</span>::<span class="hljs-title class_">Two</span>,
            <span class="hljs-function"><span class="hljs-params">_</span> =></span> <span class="hljs-title class_">Player</span>::<span class="hljs-title class_">None</span>,
        }
    }
}
</code></pre>
<h1>보드 표시</h1>
<p>디버깅을 위해, 보드를 시각화하는 좋은 방법을 빠르게 코드화하는 것이 도움이 될 것입니다. 명령줄에 출력하기 위해 크레이트를 사용하는 대신에 간단한 색을 나타내기 위해 16진수 이스케이프 문자열을 사용할 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-attr">RESET</span>: str = <span class="hljs-string">"\x1b[0m"</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">ORANGE</span>: str = <span class="hljs-string">"\x1b[93m"</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">RED</span>: str = <span class="hljs-string">"\x1b[0;31m"</span>;
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아래의 코드에서는 맵을 사용하여 Connect 4 토큰과 유사한 이모지로 슬롯을 변환할 것입니다. 게임이 종료되면 우승자를 발표하는 좋은 장소로 보입니다.</p>
<pre><code class="hljs language-js">impl <span class="hljs-title class_">Game</span> {
    <span class="hljs-comment">// 다른 함수들</span>

    fn <span class="hljs-title function_">display_board</span>(<span class="hljs-params">&#x26;self</span>) {
        println!(<span class="hljs-string">"{}--------------------{}"</span>, <span class="hljs-variable constant_">ORANGE</span>, <span class="hljs-variable constant_">RESET</span>);
        println!(<span class="hljs-string">"{}CONNECT 4 (Move {}){}"</span>, <span class="hljs-variable constant_">ORANGE</span>, self.<span class="hljs-property">current_move</span>, <span class="hljs-variable constant_">RESET</span>);
        println!(<span class="hljs-string">"{}--------------------{}"</span>, <span class="hljs-variable constant_">ORANGE</span>, <span class="hljs-variable constant_">RESET</span>);

        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> self.<span class="hljs-property">board</span> {
            <span class="hljs-keyword">let</span> <span class="hljs-attr">row_str</span>: <span class="hljs-title class_">String</span> = row
                .<span class="hljs-title function_">iter</span>()
                .<span class="hljs-title function_">map</span>(|&#x26;cell| match cell {
                    <span class="hljs-number">1</span> => <span class="hljs-string">"🔴"</span>,
                    <span class="hljs-number">2</span> => <span class="hljs-string">"🟡"</span>,
                    <span class="hljs-function"><span class="hljs-params">_</span> =></span> <span class="hljs-string">"⚫"</span>,
                })
                .<span class="hljs-property">collect</span>::&#x3C;<span class="hljs-title class_">Vec</span>&#x3C;&#x26;str>>()
                .<span class="hljs-title function_">join</span>(<span class="hljs-string">" "</span>);

            println!(<span class="hljs-string">"{}"</span>, row_str);
        }

        println!(<span class="hljs-string">"{}--------------------{}"</span>, <span class="hljs-variable constant_">ORANGE</span>, <span class="hljs-variable constant_">RESET</span>);

        <span class="hljs-keyword">if</span> self.<span class="hljs-property">is_finished</span> {
            match self.<span class="hljs-property">winner</span> {
                <span class="hljs-title class_">Player</span>::<span class="hljs-function"><span class="hljs-params">One</span> =></span> println!(<span class="hljs-string">"{}🔴 Player 1이 승리했습니다!{}"</span>, <span class="hljs-variable constant_">ORANGE</span>, <span class="hljs-variable constant_">RESET</span>),
                <span class="hljs-title class_">Player</span>::<span class="hljs-function"><span class="hljs-params">Two</span> =></span> println!(<span class="hljs-string">"{}🟡 Player 2가 승리했습니다!{}"</span>, <span class="hljs-variable constant_">ORANGE</span>, <span class="hljs-variable constant_">RESET</span>),
                <span class="hljs-title class_">Player</span>::<span class="hljs-function"><span class="hljs-params">None</span> =></span> println!(<span class="hljs-string">"{}무승부입니다!{}"</span>, <span class="hljs-variable constant_">ORANGE</span>, <span class="hljs-variable constant_">RESET</span>),
            }

            println!(<span class="hljs-string">"{}--------------------{}"</span>, <span class="hljs-variable constant_">ORANGE</span>, <span class="hljs-variable constant_">RESET</span>);
        }
    }
}
</code></pre>
<p>우리는 이것을 언제든지 메인 함수 내에서 호출하여 보드의 상태를 확인할 수 있습니다.</p>
<pre><code class="hljs language-js">fn <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> mut game = <span class="hljs-title class_">Game</span>::<span class="hljs-title function_">default</span>();
    game.<span class="hljs-title function_">display_board</span>();
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>조금 지루하지만 수를 두지 않고는 재미가 없죠. 그래서 이제 수를 두는 방법을 프로그래밍해 봅시다!</p>
<h1>수 두기</h1>
<p>우리의 play_move 함수를 첫 번째로 살펴보면, 이 함수는 이차원 배열에서 올바른 항목을 변경하고, 수를 증가시킨 다음 현재 플레이어를 변경해야 합니다.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Game</span> {
    <span class="hljs-comment">// other functions</span>

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">play_move</span>(&#x26;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, column: <span class="hljs-type">usize</span>) {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(row) = (<span class="hljs-number">0</span>..BOARD_HEIGHT)
            .<span class="hljs-title function_ invoke__">rev</span>()
            .<span class="hljs-title function_ invoke__">find</span>(|&#x26;row| <span class="hljs-keyword">self</span>.board[row][column] == <span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">self</span>.board[row][column] = <span class="hljs-keyword">self</span>.current_player <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>;

            <span class="hljs-keyword">self</span>.current_move += <span class="hljs-number">1</span>;

            <span class="hljs-keyword">self</span>.current_player = <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.current_player {
                Player::One => Player::Two,
                _ => Player::One,
            };
        }
    }
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위의 if let 코드에서는 열의 맨 아래부터 시작하여 하나씩 올라가면서 빈 칸을 찾을 때까지 진행합니다. 빈 칸을 찾으면 그 위치에 현재 플레이어를 나타내는 정수로 변경하고, 현재 이동을 증가시킨 후 match 표현식을 사용하여 플레이어를 변경합니다.</p>
<p>이 시점에서 코드를 통해 움직임을 실행하고 터미널에서 결과를 확인할 수 있습니다:</p>
<pre><code class="hljs language-js">fn <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> mut game = <span class="hljs-title class_">Game</span>::<span class="hljs-title function_">default</span>();

    game.<span class="hljs-title function_">play_move</span>(<span class="hljs-number">3</span>);
    game.<span class="hljs-title function_">play_move</span>(<span class="hljs-number">3</span>);
    game.<span class="hljs-title function_">play_move</span>(<span class="hljs-number">4</span>);
    game.<span class="hljs-title function_">play_move</span>(<span class="hljs-number">3</span>);

    game.<span class="hljs-title function_">display_board</span>();
}
</code></pre>
<h1>오류 처리</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>지금까지 우리는 보드 바깥으로 이동을 시도하는 잠재적인 오류를 처리하지 않고 있습니다. 따라서 세 가지 가능한 오류를 처리해 봅시다:</p>
<ul>
<li>제공된 열이 허용 범위를 벗어납니다.</li>
<li>제공된 열이 이미 가득 찼습니다.</li>
<li>게임이 끝났습니다.</li>
</ul>
<p>(사용자 입력을 받기 시작하면 추가적인 오류 처리가 필요할 것입니다. 나중에 처리하겠습니다.)</p>
<p>세 가지 오류 유형을 포함한 enum을 만들어 봅시다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">enum <span class="hljs-title class_">MoveError</span> {
    <span class="hljs-title class_">GameFinished</span>,
    <span class="hljs-title class_">InvalidColumn</span>,
    <span class="hljs-title class_">ColumnFull</span>,
}
</code></pre>
<p>우리는 에러를 명령줄에 출력하기를 원하기 때문에, 우리의 에러 메시지를 포함하는 사용자 정의 Display 트레이트를 구현해야 합니다. 예를 들어:</p>
<pre><code class="hljs language-js">impl <span class="hljs-attr">std</span>::<span class="hljs-attr">fmt</span>::<span class="hljs-title class_">Display</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MoveError</span> {
    fn <span class="hljs-title function_">fmt</span>(&#x26;self, <span class="hljs-attr">f</span>: &#x26;mut <span class="hljs-attr">std</span>::<span class="hljs-attr">fmt</span>::<span class="hljs-title class_">Formatter</span>&#x3C;<span class="hljs-string">'_>) -> std::fmt::Result {
        match self {
            MoveError::ColumnFull => write!(f, "column is full"),
            MoveError::InvalidColumn => write!(f, "column must be between 1 and 7"),
            MoveError::GameFinished => write!(f, "game is already finished"),
        }
    }
}
</span></code></pre>
<p>이제 이를 사용하여 play_move 함수를 수정할 수 있습니다. 이제 우리는 움직임이 성공적이면 아무것도 반환하지만, 그렇지 않은 경우 에러가 반환되는 Result enum을 반환합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Game</span> {
    <span class="hljs-comment">// 다른 함수들</span>

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">play_move</span>(&#x26;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, column: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-></span> <span class="hljs-type">Result</span>&#x3C;(), MoveError> {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.is_finished {
            <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(MoveError::GameFinished);
        }

        <span class="hljs-keyword">if</span> column >= BOARD_WIDTH {
            <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(MoveError::InvalidColumn);
        }

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(row) = (<span class="hljs-number">0</span>..BOARD_HEIGHT)
            .<span class="hljs-title function_ invoke__">rev</span>()
            .<span class="hljs-title function_ invoke__">find</span>(|&#x26;row| <span class="hljs-keyword">self</span>.board[row][column] == <span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">self</span>.board[row][column] = <span class="hljs-keyword">self</span>.current_player <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(MoveError::ColumnFull);
        }

        <span class="hljs-keyword">self</span>.current_move += <span class="hljs-number">1</span>;

        <span class="hljs-keyword">self</span>.current_player = <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.current_player {
            Player::One => Player::Two,
            _ => Player::One,
        };

        <span class="hljs-title function_ invoke__">Ok</span>(())
    }
}
</code></pre>
<p>디버깅을 위해 이제 play_move의 결과를 인쇄할 수 있으며, 예상치 못한 입력이 있는 경우 enum으로부터 에러를 볼 수 있습니다.</p>
<p>우리가 여기에 있는 동안, 명령줄에 에러 메시지를 인쇄하는 도우미 함수를 추가해 봅시다.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Game</span> {
    <span class="hljs-comment">// 다른 함수들</span>

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">display_error</span>(&#x26;<span class="hljs-keyword">self</span>, error: <span class="hljs-type">String</span>) {
        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">display_board</span>();
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}에러: {}{}"</span>, RED, error, RESET);
    }
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>게임에서 승리했는지 계산하기</h1>
<p>누군가가 이겼는지 확인하기 위해 2차원 배열을 여러 방향으로 탐색해야 합니다. 이 Leetcode 스타일 문제는 재미있는 도전이었고, 결과물을 얻기까지 몇 번 시도해야 했어요.</p>
<p>누군가가 4칸을 연달아 얻을 수 있는 네 가지 방향이 있어요:</p>
<ul>
<li>수평,</li>
<li>수직,</li>
<li>역 슬래시 대각선 (왼쪽 위에서 오른쪽 아래로),</li>
<li>순방향 슬래시 대각선 (왼쪽 아래에서 오른쪽 위로).</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>게시판의 모든 슬롯을 반복하여 네 방향 중 하나에서 테스트할 수 있습니다. (게시판이 작기 때문에 무차별 대입 방식을 사용하는 것이 부담이 되지 않습니다. 그러나 더 나은 방법이 있는지 궁금합니다!)</p>
<p>게시판의 주어진 슬롯에서 시작합니다. 플레이어의 토큰이 들어있는 경우, 첫 번째 방향으로 한 단계 이동합니다. 이 새로운 슬롯도 같은 토큰을 포함하는 경우, 이 방향으로 또 다른 단계를 이동합니다. 이를 반복하여 같은 토큰이 있는 네 개의 슬롯을 찾을 때까지 진행합니다. 그렇지 않으면 다른 방향으로 이동합니다.</p>
<p>각 방향은 정수들의 튜플로 나타낼 수 있습니다 - 행당 거리에 대한 값과 열당 거리에 대한 값 하나씩 - 이 정보를 배열에 저장할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> directions = [
  (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), <span class="hljs-comment">// 가로</span>
  (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), <span class="hljs-comment">// 세로</span>
  (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), <span class="hljs-comment">// 대각선 (왼쪽 위에서 오른쪽 아래)</span>
  (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), <span class="hljs-comment">// 대각선 (왼쪽 아래에서 오른쪽 위)</span>
];
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 튜플들이 무엇을 나타내는지 알려드릴게요:</p>
<ul>
<li>수평으로 이동하려면 행은 변하지 않고(0), 열만 변해야 합니다(1).</li>
<li>수직으로 이동하려면 행이 변해야 하고(1), 열은 변하지 않아야 합니다(0).</li>
<li>역 슬래시 대각선으로 이동하려면 행과 열이 둘 다 증가해야 합니다(1, 1).</li>
<li>마지막으로, 슬래시 대각선으로 이동하려면 열은 증가하고 행은 감소해야 합니다(-1, 1).</li>
</ul>
<p>각 방향의 모든 슬롯을 테스트하려면 아래와 같이 세 개의 루프가 필요합니다.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Game</span> {
    <span class="hljs-comment">// 다른 함수들</span>

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_winner</span>(&#x26;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-></span> Player {
        <span class="hljs-keyword">for</span> <span class="hljs-variable">row</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..BOARD_HEIGHT {
            <span class="hljs-keyword">for</span> <span class="hljs-variable">col</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..BOARD_WIDTH {
                <span class="hljs-keyword">let</span> <span class="hljs-variable">cell</span> = <span class="hljs-keyword">self</span>.board[row][col];

                <span class="hljs-keyword">if</span> cell != <span class="hljs-number">0</span> {
                    <span class="hljs-keyword">let</span> <span class="hljs-variable">directions</span> = [
                        (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>),  <span class="hljs-comment">// 수평</span>
                        (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),  <span class="hljs-comment">// 수직</span>
                        (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>),  <span class="hljs-comment">// 대각선 (왼쪽 위에서 오른쪽 아래로)</span>
                        (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), <span class="hljs-comment">// 대각선 (왼쪽 아래에서 오른쪽 위로)</span>
                    ];

                    <span class="hljs-title function_ invoke__">for</span> (row_step, col_step) <span class="hljs-keyword">in</span> directions {
                        <span class="hljs-comment">// TODO - 주어진 방향으로 보드를 탐색하고</span>
                        <span class="hljs-comment">// 승자를 찾았다면 해당 플레이어를 반환하세요</span>
                    }
                }
            }
        }
        Player::<span class="hljs-literal">None</span>
    }
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우리는 연속 카운트를 유지하고 — 4에 도달하면 승자가 나온 것을 알 수 있습니다.</p>
<p>그럼, 최종 중첩된 루프에서는 시작 토큰부터 슬롯별로 이동을 시도할 것입니다. 그때까지…</p>
<ul>
<li>시작 토큰과 다른 토큰을 만날 때 (그러한 경우 루프를 종료합니다);</li>
<li>보드의 가장자리에 도달할 때 (그러한 경우 루프를 종료합니다);</li>
<li>동일한 토큰의 4연속을 만날 때 (그러한 경우 게임을 종료하고 승자를 지정합니다).</li>
</ul>
<pre><code class="hljs language-js">impl <span class="hljs-title class_">Game</span> {
    <span class="hljs-comment">// 다른 함수들</span>

    fn <span class="hljs-title function_">calculate_winner</span>(&#x26;mut self) -> <span class="hljs-title class_">Player</span> {
        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.<span class="hljs-property">BOARD_HEIGHT</span> {
            <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.<span class="hljs-property">BOARD_WIDTH</span> {
                <span class="hljs-keyword">let</span> cell = self.<span class="hljs-property">board</span>[row][col];

                <span class="hljs-keyword">if</span> cell != <span class="hljs-number">0</span> {
                    <span class="hljs-keyword">let</span> directions = [
                        (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>),  <span class="hljs-comment">// 가로</span>
                        (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),  <span class="hljs-comment">// 세로</span>
                        (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>),  <span class="hljs-comment">// 대각선 (왼쪽 위에서 오른쪽 아래로)</span>
                        (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), <span class="hljs-comment">// 대각선 (왼쪽 아래에서 오른쪽 위로)</span>
                    ];

                    <span class="hljs-keyword">for</span> (row_step, col_step) <span class="hljs-keyword">in</span> directions {
                        <span class="hljs-keyword">let</span> mut consecutive_count = <span class="hljs-number">1</span>;
                        <span class="hljs-keyword">let</span> mut r = row <span class="hljs-keyword">as</span> isize + row_step;
                        <span class="hljs-keyword">let</span> mut c = col <span class="hljs-keyword">as</span> isize + col_step;

                        <span class="hljs-keyword">while</span> r >= <span class="hljs-number">0</span>
                            &#x26;&#x26; r &#x3C; <span class="hljs-variable constant_">BOARD_HEIGHT</span> <span class="hljs-keyword">as</span> isize
                            &#x26;&#x26; c >= <span class="hljs-number">0</span>
                            &#x26;&#x26; c &#x3C; <span class="hljs-variable constant_">BOARD_WIDTH</span> <span class="hljs-keyword">as</span> isize
                        {
                            <span class="hljs-keyword">if</span> self.<span class="hljs-property">board</span>[r <span class="hljs-keyword">as</span> usize][c <span class="hljs-keyword">as</span> usize] == cell {
                                consecutive_count += <span class="hljs-number">1</span>;

                                <span class="hljs-keyword">if</span> consecutive_count == <span class="hljs-number">4</span> {
                                    self.<span class="hljs-property">is_finished</span> = <span class="hljs-literal">true</span>;
                                    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Player</span>::<span class="hljs-title function_">from_int</span>(cell);
                                }
                            } <span class="hljs-keyword">else</span> {
                                <span class="hljs-keyword">break</span>;
                            }
                            r += row_step;
                            c += col_step;
                        }
                    }
                }
            }
        }

        <span class="hljs-title class_">Player</span>::<span class="hljs-title class_">None</span>
    }
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우리는 이동 횟수가 일곱 미만인 경우 이러한 확인 작업을 수행하지 않고 최적화를 조금 추가할 수 있습니다. 그때까지는 게임에서 이기는 것이 불가능하기 때문입니다. 그래서 함수 맨 위에 이를 추가해 봅시다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> self.<span class="hljs-property">current_move</span> &#x3C; <span class="hljs-number">7</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Player</span>::<span class="hljs-title class_">None</span>;
}
</code></pre>
<p>그리고 보드가 가득 찼지만 승자가 없는 경우(즉, 무승부인 경우)에 게임을 종료로 표시해야 합니다. 이를 반환문 위에 추가해 줍시다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> self.<span class="hljs-property">current_move</span> >= <span class="hljs-variable constant_">BOARD_HEIGHT</span> <span class="hljs-keyword">as</span> u8 * <span class="hljs-variable constant_">BOARD_WIDTH</span> <span class="hljs-keyword">as</span> u8 {
    self.<span class="hljs-property">is_finished</span> = <span class="hljs-literal">true</span>;
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>마지막으로, 새로운 calculate_winner 함수를 play_move 함수에 추가할 수 있습니다. 이번에는 아무것도 반환하는 대신, 성공인 Result enum을 반환하거나 실패인 경우에는 오류를 반환합니다.</p>
<pre><code class="hljs language-js">impl <span class="hljs-title class_">Game</span> {
    <span class="hljs-comment">// 다른 함수들</span>

    fn <span class="hljs-title function_">play_move</span>(&#x26;mut self, <span class="hljs-attr">column</span>: usize) -> <span class="hljs-title class_">Result</span>&#x3C;(), <span class="hljs-title class_">MoveError</span>> {
        <span class="hljs-keyword">if</span> self.<span class="hljs-property">is_finished</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Err</span>(<span class="hljs-title class_">MoveError</span>::<span class="hljs-title class_">GameFinished</span>);
        }

        <span class="hljs-keyword">if</span> column >= <span class="hljs-variable constant_">BOARD_WIDTH</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Err</span>(<span class="hljs-title class_">MoveError</span>::<span class="hljs-title class_">InvalidColumn</span>);
        }

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-title class_">Some</span>(row) = (<span class="hljs-number">0.</span>.<span class="hljs-property">BOARD_HEIGHT</span>)
            .<span class="hljs-title function_">rev</span>()
            .<span class="hljs-title function_">find</span>(<span class="hljs-params">|&#x26;row| self.board[row][column] == <span class="hljs-number">0</span></span>)
        {
            self.<span class="hljs-property">board</span>[row][column] = self.<span class="hljs-property">current_player</span> <span class="hljs-keyword">as</span> u8;
            self.<span class="hljs-property">current_move</span> += <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Err</span>(<span class="hljs-title class_">MoveError</span>::<span class="hljs-title class_">ColumnFull</span>);
        }

        <span class="hljs-keyword">let</span> calculated_winner = self.<span class="hljs-title function_">calculate_winner</span>();

        <span class="hljs-keyword">if</span> calculated_winner != <span class="hljs-title class_">Player</span>::<span class="hljs-title class_">None</span> {
            self.<span class="hljs-property">winner</span> = calculated_winner;
        } <span class="hljs-keyword">else</span> {
            self.<span class="hljs-property">current_player</span> = match self.<span class="hljs-property">current_player</span> {
                <span class="hljs-title class_">Player</span>::<span class="hljs-function"><span class="hljs-params">One</span> =></span> <span class="hljs-title class_">Player</span>::<span class="hljs-title class_">Two</span>,
                <span class="hljs-function"><span class="hljs-params">_</span> =></span> <span class="hljs-title class_">Player</span>::<span class="hljs-title class_">One</span>,
            };
        }

        <span class="hljs-title class_">Ok</span>(())
    }
}
</code></pre>
<p>우리의 Connect 4 게임 엔진이 완성되었습니다! 사용자로부터 입력을 받는 방법만 남았습니다...</p>
<h1>사용자 입력 받기</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우리 명령 줄 게임의 마지막 부분에서는 주 함수로 돌아가 사용자 입력을 읽을 수 있도록 할 것입니다.</p>
<p>먼저, Rust의 표준 I/O 라이브러리를 가져오겠습니다.</p>
<pre><code class="hljs language-js">use <span class="hljs-attr">std</span>::io;
</code></pre>
<p>사용자 입력을 읽는 논리는 다음과 같이 보일 수 있습니다. 여기서는 컴퓨터와 달리 0이 아닌 1부터 시작하여 카운트하게 됩니다!</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> mut user_move = <span class="hljs-title class_">String</span>::<span class="hljs-title function_">new</span>();

<span class="hljs-attr">io</span>::<span class="hljs-title function_">stdin</span>()
    .<span class="hljs-title function_">read_line</span>(&#x26;mut user_move)
    .<span class="hljs-title function_">expect</span>(<span class="hljs-string">"Failed to read line"</span>);

<span class="hljs-keyword">let</span> <span class="hljs-attr">user_move</span>: usize = match user_move.<span class="hljs-title function_">trim</span>().<span class="hljs-title function_">parse</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title class_">Ok</span>(num) => {
        <span class="hljs-keyword">if</span> num &#x3C; <span class="hljs-number">1</span> || num > <span class="hljs-variable constant_">BOARD_WIDTH</span> <span class="hljs-keyword">as</span> u8 {
            game.<span class="hljs-title function_">display_error</span>(<span class="hljs-title class_">MoveError</span>::<span class="hljs-title class_">InvalidColumn</span>.<span class="hljs-title function_">to_string</span>());
            <span class="hljs-keyword">continue</span>;
        } <span class="hljs-keyword">else</span> {
            num
        }
    }
    <span class="hljs-title class_">Err</span>(err) => {
        game.<span class="hljs-title function_">display_error</span>(err.<span class="hljs-title function_">to_string</span>());
        <span class="hljs-keyword">continue</span>;
    }
};

match game.<span class="hljs-title function_">play_move</span>(<span class="hljs-params">user_move - <span class="hljs-number">1</span></span>) {
    <span class="hljs-title class_">Ok</span>(_) => {
        game.<span class="hljs-title function_">display_board</span>();
    }
    <span class="hljs-title class_">Err</span>(err) => {
        game.<span class="hljs-title function_">display_error</span>(err.<span class="hljs-title function_">to_string</span>());
    }
}
</code></pre>
<p>먼저, 우리는 빈 문자열을 정의한 뒤 사용자로부터 텍스트를 받기 위해 stdin 메소드를 사용합니다.</p>
<p>다음으로 이 입력을 구문 분석을 시도합니다. 다음 중 하나라도 해당하는 경우 오류를 표시합니다:</p>
<ul>
<li>구문 분석이 실패하는 경우 (예: 입력이 숫자가 아닌 경우).</li>
<li>구문 분석이 성공하지만 숫자가 원하는 범위를 벗어난 경우.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>만약 오류가 표시되지 않는다면, 우리는 선택한 수를 둘 것입니다. 그러나 해당 시나리오에서 오류가 발생할 수도 있으므로, 그런 경우에는 오류를 표시할 것입니다.</p>
<p>그러나 위의 코드는 한 번만 실행됩니다. 게임이 끝날 때까지 루프를 실행해야 합니다. 아래는 그 반복문을 추가한 main 함수와 사용자를 도와줄 몇 가지 유용한 메시지입니다:</p>
<pre><code class="hljs language-js">fn <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> mut game = <span class="hljs-title class_">Game</span>::<span class="hljs-title function_">default</span>();
    game.<span class="hljs-title function_">display_board</span>();

    <span class="hljs-keyword">while</span> !game.<span class="hljs-property">is_finished</span> {
        println!(<span class="hljs-string">"\n"</span>);

        match game.<span class="hljs-property">current_player</span> {
            <span class="hljs-title class_">Player</span>::<span class="hljs-function"><span class="hljs-params">One</span> =></span> println!(<span class="hljs-string">"플레이어 1"</span>),
            <span class="hljs-title class_">Player</span>::<span class="hljs-function"><span class="hljs-params">Two</span> =></span> println!(<span class="hljs-string">"플레이어 2"</span>),
            <span class="hljs-function"><span class="hljs-params">_</span> =></span> (),
        };

        println!(<span class="hljs-string">"1부터 7 사이의 열을 입력하세요:"</span>);

        <span class="hljs-keyword">let</span> mut user_move = <span class="hljs-title class_">String</span>::<span class="hljs-title function_">new</span>();
        <span class="hljs-attr">io</span>::<span class="hljs-title function_">stdin</span>()
            .<span class="hljs-title function_">read_line</span>(&#x26;mut user_move)
            .<span class="hljs-title function_">expect</span>(<span class="hljs-string">"라인을 읽는 데 실패했습니다"</span>);

        <span class="hljs-keyword">let</span> <span class="hljs-attr">user_move</span>: usize = match user_move.<span class="hljs-title function_">trim</span>().<span class="hljs-title function_">parse</span>(<span class="hljs-params"></span>) {
            <span class="hljs-title class_">Ok</span>(num) => {
                <span class="hljs-keyword">if</span> num &#x3C; <span class="hljs-number">1</span> || num > <span class="hljs-number">7</span> {
                    game.<span class="hljs-title function_">display_error</span>(<span class="hljs-title class_">MoveError</span>::<span class="hljs-title class_">InvalidColumn</span>.<span class="hljs-title function_">to_string</span>());
                    <span class="hljs-keyword">continue</span>;
                } <span class="hljs-keyword">else</span> {
                    num
                }
            }
            <span class="hljs-title class_">Err</span>(err) => {
                game.<span class="hljs-title function_">display_error</span>(err.<span class="hljs-title function_">to_string</span>());
                <span class="hljs-keyword">continue</span>;
            }
        };

        match game.<span class="hljs-title function_">play_move</span>(<span class="hljs-params">user_move - <span class="hljs-number">1</span></span>) {
            <span class="hljs-title class_">Ok</span>(_) => {
                game.<span class="hljs-title function_">display_board</span>();
            }
            <span class="hljs-title class_">Err</span>(err) => {
                game.<span class="hljs-title function_">display_error</span>(err.<span class="hljs-title function_">to_string</span>());
            }
        }
    }
}
</code></pre>
<h1>여러 판을 플레이하기</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>마지막으로, 사용자가 게임을 끝내면 게임을 다시 시작할 수 있도록 추가 코드를 추가하고 싶어요. 매번 실행 파일을 다시 시작해야 하는 번거로움은 피하고 싶으니까요!</p>
<p>이를 위해 새로운 루프를 만들 것입니다. 이전과 동일한 방법을 사용하여 사용자의 입력을 읽을 수 있습니다. "R"을 누르면 새 게임을 시작하고, "Q"를 누르면 루프를 중단하고 코드를 끝까지 실행합니다.</p>
<pre><code class="hljs language-js">fn <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> mut game = <span class="hljs-title class_">Game</span>::<span class="hljs-title function_">default</span>();
    game.<span class="hljs-title function_">display_board</span>();

    loop {
        <span class="hljs-keyword">while</span> !game.<span class="hljs-property">is_finished</span> {
            <span class="hljs-comment">// 코드 변경 없음</span>
        }

        println!(<span class="hljs-string">"Press 'R' to restart or 'Q' to quit the game."</span>);

        <span class="hljs-keyword">let</span> mut user_input = <span class="hljs-title class_">String</span>::<span class="hljs-title function_">new</span>();

        <span class="hljs-attr">io</span>::<span class="hljs-title function_">stdin</span>()
            .<span class="hljs-title function_">read_line</span>(&#x26;mut user_input)
            .<span class="hljs-title function_">expect</span>(<span class="hljs-string">"Failed to read line"</span>);

        match user_input.<span class="hljs-title function_">trim</span>(<span class="hljs-params"></span>) {
            <span class="hljs-string">"R"</span> | <span class="hljs-string">"r"</span> => {
                game = <span class="hljs-title class_">Game</span>::<span class="hljs-title function_">default</span>();
                game.<span class="hljs-title function_">display_board</span>();
            }
            <span class="hljs-string">"Q"</span> | <span class="hljs-string">"q"</span> => {
                println!(<span class="hljs-string">"Quitting..."</span>);
                <span class="hljs-keyword">break</span>;
            }
            _ => game.<span class="hljs-title function_">display_error</span>(<span class="hljs-string">"잘못된 입력"</span>.<span class="hljs-title function_">to_string</span>()),
        }
    }
}
</code></pre>
<p>마지막으로, 차례 사이에 터미널을 지우기 위한 ASCII 이스케이프 코드를 사용할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">fn <span class="hljs-title function_">clear_screen</span>(<span class="hljs-params">&#x26;self</span>) {
    print!(<span class="hljs-string">"{}[2J"</span>, <span class="hljs-number">27</span> <span class="hljs-keyword">as</span> char);
}
</code></pre>
<p>게임 보드를 표시할 때마다 이 작업을 수행할 수 있습니다.</p>
<pre><code class="hljs language-js">fn <span class="hljs-title function_">display_board</span>(<span class="hljs-params">&#x26;self</span>) {
    self.<span class="hljs-title function_">clear_screen</span>();

    <span class="hljs-comment">// 코드 변경 없음</span>
}
</code></pre>
<h1>모두 함께 가져오기</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그것이 커넥트 4의 간단한 명령줄 게임을 위해 필요한 모든 것입니다! 이 작업 중인 파일을 사용하는 작동 버전을 시험하려면 Rust 플레이그라운드를 확인해보세요.</p>
<p>우리가 지금까지 만든 전체 파일은 아래와 같습니다:</p>
<pre><code class="hljs language-js">use <span class="hljs-attr">std</span>::io;

<span class="hljs-keyword">const</span> <span class="hljs-attr">RESET</span>: &#x26;str = <span class="hljs-string">"\x1b[0m"</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">ORANGE</span>: &#x26;str = <span class="hljs-string">"\x1b[93m"</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">RED</span>: &#x26;str = <span class="hljs-string">"\x1b[0;31m"</span>;

<span class="hljs-keyword">const</span> <span class="hljs-attr">BOARD_WIDTH</span>: usize = <span class="hljs-number">7</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">BOARD_HEIGHT</span>: usize = <span class="hljs-number">6</span>;

type <span class="hljs-title class_">Board</span> = [[u8; <span class="hljs-variable constant_">BOARD_WIDTH</span>]; <span class="hljs-variable constant_">BOARD_HEIGHT</span>];

#[<span class="hljs-title function_">derive</span>(<span class="hljs-title class_">Clone</span>, <span class="hljs-title class_">Copy</span>, <span class="hljs-title class_">Debug</span>, <span class="hljs-title class_">PartialEq</span>)]
#[<span class="hljs-title function_">repr</span>(u8)]
enum <span class="hljs-title class_">Player</span> {
    <span class="hljs-title class_">One</span> = <span class="hljs-number">1</span>,
    <span class="hljs-title class_">Two</span> = <span class="hljs-number">2</span>,
    <span class="hljs-title class_">None</span> = <span class="hljs-number">0</span>,
}

impl <span class="hljs-title class_">Player</span> {
    fn <span class="hljs-title function_">from_int</span>(<span class="hljs-attr">int</span>: u8) -> <span class="hljs-title class_">Player</span> {
        match int {
            <span class="hljs-number">1</span> => <span class="hljs-title class_">Player</span>::<span class="hljs-title class_">One</span>,
            <span class="hljs-number">2</span> => <span class="hljs-title class_">Player</span>::<span class="hljs-title class_">Two</span>,
            <span class="hljs-function"><span class="hljs-params">_</span> =></span> <span class="hljs-title class_">Player</span>::<span class="hljs-title class_">None</span>,
        }
    }
}

#[...]

# 결론

&#x3C;!-- ui-station 사각형 -->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ins</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"adsbygoogle"</span>
<span class="hljs-attr">style</span>=<span class="hljs-string">"display:block"</span>
<span class="hljs-attr">data-ad-client</span>=<span class="hljs-string">"ca-pub-4877378276818686"</span>
<span class="hljs-attr">data-ad-slot</span>=<span class="hljs-string">"7249294152"</span>
<span class="hljs-attr">data-ad-format</span>=<span class="hljs-string">"auto"</span>
<span class="hljs-attr">data-full-width-responsive</span>=<span class="hljs-string">"true"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">ins</span>></span></span>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
(adsbygoogle = <span class="hljs-variable language_">window</span>.<span class="hljs-property">adsbygoogle</span> || []).<span class="hljs-title function_">push</span>({});
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span></span>

지금까지 따라오셨다면 프로젝트를 더 나아가고 싶을 것입니다. 여러 게임을 거치면서 승리를 추적해 볼 수도 있고, 어떨까요? 어플리케이션을 웹 서버로 전환하여 웹사이트가 <span class="hljs-variable constant_">HTTP</span>를 통해 <span class="hljs-title class_">Connect</span> <span class="hljs-number">4</span>를 플레이할 수 있게끔 만들어 보는 것은 어떤가요?

이번 명령줄 어플리케이션을 <span class="hljs-title class_">Rust</span>로 개발하는 방법에 대한 유용하고 재미있는 통찰력으로 여기시길 바랍니다. 아직 <span class="hljs-title class_">Rust</span> 여행을 시작한 지 얼마 되지 않았기 때문에, 어떠한 비평이나 더 많은 <span class="hljs-title class_">Rust</span> 다운 방식으로 어플리케이션을 작성하는 아이디어가 있다면 꼭 알려주세요. 함께 고민해보고 싶습니다.
</code></pre>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Rust로 코딩하는 커맨드 라인 Connect 4 게임 배우기","description":"","date":"2024-05-20 16:00","slug":"2024-05-20-LearnRustbycodingacommandlineConnect4game","content":"\n![Rust Connect 4](/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png)\n\n안녕하세요! 이번 글에서는 Rust가 어떻게 우리가 Connect 4의 간단한 버전을 만들며 명령줄 응용 프로그램을 작성하는 데 도움이 되는지 살펴볼 거에요.\n\n최근 Rust를 배우는 도전에 도전했고, 제 자신의 조언을 따르기 위해 개인 프로젝트에서 Rust를 사용해 손을 더럽히며 배운 것을 정리하려고 노력하고 있어요. Connect 4는 아주 좋은 도전 과제에요. 오후 하루 동안 코딩할 수 있는 것은 간단하지만 잘 하려면 약간의 생각이 필요한 복잡한 문제이죠.\n\n여기 제 마지막 결과물이 포함된 Rust 플레이그라운드가 있어요. 아래에서는 거기에 이르기까지 취한 정확한 단계를 살펴볼 거에요. 따라오고 싶으시면 Rust가 설치되어 있는지 확인한 후 터미널에서 `cargo new rust_connect_4_tutorial`을 실행해서 프로젝트를 열고 좋아하는 편집기에서 src/main.rs로 이동해서 시작해봐요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n혹은 비디오를 통해 학습하는 것을 선호한다면, 해당 튜토리얼의 비디오 버전을 확인해보세요:\n\n# 우리의 타입 정의하기\n\nRust에서 시작하는 가장 좋은 방법 중 하나는 종종 우리의 타입을 정의하는 것이므로, 우리는 정확히 그것을 할 것입니다!\n\n먼저, 게임에 사용할 보드를 정의해 보겠습니다. Connect 4의 클래식 버전은 7개의 슬롯이 가로로 있고 6개의 슬롯이 세로로 있기 때문에, 이들 정수를 상수로 저장하고, 그 상수를 사용하여 두 차원 배열의 길이를 정의하는 데 사용할 수 있습니다. Board 타입으로 정의합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```rust\nconst BOARD_WIDTH: usize = 7;\nconst BOARD_HEIGHT: usize = 6;\n\ntype Board = [[u8; BOARD_WIDTH]; BOARD_HEIGHT];\n```\n\n플레이어를 추적할 방법이 필요할 것입니다. 이를 enum으로 구현할 수 있습니다. 우리는 두 명의 플레이어만 지원하지만, 한 명의 피스가 없는 슬롯을 나타내는 None 변형과 게임이 무승부로 끝날 때 처리하는 데 유용할 것입니다.\n\n```rust\n#[derive(Clone, Copy, Debug, PartialEq)]\n#[repr(u8)]\nenum Player {\n    One = 1,\n    Two = 2,\n    None = 0,\n}\n```\n\n위에서는 나중에 유용할 몇 가지 트레잇을 구현하기 위해 derive를 사용하고, enum의 메모리 레이아웃을 제어하기 위해 repr을 사용했습니다. 가능한 모든 값을 알기 때문에 u8로 제한할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음으로, 우리는 게임을 나타내는 struct를 만들 것입니다. 여기에는 추적해야 할 모든 상태가 포함될 것입니다.\n\n```javascript\nstruct Game {\n    current_move: u8,\n    current_player: Player,\n    board: Board,\n    is_finished: bool,\n    winner: Player,\n}\n```\n\ncurrent_move는 플레이어가 선택한 열을 나타내는 정수입니다. 우리에게는 승자 필드가 있지만, 게임이 비김으로 끝날 때 별도로 is_finished 부울도 유용할 것입니다!\n\n마지막으로, Game에 대한 기본 함수를 구현할 것입니다. 이 함수에는 초기 상태가 포함될 것입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```rust\nimpl Game {\n    fn default() -\u003e Game {\n        Game {\n            current_move: 0,\n            current_player: Player::One,\n            board: [\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n            ],\n            is_finished: false,\n            winner: Player::None,\n        }\n    }\n}\n```\n\n보드에 대해 조금 이야기해 봅시다. 여기서 0은 빈 칸을 나타내며, 1은 Player One이 차지한 칸을 나타내고, 2는 Player Two가 차지한 칸을 나타냅니다.\n\nBOARD_WIDTH와 BOARD_HEIGHT를 사용하여 동적으로 생성할 수도 있었지만, 코드를 작성하는 동안 전체 배열을 보는 것이 도움이 되는 시각적 도구라는 것을 발견했습니다. 같은 이유로, 정수가 아닌 Player 열거형을 사용하지 않았습니다. 텍스트가 더 많아지면 코드를 한눈에 이해하기 어려워지기 때문입니다.\n\n이 방법의 (약간의) 단점은 나중에 정수를 Player로 변환해야 한다는 것입니다. 하지만 Player에 from_int 함수를 구현함으로써 쉽게 해결할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n구현 Player {\n    fn from_int(int: u8) -\u003e Player {\n        match int {\n            1 =\u003e Player::One,\n            2 =\u003e Player::Two,\n            _ =\u003e Player::None,\n        }\n    }\n}\n```\n\n# 보드 표시\n\n디버깅을 위해, 보드를 시각화하는 좋은 방법을 빠르게 코드화하는 것이 도움이 될 것입니다. 명령줄에 출력하기 위해 크레이트를 사용하는 대신에 간단한 색을 나타내기 위해 16진수 이스케이프 문자열을 사용할 것입니다.\n\n```js\nconst RESET: str = \"\\x1b[0m\";\nconst ORANGE: str = \"\\x1b[93m\";\nconst RED: str = \"\\x1b[0;31m\";\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래의 코드에서는 맵을 사용하여 Connect 4 토큰과 유사한 이모지로 슬롯을 변환할 것입니다. 게임이 종료되면 우승자를 발표하는 좋은 장소로 보입니다.\n\n```js\nimpl Game {\n    // 다른 함수들\n\n    fn display_board(\u0026self) {\n        println!(\"{}--------------------{}\", ORANGE, RESET);\n        println!(\"{}CONNECT 4 (Move {}){}\", ORANGE, self.current_move, RESET);\n        println!(\"{}--------------------{}\", ORANGE, RESET);\n\n        for row in self.board {\n            let row_str: String = row\n                .iter()\n                .map(|\u0026cell| match cell {\n                    1 =\u003e \"🔴\",\n                    2 =\u003e \"🟡\",\n                    _ =\u003e \"⚫\",\n                })\n                .collect::\u003cVec\u003c\u0026str\u003e\u003e()\n                .join(\" \");\n\n            println!(\"{}\", row_str);\n        }\n\n        println!(\"{}--------------------{}\", ORANGE, RESET);\n\n        if self.is_finished {\n            match self.winner {\n                Player::One =\u003e println!(\"{}🔴 Player 1이 승리했습니다!{}\", ORANGE, RESET),\n                Player::Two =\u003e println!(\"{}🟡 Player 2가 승리했습니다!{}\", ORANGE, RESET),\n                Player::None =\u003e println!(\"{}무승부입니다!{}\", ORANGE, RESET),\n            }\n\n            println!(\"{}--------------------{}\", ORANGE, RESET);\n        }\n    }\n}\n```\n\n우리는 이것을 언제든지 메인 함수 내에서 호출하여 보드의 상태를 확인할 수 있습니다.\n\n```js\nfn main() {\n    let mut game = Game::default();\n    game.display_board();\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n조금 지루하지만 수를 두지 않고는 재미가 없죠. 그래서 이제 수를 두는 방법을 프로그래밍해 봅시다!\n\n# 수 두기\n\n우리의 play_move 함수를 첫 번째로 살펴보면, 이 함수는 이차원 배열에서 올바른 항목을 변경하고, 수를 증가시킨 다음 현재 플레이어를 변경해야 합니다.\n\n```rust\nimpl Game {\n    // other functions\n\n    fn play_move(\u0026mut self, column: usize) {\n        if let Some(row) = (0..BOARD_HEIGHT)\n            .rev()\n            .find(|\u0026row| self.board[row][column] == 0)\n        {\n            self.board[row][column] = self.current_player as u8;\n\n            self.current_move += 1;\n\n            self.current_player = match self.current_player {\n                Player::One =\u003e Player::Two,\n                _ =\u003e Player::One,\n            };\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 if let 코드에서는 열의 맨 아래부터 시작하여 하나씩 올라가면서 빈 칸을 찾을 때까지 진행합니다. 빈 칸을 찾으면 그 위치에 현재 플레이어를 나타내는 정수로 변경하고, 현재 이동을 증가시킨 후 match 표현식을 사용하여 플레이어를 변경합니다.\n\n이 시점에서 코드를 통해 움직임을 실행하고 터미널에서 결과를 확인할 수 있습니다:\n\n```js\nfn main() {\n    let mut game = Game::default();\n\n    game.play_move(3);\n    game.play_move(3);\n    game.play_move(4);\n    game.play_move(3);\n\n    game.display_board();\n}\n```\n\n# 오류 처리\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금까지 우리는 보드 바깥으로 이동을 시도하는 잠재적인 오류를 처리하지 않고 있습니다. 따라서 세 가지 가능한 오류를 처리해 봅시다:\n\n- 제공된 열이 허용 범위를 벗어납니다.\n- 제공된 열이 이미 가득 찼습니다.\n- 게임이 끝났습니다.\n\n(사용자 입력을 받기 시작하면 추가적인 오류 처리가 필요할 것입니다. 나중에 처리하겠습니다.)\n\n세 가지 오류 유형을 포함한 enum을 만들어 봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nenum MoveError {\n    GameFinished,\n    InvalidColumn,\n    ColumnFull,\n}\n```\n\n우리는 에러를 명령줄에 출력하기를 원하기 때문에, 우리의 에러 메시지를 포함하는 사용자 정의 Display 트레이트를 구현해야 합니다. 예를 들어:\n\n```js\nimpl std::fmt::Display for MoveError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            MoveError::ColumnFull =\u003e write!(f, \"column is full\"),\n            MoveError::InvalidColumn =\u003e write!(f, \"column must be between 1 and 7\"),\n            MoveError::GameFinished =\u003e write!(f, \"game is already finished\"),\n        }\n    }\n}\n```\n\n이제 이를 사용하여 play_move 함수를 수정할 수 있습니다. 이제 우리는 움직임이 성공적이면 아무것도 반환하지만, 그렇지 않은 경우 에러가 반환되는 Result enum을 반환합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```rust\nimpl Game {\n    // 다른 함수들\n\n    fn play_move(\u0026mut self, column: usize) -\u003e Result\u003c(), MoveError\u003e {\n        if self.is_finished {\n            return Err(MoveError::GameFinished);\n        }\n\n        if column \u003e= BOARD_WIDTH {\n            return Err(MoveError::InvalidColumn);\n        }\n\n        if let Some(row) = (0..BOARD_HEIGHT)\n            .rev()\n            .find(|\u0026row| self.board[row][column] == 0)\n        {\n            self.board[row][column] = self.current_player as u8;\n        } else {\n            return Err(MoveError::ColumnFull);\n        }\n\n        self.current_move += 1;\n\n        self.current_player = match self.current_player {\n            Player::One =\u003e Player::Two,\n            _ =\u003e Player::One,\n        };\n\n        Ok(())\n    }\n}\n```\n\n디버깅을 위해 이제 play_move의 결과를 인쇄할 수 있으며, 예상치 못한 입력이 있는 경우 enum으로부터 에러를 볼 수 있습니다.\n\n우리가 여기에 있는 동안, 명령줄에 에러 메시지를 인쇄하는 도우미 함수를 추가해 봅시다.\n\n```rust\nimpl Game {\n    // 다른 함수들\n\n    fn display_error(\u0026self, error: String) {\n        self.display_board();\n        println!(\"{}에러: {}{}\", RED, error, RESET);\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 게임에서 승리했는지 계산하기\n\n누군가가 이겼는지 확인하기 위해 2차원 배열을 여러 방향으로 탐색해야 합니다. 이 Leetcode 스타일 문제는 재미있는 도전이었고, 결과물을 얻기까지 몇 번 시도해야 했어요.\n\n누군가가 4칸을 연달아 얻을 수 있는 네 가지 방향이 있어요:\n\n- 수평,\n- 수직,\n- 역 슬래시 대각선 (왼쪽 위에서 오른쪽 아래로),\n- 순방향 슬래시 대각선 (왼쪽 아래에서 오른쪽 위로).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n게시판의 모든 슬롯을 반복하여 네 방향 중 하나에서 테스트할 수 있습니다. (게시판이 작기 때문에 무차별 대입 방식을 사용하는 것이 부담이 되지 않습니다. 그러나 더 나은 방법이 있는지 궁금합니다!)\n\n게시판의 주어진 슬롯에서 시작합니다. 플레이어의 토큰이 들어있는 경우, 첫 번째 방향으로 한 단계 이동합니다. 이 새로운 슬롯도 같은 토큰을 포함하는 경우, 이 방향으로 또 다른 단계를 이동합니다. 이를 반복하여 같은 토큰이 있는 네 개의 슬롯을 찾을 때까지 진행합니다. 그렇지 않으면 다른 방향으로 이동합니다.\n\n각 방향은 정수들의 튜플로 나타낼 수 있습니다 - 행당 거리에 대한 값과 열당 거리에 대한 값 하나씩 - 이 정보를 배열에 저장할 수 있습니다.\n\n```js\nlet directions = [\n  (0, 1), // 가로\n  (1, 0), // 세로\n  (1, 1), // 대각선 (왼쪽 위에서 오른쪽 아래)\n  (-1, 1), // 대각선 (왼쪽 아래에서 오른쪽 위)\n];\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 튜플들이 무엇을 나타내는지 알려드릴게요:\n\n- 수평으로 이동하려면 행은 변하지 않고(0), 열만 변해야 합니다(1).\n- 수직으로 이동하려면 행이 변해야 하고(1), 열은 변하지 않아야 합니다(0).\n- 역 슬래시 대각선으로 이동하려면 행과 열이 둘 다 증가해야 합니다(1, 1).\n- 마지막으로, 슬래시 대각선으로 이동하려면 열은 증가하고 행은 감소해야 합니다(-1, 1).\n\n각 방향의 모든 슬롯을 테스트하려면 아래와 같이 세 개의 루프가 필요합니다.\n\n```rust\nimpl Game {\n    // 다른 함수들\n\n    fn calculate_winner(\u0026mut self) -\u003e Player {\n        for row in 0..BOARD_HEIGHT {\n            for col in 0..BOARD_WIDTH {\n                let cell = self.board[row][col];\n\n                if cell != 0 {\n                    let directions = [\n                        (0, 1),  // 수평\n                        (1, 0),  // 수직\n                        (1, 1),  // 대각선 (왼쪽 위에서 오른쪽 아래로)\n                        (-1, 1), // 대각선 (왼쪽 아래에서 오른쪽 위로)\n                    ];\n\n                    for (row_step, col_step) in directions {\n                        // TODO - 주어진 방향으로 보드를 탐색하고\n                        // 승자를 찾았다면 해당 플레이어를 반환하세요\n                    }\n                }\n            }\n        }\n        Player::None\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 연속 카운트를 유지하고 — 4에 도달하면 승자가 나온 것을 알 수 있습니다.\n\n그럼, 최종 중첩된 루프에서는 시작 토큰부터 슬롯별로 이동을 시도할 것입니다. 그때까지…\n\n- 시작 토큰과 다른 토큰을 만날 때 (그러한 경우 루프를 종료합니다);\n- 보드의 가장자리에 도달할 때 (그러한 경우 루프를 종료합니다);\n- 동일한 토큰의 4연속을 만날 때 (그러한 경우 게임을 종료하고 승자를 지정합니다).\n\n```js\nimpl Game {\n    // 다른 함수들\n\n    fn calculate_winner(\u0026mut self) -\u003e Player {\n        for row in 0..BOARD_HEIGHT {\n            for col in 0..BOARD_WIDTH {\n                let cell = self.board[row][col];\n\n                if cell != 0 {\n                    let directions = [\n                        (0, 1),  // 가로\n                        (1, 0),  // 세로\n                        (1, 1),  // 대각선 (왼쪽 위에서 오른쪽 아래로)\n                        (-1, 1), // 대각선 (왼쪽 아래에서 오른쪽 위로)\n                    ];\n\n                    for (row_step, col_step) in directions {\n                        let mut consecutive_count = 1;\n                        let mut r = row as isize + row_step;\n                        let mut c = col as isize + col_step;\n\n                        while r \u003e= 0\n                            \u0026\u0026 r \u003c BOARD_HEIGHT as isize\n                            \u0026\u0026 c \u003e= 0\n                            \u0026\u0026 c \u003c BOARD_WIDTH as isize\n                        {\n                            if self.board[r as usize][c as usize] == cell {\n                                consecutive_count += 1;\n\n                                if consecutive_count == 4 {\n                                    self.is_finished = true;\n                                    return Player::from_int(cell);\n                                }\n                            } else {\n                                break;\n                            }\n                            r += row_step;\n                            c += col_step;\n                        }\n                    }\n                }\n            }\n        }\n\n        Player::None\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 이동 횟수가 일곱 미만인 경우 이러한 확인 작업을 수행하지 않고 최적화를 조금 추가할 수 있습니다. 그때까지는 게임에서 이기는 것이 불가능하기 때문입니다. 그래서 함수 맨 위에 이를 추가해 봅시다:\n\n```js\nif self.current_move \u003c 7 {\n    return Player::None;\n}\n```\n\n그리고 보드가 가득 찼지만 승자가 없는 경우(즉, 무승부인 경우)에 게임을 종료로 표시해야 합니다. 이를 반환문 위에 추가해 줍시다:\n\n```js\nif self.current_move \u003e= BOARD_HEIGHT as u8 * BOARD_WIDTH as u8 {\n    self.is_finished = true;\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로, 새로운 calculate_winner 함수를 play_move 함수에 추가할 수 있습니다. 이번에는 아무것도 반환하는 대신, 성공인 Result enum을 반환하거나 실패인 경우에는 오류를 반환합니다.\n\n```js\nimpl Game {\n    // 다른 함수들\n\n    fn play_move(\u0026mut self, column: usize) -\u003e Result\u003c(), MoveError\u003e {\n        if self.is_finished {\n            return Err(MoveError::GameFinished);\n        }\n\n        if column \u003e= BOARD_WIDTH {\n            return Err(MoveError::InvalidColumn);\n        }\n\n        if let Some(row) = (0..BOARD_HEIGHT)\n            .rev()\n            .find(|\u0026row| self.board[row][column] == 0)\n        {\n            self.board[row][column] = self.current_player as u8;\n            self.current_move += 1;\n        } else {\n            return Err(MoveError::ColumnFull);\n        }\n\n        let calculated_winner = self.calculate_winner();\n\n        if calculated_winner != Player::None {\n            self.winner = calculated_winner;\n        } else {\n            self.current_player = match self.current_player {\n                Player::One =\u003e Player::Two,\n                _ =\u003e Player::One,\n            };\n        }\n\n        Ok(())\n    }\n}\n```\n\n우리의 Connect 4 게임 엔진이 완성되었습니다! 사용자로부터 입력을 받는 방법만 남았습니다...\n\n# 사용자 입력 받기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 명령 줄 게임의 마지막 부분에서는 주 함수로 돌아가 사용자 입력을 읽을 수 있도록 할 것입니다.\n\n먼저, Rust의 표준 I/O 라이브러리를 가져오겠습니다.\n\n```js\nuse std::io;\n```\n\n사용자 입력을 읽는 논리는 다음과 같이 보일 수 있습니다. 여기서는 컴퓨터와 달리 0이 아닌 1부터 시작하여 카운트하게 됩니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nlet mut user_move = String::new();\n\nio::stdin()\n    .read_line(\u0026mut user_move)\n    .expect(\"Failed to read line\");\n\nlet user_move: usize = match user_move.trim().parse() {\n    Ok(num) =\u003e {\n        if num \u003c 1 || num \u003e BOARD_WIDTH as u8 {\n            game.display_error(MoveError::InvalidColumn.to_string());\n            continue;\n        } else {\n            num\n        }\n    }\n    Err(err) =\u003e {\n        game.display_error(err.to_string());\n        continue;\n    }\n};\n\nmatch game.play_move(user_move - 1) {\n    Ok(_) =\u003e {\n        game.display_board();\n    }\n    Err(err) =\u003e {\n        game.display_error(err.to_string());\n    }\n}\n```\n\n먼저, 우리는 빈 문자열을 정의한 뒤 사용자로부터 텍스트를 받기 위해 stdin 메소드를 사용합니다.\n\n다음으로 이 입력을 구문 분석을 시도합니다. 다음 중 하나라도 해당하는 경우 오류를 표시합니다:\n\n- 구문 분석이 실패하는 경우 (예: 입력이 숫자가 아닌 경우).\n- 구문 분석이 성공하지만 숫자가 원하는 범위를 벗어난 경우.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 오류가 표시되지 않는다면, 우리는 선택한 수를 둘 것입니다. 그러나 해당 시나리오에서 오류가 발생할 수도 있으므로, 그런 경우에는 오류를 표시할 것입니다.\n\n그러나 위의 코드는 한 번만 실행됩니다. 게임이 끝날 때까지 루프를 실행해야 합니다. 아래는 그 반복문을 추가한 main 함수와 사용자를 도와줄 몇 가지 유용한 메시지입니다:\n\n```js\nfn main() {\n    let mut game = Game::default();\n    game.display_board();\n\n    while !game.is_finished {\n        println!(\"\\n\");\n\n        match game.current_player {\n            Player::One =\u003e println!(\"플레이어 1\"),\n            Player::Two =\u003e println!(\"플레이어 2\"),\n            _ =\u003e (),\n        };\n\n        println!(\"1부터 7 사이의 열을 입력하세요:\");\n\n        let mut user_move = String::new();\n        io::stdin()\n            .read_line(\u0026mut user_move)\n            .expect(\"라인을 읽는 데 실패했습니다\");\n\n        let user_move: usize = match user_move.trim().parse() {\n            Ok(num) =\u003e {\n                if num \u003c 1 || num \u003e 7 {\n                    game.display_error(MoveError::InvalidColumn.to_string());\n                    continue;\n                } else {\n                    num\n                }\n            }\n            Err(err) =\u003e {\n                game.display_error(err.to_string());\n                continue;\n            }\n        };\n\n        match game.play_move(user_move - 1) {\n            Ok(_) =\u003e {\n                game.display_board();\n            }\n            Err(err) =\u003e {\n                game.display_error(err.to_string());\n            }\n        }\n    }\n}\n```\n\n# 여러 판을 플레이하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로, 사용자가 게임을 끝내면 게임을 다시 시작할 수 있도록 추가 코드를 추가하고 싶어요. 매번 실행 파일을 다시 시작해야 하는 번거로움은 피하고 싶으니까요!\n\n이를 위해 새로운 루프를 만들 것입니다. 이전과 동일한 방법을 사용하여 사용자의 입력을 읽을 수 있습니다. \"R\"을 누르면 새 게임을 시작하고, \"Q\"를 누르면 루프를 중단하고 코드를 끝까지 실행합니다.\n\n```js\nfn main() {\n    let mut game = Game::default();\n    game.display_board();\n\n    loop {\n        while !game.is_finished {\n            // 코드 변경 없음\n        }\n\n        println!(\"Press 'R' to restart or 'Q' to quit the game.\");\n\n        let mut user_input = String::new();\n\n        io::stdin()\n            .read_line(\u0026mut user_input)\n            .expect(\"Failed to read line\");\n\n        match user_input.trim() {\n            \"R\" | \"r\" =\u003e {\n                game = Game::default();\n                game.display_board();\n            }\n            \"Q\" | \"q\" =\u003e {\n                println!(\"Quitting...\");\n                break;\n            }\n            _ =\u003e game.display_error(\"잘못된 입력\".to_string()),\n        }\n    }\n}\n```\n\n마지막으로, 차례 사이에 터미널을 지우기 위한 ASCII 이스케이프 코드를 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfn clear_screen(\u0026self) {\n    print!(\"{}[2J\", 27 as char);\n}\n```\n\n게임 보드를 표시할 때마다 이 작업을 수행할 수 있습니다.\n\n```js\nfn display_board(\u0026self) {\n    self.clear_screen();\n\n    // 코드 변경 없음\n}\n```\n\n# 모두 함께 가져오기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그것이 커넥트 4의 간단한 명령줄 게임을 위해 필요한 모든 것입니다! 이 작업 중인 파일을 사용하는 작동 버전을 시험하려면 Rust 플레이그라운드를 확인해보세요.\n\n우리가 지금까지 만든 전체 파일은 아래와 같습니다:\n\n```js\nuse std::io;\n\nconst RESET: \u0026str = \"\\x1b[0m\";\nconst ORANGE: \u0026str = \"\\x1b[93m\";\nconst RED: \u0026str = \"\\x1b[0;31m\";\n\nconst BOARD_WIDTH: usize = 7;\nconst BOARD_HEIGHT: usize = 6;\n\ntype Board = [[u8; BOARD_WIDTH]; BOARD_HEIGHT];\n\n#[derive(Clone, Copy, Debug, PartialEq)]\n#[repr(u8)]\nenum Player {\n    One = 1,\n    Two = 2,\n    None = 0,\n}\n\nimpl Player {\n    fn from_int(int: u8) -\u003e Player {\n        match int {\n            1 =\u003e Player::One,\n            2 =\u003e Player::Two,\n            _ =\u003e Player::None,\n        }\n    }\n}\n\n#[...]\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금까지 따라오셨다면 프로젝트를 더 나아가고 싶을 것입니다. 여러 게임을 거치면서 승리를 추적해 볼 수도 있고, 어떨까요? 어플리케이션을 웹 서버로 전환하여 웹사이트가 HTTP를 통해 Connect 4를 플레이할 수 있게끔 만들어 보는 것은 어떤가요?\n\n이번 명령줄 어플리케이션을 Rust로 개발하는 방법에 대한 유용하고 재미있는 통찰력으로 여기시길 바랍니다. 아직 Rust 여행을 시작한 지 얼마 되지 않았기 때문에, 어떠한 비평이나 더 많은 Rust 다운 방식으로 어플리케이션을 작성하는 아이디어가 있다면 꼭 알려주세요. 함께 고민해보고 싶습니다.\n```\n","ogImage":{"url":"/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png"},"coverImage":"/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png","tag":["Tech"],"readingTime":24},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png\" alt=\"Rust Connect 4\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요! 이번 글에서는 Rust가 어떻게 우리가 Connect 4의 간단한 버전을 만들며 명령줄 응용 프로그램을 작성하는 데 도움이 되는지 살펴볼 거에요.\u003c/p\u003e\n\u003cp\u003e최근 Rust를 배우는 도전에 도전했고, 제 자신의 조언을 따르기 위해 개인 프로젝트에서 Rust를 사용해 손을 더럽히며 배운 것을 정리하려고 노력하고 있어요. Connect 4는 아주 좋은 도전 과제에요. 오후 하루 동안 코딩할 수 있는 것은 간단하지만 잘 하려면 약간의 생각이 필요한 복잡한 문제이죠.\u003c/p\u003e\n\u003cp\u003e여기 제 마지막 결과물이 포함된 Rust 플레이그라운드가 있어요. 아래에서는 거기에 이르기까지 취한 정확한 단계를 살펴볼 거에요. 따라오고 싶으시면 Rust가 설치되어 있는지 확인한 후 터미널에서 \u003ccode\u003ecargo new rust_connect_4_tutorial\u003c/code\u003e을 실행해서 프로젝트를 열고 좋아하는 편집기에서 src/main.rs로 이동해서 시작해봐요!\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e혹은 비디오를 통해 학습하는 것을 선호한다면, 해당 튜토리얼의 비디오 버전을 확인해보세요:\u003c/p\u003e\n\u003ch1\u003e우리의 타입 정의하기\u003c/h1\u003e\n\u003cp\u003eRust에서 시작하는 가장 좋은 방법 중 하나는 종종 우리의 타입을 정의하는 것이므로, 우리는 정확히 그것을 할 것입니다!\u003c/p\u003e\n\u003cp\u003e먼저, 게임에 사용할 보드를 정의해 보겠습니다. Connect 4의 클래식 버전은 7개의 슬롯이 가로로 있고 6개의 슬롯이 세로로 있기 때문에, 이들 정수를 상수로 저장하고, 그 상수를 사용하여 두 차원 배열의 길이를 정의하는 데 사용할 수 있습니다. Board 타입으로 정의합니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e BOARD_WIDTH: \u003cspan class=\"hljs-type\"\u003eusize\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e BOARD_HEIGHT: \u003cspan class=\"hljs-type\"\u003eusize\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBoard\u003c/span\u003e = [[\u003cspan class=\"hljs-type\"\u003eu8\u003c/span\u003e; BOARD_WIDTH]; BOARD_HEIGHT];\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e플레이어를 추적할 방법이 필요할 것입니다. 이를 enum으로 구현할 수 있습니다. 우리는 두 명의 플레이어만 지원하지만, 한 명의 피스가 없는 슬롯을 나타내는 None 변형과 게임이 무승부로 끝날 때 처리하는 데 유용할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-meta\"\u003e#[derive(Clone, Copy, Debug, PartialEq)]\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e#[repr(u8)]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eenum\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e {\n    One = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n    Two = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\n    \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위에서는 나중에 유용할 몇 가지 트레잇을 구현하기 위해 derive를 사용하고, enum의 메모리 레이아웃을 제어하기 위해 repr을 사용했습니다. 가능한 모든 값을 알기 때문에 u8로 제한할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다음으로, 우리는 게임을 나타내는 struct를 만들 것입니다. 여기에는 추적해야 할 모든 상태가 포함될 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eGame\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003ecurrent_move\u003c/span\u003e: u8,\n    \u003cspan class=\"hljs-attr\"\u003ecurrent_player\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eboard\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBoard\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eis_finished\u003c/span\u003e: bool,\n    \u003cspan class=\"hljs-attr\"\u003ewinner\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecurrent_move는 플레이어가 선택한 열을 나타내는 정수입니다. 우리에게는 승자 필드가 있지만, 게임이 비김으로 끝날 때 별도로 is_finished 부울도 유용할 것입니다!\u003c/p\u003e\n\u003cp\u003e마지막으로, Game에 대한 기본 함수를 구현할 것입니다. 이 함수에는 초기 상태가 포함될 것입니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGame\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e() \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e Game {\n        Game {\n            current_move: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n            current_player: Player::One,\n            board: [\n                [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n                [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n                [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n                [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n                [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n                [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n            ],\n            is_finished: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n            winner: Player::\u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e,\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e보드에 대해 조금 이야기해 봅시다. 여기서 0은 빈 칸을 나타내며, 1은 Player One이 차지한 칸을 나타내고, 2는 Player Two가 차지한 칸을 나타냅니다.\u003c/p\u003e\n\u003cp\u003eBOARD_WIDTH와 BOARD_HEIGHT를 사용하여 동적으로 생성할 수도 있었지만, 코드를 작성하는 동안 전체 배열을 보는 것이 도움이 되는 시각적 도구라는 것을 발견했습니다. 같은 이유로, 정수가 아닌 Player 열거형을 사용하지 않았습니다. 텍스트가 더 많아지면 코드를 한눈에 이해하기 어려워지기 때문입니다.\u003c/p\u003e\n\u003cp\u003e이 방법의 (약간의) 단점은 나중에 정수를 Player로 변환해야 한다는 것입니다. 하지만 Player에 from_int 함수를 구현함으로써 쉽게 해결할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e구현 \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e {\n    fn \u003cspan class=\"hljs-title function_\"\u003efrom_int\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eint\u003c/span\u003e: u8) -\u003e \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e {\n        match int {\n            \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e =\u003e \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eOne\u003c/span\u003e,\n            \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e =\u003e \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eTwo\u003c/span\u003e,\n            \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e_\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e,\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e보드 표시\u003c/h1\u003e\n\u003cp\u003e디버깅을 위해, 보드를 시각화하는 좋은 방법을 빠르게 코드화하는 것이 도움이 될 것입니다. 명령줄에 출력하기 위해 크레이트를 사용하는 대신에 간단한 색을 나타내기 위해 16진수 이스케이프 문자열을 사용할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eRESET\u003c/span\u003e: str = \u003cspan class=\"hljs-string\"\u003e\"\\x1b[0m\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eORANGE\u003c/span\u003e: str = \u003cspan class=\"hljs-string\"\u003e\"\\x1b[93m\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eRED\u003c/span\u003e: str = \u003cspan class=\"hljs-string\"\u003e\"\\x1b[0;31m\"\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아래의 코드에서는 맵을 사용하여 Connect 4 토큰과 유사한 이모지로 슬롯을 변환할 것입니다. 게임이 종료되면 우승자를 발표하는 좋은 장소로 보입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eimpl \u003cspan class=\"hljs-title class_\"\u003eGame\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 다른 함수들\u003c/span\u003e\n\n    fn \u003cspan class=\"hljs-title function_\"\u003edisplay_board\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u0026#x26;self\u003c/span\u003e) {\n        println!(\u003cspan class=\"hljs-string\"\u003e\"{}--------------------{}\"\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eORANGE\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eRESET\u003c/span\u003e);\n        println!(\u003cspan class=\"hljs-string\"\u003e\"{}CONNECT 4 (Move {}){}\"\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eORANGE\u003c/span\u003e, self.\u003cspan class=\"hljs-property\"\u003ecurrent_move\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eRESET\u003c/span\u003e);\n        println!(\u003cspan class=\"hljs-string\"\u003e\"{}--------------------{}\"\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eORANGE\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eRESET\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e row \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e self.\u003cspan class=\"hljs-property\"\u003eboard\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erow_str\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e = row\n                .\u003cspan class=\"hljs-title function_\"\u003eiter\u003c/span\u003e()\n                .\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(|\u0026#x26;cell| match cell {\n                    \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e =\u003e \u003cspan class=\"hljs-string\"\u003e\"🔴\"\u003c/span\u003e,\n                    \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e =\u003e \u003cspan class=\"hljs-string\"\u003e\"🟡\"\u003c/span\u003e,\n                    \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e_\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"⚫\"\u003c/span\u003e,\n                })\n                .\u003cspan class=\"hljs-property\"\u003ecollect\u003c/span\u003e::\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eVec\u003c/span\u003e\u0026#x3C;\u0026#x26;str\u003e\u003e()\n                .\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\" \"\u003c/span\u003e);\n\n            println!(\u003cspan class=\"hljs-string\"\u003e\"{}\"\u003c/span\u003e, row_str);\n        }\n\n        println!(\u003cspan class=\"hljs-string\"\u003e\"{}--------------------{}\"\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eORANGE\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eRESET\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e self.\u003cspan class=\"hljs-property\"\u003eis_finished\u003c/span\u003e {\n            match self.\u003cspan class=\"hljs-property\"\u003ewinner\u003c/span\u003e {\n                \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e::\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eOne\u003c/span\u003e =\u003e\u003c/span\u003e println!(\u003cspan class=\"hljs-string\"\u003e\"{}🔴 Player 1이 승리했습니다!{}\"\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eORANGE\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eRESET\u003c/span\u003e),\n                \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e::\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eTwo\u003c/span\u003e =\u003e\u003c/span\u003e println!(\u003cspan class=\"hljs-string\"\u003e\"{}🟡 Player 2가 승리했습니다!{}\"\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eORANGE\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eRESET\u003c/span\u003e),\n                \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e::\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eNone\u003c/span\u003e =\u003e\u003c/span\u003e println!(\u003cspan class=\"hljs-string\"\u003e\"{}무승부입니다!{}\"\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eORANGE\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eRESET\u003c/span\u003e),\n            }\n\n            println!(\u003cspan class=\"hljs-string\"\u003e\"{}--------------------{}\"\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eORANGE\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eRESET\u003c/span\u003e);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 이것을 언제든지 메인 함수 내에서 호출하여 보드의 상태를 확인할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efn \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e mut game = \u003cspan class=\"hljs-title class_\"\u003eGame\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e();\n    game.\u003cspan class=\"hljs-title function_\"\u003edisplay_board\u003c/span\u003e();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e조금 지루하지만 수를 두지 않고는 재미가 없죠. 그래서 이제 수를 두는 방법을 프로그래밍해 봅시다!\u003c/p\u003e\n\u003ch1\u003e수 두기\u003c/h1\u003e\n\u003cp\u003e우리의 play_move 함수를 첫 번째로 살펴보면, 이 함수는 이차원 배열에서 올바른 항목을 변경하고, 수를 증가시킨 다음 현재 플레이어를 변경해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGame\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// other functions\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eplay_move\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, column: \u003cspan class=\"hljs-type\"\u003eusize\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eSome\u003c/span\u003e(row) = (\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e..BOARD_HEIGHT)\n            .\u003cspan class=\"hljs-title function_ invoke__\"\u003erev\u003c/span\u003e()\n            .\u003cspan class=\"hljs-title function_ invoke__\"\u003efind\u003c/span\u003e(|\u0026#x26;row| \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.board[row][column] == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n        {\n            \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.board[row][column] = \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.current_player \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eu8\u003c/span\u003e;\n\n            \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.current_move += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\n            \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.current_player = \u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.current_player {\n                Player::One =\u003e Player::Two,\n                _ =\u003e Player::One,\n            };\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위의 if let 코드에서는 열의 맨 아래부터 시작하여 하나씩 올라가면서 빈 칸을 찾을 때까지 진행합니다. 빈 칸을 찾으면 그 위치에 현재 플레이어를 나타내는 정수로 변경하고, 현재 이동을 증가시킨 후 match 표현식을 사용하여 플레이어를 변경합니다.\u003c/p\u003e\n\u003cp\u003e이 시점에서 코드를 통해 움직임을 실행하고 터미널에서 결과를 확인할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efn \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e mut game = \u003cspan class=\"hljs-title class_\"\u003eGame\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e();\n\n    game.\u003cspan class=\"hljs-title function_\"\u003eplay_move\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n    game.\u003cspan class=\"hljs-title function_\"\u003eplay_move\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n    game.\u003cspan class=\"hljs-title function_\"\u003eplay_move\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e);\n    game.\u003cspan class=\"hljs-title function_\"\u003eplay_move\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\n    game.\u003cspan class=\"hljs-title function_\"\u003edisplay_board\u003c/span\u003e();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e오류 처리\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e지금까지 우리는 보드 바깥으로 이동을 시도하는 잠재적인 오류를 처리하지 않고 있습니다. 따라서 세 가지 가능한 오류를 처리해 봅시다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e제공된 열이 허용 범위를 벗어납니다.\u003c/li\u003e\n\u003cli\u003e제공된 열이 이미 가득 찼습니다.\u003c/li\u003e\n\u003cli\u003e게임이 끝났습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e(사용자 입력을 받기 시작하면 추가적인 오류 처리가 필요할 것입니다. 나중에 처리하겠습니다.)\u003c/p\u003e\n\u003cp\u003e세 가지 오류 유형을 포함한 enum을 만들어 봅시다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eenum \u003cspan class=\"hljs-title class_\"\u003eMoveError\u003c/span\u003e {\n    \u003cspan class=\"hljs-title class_\"\u003eGameFinished\u003c/span\u003e,\n    \u003cspan class=\"hljs-title class_\"\u003eInvalidColumn\u003c/span\u003e,\n    \u003cspan class=\"hljs-title class_\"\u003eColumnFull\u003c/span\u003e,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 에러를 명령줄에 출력하기를 원하기 때문에, 우리의 에러 메시지를 포함하는 사용자 정의 Display 트레이트를 구현해야 합니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eimpl \u003cspan class=\"hljs-attr\"\u003estd\u003c/span\u003e::\u003cspan class=\"hljs-attr\"\u003efmt\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eDisplay\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMoveError\u003c/span\u003e {\n    fn \u003cspan class=\"hljs-title function_\"\u003efmt\u003c/span\u003e(\u0026#x26;self, \u003cspan class=\"hljs-attr\"\u003ef\u003c/span\u003e: \u0026#x26;mut \u003cspan class=\"hljs-attr\"\u003estd\u003c/span\u003e::\u003cspan class=\"hljs-attr\"\u003efmt\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eFormatter\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-string\"\u003e'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            MoveError::ColumnFull =\u003e write!(f, \"column is full\"),\n            MoveError::InvalidColumn =\u003e write!(f, \"column must be between 1 and 7\"),\n            MoveError::GameFinished =\u003e write!(f, \"game is already finished\"),\n        }\n    }\n}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 이를 사용하여 play_move 함수를 수정할 수 있습니다. 이제 우리는 움직임이 성공적이면 아무것도 반환하지만, 그렇지 않은 경우 에러가 반환되는 Result enum을 반환합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGame\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 다른 함수들\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eplay_move\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, column: \u003cspan class=\"hljs-type\"\u003eusize\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eResult\u003c/span\u003e\u0026#x3C;(), MoveError\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.is_finished {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_ invoke__\"\u003eErr\u003c/span\u003e(MoveError::GameFinished);\n        }\n\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e column \u003e= BOARD_WIDTH {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_ invoke__\"\u003eErr\u003c/span\u003e(MoveError::InvalidColumn);\n        }\n\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eSome\u003c/span\u003e(row) = (\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e..BOARD_HEIGHT)\n            .\u003cspan class=\"hljs-title function_ invoke__\"\u003erev\u003c/span\u003e()\n            .\u003cspan class=\"hljs-title function_ invoke__\"\u003efind\u003c/span\u003e(|\u0026#x26;row| \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.board[row][column] == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n        {\n            \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.board[row][column] = \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.current_player \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eu8\u003c/span\u003e;\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_ invoke__\"\u003eErr\u003c/span\u003e(MoveError::ColumnFull);\n        }\n\n        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.current_move += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\n        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.current_player = \u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.current_player {\n            Player::One =\u003e Player::Two,\n            _ =\u003e Player::One,\n        };\n\n        \u003cspan class=\"hljs-title function_ invoke__\"\u003eOk\u003c/span\u003e(())\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e디버깅을 위해 이제 play_move의 결과를 인쇄할 수 있으며, 예상치 못한 입력이 있는 경우 enum으로부터 에러를 볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e우리가 여기에 있는 동안, 명령줄에 에러 메시지를 인쇄하는 도우미 함수를 추가해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGame\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 다른 함수들\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edisplay_error\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, error: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.\u003cspan class=\"hljs-title function_ invoke__\"\u003edisplay_board\u003c/span\u003e();\n        \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"{}에러: {}{}\"\u003c/span\u003e, RED, error, RESET);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e게임에서 승리했는지 계산하기\u003c/h1\u003e\n\u003cp\u003e누군가가 이겼는지 확인하기 위해 2차원 배열을 여러 방향으로 탐색해야 합니다. 이 Leetcode 스타일 문제는 재미있는 도전이었고, 결과물을 얻기까지 몇 번 시도해야 했어요.\u003c/p\u003e\n\u003cp\u003e누군가가 4칸을 연달아 얻을 수 있는 네 가지 방향이 있어요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e수평,\u003c/li\u003e\n\u003cli\u003e수직,\u003c/li\u003e\n\u003cli\u003e역 슬래시 대각선 (왼쪽 위에서 오른쪽 아래로),\u003c/li\u003e\n\u003cli\u003e순방향 슬래시 대각선 (왼쪽 아래에서 오른쪽 위로).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e게시판의 모든 슬롯을 반복하여 네 방향 중 하나에서 테스트할 수 있습니다. (게시판이 작기 때문에 무차별 대입 방식을 사용하는 것이 부담이 되지 않습니다. 그러나 더 나은 방법이 있는지 궁금합니다!)\u003c/p\u003e\n\u003cp\u003e게시판의 주어진 슬롯에서 시작합니다. 플레이어의 토큰이 들어있는 경우, 첫 번째 방향으로 한 단계 이동합니다. 이 새로운 슬롯도 같은 토큰을 포함하는 경우, 이 방향으로 또 다른 단계를 이동합니다. 이를 반복하여 같은 토큰이 있는 네 개의 슬롯을 찾을 때까지 진행합니다. 그렇지 않으면 다른 방향으로 이동합니다.\u003c/p\u003e\n\u003cp\u003e각 방향은 정수들의 튜플로 나타낼 수 있습니다 - 행당 거리에 대한 값과 열당 거리에 대한 값 하나씩 - 이 정보를 배열에 저장할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e directions = [\n  (\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e), \u003cspan class=\"hljs-comment\"\u003e// 가로\u003c/span\u003e\n  (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e), \u003cspan class=\"hljs-comment\"\u003e// 세로\u003c/span\u003e\n  (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e), \u003cspan class=\"hljs-comment\"\u003e// 대각선 (왼쪽 위에서 오른쪽 아래)\u003c/span\u003e\n  (-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e), \u003cspan class=\"hljs-comment\"\u003e// 대각선 (왼쪽 아래에서 오른쪽 위)\u003c/span\u003e\n];\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 튜플들이 무엇을 나타내는지 알려드릴게요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e수평으로 이동하려면 행은 변하지 않고(0), 열만 변해야 합니다(1).\u003c/li\u003e\n\u003cli\u003e수직으로 이동하려면 행이 변해야 하고(1), 열은 변하지 않아야 합니다(0).\u003c/li\u003e\n\u003cli\u003e역 슬래시 대각선으로 이동하려면 행과 열이 둘 다 증가해야 합니다(1, 1).\u003c/li\u003e\n\u003cli\u003e마지막으로, 슬래시 대각선으로 이동하려면 열은 증가하고 행은 감소해야 합니다(-1, 1).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e각 방향의 모든 슬롯을 테스트하려면 아래와 같이 세 개의 루프가 필요합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGame\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 다른 함수들\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculate_winner\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e Player {\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003erow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e..BOARD_HEIGHT {\n            \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ecol\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e..BOARD_WIDTH {\n                \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ecell\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.board[row][col];\n\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e cell != \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n                    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003edirections\u003c/span\u003e = [\n                        (\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e),  \u003cspan class=\"hljs-comment\"\u003e// 수평\u003c/span\u003e\n                        (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e),  \u003cspan class=\"hljs-comment\"\u003e// 수직\u003c/span\u003e\n                        (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e),  \u003cspan class=\"hljs-comment\"\u003e// 대각선 (왼쪽 위에서 오른쪽 아래로)\u003c/span\u003e\n                        (-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e), \u003cspan class=\"hljs-comment\"\u003e// 대각선 (왼쪽 아래에서 오른쪽 위로)\u003c/span\u003e\n                    ];\n\n                    \u003cspan class=\"hljs-title function_ invoke__\"\u003efor\u003c/span\u003e (row_step, col_step) \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e directions {\n                        \u003cspan class=\"hljs-comment\"\u003e// TODO - 주어진 방향으로 보드를 탐색하고\u003c/span\u003e\n                        \u003cspan class=\"hljs-comment\"\u003e// 승자를 찾았다면 해당 플레이어를 반환하세요\u003c/span\u003e\n                    }\n                }\n            }\n        }\n        Player::\u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우리는 연속 카운트를 유지하고 — 4에 도달하면 승자가 나온 것을 알 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그럼, 최종 중첩된 루프에서는 시작 토큰부터 슬롯별로 이동을 시도할 것입니다. 그때까지…\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e시작 토큰과 다른 토큰을 만날 때 (그러한 경우 루프를 종료합니다);\u003c/li\u003e\n\u003cli\u003e보드의 가장자리에 도달할 때 (그러한 경우 루프를 종료합니다);\u003c/li\u003e\n\u003cli\u003e동일한 토큰의 4연속을 만날 때 (그러한 경우 게임을 종료하고 승자를 지정합니다).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eimpl \u003cspan class=\"hljs-title class_\"\u003eGame\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 다른 함수들\u003c/span\u003e\n\n    fn \u003cspan class=\"hljs-title function_\"\u003ecalculate_winner\u003c/span\u003e(\u0026#x26;mut self) -\u003e \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e row \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eBOARD_HEIGHT\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e col \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eBOARD_WIDTH\u003c/span\u003e {\n                \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e cell = self.\u003cspan class=\"hljs-property\"\u003eboard\u003c/span\u003e[row][col];\n\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e cell != \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n                    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e directions = [\n                        (\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e),  \u003cspan class=\"hljs-comment\"\u003e// 가로\u003c/span\u003e\n                        (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e),  \u003cspan class=\"hljs-comment\"\u003e// 세로\u003c/span\u003e\n                        (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e),  \u003cspan class=\"hljs-comment\"\u003e// 대각선 (왼쪽 위에서 오른쪽 아래로)\u003c/span\u003e\n                        (-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e), \u003cspan class=\"hljs-comment\"\u003e// 대각선 (왼쪽 아래에서 오른쪽 위로)\u003c/span\u003e\n                    ];\n\n                    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (row_step, col_step) \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e directions {\n                        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e mut consecutive_count = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n                        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e mut r = row \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e isize + row_step;\n                        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e mut c = col \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e isize + col_step;\n\n                        \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e r \u003e= \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n                            \u0026#x26;\u0026#x26; r \u0026#x3C; \u003cspan class=\"hljs-variable constant_\"\u003eBOARD_HEIGHT\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e isize\n                            \u0026#x26;\u0026#x26; c \u003e= \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n                            \u0026#x26;\u0026#x26; c \u0026#x3C; \u003cspan class=\"hljs-variable constant_\"\u003eBOARD_WIDTH\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e isize\n                        {\n                            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e self.\u003cspan class=\"hljs-property\"\u003eboard\u003c/span\u003e[r \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e usize][c \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e usize] == cell {\n                                consecutive_count += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\n                                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e consecutive_count == \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e {\n                                    self.\u003cspan class=\"hljs-property\"\u003eis_finished\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n                                    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003efrom_int\u003c/span\u003e(cell);\n                                }\n                            } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n                                \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n                            }\n                            r += row_step;\n                            c += col_step;\n                        }\n                    }\n                }\n            }\n        }\n\n        \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우리는 이동 횟수가 일곱 미만인 경우 이러한 확인 작업을 수행하지 않고 최적화를 조금 추가할 수 있습니다. 그때까지는 게임에서 이기는 것이 불가능하기 때문입니다. 그래서 함수 맨 위에 이를 추가해 봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e self.\u003cspan class=\"hljs-property\"\u003ecurrent_move\u003c/span\u003e \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 보드가 가득 찼지만 승자가 없는 경우(즉, 무승부인 경우)에 게임을 종료로 표시해야 합니다. 이를 반환문 위에 추가해 줍시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e self.\u003cspan class=\"hljs-property\"\u003ecurrent_move\u003c/span\u003e \u003e= \u003cspan class=\"hljs-variable constant_\"\u003eBOARD_HEIGHT\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e u8 * \u003cspan class=\"hljs-variable constant_\"\u003eBOARD_WIDTH\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e u8 {\n    self.\u003cspan class=\"hljs-property\"\u003eis_finished\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e마지막으로, 새로운 calculate_winner 함수를 play_move 함수에 추가할 수 있습니다. 이번에는 아무것도 반환하는 대신, 성공인 Result enum을 반환하거나 실패인 경우에는 오류를 반환합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eimpl \u003cspan class=\"hljs-title class_\"\u003eGame\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 다른 함수들\u003c/span\u003e\n\n    fn \u003cspan class=\"hljs-title function_\"\u003eplay_move\u003c/span\u003e(\u0026#x26;mut self, \u003cspan class=\"hljs-attr\"\u003ecolumn\u003c/span\u003e: usize) -\u003e \u003cspan class=\"hljs-title class_\"\u003eResult\u003c/span\u003e\u0026#x3C;(), \u003cspan class=\"hljs-title class_\"\u003eMoveError\u003c/span\u003e\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e self.\u003cspan class=\"hljs-property\"\u003eis_finished\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eErr\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMoveError\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eGameFinished\u003c/span\u003e);\n        }\n\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e column \u003e= \u003cspan class=\"hljs-variable constant_\"\u003eBOARD_WIDTH\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eErr\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMoveError\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eInvalidColumn\u003c/span\u003e);\n        }\n\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSome\u003c/span\u003e(row) = (\u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eBOARD_HEIGHT\u003c/span\u003e)\n            .\u003cspan class=\"hljs-title function_\"\u003erev\u003c/span\u003e()\n            .\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e|\u0026#x26;row| self.board[row][column] == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\u003c/span\u003e)\n        {\n            self.\u003cspan class=\"hljs-property\"\u003eboard\u003c/span\u003e[row][column] = self.\u003cspan class=\"hljs-property\"\u003ecurrent_player\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e u8;\n            self.\u003cspan class=\"hljs-property\"\u003ecurrent_move\u003c/span\u003e += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eErr\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMoveError\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eColumnFull\u003c/span\u003e);\n        }\n\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e calculated_winner = self.\u003cspan class=\"hljs-title function_\"\u003ecalculate_winner\u003c/span\u003e();\n\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e calculated_winner != \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e {\n            self.\u003cspan class=\"hljs-property\"\u003ewinner\u003c/span\u003e = calculated_winner;\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            self.\u003cspan class=\"hljs-property\"\u003ecurrent_player\u003c/span\u003e = match self.\u003cspan class=\"hljs-property\"\u003ecurrent_player\u003c/span\u003e {\n                \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e::\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eOne\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eTwo\u003c/span\u003e,\n                \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e_\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eOne\u003c/span\u003e,\n            };\n        }\n\n        \u003cspan class=\"hljs-title class_\"\u003eOk\u003c/span\u003e(())\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리의 Connect 4 게임 엔진이 완성되었습니다! 사용자로부터 입력을 받는 방법만 남았습니다...\u003c/p\u003e\n\u003ch1\u003e사용자 입력 받기\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우리 명령 줄 게임의 마지막 부분에서는 주 함수로 돌아가 사용자 입력을 읽을 수 있도록 할 것입니다.\u003c/p\u003e\n\u003cp\u003e먼저, Rust의 표준 I/O 라이브러리를 가져오겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003euse \u003cspan class=\"hljs-attr\"\u003estd\u003c/span\u003e::io;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e사용자 입력을 읽는 논리는 다음과 같이 보일 수 있습니다. 여기서는 컴퓨터와 달리 0이 아닌 1부터 시작하여 카운트하게 됩니다!\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e mut user_move = \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003enew\u003c/span\u003e();\n\n\u003cspan class=\"hljs-attr\"\u003eio\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003estdin\u003c/span\u003e()\n    .\u003cspan class=\"hljs-title function_\"\u003eread_line\u003c/span\u003e(\u0026#x26;mut user_move)\n    .\u003cspan class=\"hljs-title function_\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Failed to read line\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003euser_move\u003c/span\u003e: usize = match user_move.\u003cspan class=\"hljs-title function_\"\u003etrim\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title class_\"\u003eOk\u003c/span\u003e(num) =\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e num \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e || num \u003e \u003cspan class=\"hljs-variable constant_\"\u003eBOARD_WIDTH\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e u8 {\n            game.\u003cspan class=\"hljs-title function_\"\u003edisplay_error\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMoveError\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eInvalidColumn\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eto_string\u003c/span\u003e());\n            \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e;\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            num\n        }\n    }\n    \u003cspan class=\"hljs-title class_\"\u003eErr\u003c/span\u003e(err) =\u003e {\n        game.\u003cspan class=\"hljs-title function_\"\u003edisplay_error\u003c/span\u003e(err.\u003cspan class=\"hljs-title function_\"\u003eto_string\u003c/span\u003e());\n        \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e;\n    }\n};\n\nmatch game.\u003cspan class=\"hljs-title function_\"\u003eplay_move\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003euser_move - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title class_\"\u003eOk\u003c/span\u003e(_) =\u003e {\n        game.\u003cspan class=\"hljs-title function_\"\u003edisplay_board\u003c/span\u003e();\n    }\n    \u003cspan class=\"hljs-title class_\"\u003eErr\u003c/span\u003e(err) =\u003e {\n        game.\u003cspan class=\"hljs-title function_\"\u003edisplay_error\u003c/span\u003e(err.\u003cspan class=\"hljs-title function_\"\u003eto_string\u003c/span\u003e());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e먼저, 우리는 빈 문자열을 정의한 뒤 사용자로부터 텍스트를 받기 위해 stdin 메소드를 사용합니다.\u003c/p\u003e\n\u003cp\u003e다음으로 이 입력을 구문 분석을 시도합니다. 다음 중 하나라도 해당하는 경우 오류를 표시합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e구문 분석이 실패하는 경우 (예: 입력이 숫자가 아닌 경우).\u003c/li\u003e\n\u003cli\u003e구문 분석이 성공하지만 숫자가 원하는 범위를 벗어난 경우.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e만약 오류가 표시되지 않는다면, 우리는 선택한 수를 둘 것입니다. 그러나 해당 시나리오에서 오류가 발생할 수도 있으므로, 그런 경우에는 오류를 표시할 것입니다.\u003c/p\u003e\n\u003cp\u003e그러나 위의 코드는 한 번만 실행됩니다. 게임이 끝날 때까지 루프를 실행해야 합니다. 아래는 그 반복문을 추가한 main 함수와 사용자를 도와줄 몇 가지 유용한 메시지입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efn \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e mut game = \u003cspan class=\"hljs-title class_\"\u003eGame\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e();\n    game.\u003cspan class=\"hljs-title function_\"\u003edisplay_board\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e !game.\u003cspan class=\"hljs-property\"\u003eis_finished\u003c/span\u003e {\n        println!(\u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e);\n\n        match game.\u003cspan class=\"hljs-property\"\u003ecurrent_player\u003c/span\u003e {\n            \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e::\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eOne\u003c/span\u003e =\u003e\u003c/span\u003e println!(\u003cspan class=\"hljs-string\"\u003e\"플레이어 1\"\u003c/span\u003e),\n            \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e::\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eTwo\u003c/span\u003e =\u003e\u003c/span\u003e println!(\u003cspan class=\"hljs-string\"\u003e\"플레이어 2\"\u003c/span\u003e),\n            \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e_\u003c/span\u003e =\u003e\u003c/span\u003e (),\n        };\n\n        println!(\u003cspan class=\"hljs-string\"\u003e\"1부터 7 사이의 열을 입력하세요:\"\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e mut user_move = \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003enew\u003c/span\u003e();\n        \u003cspan class=\"hljs-attr\"\u003eio\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003estdin\u003c/span\u003e()\n            .\u003cspan class=\"hljs-title function_\"\u003eread_line\u003c/span\u003e(\u0026#x26;mut user_move)\n            .\u003cspan class=\"hljs-title function_\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"라인을 읽는 데 실패했습니다\"\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003euser_move\u003c/span\u003e: usize = match user_move.\u003cspan class=\"hljs-title function_\"\u003etrim\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n            \u003cspan class=\"hljs-title class_\"\u003eOk\u003c/span\u003e(num) =\u003e {\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e num \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e || num \u003e \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e {\n                    game.\u003cspan class=\"hljs-title function_\"\u003edisplay_error\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMoveError\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eInvalidColumn\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eto_string\u003c/span\u003e());\n                    \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e;\n                } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n                    num\n                }\n            }\n            \u003cspan class=\"hljs-title class_\"\u003eErr\u003c/span\u003e(err) =\u003e {\n                game.\u003cspan class=\"hljs-title function_\"\u003edisplay_error\u003c/span\u003e(err.\u003cspan class=\"hljs-title function_\"\u003eto_string\u003c/span\u003e());\n                \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e;\n            }\n        };\n\n        match game.\u003cspan class=\"hljs-title function_\"\u003eplay_move\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003euser_move - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\u003c/span\u003e) {\n            \u003cspan class=\"hljs-title class_\"\u003eOk\u003c/span\u003e(_) =\u003e {\n                game.\u003cspan class=\"hljs-title function_\"\u003edisplay_board\u003c/span\u003e();\n            }\n            \u003cspan class=\"hljs-title class_\"\u003eErr\u003c/span\u003e(err) =\u003e {\n                game.\u003cspan class=\"hljs-title function_\"\u003edisplay_error\u003c/span\u003e(err.\u003cspan class=\"hljs-title function_\"\u003eto_string\u003c/span\u003e());\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e여러 판을 플레이하기\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e마지막으로, 사용자가 게임을 끝내면 게임을 다시 시작할 수 있도록 추가 코드를 추가하고 싶어요. 매번 실행 파일을 다시 시작해야 하는 번거로움은 피하고 싶으니까요!\u003c/p\u003e\n\u003cp\u003e이를 위해 새로운 루프를 만들 것입니다. 이전과 동일한 방법을 사용하여 사용자의 입력을 읽을 수 있습니다. \"R\"을 누르면 새 게임을 시작하고, \"Q\"를 누르면 루프를 중단하고 코드를 끝까지 실행합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efn \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e mut game = \u003cspan class=\"hljs-title class_\"\u003eGame\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e();\n    game.\u003cspan class=\"hljs-title function_\"\u003edisplay_board\u003c/span\u003e();\n\n    loop {\n        \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e !game.\u003cspan class=\"hljs-property\"\u003eis_finished\u003c/span\u003e {\n            \u003cspan class=\"hljs-comment\"\u003e// 코드 변경 없음\u003c/span\u003e\n        }\n\n        println!(\u003cspan class=\"hljs-string\"\u003e\"Press 'R' to restart or 'Q' to quit the game.\"\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e mut user_input = \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003enew\u003c/span\u003e();\n\n        \u003cspan class=\"hljs-attr\"\u003eio\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003estdin\u003c/span\u003e()\n            .\u003cspan class=\"hljs-title function_\"\u003eread_line\u003c/span\u003e(\u0026#x26;mut user_input)\n            .\u003cspan class=\"hljs-title function_\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Failed to read line\"\u003c/span\u003e);\n\n        match user_input.\u003cspan class=\"hljs-title function_\"\u003etrim\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n            \u003cspan class=\"hljs-string\"\u003e\"R\"\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e\"r\"\u003c/span\u003e =\u003e {\n                game = \u003cspan class=\"hljs-title class_\"\u003eGame\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e();\n                game.\u003cspan class=\"hljs-title function_\"\u003edisplay_board\u003c/span\u003e();\n            }\n            \u003cspan class=\"hljs-string\"\u003e\"Q\"\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e\"q\"\u003c/span\u003e =\u003e {\n                println!(\u003cspan class=\"hljs-string\"\u003e\"Quitting...\"\u003c/span\u003e);\n                \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n            }\n            _ =\u003e game.\u003cspan class=\"hljs-title function_\"\u003edisplay_error\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"잘못된 입력\"\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eto_string\u003c/span\u003e()),\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막으로, 차례 사이에 터미널을 지우기 위한 ASCII 이스케이프 코드를 사용할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efn \u003cspan class=\"hljs-title function_\"\u003eclear_screen\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u0026#x26;self\u003c/span\u003e) {\n    print!(\u003cspan class=\"hljs-string\"\u003e\"{}[2J\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e27\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e char);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e게임 보드를 표시할 때마다 이 작업을 수행할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efn \u003cspan class=\"hljs-title function_\"\u003edisplay_board\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u0026#x26;self\u003c/span\u003e) {\n    self.\u003cspan class=\"hljs-title function_\"\u003eclear_screen\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-comment\"\u003e// 코드 변경 없음\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e모두 함께 가져오기\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그것이 커넥트 4의 간단한 명령줄 게임을 위해 필요한 모든 것입니다! 이 작업 중인 파일을 사용하는 작동 버전을 시험하려면 Rust 플레이그라운드를 확인해보세요.\u003c/p\u003e\n\u003cp\u003e우리가 지금까지 만든 전체 파일은 아래와 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003euse \u003cspan class=\"hljs-attr\"\u003estd\u003c/span\u003e::io;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eRESET\u003c/span\u003e: \u0026#x26;str = \u003cspan class=\"hljs-string\"\u003e\"\\x1b[0m\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eORANGE\u003c/span\u003e: \u0026#x26;str = \u003cspan class=\"hljs-string\"\u003e\"\\x1b[93m\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eRED\u003c/span\u003e: \u0026#x26;str = \u003cspan class=\"hljs-string\"\u003e\"\\x1b[0;31m\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eBOARD_WIDTH\u003c/span\u003e: usize = \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eBOARD_HEIGHT\u003c/span\u003e: usize = \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e;\n\ntype \u003cspan class=\"hljs-title class_\"\u003eBoard\u003c/span\u003e = [[u8; \u003cspan class=\"hljs-variable constant_\"\u003eBOARD_WIDTH\u003c/span\u003e]; \u003cspan class=\"hljs-variable constant_\"\u003eBOARD_HEIGHT\u003c/span\u003e];\n\n#[\u003cspan class=\"hljs-title function_\"\u003ederive\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eClone\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eCopy\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eDebug\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003ePartialEq\u003c/span\u003e)]\n#[\u003cspan class=\"hljs-title function_\"\u003erepr\u003c/span\u003e(u8)]\nenum \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e {\n    \u003cspan class=\"hljs-title class_\"\u003eOne\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n    \u003cspan class=\"hljs-title class_\"\u003eTwo\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\n    \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n}\n\nimpl \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e {\n    fn \u003cspan class=\"hljs-title function_\"\u003efrom_int\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eint\u003c/span\u003e: u8) -\u003e \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e {\n        match int {\n            \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e =\u003e \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eOne\u003c/span\u003e,\n            \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e =\u003e \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eTwo\u003c/span\u003e,\n            \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e_\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e,\n        }\n    }\n}\n\n#[...]\n\n# 결론\n\n\u0026#x3C;!-- ui-station 사각형 --\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"adsbygoogle\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"display:block\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-client\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ca-pub-4877378276818686\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-slot\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"7249294152\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-ad-format\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"auto\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata-full-width-responsive\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"true\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eins\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"javascript\"\u003e\n(adsbygoogle = \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eadsbygoogle\u003c/span\u003e || []).\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e({});\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n지금까지 따라오셨다면 프로젝트를 더 나아가고 싶을 것입니다. 여러 게임을 거치면서 승리를 추적해 볼 수도 있고, 어떨까요? 어플리케이션을 웹 서버로 전환하여 웹사이트가 \u003cspan class=\"hljs-variable constant_\"\u003eHTTP\u003c/span\u003e를 통해 \u003cspan class=\"hljs-title class_\"\u003eConnect\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e를 플레이할 수 있게끔 만들어 보는 것은 어떤가요?\n\n이번 명령줄 어플리케이션을 \u003cspan class=\"hljs-title class_\"\u003eRust\u003c/span\u003e로 개발하는 방법에 대한 유용하고 재미있는 통찰력으로 여기시길 바랍니다. 아직 \u003cspan class=\"hljs-title class_\"\u003eRust\u003c/span\u003e 여행을 시작한 지 얼마 되지 않았기 때문에, 어떠한 비평이나 더 많은 \u003cspan class=\"hljs-title class_\"\u003eRust\u003c/span\u003e 다운 방식으로 어플리케이션을 작성하는 아이디어가 있다면 꼭 알려주세요. 함께 고민해보고 싶습니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-20-LearnRustbycodingacommandlineConnect4game"},"buildId":"wOkGEDZCvEs3S_XaNsdwr","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>