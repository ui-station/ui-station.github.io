<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>단위 테스트보다 통합 테스트를 선호하여 정확성 확인하기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="단위 테스트보다 통합 테스트를 선호하여 정확성 확인하기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="단위 테스트보다 통합 테스트를 선호하여 정확성 확인하기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness" data-gatsby-head="true"/><meta name="twitter:title" content="단위 테스트보다 통합 테스트를 선호하여 정확성 확인하기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-27 16:17" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_buildManifest.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">단위 테스트보다 통합 테스트를 선호하여 정확성 확인하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="단위 테스트보다 통합 테스트를 선호하여 정확성 확인하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 27, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness_0.png" alt="unit test image"></p>
<p>저는 전문적인 코딩을 시작한 이후로 단위 테스트를 작성해 왔어요. 그 속에는 특별한 "영감"이 있죠. 다른 개발자가 여러분의 코드를 사용해야 한다는 점을 생각하게 만들어요.</p>
<p>그 "다른 개발자"가 바로 여러분의 미래 자신이기도 해요.</p>
<p>단위 테스트를 작성할 때마다, 정확성을 검증할 뿐만 아니라 클래스의 작업 편의성도 평가하려고 해요. 좋은 코드를 작성하는 중요한 측면 중 하나는 함께 작업하기 즐거운 코드를 작성하는 것이라고 생각해요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그러나 전반적인 시스템의 정확성을 검증하는 것은 단위 테스트가 갖고 있지 않은 특징입니다.</p>
<p>단위 테스트를 작성하는 데 드는 비용은 매우 적습니다. 기대되는 결과를 빠르게 작성, 실행 및 확인할 수 있습니다. 그러나 다른 측면에서도 저렴하다고 할 수 있습니다. 단위 테스트는 실제로 발생할 수 있는 프로덕션에서 발생할 수 있는 버그를 잡는 데는 거의 충분하지 않습니다.</p>
<p>🔔 이와 유사한 기사를 더 보고 싶으시면 여기에서 가입하세요.</p>
<p>매우 제어된 상황에서 고립된 상태로 작동하는 것을 본다는 것은 여러 협업 객체, 다양한 사용 사례 등이 포함된 더 큰 환경에서 작동하는 것을 보는 것과는 전혀 다릅니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>의존성을 경멸하는 것은 재앙의 길이 될 수 있습니다. 그리고 내 경험상, 데이터베이스와의 상호 작용을 모의하는 경우에는 특히 그렇습니다.</p>
<p>이 유닛 테스트를 분석해 보세요. 우리는 "UserManager"를 통해 사용자를 저장하는 것을 확인하려고 합니다.</p>
<pre><code class="hljs language-js">[<span class="hljs-title class_">Fact</span>]
public <span class="hljs-keyword">void</span> <span class="hljs-title class_">SaveNewUser</span>()
{
   <span class="hljs-comment">// Arrange</span>
   <span class="hljs-keyword">var</span> repository = <span class="hljs-title class_">Substitute</span>.<span class="hljs-property">For</span>&#x3C;<span class="hljs-title class_">IUserRepository</span>>();


   <span class="hljs-keyword">var</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
   <span class="hljs-keyword">var</span> sut = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserManager</span>(repository);

   <span class="hljs-comment">// Act</span>
   sut.<span class="hljs-title class_">SaveUser</span>(user);

   <span class="hljs-comment">// Assert</span>
   repository.<span class="hljs-title class_">Received</span>(<span class="hljs-number">1</span>).<span class="hljs-title class_">SaveUser</span>(<span class="hljs-title class_">Arg</span>.<span class="hljs-property">Any</span>&#x3C;<span class="hljs-title class_">User</span>>());
}
</code></pre>
<p>이것은 투명하고 화이트박스 테스트입니다. UserManager는 실제 저장을 협력자 "IUserRepository"에 위임하고 있으며, "UserManager"가 "SaveUser" 메서드를 호출하는지 확인합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이는 아무 것도 테스트하지 않는 종류의 단위 테스트입니다. 아무 것도 확인하지 않으며 확신을 줄 수도 없습니다.</p>
<p>우리는 모든 것이 잘되도록 하려는 중입니다.</p>
<p>이러한 테스트는 무언가를 확실히 해서 빌드 서버에서 코드 품질 단계를 통과시키는 임의의 코드 커버리지 목표를 충족하는 데로 인해 우리를 기분 좋게 만들어 줍니다. 하지만 실제로는 일이 잘 되고 있다는 빈 약속일 뿐입니다.</p>
<p>만약 당신의 코드베이스에 제가 방금 보여준 것과 유사한 테스트가 있다면, 그것은 당신에게 큰 문제가 있을 수 있다는 것을 의미합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위의 "사용자" 테이블이 이렇게 생겼다고 가정해 봅시다.</p>
<pre><code class="hljs language-js">-- <span class="hljs-title class_">PostgreSQL</span>
<span class="hljs-variable constant_">CREATE</span> <span class="hljs-variable constant_">TABLE</span> <span class="hljs-string">"Users"</span> (
   <span class="hljs-string">"Id"</span> uuid <span class="hljs-variable constant_">NOT</span> <span class="hljs-variable constant_">NULL</span>,
   <span class="hljs-string">"Name"</span> text <span class="hljs-variable constant_">NOT</span> <span class="hljs-variable constant_">NULL</span>,

   -- 그리고 다른 많은 열들

   <span class="hljs-variable constant_">CONSTRAINT</span> <span class="hljs-string">"PK_Users"</span> <span class="hljs-variable constant_">PRIMARY</span> <span class="hljs-variable constant_">KEY</span> (<span class="hljs-string">"Id"</span>)
);
</code></pre>
<p>그럼 "Id"나 "Name"이 없이 만들어진 사용자를 저장하려고 하면 예외가 발생하게 되어, 모든 것이 정상적으로 작동되고 있다고 생각하는 것을 방지할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(); <span class="hljs-comment">// 저장되지 않아야 함</span>
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이것은 분명히 클래스와 협력자 간의 상호 작용이 매우 적은 간단한 예제입니다. 그러나 단위 테스트에 무작정 의존하는 함정을 보여줍니다.</p>
<p>🔔 이와 유사한 기사를 더 보시려면 여기에서 가입하세요.</p>
<p>프로페셔널 소프트웨어 개발의 여러 해를 거친 후, 무언가를 모킹할 때 항상 그 테스트를 단위 테스트로 유지해야 하는지 아니면 통합 테스트로 승격해야 하는지 신중하게 생각하는 시간을 가집니다.</p>
<p>이제 이 전환된 테스트와 이 통합 테스트를 대조해 보세요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UserManagerShould</span>(<span class="hljs-params">DatabaseFixture fixture</span>) : IClassFixture&#x3C;DatabaseFixture></span>
{
  [<span class="hljs-meta">Fact</span>]
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">SaveNewUser</span>()</span>
  {
     <span class="hljs-comment">// Arrange</span>
     UserDbContext context = <span class="hljs-keyword">new</span> TestDbContextFactory(fixture.ConnectionString)
         .CreateDbContext(<span class="hljs-literal">null</span>!);

     <span class="hljs-keyword">await</span> context.Database.EnsureCreatedAsync();
     <span class="hljs-keyword">await</span> context.Users.ExecuteDeleteAsync();

     <span class="hljs-keyword">var</span> repository = <span class="hljs-keyword">new</span> EfUserRepository(context);

     <span class="hljs-keyword">var</span> user = <span class="hljs-keyword">new</span> User();
     <span class="hljs-keyword">var</span> sut = <span class="hljs-keyword">new</span> UserManager(repository);


     <span class="hljs-comment">// Act</span>
     sut.SaveUser(user);

     <span class="hljs-comment">// Assert</span>
     List&#x3C;User> result = context.Users
         .AsNoTracking()
         .ToList();

     result.Should()
           .HaveCount(<span class="hljs-number">1</span>);
  }
}
</code></pre>
<p>이 테스트는 우리 시스템이 프로덕션에서 수행할 작업을 정확히 모방합니다. 이 테스트는 픽스처와 PostgreSQL 도커 컨테이너가 하나의 테스트를 위해 실행됩니다.</p>
<p>이제 "SaveUser(user)" 메서드를 호출하면 실제 데이터베이스에 삽입이 수행되며, 사용자에게 이름이 없기 때문에 오류가 발생합니다: Npgsql.PostgresException 23502: null value in column "Name" of relation "Users" violates not-null constraint.</p>
<p>실제로 잘못된 상황에서 오류가 발생하는 이러한 테스트는 사용자를 저장하기 전에 추가적인 확인 절차를 수행해야 함을 알려줍니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>테스트 실패는 우리에게 대응을 촉발시킵니다. 이 경우 UserManager의 SaveUser(user) 메서드에 가드 절을 추가하여 사용자가 유효한 상태에 있는지 확인하십시오.</p>
<h1>요약하자면...</h1>
<p>테스트는 시스템이 작동한다는 확신을 주어야 하며, 단순히 통제된 실험실 조건에서 각 부분이 작동하는 것만으로는 충분하지 않습니다.</p>
<p>🔔 이와 같은 기사를 더 읽고 싶으신가요? 여기에서 등록하세요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>시스템 내 중요한 클래스 상호작용을 모의하는 것은 클래스 간 통신 및 데이터 교환에서 발생하는 통합 문제를 알리지 못하게 할 수 있습니다. 실제 데이터베이스를 사용하는 데 조금 노력을 기울이면 장기적으로 이득을 볼 수 있습니다.</p>
<p>빌드 시간에 통합 문제를 발견하는 것은 운영시간(프로덕션)에 발생하는 쉽게 피할 수 있는 문제를 발견하는 것보다 훨씬 저렴합니다.</p>
<h1>계속 연락을 유지합시다!</h1>
<p>뉴스레터에 등록하여 유사한 기사에 대한 알림을 받고 YouTube 채널인 @Nicklas Millard를 확인해보세요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>린크드인에 연결하지 않는 것을 잊지 마세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"단위 테스트보다 통합 테스트를 선호하여 정확성 확인하기","description":"","date":"2024-05-27 16:17","slug":"2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness","content":"\n![unit test image](/assets/img/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness_0.png)\n\n저는 전문적인 코딩을 시작한 이후로 단위 테스트를 작성해 왔어요. 그 속에는 특별한 \"영감\"이 있죠. 다른 개발자가 여러분의 코드를 사용해야 한다는 점을 생각하게 만들어요.\n\n그 \"다른 개발자\"가 바로 여러분의 미래 자신이기도 해요.\n\n단위 테스트를 작성할 때마다, 정확성을 검증할 뿐만 아니라 클래스의 작업 편의성도 평가하려고 해요. 좋은 코드를 작성하는 중요한 측면 중 하나는 함께 작업하기 즐거운 코드를 작성하는 것이라고 생각해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 전반적인 시스템의 정확성을 검증하는 것은 단위 테스트가 갖고 있지 않은 특징입니다.\n\n단위 테스트를 작성하는 데 드는 비용은 매우 적습니다. 기대되는 결과를 빠르게 작성, 실행 및 확인할 수 있습니다. 그러나 다른 측면에서도 저렴하다고 할 수 있습니다. 단위 테스트는 실제로 발생할 수 있는 프로덕션에서 발생할 수 있는 버그를 잡는 데는 거의 충분하지 않습니다.\n\n🔔 이와 유사한 기사를 더 보고 싶으시면 여기에서 가입하세요.\n\n매우 제어된 상황에서 고립된 상태로 작동하는 것을 본다는 것은 여러 협업 객체, 다양한 사용 사례 등이 포함된 더 큰 환경에서 작동하는 것을 보는 것과는 전혀 다릅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n의존성을 경멸하는 것은 재앙의 길이 될 수 있습니다. 그리고 내 경험상, 데이터베이스와의 상호 작용을 모의하는 경우에는 특히 그렇습니다.\n\n이 유닛 테스트를 분석해 보세요. 우리는 \"UserManager\"를 통해 사용자를 저장하는 것을 확인하려고 합니다.\n\n```js\n[Fact]\npublic void SaveNewUser()\n{\n   // Arrange\n   var repository = Substitute.For\u003cIUserRepository\u003e();\n\n\n   var user = new User();\n   var sut = new UserManager(repository);\n\n   // Act\n   sut.SaveUser(user);\n\n   // Assert\n   repository.Received(1).SaveUser(Arg.Any\u003cUser\u003e());\n}\n```\n\n이것은 투명하고 화이트박스 테스트입니다. UserManager는 실제 저장을 협력자 \"IUserRepository\"에 위임하고 있으며, \"UserManager\"가 \"SaveUser\" 메서드를 호출하는지 확인합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이는 아무 것도 테스트하지 않는 종류의 단위 테스트입니다. 아무 것도 확인하지 않으며 확신을 줄 수도 없습니다.\n\n우리는 모든 것이 잘되도록 하려는 중입니다.\n\n이러한 테스트는 무언가를 확실히 해서 빌드 서버에서 코드 품질 단계를 통과시키는 임의의 코드 커버리지 목표를 충족하는 데로 인해 우리를 기분 좋게 만들어 줍니다. 하지만 실제로는 일이 잘 되고 있다는 빈 약속일 뿐입니다.\n\n만약 당신의 코드베이스에 제가 방금 보여준 것과 유사한 테스트가 있다면, 그것은 당신에게 큰 문제가 있을 수 있다는 것을 의미합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 \"사용자\" 테이블이 이렇게 생겼다고 가정해 봅시다.\n\n```js\n-- PostgreSQL\nCREATE TABLE \"Users\" (\n   \"Id\" uuid NOT NULL,\n   \"Name\" text NOT NULL,\n\n   -- 그리고 다른 많은 열들\n\n   CONSTRAINT \"PK_Users\" PRIMARY KEY (\"Id\")\n);\n```\n\n그럼 \"Id\"나 \"Name\"이 없이 만들어진 사용자를 저장하려고 하면 예외가 발생하게 되어, 모든 것이 정상적으로 작동되고 있다고 생각하는 것을 방지할 수 있습니다.\n\n```js\nvar user = new User(); // 저장되지 않아야 함\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 분명히 클래스와 협력자 간의 상호 작용이 매우 적은 간단한 예제입니다. 그러나 단위 테스트에 무작정 의존하는 함정을 보여줍니다.\n\n🔔 이와 유사한 기사를 더 보시려면 여기에서 가입하세요.\n\n프로페셔널 소프트웨어 개발의 여러 해를 거친 후, 무언가를 모킹할 때 항상 그 테스트를 단위 테스트로 유지해야 하는지 아니면 통합 테스트로 승격해야 하는지 신중하게 생각하는 시간을 가집니다.\n\n이제 이 전환된 테스트와 이 통합 테스트를 대조해 보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```csharp\npublic class UserManagerShould(DatabaseFixture fixture) : IClassFixture\u003cDatabaseFixture\u003e\n{\n  [Fact]\n  public async Task SaveNewUser()\n  {\n     // Arrange\n     UserDbContext context = new TestDbContextFactory(fixture.ConnectionString)\n         .CreateDbContext(null!);\n\n     await context.Database.EnsureCreatedAsync();\n     await context.Users.ExecuteDeleteAsync();\n\n     var repository = new EfUserRepository(context);\n\n     var user = new User();\n     var sut = new UserManager(repository);\n\n\n     // Act\n     sut.SaveUser(user);\n\n     // Assert\n     List\u003cUser\u003e result = context.Users\n         .AsNoTracking()\n         .ToList();\n\n     result.Should()\n           .HaveCount(1);\n  }\n}\n```\n\n이 테스트는 우리 시스템이 프로덕션에서 수행할 작업을 정확히 모방합니다. 이 테스트는 픽스처와 PostgreSQL 도커 컨테이너가 하나의 테스트를 위해 실행됩니다.\n\n이제 \"SaveUser(user)\" 메서드를 호출하면 실제 데이터베이스에 삽입이 수행되며, 사용자에게 이름이 없기 때문에 오류가 발생합니다: Npgsql.PostgresException 23502: null value in column \"Name\" of relation \"Users\" violates not-null constraint.\n\n실제로 잘못된 상황에서 오류가 발생하는 이러한 테스트는 사용자를 저장하기 전에 추가적인 확인 절차를 수행해야 함을 알려줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테스트 실패는 우리에게 대응을 촉발시킵니다. 이 경우 UserManager의 SaveUser(user) 메서드에 가드 절을 추가하여 사용자가 유효한 상태에 있는지 확인하십시오.\n\n# 요약하자면...\n\n테스트는 시스템이 작동한다는 확신을 주어야 하며, 단순히 통제된 실험실 조건에서 각 부분이 작동하는 것만으로는 충분하지 않습니다.\n\n🔔 이와 같은 기사를 더 읽고 싶으신가요? 여기에서 등록하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n시스템 내 중요한 클래스 상호작용을 모의하는 것은 클래스 간 통신 및 데이터 교환에서 발생하는 통합 문제를 알리지 못하게 할 수 있습니다. 실제 데이터베이스를 사용하는 데 조금 노력을 기울이면 장기적으로 이득을 볼 수 있습니다.\n\n빌드 시간에 통합 문제를 발견하는 것은 운영시간(프로덕션)에 발생하는 쉽게 피할 수 있는 문제를 발견하는 것보다 훨씬 저렴합니다.\n\n# 계속 연락을 유지합시다!\n\n뉴스레터에 등록하여 유사한 기사에 대한 알림을 받고 YouTube 채널인 @Nicklas Millard를 확인해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n린크드인에 연결하지 않는 것을 잊지 마세요.\n","ogImage":{"url":"/assets/img/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness_0.png"},"coverImage":"/assets/img/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness_0.png\" alt=\"unit test image\"\u003e\u003c/p\u003e\n\u003cp\u003e저는 전문적인 코딩을 시작한 이후로 단위 테스트를 작성해 왔어요. 그 속에는 특별한 \"영감\"이 있죠. 다른 개발자가 여러분의 코드를 사용해야 한다는 점을 생각하게 만들어요.\u003c/p\u003e\n\u003cp\u003e그 \"다른 개발자\"가 바로 여러분의 미래 자신이기도 해요.\u003c/p\u003e\n\u003cp\u003e단위 테스트를 작성할 때마다, 정확성을 검증할 뿐만 아니라 클래스의 작업 편의성도 평가하려고 해요. 좋은 코드를 작성하는 중요한 측면 중 하나는 함께 작업하기 즐거운 코드를 작성하는 것이라고 생각해요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그러나 전반적인 시스템의 정확성을 검증하는 것은 단위 테스트가 갖고 있지 않은 특징입니다.\u003c/p\u003e\n\u003cp\u003e단위 테스트를 작성하는 데 드는 비용은 매우 적습니다. 기대되는 결과를 빠르게 작성, 실행 및 확인할 수 있습니다. 그러나 다른 측면에서도 저렴하다고 할 수 있습니다. 단위 테스트는 실제로 발생할 수 있는 프로덕션에서 발생할 수 있는 버그를 잡는 데는 거의 충분하지 않습니다.\u003c/p\u003e\n\u003cp\u003e🔔 이와 유사한 기사를 더 보고 싶으시면 여기에서 가입하세요.\u003c/p\u003e\n\u003cp\u003e매우 제어된 상황에서 고립된 상태로 작동하는 것을 본다는 것은 여러 협업 객체, 다양한 사용 사례 등이 포함된 더 큰 환경에서 작동하는 것을 보는 것과는 전혀 다릅니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e의존성을 경멸하는 것은 재앙의 길이 될 수 있습니다. 그리고 내 경험상, 데이터베이스와의 상호 작용을 모의하는 경우에는 특히 그렇습니다.\u003c/p\u003e\n\u003cp\u003e이 유닛 테스트를 분석해 보세요. 우리는 \"UserManager\"를 통해 사용자를 저장하는 것을 확인하려고 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e[\u003cspan class=\"hljs-title class_\"\u003eFact\u003c/span\u003e]\npublic \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSaveNewUser\u003c/span\u003e()\n{\n   \u003cspan class=\"hljs-comment\"\u003e// Arrange\u003c/span\u003e\n   \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e repository = \u003cspan class=\"hljs-title class_\"\u003eSubstitute\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFor\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eIUserRepository\u003c/span\u003e\u003e();\n\n\n   \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e user = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e();\n   \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e sut = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserManager\u003c/span\u003e(repository);\n\n   \u003cspan class=\"hljs-comment\"\u003e// Act\u003c/span\u003e\n   sut.\u003cspan class=\"hljs-title class_\"\u003eSaveUser\u003c/span\u003e(user);\n\n   \u003cspan class=\"hljs-comment\"\u003e// Assert\u003c/span\u003e\n   repository.\u003cspan class=\"hljs-title class_\"\u003eReceived\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e).\u003cspan class=\"hljs-title class_\"\u003eSaveUser\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eArg\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eAny\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e\u003e());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 투명하고 화이트박스 테스트입니다. UserManager는 실제 저장을 협력자 \"IUserRepository\"에 위임하고 있으며, \"UserManager\"가 \"SaveUser\" 메서드를 호출하는지 확인합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이는 아무 것도 테스트하지 않는 종류의 단위 테스트입니다. 아무 것도 확인하지 않으며 확신을 줄 수도 없습니다.\u003c/p\u003e\n\u003cp\u003e우리는 모든 것이 잘되도록 하려는 중입니다.\u003c/p\u003e\n\u003cp\u003e이러한 테스트는 무언가를 확실히 해서 빌드 서버에서 코드 품질 단계를 통과시키는 임의의 코드 커버리지 목표를 충족하는 데로 인해 우리를 기분 좋게 만들어 줍니다. 하지만 실제로는 일이 잘 되고 있다는 빈 약속일 뿐입니다.\u003c/p\u003e\n\u003cp\u003e만약 당신의 코드베이스에 제가 방금 보여준 것과 유사한 테스트가 있다면, 그것은 당신에게 큰 문제가 있을 수 있다는 것을 의미합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위의 \"사용자\" 테이블이 이렇게 생겼다고 가정해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e-- \u003cspan class=\"hljs-title class_\"\u003ePostgreSQL\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eCREATE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTABLE\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Users\"\u003c/span\u003e (\n   \u003cspan class=\"hljs-string\"\u003e\"Id\"\u003c/span\u003e uuid \u003cspan class=\"hljs-variable constant_\"\u003eNOT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eNULL\u003c/span\u003e,\n   \u003cspan class=\"hljs-string\"\u003e\"Name\"\u003c/span\u003e text \u003cspan class=\"hljs-variable constant_\"\u003eNOT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eNULL\u003c/span\u003e,\n\n   -- 그리고 다른 많은 열들\n\n   \u003cspan class=\"hljs-variable constant_\"\u003eCONSTRAINT\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"PK_Users\"\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePRIMARY\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eKEY\u003c/span\u003e (\u003cspan class=\"hljs-string\"\u003e\"Id\"\u003c/span\u003e)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그럼 \"Id\"나 \"Name\"이 없이 만들어진 사용자를 저장하려고 하면 예외가 발생하게 되어, 모든 것이 정상적으로 작동되고 있다고 생각하는 것을 방지할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e user = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 저장되지 않아야 함\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이것은 분명히 클래스와 협력자 간의 상호 작용이 매우 적은 간단한 예제입니다. 그러나 단위 테스트에 무작정 의존하는 함정을 보여줍니다.\u003c/p\u003e\n\u003cp\u003e🔔 이와 유사한 기사를 더 보시려면 여기에서 가입하세요.\u003c/p\u003e\n\u003cp\u003e프로페셔널 소프트웨어 개발의 여러 해를 거친 후, 무언가를 모킹할 때 항상 그 테스트를 단위 테스트로 유지해야 하는지 아니면 통합 테스트로 승격해야 하는지 신중하게 생각하는 시간을 가집니다.\u003c/p\u003e\n\u003cp\u003e이제 이 전환된 테스트와 이 통합 테스트를 대조해 보세요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-csharp\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eUserManagerShould\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eDatabaseFixture fixture\u003c/span\u003e) : IClassFixture\u0026#x3C;DatabaseFixture\u003e\u003c/span\u003e\n{\n  [\u003cspan class=\"hljs-meta\"\u003eFact\u003c/span\u003e]\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e Task \u003cspan class=\"hljs-title\"\u003eSaveNewUser\u003c/span\u003e()\u003c/span\u003e\n  {\n     \u003cspan class=\"hljs-comment\"\u003e// Arrange\u003c/span\u003e\n     UserDbContext context = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e TestDbContextFactory(fixture.ConnectionString)\n         .CreateDbContext(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e!);\n\n     \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e context.Database.EnsureCreatedAsync();\n     \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e context.Users.ExecuteDeleteAsync();\n\n     \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e repository = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e EfUserRepository(context);\n\n     \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e user = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e User();\n     \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e sut = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e UserManager(repository);\n\n\n     \u003cspan class=\"hljs-comment\"\u003e// Act\u003c/span\u003e\n     sut.SaveUser(user);\n\n     \u003cspan class=\"hljs-comment\"\u003e// Assert\u003c/span\u003e\n     List\u0026#x3C;User\u003e result = context.Users\n         .AsNoTracking()\n         .ToList();\n\n     result.Should()\n           .HaveCount(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 테스트는 우리 시스템이 프로덕션에서 수행할 작업을 정확히 모방합니다. 이 테스트는 픽스처와 PostgreSQL 도커 컨테이너가 하나의 테스트를 위해 실행됩니다.\u003c/p\u003e\n\u003cp\u003e이제 \"SaveUser(user)\" 메서드를 호출하면 실제 데이터베이스에 삽입이 수행되며, 사용자에게 이름이 없기 때문에 오류가 발생합니다: Npgsql.PostgresException 23502: null value in column \"Name\" of relation \"Users\" violates not-null constraint.\u003c/p\u003e\n\u003cp\u003e실제로 잘못된 상황에서 오류가 발생하는 이러한 테스트는 사용자를 저장하기 전에 추가적인 확인 절차를 수행해야 함을 알려줍니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e테스트 실패는 우리에게 대응을 촉발시킵니다. 이 경우 UserManager의 SaveUser(user) 메서드에 가드 절을 추가하여 사용자가 유효한 상태에 있는지 확인하십시오.\u003c/p\u003e\n\u003ch1\u003e요약하자면...\u003c/h1\u003e\n\u003cp\u003e테스트는 시스템이 작동한다는 확신을 주어야 하며, 단순히 통제된 실험실 조건에서 각 부분이 작동하는 것만으로는 충분하지 않습니다.\u003c/p\u003e\n\u003cp\u003e🔔 이와 같은 기사를 더 읽고 싶으신가요? 여기에서 등록하세요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e시스템 내 중요한 클래스 상호작용을 모의하는 것은 클래스 간 통신 및 데이터 교환에서 발생하는 통합 문제를 알리지 못하게 할 수 있습니다. 실제 데이터베이스를 사용하는 데 조금 노력을 기울이면 장기적으로 이득을 볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e빌드 시간에 통합 문제를 발견하는 것은 운영시간(프로덕션)에 발생하는 쉽게 피할 수 있는 문제를 발견하는 것보다 훨씬 저렴합니다.\u003c/p\u003e\n\u003ch1\u003e계속 연락을 유지합시다!\u003c/h1\u003e\n\u003cp\u003e뉴스레터에 등록하여 유사한 기사에 대한 알림을 받고 YouTube 채널인 @Nicklas Millard를 확인해보세요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e린크드인에 연결하지 않는 것을 잊지 마세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness"},"buildId":"T_Nz0g9U1yttYMSEma95P","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>