<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title> 테라폼을 사용하여 쿠버네티스에서 MERN 앱을 위한 엔드투엔드 CICD 파이프라인 구축하기, GitHub Actions와 Ansible으로 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content=" 테라폼을 사용하여 쿠버네티스에서 MERN 앱을 위한 엔드투엔드 CICD 파이프라인 구축하기, GitHub Actions와 Ansible으로 | ui-station" data-gatsby-head="true"/><meta property="og:title" content=" 테라폼을 사용하여 쿠버네티스에서 MERN 앱을 위한 엔드투엔드 CICD 파이프라인 구축하기, GitHub Actions와 Ansible으로 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible" data-gatsby-head="true"/><meta name="twitter:title" content=" 테라폼을 사용하여 쿠버네티스에서 MERN 앱을 위한 엔드투엔드 CICD 파이프라인 구축하기, GitHub Actions와 Ansible으로 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-18 16:59" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_buildManifest.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx"> 테라폼을 사용하여 쿠버네티스에서 MERN 앱을 위한 엔드투엔드 CICD 파이프라인 구축하기, GitHub Actions와 Ansible으로</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt=" 테라폼을 사용하여 쿠버네티스에서 MERN 앱을 위한 엔드투엔드 CICD 파이프라인 구축하기, GitHub Actions와 Ansible으로" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 18, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>쿠버네티스에서 MERN 웹 애플리케이션을 위한 완벽한 CI/CD 파이프라인을 알아보고 테라폼을 GitHub Actions와 통합하여 인프라 프로비저닝 및 관리를 자동화합니다. AWS EC2 구성, Kubernetes (K3s) 설치 및 EC2에 풀 스택 MERN 프로젝트를 배포하는 데 Ansible을 사용합니다.</p>
<h1>🛠️사전 요구 사항</h1>
<ul>
<li>필요한 권한을 갖춘 AWS 계정</li>
<li>전체 스택 응용 프로그램(MERN)을 컨테이너화</li>
<li>HCP Terraform, GitHub 및 Docker Hub 계정</li>
<li>AWS 클라우드의 기본 지식</li>
<li>DNS 편집 권한이 있는 도메인</li>
</ul>
<p>이 기사는 조금 길어요. 그래서 마지막 단계로 따라와서 테라폼을 사용해 쿠버네티스에 MERN 앱용 엔드투엔드 CI/CD 파이프라인을 구축하는 방법을 배우시면 좋겠네요. GitHub Actions와 Ansible을 활용해요.</p>
<p>이 프로젝트는 고급 수준의 프로젝트에요. 그래서 AWS, 테라폼, 앤서블, MERN 프로젝트, GitHub Actions의 기본 개념이 명확하다고 가정할게요. 기본 수준은 말하지 않아요. 그냥 프로젝트를 통합하고 구현했어요.</p>
<p>이 기사는 세 가지 섹션으로 구성되어 있어요:</p>
<p>섹션 1: GitHub Actions를 사용해 테라폼을 활용해 AWS 인프라 배포를 자동화하기.</p>
<p>Section 2: EC2 구성, Kubernetes (K3s) 설치 및 Ansible을 사용하여 MERN 앱 배포하기.</p>
<p>Section 3: GitHub Actions를 사용한 Kubernetes (K3s)에서 MERN 앱을 위한 CI/CD 파이프라인 구성.</p>
<p>그럼, 지금 가보자, 만약 이 글에 대한 질문이 있거나 도움이 필요하면 언제든지 연락해 주세요.</p>
<h1>📘Section 1: GitHub Actions를 이용하여 Terraform을 사용하여 AWS 인프라 자동화하기</h1>
<p>우선 GitHub에서 Terraform을 사용하여 AWS 인프라를 생성하기 위해 GitHub 액션을 이용해 git 저장소(terraform)를 복제하세요.</p>
<p>단계 1: 로컬 머신에서 저장소를 복제합니다.</p>
<pre><code class="hljs language-js">git clone <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/bjnandi/terraform-ci-cd-aws.git</span>
</code></pre>
<p>복제 후에는 VS Code 편집기의 Dev Container에서 해당 저장소를 엽니다. Dev Container를 사용하면 주요 머신으로부터 환경(Terraform)을 격리할 수 있습니다.</p>
<p>단계 2: HCP Terraform Cloud 설정하기
우리가 생성할 GitHub Action은 HCP Terraform Cloud에 연결하여 구성을 계획하고 적용할 것입니다. 액션 워크플로우를 설정하기 전에, HCP Terraform Cloud에 로그인하고 조직 내에서 워크스페이스를 생성한 다음 AWS 자격 증명을 HCP Terraform 워크스페이스에 추가해야 합니다. 다음 단계를 따라주세요:</p>
<p>조직 <code>워크스페이스</code> 변수</p>
<p><img src="/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_1.png" alt="이미지"></p>
<p>단계 3: API 토큰 생성하기
HCP Terraform 사용자 API 토큰을 생성하세요. 이를 위해 HCP Terraform 사용자 설정의 토큰 페이지로 이동하세요. API 토큰 생성을 클릭한 다음 "Generate token"을 클릭하여 GitHub Actions 토큰을 설명란에 입력하세요.</p>
<p><img src="/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_2.png" alt="이미지"></p>
<p><strong>단계 4:</strong> GitHub Secrets에 GitHub 저장소에 API 토큰을 설정합니다.
자세한 내용은 GitHub Secrets에서 확인하실 수 있습니다. 이제 시크릿과 변수로 이동하여 값을 설정합니다.</p>
<p>GitHub <code>저장소 이름</code> 설정 <code>시크릿과 변수</code> 작업 <code>저장소 시크릿</code> 새 저장소 시크릿 :</p>
<p>TF_API_TOKEN: HCP Terraform 사용자 설정에서 생성된 API 토큰입니다.</p>
<p>5단계: VS Code 편집기로 돌아가서 "tf-infa-test"라는 이름의 새 브랜치를 만듭니다.</p>
<pre><code class="hljs language-js">git checkout -b <span class="hljs-string">'tf-infa-test'</span>
</code></pre>
<p>그런 다음 "env/dev" 디렉토리의 main.tf 파일을 엽니다. HCP Terraform에서 생성된 HCP Terraform 조직 및 워크스페이스 이름으로 "organization"과 "workspaces"를 설정한 다음 파일을 저장하세요.</p>
<pre><code class="hljs language-js">  cloud {
    organization = <span class="hljs-string">"YOUR-ORGANIZATION-HERE"</span>

    workspaces {
      name = <span class="hljs-string">"YOUR-WORKS-SPACE"</span>
    }
  }
</code></pre>
<p>그런 다음 ".github/workflows/" 디렉토리에서 두 개의 워크플로 파일 (terraform-plan.yml 및 terraform-plan.yml)을 엽니다.</p>
<ul>
<li>terraform-plan.yml</li>
<li>terraform-plan.yml</li>
</ul>
<p>“TF_CLOUD_ORGANIZATION” 및 “TF_WORKSPACE”를 HCP Terraform 조직 및 워크스페이스의 이름으로 업데이트하고 파일을 저장하세요.</p>
<p>6단계: 저희의 테라폼 파일 구조는 루트 작업 디렉토리가 "env/dev"인 블루프린트 모델입니다. 그래서 HCP 테라폼 클라우드에서 테라폼 작업 디렉토리에 "env/dev"를 추가했습니다.</p>
<p>이를 위해 테라폼 클라우드로 이동하십시오:</p>
<p>Organizations <code>Workspaces</code> Workspace Name <code>Setting</code> Terraform Working Directory</p>
<pre><code class="hljs language-js">env/dev
</code></pre>
<p>아래의 코드를 추가하세요.</p>
<p><img src="/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_4.png" alt="image"></p>
<p>마지막으로 "Save settings"를 클릭하세요.</p>
<p>이제 GitHub Actions를 사용하여 인프라 프로비저닝을 준비했습니다.</p>
<p><strong>단계 7: 풀 리퀘스트 생성하기</strong>
이제 VS Code 편집기로 돌아가서 데모 테스트용 코드를 약간 수정한 후, 해당 코드를 GitHub "tf-infa-test" 브랜치에 커밋하고 푸시하세요. 그런 다음 GitHub에서 이 브랜치에 대한 풀 리퀘스트를 생성하세요.</p>
<p>풀 리퀘스트를 생성한 후 GitHub 워크플로우(테라폼 플랜)를 실행하여 테라폼 플랜을 확인하세요.</p>
<p><img src="/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_5.png" alt="이미지"></p>
<p><strong>단계 8: 풀 리퀘스트 검토 및 병합</strong>
"Terraform plan"에 만족한다면, 'main' 브랜치에 '병합' 코드로 풀 리퀘스트를 닫은 다음 인프라 구축을 위해 워크플로우(테라폼 애플라이)를 실행하세요.</p>
<p><img src="/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_6.png" alt="Step 9"></p>
<p>9단계: 프로비전된 EC2 인스턴스 확인</p>
<p>모든 리소스가 생성되었습니다.</p>
<p><img src="/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_7.png" alt="Step 9"></p>
<h1>📘 섹션 2: EC2 구성, Kubernetes (K3s) 설치 및 Ansible를 사용하여 MERN 앱 배포</h1>
<p>인프라 프로비저닝이 완료되면 GitHub의 두 번째 git 저장소 (Ansible)로 이동하여 AWS EC2를 구성하고 Kubernetes (K3s)를 설치하고 Ansible를 사용하여 MERN 앱을 배포합니다.</p>
<p>단계 1: 로컬 머신에서 저장소를 복제합니다.</p>
<pre><code class="hljs language-js">git clone <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/bjnandi/ansible-k3s-nginx-lb.git</span>
</code></pre>
<p>깃 저장소를 복제한 후, VS Code의 Dev Container에서 열어보세요. Dev Container는 환경(Ansible)을 메인 머신과 격리시킵니다.</p>
<p>단계 2: SSH 키를 위해 ".ssh" 폴더에 "linux.pem" 파일을 만드세요.</p>
<pre><code class="hljs language-bash">nano ~/.ssh/linux.pem
</code></pre>
<p>여기에 "pem" 파일 코드를 붙여넣고 파일을 저장하세요.</p>
<p>Step 3: "linux.pem" 파일의 권한을 설정하세요</p>
<pre><code class="hljs language-js">chmod <span class="hljs-number">400</span> ~<span class="hljs-regexp">/.ssh/</span>linux.<span class="hljs-property">pem</span>
</code></pre>
<p>Step 4: 이제 디렉토리의 권한을 설정하세요. Dev Container는 모든 사용자에 대해 기본 권한으로 디렉토리를 마운트합니다.</p>
<pre><code class="hljs language-js">chmod <span class="hljs-number">755</span> /workspaces/ansible-k3s-nginx-lb
</code></pre>
<p>단계 5: 이제 우리의 AWS EC2 IP 주소로 IP 주소를 업데이트하세요.</p>
<ul>
<li>
<p>“hosts” 파일에서:</p>
</li>
<li>
<p>bastion (공용 IP)</p>
</li>
<li>
<p>k3s_nodes, additional_agent_nodes 및 nginx_lb (사설 IP)</p>
</li>
<li>
<p>nginx_lb(사설 IP)</p>
</li>
<li>
<p>ProxyCommand용 (공용 IP)</p>
</li>
</ul>
<pre><code class="hljs language-js">[bastion]
bastion ansible_host=<span class="hljs-number">34.195</span><span class="hljs-number">.33</span><span class="hljs-number">.137</span>
[<span class="hljs-attr">bastion</span>:vars]
ansible_user=ubuntu
ansible_ssh_private_key_file=~<span class="hljs-regexp">/.ssh/</span>linux.<span class="hljs-property">pem</span>

[k3s_nodes]
master ansible_host=<span class="hljs-number">10.0</span><span class="hljs-number">.1</span><span class="hljs-number">.222</span>
[<span class="hljs-attr">k3s_nodes</span>:vars]
ansible_user=ubuntu
ansible_ssh_private_key_file=~<span class="hljs-regexp">/.ssh/</span>linux.<span class="hljs-property">pem</span>
ansible_ssh_common_args=<span class="hljs-string">'-o ProxyCommand="ssh -o StrictHostKeyChecking=no -i ~/.ssh/linux.pem -W %h:%p -q ubuntu@34.195.33.137"'</span>

[additional_agent_nodes]
worker1 ansible_host=<span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.244</span>
worker2 ansible_host=<span class="hljs-number">10.0</span><span class="hljs-number">.1</span><span class="hljs-number">.236</span>
[<span class="hljs-attr">additional_agent_nodes</span>:vars]
ansible_user=ubuntu
ansible_ssh_private_key_file=~<span class="hljs-regexp">/.ssh/</span>linux.<span class="hljs-property">pem</span>
ansible_ssh_common_args=<span class="hljs-string">'-o ProxyCommand=" ssh -o StrictHostKeyChecking=no -i ~/.ssh/linux.pem -W %h:%p -q ubuntu@34.195.33.137"'</span>

[nginx_lb]
nginx_lb ansible_host=<span class="hljs-number">10.0</span><span class="hljs-number">.5</span><span class="hljs-number">.187</span>
[<span class="hljs-attr">nginx_lb</span>:vars]
ansible_user=ubuntu
ansible_ssh_private_key_file=~<span class="hljs-regexp">/.ssh/</span>linux.<span class="hljs-property">pem</span>
ansible_ssh_common_args=<span class="hljs-string">'-o ProxyCommand=" ssh -o StrictHostKeyChecking=no -i ~/.ssh/linux.pem -W %h:%p -q ubuntu@34.195.33.137"'</span>
</code></pre>
<ol start="2">
<li>"nginx.conf" 파일에서:</li>
</ol>
<ul>
<li>업스트림 클라이언트 및 API 서버</li>
</ul>
<pre><code class="hljs language-js">   upstream client {
        server <span class="hljs-number">10.0</span><span class="hljs-number">.1</span><span class="hljs-number">.222</span>:<span class="hljs-number">30001</span>; # 귀하의 <span class="hljs-title class_">EC2</span> 인스턴스 사설 <span class="hljs-variable constant_">IP</span>로 교체하세요
        server <span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.244</span>:<span class="hljs-number">30001</span>; # 귀하의 <span class="hljs-title class_">EC2</span> 인스턴스 사설 <span class="hljs-variable constant_">IP</span>로 교체하세요
        server <span class="hljs-number">10.0</span><span class="hljs-number">.1</span><span class="hljs-number">.236</span>:<span class="hljs-number">30001</span>; # 귀하의 <span class="hljs-title class_">EC2</span> 인스턴스 사설 <span class="hljs-variable constant_">IP</span>로 교체하세요
    }

    upstream apiserver {
        server <span class="hljs-number">10.0</span><span class="hljs-number">.1</span><span class="hljs-number">.222</span>:<span class="hljs-number">30005</span>;  # 귀하의 <span class="hljs-title class_">EC2</span> 인스턴스 사설 <span class="hljs-variable constant_">IP</span>로 교체하세요
        server <span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.244</span>:<span class="hljs-number">30005</span>; # 귀하의 <span class="hljs-title class_">EC2</span> 인스턴스 사설 <span class="hljs-variable constant_">IP</span>로 교체하세요
        server <span class="hljs-number">10.0</span><span class="hljs-number">.1</span><span class="hljs-number">.236</span>:<span class="hljs-number">30005</span>; # 귀하의 <span class="hljs-title class_">EC2</span> 인스턴스 사설 <span class="hljs-variable constant_">IP</span>로 교체하세요
    }
</code></pre>
<ol start="3">
<li>이제 "project_vars" 파일에서:</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-attr">master_ip</span>: <span class="hljs-number">10.0</span><span class="hljs-number">.1</span><span class="hljs-number">.222</span>
</code></pre>
<p>단계 6: Ansible 구성이 실행 준비 완료되었습니다</p>
<ul>
<li>Makefile을 사용하여 모든 구성을 한 주석에서 실행하려면:</li>
</ul>
<pre><code class="hljs language-js">make run_ansible
</code></pre>
<ul>
<li>하나씩 실행하려면:</li>
</ul>
<pre><code class="hljs language-js"> ansible-playbook -i hosts k3s_install.<span class="hljs-property">yaml</span>

 ansible-playbook -i hosts k3s_mern_deploy.<span class="hljs-property">yaml</span>

 ansible-playbook -i hosts config_nginx_lb.<span class="hljs-property">yaml</span>

 ansible-playbook -i hosts config_bastion.<span class="hljs-property">yaml</span>
</code></pre>
<p>이제, 모든 EC2를 구성하고 Kubernetes(k3s)를 설치한 다음 Kubernetes(k3s)에 MERN 앱을 배포합니다.</p>
<p>단계 7: 이제 도메인 DNS 설정으로 이동하여 "A" 레코드를 업데이트합니다. 저희 도메인은 Squarespace에서 제공합니다. 그래서, Squarespace DNS 설정에서 이 도메인 DNS를 업데이트했습니다.</p>
<p>우리 앱에 대해 EC2 인스턴스(개발 로드밸런서)의 공개 IP로 두 개의 사용자 정의 "A" 레코드를 추가했어요.</p>
<p><img src="/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_8.png" alt="이미지"></p>
<p>단계 8: 이제 도메인을 사용하여 앱을 보여줄 차례에요.</p>
<p>이 도메인(<a href="http://bjtechlife.com)%EC%97%90%EC%84%9C" rel="nofollow" target="_blank">http://bjtechlife.com)에서</a> 우리 앱을 봤어요.</p>
<p>만약 Docker Hub repository 이미지가 있거나 수동으로 이미지를 빌드하여 Docker Hub에 푸시했다면, 먼저 출력에서 앱 UI를 확인할 수 있습니다. 그렇지 않은 경우 (섹션 3)를 완료한 다음 출력에서 앱 UI를 확인할 수 있습니다.</p>
<p><img src="/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_9.png" alt=""></p>
<h1>📘세션 3: Kubernetes (k3s)에서 MERN 앱을 위한 CI/CD 파이프라인 구축하기 (GitHub Actions 사용)</h1>
<p>EC2 구성, (k3s) 설치 및 앱 배포를 완료하고, AWS EC2 인스턴스에서 GitHub Actions를 사용하여 Kubernetes (k3s)에서 MERN 앱을 위한 CI/CD 파이프라인을 만들기 위해 GitHub의 세 번째 git 저장소(MERN 프로젝트)로 이동하세요.</p>
<p>스텝 1: 로컬 머신에서 저장소를 복제하세요</p>
<pre><code class="hljs language-js">git clone <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/bjnandi/ci-cd-pipeline-MERN-k3s.git</span>
</code></pre>
<p>복제한 후, VS Code 에디터에서 열어주세요.</p>
<p>".github/workflows/" 디렉토리에 두 개의 워크플로우 파일 (docker-ci 및 k3s-cd)이 있습니다.</p>
<ul>
<li>docker-ci.yml</li>
<li>k3s-cd.yml</li>
</ul>
<p>첫 번째 워크플로우 "docker-ci.yml" 파일은 이미지를 빌드하여 Docker Hub에 푸시하고, 다른 워크플로우 "k3s-cd.yml" 파일은 Kubernetes(k3s)에서 이미지를 업데이트합니다.</p>
<p>단계 2: 이제 GitHub Secrets를 사용하여 시크릿을 채워넣어야합니다. GitHub 리포지토리에 추가할 수 있습니다. 자세한 정보는 GitHub Secrets에서 확인할 수 있습니다. 이제 시크릿과 변수로 이동하여 값을 설정합니다.</p>
<p>Github <code>Repo Name</code> 설정 <code>Secrets and variables</code> 작업 <code>Repository Secrets</code> 새 리포지토리 시크릿 :</p>
<p>EC2_HOST: 배스천 호스트 EC2 인스턴스의 공개 IP 주소는 대략 이와 같을 것입니다. "34.195.33.137".</p>
<p>MASTER_NODE: k8s-instance-master EC2 인스턴스의 사설 IP 주소는 대략 이와 같을 것입니다. "10.0.1.222".</p>
<p>EC2_USERNAME: EC2 인스턴스의 사용자 이름은 일반적으로 "ubuntu"입니다.</p>
<p>SSH_PRIVATE_KEY: 인스턴스에 로그인하는 데 사용할 “.pem” 파일입니다.</p>
<p>DOCKER_USERNAME: 이것은 도커 허브 계정 프로필로 이동하면 확인할 수 있는 도커 허브의 "사용자 이름"입니다. 도커 이미지를 도커 허브에 푸시하는 데 사용됩니다.</p>
<p>DOCKER_PASSWORD: 이것은 도커 허브 계정의 "비밀번호"입니다.</p>
<p><img src="/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_10.png" alt="이미지"></p>
<p>단계 3: "VS Code Editor"로 돌아가서 데모 테스트를 위해 코드나 UI 파일을 편집하거나 작은 변경 사항을 수행한 후, 현재 파일에서 앱의 CI/CD 테스트를 위해 GitHub의 "main" 브랜치에 코드를 커밋하고 푸시하세요.</p>
<p>고객님, <code>src</code> 폴더의 <code>components</code> 폴더 안에 있는 <code>Navbar.js</code> 파일을 수정해야 합니다.</p>
<p>"CRUD" 텍스트를 "CRUD test"로 변경한 다음, 변경사항을 커밋하고 메인 브랜치에 푸시하세요.</p>
<p>빌드, 푸시, 그리고 배포하는 데 시간이 걸릴 수 있습니다. 나중에 앱 UI(<a href="http://bjtechlife.com)%EC%97%90" rel="nofollow" target="_blank">http://bjtechlife.com)에</a> 변경 사항이 표시되고 데이터를 삽입하는 것과 같이 제대로 작동하는 것을 확인할 수 있습니다.</p>
<p>와우! 😎🚀 여기에는 우리가 코드에서 변경한 "CRUD 테스트"가 나와 있네요.</p>
<p>저희 앱 UI에서 서로 다른 변경을 계속해서 적용하면 변경 사항을 볼 수 있어요.</p>
<p>결과적으로, GitHub Actions를 사용하여 Kubernetes(k3s)에서 MERN 앱을 위한 엔드 투 엔드 CI/CD 파이프라인을 완료했어요.</p>
<p>🌟축하합니다!!🌟, 저희가 GitHub Actions 및 Ansible을 사용하여 Kubernetes에서 Terraform을 활용하여 MERN 앱을 위한 End-to-End CI/CD 파이프라인을 성공적으로 구축했습니다.</p>
<p>✨이제 AWS에서 리소스를 제거할 시간입니다. 그러므로, Terraform 저장소 VS Code 편집기 터미널(/workspaces/terraform-ci-cd-aws/env/dev)로 돌아가서 다음을 실행해주세요:</p>
<pre><code class="hljs language-js">terraform login
terraform init
terraform destroy -auto-approve
</code></pre>
<p>이렇게 함으로써 저와 함께 오래 집중해 주셔서 감사합니다. 앞으로 또 다른 주제로 포스팅하겠습니다.</p>
<h1>K8s #쿠버네티스 #k3s #테라폼 #앤서블 #MERN #풀스택 #도커 #웹애플리케이션 #컨테이너화 #데브옵스 #컨테이너화된앱 #EC2 #MERN스택 #도커화된웹앱 #MERN앱 #도커컨테이너 #CI/CD 파이프라인 #GitHub 액션 #제로다운타임 #CI/CD #자동화 #배포 #기술팁</h1>
<p>만일 쿠버네티스에서 테라폼을 사용하여 GitHub 액션 및 앤서블을 이용해 MERN 앱을 위한 엔드 투 엔드 CI/CD 파이프라인을 구축하는 데 문제가 발생한다면 언제든지 저에게 연락해 주세요. 최선을 다해 도와드리겠습니다. 감사합니다.</p>
<h1>평문으로 🚀</h1>
<p>In Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:</p>
<ul>
<li>작가를 응원하고 팔로우를 눌러주세요! 👏</li>
<li>팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터</li>
<li>다른 플랫폼도 방문해보세요: Stackademic | CoFeed | Venture | Cubed</li>
<li>알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요</li>
<li>더 많은 콘텐츠는 PlainEnglish.io에서 확인하세요</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":" 테라폼을 사용하여 쿠버네티스에서 MERN 앱을 위한 엔드투엔드 CICD 파이프라인 구축하기, GitHub Actions와 Ansible으로","description":"","date":"2024-05-18 16:59","slug":"2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible","content":"\n\n\u003cimg src=\"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_0.png\" /\u003e\n\n쿠버네티스에서 MERN 웹 애플리케이션을 위한 완벽한 CI/CD 파이프라인을 알아보고 테라폼을 GitHub Actions와 통합하여 인프라 프로비저닝 및 관리를 자동화합니다. AWS EC2 구성, Kubernetes (K3s) 설치 및 EC2에 풀 스택 MERN 프로젝트를 배포하는 데 Ansible을 사용합니다.\n\n# 🛠️사전 요구 사항\n\n- 필요한 권한을 갖춘 AWS 계정\n- 전체 스택 응용 프로그램(MERN)을 컨테이너화\n- HCP Terraform, GitHub 및 Docker Hub 계정\n- AWS 클라우드의 기본 지식\n- DNS 편집 권한이 있는 도메인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사는 조금 길어요. 그래서 마지막 단계로 따라와서 테라폼을 사용해 쿠버네티스에 MERN 앱용 엔드투엔드 CI/CD 파이프라인을 구축하는 방법을 배우시면 좋겠네요. GitHub Actions와 Ansible을 활용해요.\n\n이 프로젝트는 고급 수준의 프로젝트에요. 그래서 AWS, 테라폼, 앤서블, MERN 프로젝트, GitHub Actions의 기본 개념이 명확하다고 가정할게요. 기본 수준은 말하지 않아요. 그냥 프로젝트를 통합하고 구현했어요.\n\n이 기사는 세 가지 섹션으로 구성되어 있어요:\n\n섹션 1: GitHub Actions를 사용해 테라폼을 활용해 AWS 인프라 배포를 자동화하기.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSection 2: EC2 구성, Kubernetes (K3s) 설치 및 Ansible을 사용하여 MERN 앱 배포하기.\n\nSection 3: GitHub Actions를 사용한 Kubernetes (K3s)에서 MERN 앱을 위한 CI/CD 파이프라인 구성.\n\n그럼, 지금 가보자, 만약 이 글에 대한 질문이 있거나 도움이 필요하면 언제든지 연락해 주세요.\n\n# 📘Section 1: GitHub Actions를 이용하여 Terraform을 사용하여 AWS 인프라 자동화하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우선 GitHub에서 Terraform을 사용하여 AWS 인프라를 생성하기 위해 GitHub 액션을 이용해 git 저장소(terraform)를 복제하세요.\n\n단계 1: 로컬 머신에서 저장소를 복제합니다.\n\n```js\ngit clone https://github.com/bjnandi/terraform-ci-cd-aws.git\n```\n\n복제 후에는 VS Code 편집기의 Dev Container에서 해당 저장소를 엽니다. Dev Container를 사용하면 주요 머신으로부터 환경(Terraform)을 격리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단계 2: HCP Terraform Cloud 설정하기\n우리가 생성할 GitHub Action은 HCP Terraform Cloud에 연결하여 구성을 계획하고 적용할 것입니다. 액션 워크플로우를 설정하기 전에, HCP Terraform Cloud에 로그인하고 조직 내에서 워크스페이스를 생성한 다음 AWS 자격 증명을 HCP Terraform 워크스페이스에 추가해야 합니다. 다음 단계를 따라주세요:\n\n조직 ` 워크스페이스 ` 변수\n\n![이미지](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_1.png)\n\n단계 3: API 토큰 생성하기\nHCP Terraform 사용자 API 토큰을 생성하세요. 이를 위해 HCP Terraform 사용자 설정의 토큰 페이지로 이동하세요. API 토큰 생성을 클릭한 다음 \"Generate token\"을 클릭하여 GitHub Actions 토큰을 설명란에 입력하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_2.png)\n\n**단계 4:** GitHub Secrets에 GitHub 저장소에 API 토큰을 설정합니다.\n자세한 내용은 GitHub Secrets에서 확인하실 수 있습니다. 이제 시크릿과 변수로 이동하여 값을 설정합니다.\n\nGitHub ` 저장소 이름 ` 설정 ` 시크릿과 변수 ` 작업 ` 저장소 시크릿 ` 새 저장소 시크릿 :\n\nTF_API_TOKEN: HCP Terraform 사용자 설정에서 생성된 API 토큰입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_3.png\" /\u003e\n\n5단계: VS Code 편집기로 돌아가서 \"tf-infa-test\"라는 이름의 새 브랜치를 만듭니다.\n\n```js\ngit checkout -b 'tf-infa-test'\n```\n\n그런 다음 \"env/dev\" 디렉토리의 main.tf 파일을 엽니다. HCP Terraform에서 생성된 HCP Terraform 조직 및 워크스페이스 이름으로 \"organization\"과 \"workspaces\"를 설정한 다음 파일을 저장하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\n  cloud {\n    organization = \"YOUR-ORGANIZATION-HERE\"\n\n    workspaces {\n      name = \"YOUR-WORKS-SPACE\"\n    }\n  }\n```\n\n그런 다음 \".github/workflows/\" 디렉토리에서 두 개의 워크플로 파일 (terraform-plan.yml 및 terraform-plan.yml)을 엽니다.\n\n- terraform-plan.yml\n- terraform-plan.yml\n\n“TF_CLOUD_ORGANIZATION” 및 “TF_WORKSPACE”를 HCP Terraform 조직 및 워크스페이스의 이름으로 업데이트하고 파일을 저장하세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n6단계: 저희의 테라폼 파일 구조는 루트 작업 디렉토리가 \"env/dev\"인 블루프린트 모델입니다. 그래서 HCP 테라폼 클라우드에서 테라폼 작업 디렉토리에 \"env/dev\"를 추가했습니다.\n\n이를 위해 테라폼 클라우드로 이동하십시오:\n\nOrganizations ` Workspaces ` Workspace Name ` Setting ` Terraform Working Directory\n\n```js\nenv/dev\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래의 코드를 추가하세요.\n\n\n![image](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_4.png)\n\n\n마지막으로 \"Save settings\"를 클릭하세요.\n\n이제 GitHub Actions를 사용하여 인프라 프로비저닝을 준비했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**단계 7: 풀 리퀘스트 생성하기**\n이제 VS Code 편집기로 돌아가서 데모 테스트용 코드를 약간 수정한 후, 해당 코드를 GitHub \"tf-infa-test\" 브랜치에 커밋하고 푸시하세요. 그런 다음 GitHub에서 이 브랜치에 대한 풀 리퀘스트를 생성하세요.\n\n풀 리퀘스트를 생성한 후 GitHub 워크플로우(테라폼 플랜)를 실행하여 테라폼 플랜을 확인하세요.\n\n![이미지](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_5.png)\n\n**단계 8: 풀 리퀘스트 검토 및 병합**\n\"Terraform plan\"에 만족한다면, 'main' 브랜치에 '병합' 코드로 풀 리퀘스트를 닫은 다음 인프라 구축을 위해 워크플로우(테라폼 애플라이)를 실행하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Step 9](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_6.png)\n\n9단계: 프로비전된 EC2 인스턴스 확인\n\n모든 리소스가 생성되었습니다.\n\n![Step 9](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 📘 섹션 2: EC2 구성, Kubernetes (K3s) 설치 및 Ansible를 사용하여 MERN 앱 배포\n\n인프라 프로비저닝이 완료되면 GitHub의 두 번째 git 저장소 (Ansible)로 이동하여 AWS EC2를 구성하고 Kubernetes (K3s)를 설치하고 Ansible를 사용하여 MERN 앱을 배포합니다.\n\n단계 1: 로컬 머신에서 저장소를 복제합니다.\n\n```js\ngit clone https://github.com/bjnandi/ansible-k3s-nginx-lb.git\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n깃 저장소를 복제한 후, VS Code의 Dev Container에서 열어보세요. Dev Container는 환경(Ansible)을 메인 머신과 격리시킵니다.\n\n단계 2: SSH 키를 위해 \".ssh\" 폴더에 \"linux.pem\" 파일을 만드세요.\n\n```bash\nnano ~/.ssh/linux.pem\n```\n\n여기에 \"pem\" 파일 코드를 붙여넣고 파일을 저장하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nStep 3: \"linux.pem\" 파일의 권한을 설정하세요\n\n```js\nchmod 400 ~/.ssh/linux.pem\n```\n\nStep 4: 이제 디렉토리의 권한을 설정하세요. Dev Container는 모든 사용자에 대해 기본 권한으로 디렉토리를 마운트합니다.\n\n```js\nchmod 755 /workspaces/ansible-k3s-nginx-lb\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단계 5: 이제 우리의 AWS EC2 IP 주소로 IP 주소를 업데이트하세요.\n\n- “hosts” 파일에서:\n\n- bastion (공용 IP)\n- k3s_nodes, additional_agent_nodes 및 nginx_lb (사설 IP)\n- nginx_lb(사설 IP)\n- ProxyCommand용 (공용 IP)\n\n```js\n[bastion]\nbastion ansible_host=34.195.33.137\n[bastion:vars]\nansible_user=ubuntu\nansible_ssh_private_key_file=~/.ssh/linux.pem\n\n[k3s_nodes]\nmaster ansible_host=10.0.1.222\n[k3s_nodes:vars]\nansible_user=ubuntu\nansible_ssh_private_key_file=~/.ssh/linux.pem\nansible_ssh_common_args='-o ProxyCommand=\"ssh -o StrictHostKeyChecking=no -i ~/.ssh/linux.pem -W %h:%p -q ubuntu@34.195.33.137\"'\n\n[additional_agent_nodes]\nworker1 ansible_host=10.0.2.244\nworker2 ansible_host=10.0.1.236\n[additional_agent_nodes:vars]\nansible_user=ubuntu\nansible_ssh_private_key_file=~/.ssh/linux.pem\nansible_ssh_common_args='-o ProxyCommand=\" ssh -o StrictHostKeyChecking=no -i ~/.ssh/linux.pem -W %h:%p -q ubuntu@34.195.33.137\"'\n\n[nginx_lb]\nnginx_lb ansible_host=10.0.5.187\n[nginx_lb:vars]\nansible_user=ubuntu\nansible_ssh_private_key_file=~/.ssh/linux.pem\nansible_ssh_common_args='-o ProxyCommand=\" ssh -o StrictHostKeyChecking=no -i ~/.ssh/linux.pem -W %h:%p -q ubuntu@34.195.33.137\"'\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. \"nginx.conf\" 파일에서:\n\n- 업스트림 클라이언트 및 API 서버\n\n```js\n   upstream client {\n        server 10.0.1.222:30001; # 귀하의 EC2 인스턴스 사설 IP로 교체하세요\n        server 10.0.2.244:30001; # 귀하의 EC2 인스턴스 사설 IP로 교체하세요\n        server 10.0.1.236:30001; # 귀하의 EC2 인스턴스 사설 IP로 교체하세요\n    }\n\n    upstream apiserver {\n        server 10.0.1.222:30005;  # 귀하의 EC2 인스턴스 사설 IP로 교체하세요\n        server 10.0.2.244:30005; # 귀하의 EC2 인스턴스 사설 IP로 교체하세요\n        server 10.0.1.236:30005; # 귀하의 EC2 인스턴스 사설 IP로 교체하세요\n    }\n```\n\n3. 이제 \"project_vars\" 파일에서:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nmaster_ip: 10.0.1.222\n```\n\n단계 6: Ansible 구성이 실행 준비 완료되었습니다\n\n- Makefile을 사용하여 모든 구성을 한 주석에서 실행하려면:\n\n```js\nmake run_ansible\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 하나씩 실행하려면:\n\n```js\n ansible-playbook -i hosts k3s_install.yaml\n\n ansible-playbook -i hosts k3s_mern_deploy.yaml\n\n ansible-playbook -i hosts config_nginx_lb.yaml\n\n ansible-playbook -i hosts config_bastion.yaml\n```\n\n이제, 모든 EC2를 구성하고 Kubernetes(k3s)를 설치한 다음 Kubernetes(k3s)에 MERN 앱을 배포합니다.\n\n단계 7: 이제 도메인 DNS 설정으로 이동하여 \"A\" 레코드를 업데이트합니다. 저희 도메인은 Squarespace에서 제공합니다. 그래서, Squarespace DNS 설정에서 이 도메인 DNS를 업데이트했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 앱에 대해 EC2 인스턴스(개발 로드밸런서)의 공개 IP로 두 개의 사용자 정의 \"A\" 레코드를 추가했어요.\n\n![이미지](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_8.png)\n\n단계 8: 이제 도메인을 사용하여 앱을 보여줄 차례에요.\n\n이 도메인(http://bjtechlife.com)에서 우리 앱을 봤어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 Docker Hub repository 이미지가 있거나 수동으로 이미지를 빌드하여 Docker Hub에 푸시했다면, 먼저 출력에서 앱 UI를 확인할 수 있습니다. 그렇지 않은 경우 (섹션 3)를 완료한 다음 출력에서 앱 UI를 확인할 수 있습니다.\n\n\n![](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_9.png)\n\n\n# 📘세션 3: Kubernetes (k3s)에서 MERN 앱을 위한 CI/CD 파이프라인 구축하기 (GitHub Actions 사용)\n\nEC2 구성, (k3s) 설치 및 앱 배포를 완료하고, AWS EC2 인스턴스에서 GitHub Actions를 사용하여 Kubernetes (k3s)에서 MERN 앱을 위한 CI/CD 파이프라인을 만들기 위해 GitHub의 세 번째 git 저장소(MERN 프로젝트)로 이동하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스텝 1: 로컬 머신에서 저장소를 복제하세요\n\n```js\ngit clone https://github.com/bjnandi/ci-cd-pipeline-MERN-k3s.git\n```\n\n복제한 후, VS Code 에디터에서 열어주세요.\n\n\".github/workflows/\" 디렉토리에 두 개의 워크플로우 파일 (docker-ci 및 k3s-cd)이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- docker-ci.yml\n- k3s-cd.yml\n\n첫 번째 워크플로우 \"docker-ci.yml\" 파일은 이미지를 빌드하여 Docker Hub에 푸시하고, 다른 워크플로우 \"k3s-cd.yml\" 파일은 Kubernetes(k3s)에서 이미지를 업데이트합니다.\n\n단계 2: 이제 GitHub Secrets를 사용하여 시크릿을 채워넣어야합니다. GitHub 리포지토리에 추가할 수 있습니다. 자세한 정보는 GitHub Secrets에서 확인할 수 있습니다. 이제 시크릿과 변수로 이동하여 값을 설정합니다.\n\nGithub `Repo Name` 설정 `Secrets and variables` 작업 `Repository Secrets` 새 리포지토리 시크릿 :\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nEC2_HOST: 배스천 호스트 EC2 인스턴스의 공개 IP 주소는 대략 이와 같을 것입니다. \"34.195.33.137\".\n\nMASTER_NODE: k8s-instance-master EC2 인스턴스의 사설 IP 주소는 대략 이와 같을 것입니다. \"10.0.1.222\".\n\nEC2_USERNAME: EC2 인스턴스의 사용자 이름은 일반적으로 \"ubuntu\"입니다.\n\nSSH_PRIVATE_KEY: 인스턴스에 로그인하는 데 사용할 “.pem” 파일입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDOCKER_USERNAME: 이것은 도커 허브 계정 프로필로 이동하면 확인할 수 있는 도커 허브의 \"사용자 이름\"입니다. 도커 이미지를 도커 허브에 푸시하는 데 사용됩니다.\n\nDOCKER_PASSWORD: 이것은 도커 허브 계정의 \"비밀번호\"입니다.\n\n![이미지](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_10.png)\n\n단계 3: \"VS Code Editor\"로 돌아가서 데모 테스트를 위해 코드나 UI 파일을 편집하거나 작은 변경 사항을 수행한 후, 현재 파일에서 앱의 CI/CD 테스트를 위해 GitHub의 \"main\" 브랜치에 코드를 커밋하고 푸시하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n고객님, `src` 폴더의 `components` 폴더 안에 있는 `Navbar.js` 파일을 수정해야 합니다.\n\n\"CRUD\" 텍스트를 \"CRUD test\"로 변경한 다음, 변경사항을 커밋하고 메인 브랜치에 푸시하세요.\n\n\n\u003cimg src=\"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_11.png\" /\u003e\n\n\n빌드, 푸시, 그리고 배포하는 데 시간이 걸릴 수 있습니다. 나중에 앱 UI(http://bjtechlife.com)에 변경 사항이 표시되고 데이터를 삽입하는 것과 같이 제대로 작동하는 것을 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_12.png\" /\u003e\n\n와우! 😎🚀 여기에는 우리가 코드에서 변경한 \"CRUD 테스트\"가 나와 있네요.\n\n저희 앱 UI에서 서로 다른 변경을 계속해서 적용하면 변경 사항을 볼 수 있어요.\n\n결과적으로, GitHub Actions를 사용하여 Kubernetes(k3s)에서 MERN 앱을 위한 엔드 투 엔드 CI/CD 파이프라인을 완료했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n🌟축하합니다!!🌟, 저희가 GitHub Actions 및 Ansible을 사용하여 Kubernetes에서 Terraform을 활용하여 MERN 앱을 위한 End-to-End CI/CD 파이프라인을 성공적으로 구축했습니다.\n\n✨이제 AWS에서 리소스를 제거할 시간입니다. 그러므로, Terraform 저장소 VS Code 편집기 터미널(/workspaces/terraform-ci-cd-aws/env/dev)로 돌아가서 다음을 실행해주세요:\n\n```js\nterraform login\nterraform init\nterraform destroy -auto-approve\n```\n\n이렇게 함으로써 저와 함께 오래 집중해 주셔서 감사합니다. 앞으로 또 다른 주제로 포스팅하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# K8s #쿠버네티스 #k3s #테라폼 #앤서블 #MERN #풀스택 #도커 #웹애플리케이션 #컨테이너화 #데브옵스 #컨테이너화된앱 #EC2 #MERN스택 #도커화된웹앱 #MERN앱 #도커컨테이너 #CI/CD 파이프라인 #GitHub 액션 #제로다운타임 #CI/CD #자동화 #배포 #기술팁\n\n만일 쿠버네티스에서 테라폼을 사용하여 GitHub 액션 및 앤서블을 이용해 MERN 앱을 위한 엔드 투 엔드 CI/CD 파이프라인을 구축하는 데 문제가 발생한다면 언제든지 저에게 연락해 주세요. 최선을 다해 도와드리겠습니다. 감사합니다.\n\n# 평문으로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 작가를 응원하고 팔로우를 눌러주세요! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼도 방문해보세요: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- 더 많은 콘텐츠는 PlainEnglish.io에서 확인하세요","ogImage":{"url":"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_0.png"},"coverImage":"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_0.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e쿠버네티스에서 MERN 웹 애플리케이션을 위한 완벽한 CI/CD 파이프라인을 알아보고 테라폼을 GitHub Actions와 통합하여 인프라 프로비저닝 및 관리를 자동화합니다. AWS EC2 구성, Kubernetes (K3s) 설치 및 EC2에 풀 스택 MERN 프로젝트를 배포하는 데 Ansible을 사용합니다.\u003c/p\u003e\n\u003ch1\u003e🛠️사전 요구 사항\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e필요한 권한을 갖춘 AWS 계정\u003c/li\u003e\n\u003cli\u003e전체 스택 응용 프로그램(MERN)을 컨테이너화\u003c/li\u003e\n\u003cli\u003eHCP Terraform, GitHub 및 Docker Hub 계정\u003c/li\u003e\n\u003cli\u003eAWS 클라우드의 기본 지식\u003c/li\u003e\n\u003cli\u003eDNS 편집 권한이 있는 도메인\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 기사는 조금 길어요. 그래서 마지막 단계로 따라와서 테라폼을 사용해 쿠버네티스에 MERN 앱용 엔드투엔드 CI/CD 파이프라인을 구축하는 방법을 배우시면 좋겠네요. GitHub Actions와 Ansible을 활용해요.\u003c/p\u003e\n\u003cp\u003e이 프로젝트는 고급 수준의 프로젝트에요. 그래서 AWS, 테라폼, 앤서블, MERN 프로젝트, GitHub Actions의 기본 개념이 명확하다고 가정할게요. 기본 수준은 말하지 않아요. 그냥 프로젝트를 통합하고 구현했어요.\u003c/p\u003e\n\u003cp\u003e이 기사는 세 가지 섹션으로 구성되어 있어요:\u003c/p\u003e\n\u003cp\u003e섹션 1: GitHub Actions를 사용해 테라폼을 활용해 AWS 인프라 배포를 자동화하기.\u003c/p\u003e\n\u003cp\u003eSection 2: EC2 구성, Kubernetes (K3s) 설치 및 Ansible을 사용하여 MERN 앱 배포하기.\u003c/p\u003e\n\u003cp\u003eSection 3: GitHub Actions를 사용한 Kubernetes (K3s)에서 MERN 앱을 위한 CI/CD 파이프라인 구성.\u003c/p\u003e\n\u003cp\u003e그럼, 지금 가보자, 만약 이 글에 대한 질문이 있거나 도움이 필요하면 언제든지 연락해 주세요.\u003c/p\u003e\n\u003ch1\u003e📘Section 1: GitHub Actions를 이용하여 Terraform을 사용하여 AWS 인프라 자동화하기\u003c/h1\u003e\n\u003cp\u003e우선 GitHub에서 Terraform을 사용하여 AWS 인프라를 생성하기 위해 GitHub 액션을 이용해 git 저장소(terraform)를 복제하세요.\u003c/p\u003e\n\u003cp\u003e단계 1: 로컬 머신에서 저장소를 복제합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003egit clone \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//github.com/bjnandi/terraform-ci-cd-aws.git\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e복제 후에는 VS Code 편집기의 Dev Container에서 해당 저장소를 엽니다. Dev Container를 사용하면 주요 머신으로부터 환경(Terraform)을 격리할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e단계 2: HCP Terraform Cloud 설정하기\n우리가 생성할 GitHub Action은 HCP Terraform Cloud에 연결하여 구성을 계획하고 적용할 것입니다. 액션 워크플로우를 설정하기 전에, HCP Terraform Cloud에 로그인하고 조직 내에서 워크스페이스를 생성한 다음 AWS 자격 증명을 HCP Terraform 워크스페이스에 추가해야 합니다. 다음 단계를 따라주세요:\u003c/p\u003e\n\u003cp\u003e조직 \u003ccode\u003e워크스페이스\u003c/code\u003e 변수\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e단계 3: API 토큰 생성하기\nHCP Terraform 사용자 API 토큰을 생성하세요. 이를 위해 HCP Terraform 사용자 설정의 토큰 페이지로 이동하세요. API 토큰 생성을 클릭한 다음 \"Generate token\"을 클릭하여 GitHub Actions 토큰을 설명란에 입력하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e단계 4:\u003c/strong\u003e GitHub Secrets에 GitHub 저장소에 API 토큰을 설정합니다.\n자세한 내용은 GitHub Secrets에서 확인하실 수 있습니다. 이제 시크릿과 변수로 이동하여 값을 설정합니다.\u003c/p\u003e\n\u003cp\u003eGitHub \u003ccode\u003e저장소 이름\u003c/code\u003e 설정 \u003ccode\u003e시크릿과 변수\u003c/code\u003e 작업 \u003ccode\u003e저장소 시크릿\u003c/code\u003e 새 저장소 시크릿 :\u003c/p\u003e\n\u003cp\u003eTF_API_TOKEN: HCP Terraform 사용자 설정에서 생성된 API 토큰입니다.\u003c/p\u003e\n\u003cp\u003e5단계: VS Code 편집기로 돌아가서 \"tf-infa-test\"라는 이름의 새 브랜치를 만듭니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003egit checkout -b \u003cspan class=\"hljs-string\"\u003e'tf-infa-test'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 \"env/dev\" 디렉토리의 main.tf 파일을 엽니다. HCP Terraform에서 생성된 HCP Terraform 조직 및 워크스페이스 이름으로 \"organization\"과 \"workspaces\"를 설정한 다음 파일을 저장하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  cloud {\n    organization = \u003cspan class=\"hljs-string\"\u003e\"YOUR-ORGANIZATION-HERE\"\u003c/span\u003e\n\n    workspaces {\n      name = \u003cspan class=\"hljs-string\"\u003e\"YOUR-WORKS-SPACE\"\u003c/span\u003e\n    }\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 \".github/workflows/\" 디렉토리에서 두 개의 워크플로 파일 (terraform-plan.yml 및 terraform-plan.yml)을 엽니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eterraform-plan.yml\u003c/li\u003e\n\u003cli\u003eterraform-plan.yml\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e“TF_CLOUD_ORGANIZATION” 및 “TF_WORKSPACE”를 HCP Terraform 조직 및 워크스페이스의 이름으로 업데이트하고 파일을 저장하세요.\u003c/p\u003e\n\u003cp\u003e6단계: 저희의 테라폼 파일 구조는 루트 작업 디렉토리가 \"env/dev\"인 블루프린트 모델입니다. 그래서 HCP 테라폼 클라우드에서 테라폼 작업 디렉토리에 \"env/dev\"를 추가했습니다.\u003c/p\u003e\n\u003cp\u003e이를 위해 테라폼 클라우드로 이동하십시오:\u003c/p\u003e\n\u003cp\u003eOrganizations \u003ccode\u003eWorkspaces\u003c/code\u003e Workspace Name \u003ccode\u003eSetting\u003c/code\u003e Terraform Working Directory\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eenv/dev\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래의 코드를 추가하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_4.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e마지막으로 \"Save settings\"를 클릭하세요.\u003c/p\u003e\n\u003cp\u003e이제 GitHub Actions를 사용하여 인프라 프로비저닝을 준비했습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e단계 7: 풀 리퀘스트 생성하기\u003c/strong\u003e\n이제 VS Code 편집기로 돌아가서 데모 테스트용 코드를 약간 수정한 후, 해당 코드를 GitHub \"tf-infa-test\" 브랜치에 커밋하고 푸시하세요. 그런 다음 GitHub에서 이 브랜치에 대한 풀 리퀘스트를 생성하세요.\u003c/p\u003e\n\u003cp\u003e풀 리퀘스트를 생성한 후 GitHub 워크플로우(테라폼 플랜)를 실행하여 테라폼 플랜을 확인하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e단계 8: 풀 리퀘스트 검토 및 병합\u003c/strong\u003e\n\"Terraform plan\"에 만족한다면, 'main' 브랜치에 '병합' 코드로 풀 리퀘스트를 닫은 다음 인프라 구축을 위해 워크플로우(테라폼 애플라이)를 실행하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_6.png\" alt=\"Step 9\"\u003e\u003c/p\u003e\n\u003cp\u003e9단계: 프로비전된 EC2 인스턴스 확인\u003c/p\u003e\n\u003cp\u003e모든 리소스가 생성되었습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_7.png\" alt=\"Step 9\"\u003e\u003c/p\u003e\n\u003ch1\u003e📘 섹션 2: EC2 구성, Kubernetes (K3s) 설치 및 Ansible를 사용하여 MERN 앱 배포\u003c/h1\u003e\n\u003cp\u003e인프라 프로비저닝이 완료되면 GitHub의 두 번째 git 저장소 (Ansible)로 이동하여 AWS EC2를 구성하고 Kubernetes (K3s)를 설치하고 Ansible를 사용하여 MERN 앱을 배포합니다.\u003c/p\u003e\n\u003cp\u003e단계 1: 로컬 머신에서 저장소를 복제합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003egit clone \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//github.com/bjnandi/ansible-k3s-nginx-lb.git\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e깃 저장소를 복제한 후, VS Code의 Dev Container에서 열어보세요. Dev Container는 환경(Ansible)을 메인 머신과 격리시킵니다.\u003c/p\u003e\n\u003cp\u003e단계 2: SSH 키를 위해 \".ssh\" 폴더에 \"linux.pem\" 파일을 만드세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003enano ~/.ssh/linux.pem\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기에 \"pem\" 파일 코드를 붙여넣고 파일을 저장하세요.\u003c/p\u003e\n\u003cp\u003eStep 3: \"linux.pem\" 파일의 권한을 설정하세요\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003echmod \u003cspan class=\"hljs-number\"\u003e400\u003c/span\u003e ~\u003cspan class=\"hljs-regexp\"\u003e/.ssh/\u003c/span\u003elinux.\u003cspan class=\"hljs-property\"\u003epem\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eStep 4: 이제 디렉토리의 권한을 설정하세요. Dev Container는 모든 사용자에 대해 기본 권한으로 디렉토리를 마운트합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003echmod \u003cspan class=\"hljs-number\"\u003e755\u003c/span\u003e /workspaces/ansible-k3s-nginx-lb\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e단계 5: 이제 우리의 AWS EC2 IP 주소로 IP 주소를 업데이트하세요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e“hosts” 파일에서:\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ebastion (공용 IP)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ek3s_nodes, additional_agent_nodes 및 nginx_lb (사설 IP)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003enginx_lb(사설 IP)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eProxyCommand용 (공용 IP)\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e[bastion]\nbastion ansible_host=\u003cspan class=\"hljs-number\"\u003e34.195\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.33\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.137\u003c/span\u003e\n[\u003cspan class=\"hljs-attr\"\u003ebastion\u003c/span\u003e:vars]\nansible_user=ubuntu\nansible_ssh_private_key_file=~\u003cspan class=\"hljs-regexp\"\u003e/.ssh/\u003c/span\u003elinux.\u003cspan class=\"hljs-property\"\u003epem\u003c/span\u003e\n\n[k3s_nodes]\nmaster ansible_host=\u003cspan class=\"hljs-number\"\u003e10.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.1\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.222\u003c/span\u003e\n[\u003cspan class=\"hljs-attr\"\u003ek3s_nodes\u003c/span\u003e:vars]\nansible_user=ubuntu\nansible_ssh_private_key_file=~\u003cspan class=\"hljs-regexp\"\u003e/.ssh/\u003c/span\u003elinux.\u003cspan class=\"hljs-property\"\u003epem\u003c/span\u003e\nansible_ssh_common_args=\u003cspan class=\"hljs-string\"\u003e'-o ProxyCommand=\"ssh -o StrictHostKeyChecking=no -i ~/.ssh/linux.pem -W %h:%p -q ubuntu@34.195.33.137\"'\u003c/span\u003e\n\n[additional_agent_nodes]\nworker1 ansible_host=\u003cspan class=\"hljs-number\"\u003e10.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.2\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.244\u003c/span\u003e\nworker2 ansible_host=\u003cspan class=\"hljs-number\"\u003e10.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.1\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.236\u003c/span\u003e\n[\u003cspan class=\"hljs-attr\"\u003eadditional_agent_nodes\u003c/span\u003e:vars]\nansible_user=ubuntu\nansible_ssh_private_key_file=~\u003cspan class=\"hljs-regexp\"\u003e/.ssh/\u003c/span\u003elinux.\u003cspan class=\"hljs-property\"\u003epem\u003c/span\u003e\nansible_ssh_common_args=\u003cspan class=\"hljs-string\"\u003e'-o ProxyCommand=\" ssh -o StrictHostKeyChecking=no -i ~/.ssh/linux.pem -W %h:%p -q ubuntu@34.195.33.137\"'\u003c/span\u003e\n\n[nginx_lb]\nnginx_lb ansible_host=\u003cspan class=\"hljs-number\"\u003e10.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.5\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.187\u003c/span\u003e\n[\u003cspan class=\"hljs-attr\"\u003enginx_lb\u003c/span\u003e:vars]\nansible_user=ubuntu\nansible_ssh_private_key_file=~\u003cspan class=\"hljs-regexp\"\u003e/.ssh/\u003c/span\u003elinux.\u003cspan class=\"hljs-property\"\u003epem\u003c/span\u003e\nansible_ssh_common_args=\u003cspan class=\"hljs-string\"\u003e'-o ProxyCommand=\" ssh -o StrictHostKeyChecking=no -i ~/.ssh/linux.pem -W %h:%p -q ubuntu@34.195.33.137\"'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\"nginx.conf\" 파일에서:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e업스트림 클라이언트 및 API 서버\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e   upstream client {\n        server \u003cspan class=\"hljs-number\"\u003e10.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.1\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.222\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e30001\u003c/span\u003e; # 귀하의 \u003cspan class=\"hljs-title class_\"\u003eEC2\u003c/span\u003e 인스턴스 사설 \u003cspan class=\"hljs-variable constant_\"\u003eIP\u003c/span\u003e로 교체하세요\n        server \u003cspan class=\"hljs-number\"\u003e10.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.2\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.244\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e30001\u003c/span\u003e; # 귀하의 \u003cspan class=\"hljs-title class_\"\u003eEC2\u003c/span\u003e 인스턴스 사설 \u003cspan class=\"hljs-variable constant_\"\u003eIP\u003c/span\u003e로 교체하세요\n        server \u003cspan class=\"hljs-number\"\u003e10.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.1\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.236\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e30001\u003c/span\u003e; # 귀하의 \u003cspan class=\"hljs-title class_\"\u003eEC2\u003c/span\u003e 인스턴스 사설 \u003cspan class=\"hljs-variable constant_\"\u003eIP\u003c/span\u003e로 교체하세요\n    }\n\n    upstream apiserver {\n        server \u003cspan class=\"hljs-number\"\u003e10.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.1\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.222\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e30005\u003c/span\u003e;  # 귀하의 \u003cspan class=\"hljs-title class_\"\u003eEC2\u003c/span\u003e 인스턴스 사설 \u003cspan class=\"hljs-variable constant_\"\u003eIP\u003c/span\u003e로 교체하세요\n        server \u003cspan class=\"hljs-number\"\u003e10.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.2\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.244\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e30005\u003c/span\u003e; # 귀하의 \u003cspan class=\"hljs-title class_\"\u003eEC2\u003c/span\u003e 인스턴스 사설 \u003cspan class=\"hljs-variable constant_\"\u003eIP\u003c/span\u003e로 교체하세요\n        server \u003cspan class=\"hljs-number\"\u003e10.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.1\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.236\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e30005\u003c/span\u003e; # 귀하의 \u003cspan class=\"hljs-title class_\"\u003eEC2\u003c/span\u003e 인스턴스 사설 \u003cspan class=\"hljs-variable constant_\"\u003eIP\u003c/span\u003e로 교체하세요\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e이제 \"project_vars\" 파일에서:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003emaster_ip\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e10.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.1\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.222\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e단계 6: Ansible 구성이 실행 준비 완료되었습니다\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMakefile을 사용하여 모든 구성을 한 주석에서 실행하려면:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003emake run_ansible\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e하나씩 실행하려면:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e ansible-playbook -i hosts k3s_install.\u003cspan class=\"hljs-property\"\u003eyaml\u003c/span\u003e\n\n ansible-playbook -i hosts k3s_mern_deploy.\u003cspan class=\"hljs-property\"\u003eyaml\u003c/span\u003e\n\n ansible-playbook -i hosts config_nginx_lb.\u003cspan class=\"hljs-property\"\u003eyaml\u003c/span\u003e\n\n ansible-playbook -i hosts config_bastion.\u003cspan class=\"hljs-property\"\u003eyaml\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제, 모든 EC2를 구성하고 Kubernetes(k3s)를 설치한 다음 Kubernetes(k3s)에 MERN 앱을 배포합니다.\u003c/p\u003e\n\u003cp\u003e단계 7: 이제 도메인 DNS 설정으로 이동하여 \"A\" 레코드를 업데이트합니다. 저희 도메인은 Squarespace에서 제공합니다. 그래서, Squarespace DNS 설정에서 이 도메인 DNS를 업데이트했습니다.\u003c/p\u003e\n\u003cp\u003e우리 앱에 대해 EC2 인스턴스(개발 로드밸런서)의 공개 IP로 두 개의 사용자 정의 \"A\" 레코드를 추가했어요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_8.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e단계 8: 이제 도메인을 사용하여 앱을 보여줄 차례에요.\u003c/p\u003e\n\u003cp\u003e이 도메인(\u003ca href=\"http://bjtechlife.com)%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://bjtechlife.com)에서\u003c/a\u003e 우리 앱을 봤어요.\u003c/p\u003e\n\u003cp\u003e만약 Docker Hub repository 이미지가 있거나 수동으로 이미지를 빌드하여 Docker Hub에 푸시했다면, 먼저 출력에서 앱 UI를 확인할 수 있습니다. 그렇지 않은 경우 (섹션 3)를 완료한 다음 출력에서 앱 UI를 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_9.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch1\u003e📘세션 3: Kubernetes (k3s)에서 MERN 앱을 위한 CI/CD 파이프라인 구축하기 (GitHub Actions 사용)\u003c/h1\u003e\n\u003cp\u003eEC2 구성, (k3s) 설치 및 앱 배포를 완료하고, AWS EC2 인스턴스에서 GitHub Actions를 사용하여 Kubernetes (k3s)에서 MERN 앱을 위한 CI/CD 파이프라인을 만들기 위해 GitHub의 세 번째 git 저장소(MERN 프로젝트)로 이동하세요.\u003c/p\u003e\n\u003cp\u003e스텝 1: 로컬 머신에서 저장소를 복제하세요\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003egit clone \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//github.com/bjnandi/ci-cd-pipeline-MERN-k3s.git\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e복제한 후, VS Code 에디터에서 열어주세요.\u003c/p\u003e\n\u003cp\u003e\".github/workflows/\" 디렉토리에 두 개의 워크플로우 파일 (docker-ci 및 k3s-cd)이 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003edocker-ci.yml\u003c/li\u003e\n\u003cli\u003ek3s-cd.yml\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e첫 번째 워크플로우 \"docker-ci.yml\" 파일은 이미지를 빌드하여 Docker Hub에 푸시하고, 다른 워크플로우 \"k3s-cd.yml\" 파일은 Kubernetes(k3s)에서 이미지를 업데이트합니다.\u003c/p\u003e\n\u003cp\u003e단계 2: 이제 GitHub Secrets를 사용하여 시크릿을 채워넣어야합니다. GitHub 리포지토리에 추가할 수 있습니다. 자세한 정보는 GitHub Secrets에서 확인할 수 있습니다. 이제 시크릿과 변수로 이동하여 값을 설정합니다.\u003c/p\u003e\n\u003cp\u003eGithub \u003ccode\u003eRepo Name\u003c/code\u003e 설정 \u003ccode\u003eSecrets and variables\u003c/code\u003e 작업 \u003ccode\u003eRepository Secrets\u003c/code\u003e 새 리포지토리 시크릿 :\u003c/p\u003e\n\u003cp\u003eEC2_HOST: 배스천 호스트 EC2 인스턴스의 공개 IP 주소는 대략 이와 같을 것입니다. \"34.195.33.137\".\u003c/p\u003e\n\u003cp\u003eMASTER_NODE: k8s-instance-master EC2 인스턴스의 사설 IP 주소는 대략 이와 같을 것입니다. \"10.0.1.222\".\u003c/p\u003e\n\u003cp\u003eEC2_USERNAME: EC2 인스턴스의 사용자 이름은 일반적으로 \"ubuntu\"입니다.\u003c/p\u003e\n\u003cp\u003eSSH_PRIVATE_KEY: 인스턴스에 로그인하는 데 사용할 “.pem” 파일입니다.\u003c/p\u003e\n\u003cp\u003eDOCKER_USERNAME: 이것은 도커 허브 계정 프로필로 이동하면 확인할 수 있는 도커 허브의 \"사용자 이름\"입니다. 도커 이미지를 도커 허브에 푸시하는 데 사용됩니다.\u003c/p\u003e\n\u003cp\u003eDOCKER_PASSWORD: 이것은 도커 허브 계정의 \"비밀번호\"입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_10.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e단계 3: \"VS Code Editor\"로 돌아가서 데모 테스트를 위해 코드나 UI 파일을 편집하거나 작은 변경 사항을 수행한 후, 현재 파일에서 앱의 CI/CD 테스트를 위해 GitHub의 \"main\" 브랜치에 코드를 커밋하고 푸시하세요.\u003c/p\u003e\n\u003cp\u003e고객님, \u003ccode\u003esrc\u003c/code\u003e 폴더의 \u003ccode\u003ecomponents\u003c/code\u003e 폴더 안에 있는 \u003ccode\u003eNavbar.js\u003c/code\u003e 파일을 수정해야 합니다.\u003c/p\u003e\n\u003cp\u003e\"CRUD\" 텍스트를 \"CRUD test\"로 변경한 다음, 변경사항을 커밋하고 메인 브랜치에 푸시하세요.\u003c/p\u003e\n\u003cp\u003e빌드, 푸시, 그리고 배포하는 데 시간이 걸릴 수 있습니다. 나중에 앱 UI(\u003ca href=\"http://bjtechlife.com)%EC%97%90\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://bjtechlife.com)에\u003c/a\u003e 변경 사항이 표시되고 데이터를 삽입하는 것과 같이 제대로 작동하는 것을 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e와우! 😎🚀 여기에는 우리가 코드에서 변경한 \"CRUD 테스트\"가 나와 있네요.\u003c/p\u003e\n\u003cp\u003e저희 앱 UI에서 서로 다른 변경을 계속해서 적용하면 변경 사항을 볼 수 있어요.\u003c/p\u003e\n\u003cp\u003e결과적으로, GitHub Actions를 사용하여 Kubernetes(k3s)에서 MERN 앱을 위한 엔드 투 엔드 CI/CD 파이프라인을 완료했어요.\u003c/p\u003e\n\u003cp\u003e🌟축하합니다!!🌟, 저희가 GitHub Actions 및 Ansible을 사용하여 Kubernetes에서 Terraform을 활용하여 MERN 앱을 위한 End-to-End CI/CD 파이프라인을 성공적으로 구축했습니다.\u003c/p\u003e\n\u003cp\u003e✨이제 AWS에서 리소스를 제거할 시간입니다. 그러므로, Terraform 저장소 VS Code 편집기 터미널(/workspaces/terraform-ci-cd-aws/env/dev)로 돌아가서 다음을 실행해주세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eterraform login\nterraform init\nterraform destroy -auto-approve\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 함으로써 저와 함께 오래 집중해 주셔서 감사합니다. 앞으로 또 다른 주제로 포스팅하겠습니다.\u003c/p\u003e\n\u003ch1\u003eK8s #쿠버네티스 #k3s #테라폼 #앤서블 #MERN #풀스택 #도커 #웹애플리케이션 #컨테이너화 #데브옵스 #컨테이너화된앱 #EC2 #MERN스택 #도커화된웹앱 #MERN앱 #도커컨테이너 #CI/CD 파이프라인 #GitHub 액션 #제로다운타임 #CI/CD #자동화 #배포 #기술팁\u003c/h1\u003e\n\u003cp\u003e만일 쿠버네티스에서 테라폼을 사용하여 GitHub 액션 및 앤서블을 이용해 MERN 앱을 위한 엔드 투 엔드 CI/CD 파이프라인을 구축하는 데 문제가 발생한다면 언제든지 저에게 연락해 주세요. 최선을 다해 도와드리겠습니다. 감사합니다.\u003c/p\u003e\n\u003ch1\u003e평문으로 🚀\u003c/h1\u003e\n\u003cp\u003eIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e작가를 응원하고 팔로우를 눌러주세요! 👏\u003c/li\u003e\n\u003cli\u003e팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\u003c/li\u003e\n\u003cli\u003e다른 플랫폼도 방문해보세요: Stackademic | CoFeed | Venture | Cubed\u003c/li\u003e\n\u003cli\u003e알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\u003c/li\u003e\n\u003cli\u003e더 많은 콘텐츠는 PlainEnglish.io에서 확인하세요\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible"},"buildId":"o1YmnmSuZvAX2O4TI9r41","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>