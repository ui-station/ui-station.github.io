<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>FastAPI, Docker, 그리고 GCP를 활용하여 ML 솔루션 배포하는 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="FastAPI, Docker, 그리고 GCP를 활용하여 ML 솔루션 배포하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="FastAPI, Docker, 그리고 GCP를 활용하여 ML 솔루션 배포하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP" data-gatsby-head="true"/><meta name="twitter:title" content="FastAPI, Docker, 그리고 GCP를 활용하여 ML 솔루션 배포하는 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 12:40" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_buildManifest.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">FastAPI, Docker, 그리고 GCP를 활용하여 ML 솔루션 배포하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="FastAPI, Docker, 그리고 GCP를 활용하여 ML 솔루션 배포하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">16<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>Full Stack Data Science의 시리즈 중 5번째 기사입니다. 이 기사에서는 ML 기반 검색 API의 배포 방법을 안내합니다. 무수히 많은 방법으로 수행할 수 있지만, 여기에서는 거의 모든 머신 러닝 솔루션에 적용할 수 있는 간단한 3단계 접근법에 대해 설명합니다. 예시 코드는 GitHub 저장소에서 자유롭게 이용할 수 있습니다.</p>
<p><img src="/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_0.png" alt="이미지"></p>
<p>머신 러닝이 모델 훈련에 관한 멋진 모델만이 아니라는 것을 생각하면, 실제로 모델 스스로는 가치를 만들어내지 않습니다. ML 모델을 ML 솔루션(즉, 가치 있는 것)으로 만들기 위해 "배포"해야 합니다.</p>
<p>이를 다양한 형태로 구현할 수 있습니다. 예를 들어 사용자가 모델과 상호 작용할 수 있는 웹 인터페이스를 생성하거나, 기존 소프트웨어 시스템에 모델을 통합하거나, 개발자가 모델에 액세스할 수 있는 API를 설정하는 것 등이 있습니다 (OpenAI와 같은 사례를 생각해보세요).</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>여기서 설명하는 3단계 전략은 모든 예제와 호환됩니다. 이는 다음으로 구성됩니다:</p>
<ul>
<li>추론 API 생성 (FastAPI 사용)</li>
<li>API 컨테이너화 (도커를 통해)</li>
<li>클라우드 플랫폼에서 컨테이너 실행 (여기서는 GCP 사용)</li>
</ul>
<h1>FastAPI</h1>
<p>이 배포 전략의 첫 번째 단계는 모델을 API(즉, 응용 프로그램 프로그래밍 인터페이스)로 랩핑하는 것입니다. 간단히 말해, API를 사용하면 응용 프로그램과 프로그래밍 방식으로 상호 작용할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>첫 번째 단계를 수행하는 한 가지 방법은 파이썬 함수를 API 엔드포인트로 변환하는 매우 쉬운 방법을 제공하는 Python 라이브러리인 FastAPI를 사용하는 것입니다. 아래 코드는 구체적인 예제를 제공합니다.</p>
<h2>Docker</h2>
<p>우리의 추론 API를 직접 클라우드에 배포할 수 있지만, 먼저 "컨테이너화"하는 것이 좋습니다. 이때 Docker가 필요합니다.</p>
<p>Docker를 사용하면 API의 종속성을 모두 포함하는 가벼운 래퍼를 생성할 수 있어서 새로운 컴퓨터에서 더 쉽게 구동할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>작업은 2 단계 프로세스를 통해 수행됩니다. 첫째, 우리는 Docker 이미지를 생성합니다. 이는 기본적으로 시스템에 API를 제로에서 어떻게 구동할지 알려주는 레시피입니다 (걱정하지 마세요, 만들기 쉽습니다). 둘째, Docker가 설치된 시스템에서 이미지를 실행할 수 있습니다. 실행 중인 이미지를 컨테이너라고 하며, 이는 더 큰 시스템에 있는 작은 가상 머신과 같습니다.</p>
<h1>Google Cloud Run</h1>
<p>마지막으로, Docker 이미지를 실행할 컴퓨팅 리소스가 필요합니다. 물론 노트북에서 이 작업을 수행할 수도 있지만 (아마 좋은 아이디어는 아닙니다), 온프레미스 서버나 클라우드 제공업체를 통해 이를 수행할 수 있습니다.</p>
<p>여기서는 Google Cloud Run을 사용하여 Docker 컨테이너를 실행하는 GCP 서비스를 사용합니다. 이 서비스에는 무료 티어도 있으므로 불필요한 비용이 발생하지 않고 프로젝트를 배포할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>예시 코드: 시맨틱 검색 API 배포하기</h1>
<p>기본 개념을 이해했으니, 실제 코드에서 이 프로세스가 어떻게 보이는지 살펴봅시다. 아래 예시는 이 시리즈의 이전 기사들을 바탕으로 구축되었으며, 제 유튜브 비디오의 제목과 대본을 가져와 텍스트 임베딩으로 변환한 것을 사용합니다.</p>
<p>간단히 말해, 텍스트 임베딩은 텍스트의 의미론적인 의미 있는 숫자 표현으로, 새로운 종류의 검색(시맨틱 검색이라고도 함)을 가능하게 합니다.</p>
<p>여기에서는 제 유튜브 비디오의 모든 제목과 대본에 대한 시맨틱 검색 시스템을 위한 API를 구축하고 배포할 것입니다. 이 API는 Hugging Face spaces에서 실행되는 실시간 검색 애플리케이션의 백엔드입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 앱의 백엔드와 프론트엔드의 코드 저장소가 모두 무료로 제공됩니다.</p>
<h2>단계 1: API 만들기</h2>
<p>FastAPI를 사용하면 기존의 Python 스크립트를 몇 줄의 추가 코드로 API로 변환하는 것이 매우 쉽습니다. 이게 바로 그 모습입니다.</p>
<p>먼저 유용한 라이브러리를 import할 거에요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> <span class="hljs-title class_">FastAPI</span>
<span class="hljs-keyword">import</span> polars <span class="hljs-keyword">as</span> pl
<span class="hljs-keyword">from</span> sentence_transformers <span class="hljs-keyword">import</span> <span class="hljs-title class_">SentenceTransformer</span>
<span class="hljs-keyword">from</span> sklearn.<span class="hljs-property">metrics</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">DistanceMetric</span>
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">from</span> app.<span class="hljs-property">functions</span> <span class="hljs-keyword">import</span> returnSearchResultIndexes
</code></pre>
<p>이제 우리는 시맨틱 검색 기능의 구성 요소를 정의할 겁니다. 구체적으로 텍스트 임베딩 모델, 우리가 검색하려는 비디오들의 제목 및 대본 임베딩, 그리고 사용자 쿼리에 가장 관련성 높은 비디오를 평가하는 거리 측정 기준입니다. 시맨틱 검색에 대해 더 깊게 알아보고 싶다면, 이에 대해 이전에 다룬 글을 참조해주세요.</p>
<pre><code class="hljs language-js"># define model info
model_name = <span class="hljs-string">'all-MiniLM-L6-v2'</span>

# load model
model = <span class="hljs-title class_">SentenceTransformer</span>(model_name)

# load video index
df = pl.<span class="hljs-title function_">scan_parquet</span>(<span class="hljs-string">'app/data/video-index.parquet'</span>)

# create distance metric object
dist_name = <span class="hljs-string">'manhattan'</span>
dist = <span class="hljs-title class_">DistanceMetric</span>.<span class="hljs-title function_">get_metric</span>(dist_name)
</code></pre>
<p>이제 API 작업을 정의합니다. 여기서 3개의 GET 요청을 생성할 것입니다. 첫 번째 요청은 아래 코드 블록에 표시되어 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python"><span class="hljs-comment"># FastAPI 객체 생성</span>
app = FastAPI()

<span class="hljs-comment"># API 동작</span>
<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">"/"</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">health_check</span>():
    <span class="hljs-keyword">return</span> {<span class="hljs-string">'health_check'</span>: <span class="hljs-string">'OK'</span>}
</code></pre>
<p>위 블록에서는 FastAPI() 클래스를 사용하여 새 FastAPI 애플리케이션을 초기화하고 "health check" 엔드포인트를 만듭니다.</p>
<p>이를 위해 입력이 없고 "health_check" 키와 값이 "OK"인 사전을 반환하는 Python 함수를 정의합니다. 이 함수를 API 엔드포인트로 변환하려면 단순히 데코레이터를 추가하고 엔드포인트의 경로를 지정하면 됩니다. 여기서는 루트인 즉, "/"를 사용합니다.</p>
<p>또 다른 예제를 살펴보겠습니다. 여기서는 API에 대한 자세한 정보를 반환하는 info라는 엔드포인트가 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">@app.<span class="hljs-title function_">get</span>(<span class="hljs-string">"/info"</span>)
def <span class="hljs-title function_">info</span>():
    <span class="hljs-keyword">return</span> {<span class="hljs-string">'name'</span>: <span class="hljs-string">'yt-search'</span>, <span class="hljs-string">'description'</span>: <span class="hljs-string">"Shaw Talebi의 YouTube 비디오를 검색하는 API입니다."</span>}
</code></pre>
<p>이 엔드포인트는 헬스 체크와 매우 유사한 것을 볼 수 있습니다. 그러나 이것은 "/info" 엔드포인트에 위치합니다.</p>
<p>마지막으로 사용자 쿼리를 받아 가장 관련 있는 비디오의 제목과 ID를 반환하는 검색 엔드포인트를 만들어 봅시다.</p>
<pre><code class="hljs language-js">@app.<span class="hljs-title function_">get</span>(<span class="hljs-string">"/search"</span>)
def <span class="hljs-title function_">search</span>(<span class="hljs-attr">query</span>: str):
    idx_result = <span class="hljs-title function_">returnSearchResultIndexes</span>(query, df, model, dist)
    <span class="hljs-keyword">return</span> df.<span class="hljs-title function_">select</span>([<span class="hljs-string">'title'</span>, <span class="hljs-string">'video_id'</span>]).<span class="hljs-title function_">collect</span>()[idx_result].<span class="hljs-title function_">to_dict</span>(as_series=<span class="hljs-title class_">False</span>)
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 엔드포인트에는 입력이 필요합니다: 사용자의 쿼리입니다. 이 쿼리는 다른 스크립트에 정의된 또 다른 Python 함수로 전달됩니다. 이 함수는 검색에 대한 모든 수학 연산을 수행합니다. 여기서 자세히 다루지는 않겠지만, 궁금한 독자는 코드를 GitHub에서 볼 수도 있고 YouTube에서 검색 함수의 코드 설명을 볼 수도 있습니다.</p>
<p>이 함수는 검색 결과의 행 번호만 df 데이터프레임에서 반환하므로, 우리는 이 출력을 사용하여 관심 있는 제목과 비디오 ID를 가져와서 이를 Python 사전으로 반환해야 합니다. API 엔드포인트의 모든 출력이 사전이어야 하는데요, 이는 API의 표준 JSON 형식을 준수하기 때문입니다.</p>
<p>위 코드 블록에서 설명한대로, 두 개의 외부 파일인 app/functions.py 및 app/data/video-index.parquet을 참조합니다. 이는 다음 디렉토리 구조를 시사합니다.</p>
<p><img src="https://example.com/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_1.png" alt="image"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 API를 로컬에서 실행하려면 루트 디렉토리로 이동하여 다음 명령을 실행할 수 있습니다.</p>
<pre><code class="hljs language-js">uvicorn app.<span class="hljs-property">main</span>:app --host <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> --port <span class="hljs-number">8080</span>
</code></pre>
<p>uvicorn은 FastAPI를 사용하여 작성한 웹 애플리케이션을 실행할 수 있게 해주는 파이썬 라이브러리입니다. 이 명령은 이 API를 로컬에서 <a href="http://0.0.0.0:8080%EC%97%90%EC%84%9C" rel="nofollow" target="_blank">http://0.0.0.0:8080에서</a> 실행합니다. 나중에 Google Cloud Run에 배포할 때 이 호스트와 포트를 사용하는 이유를 나준내게 될 것입니다.</p>
<h2>단계 2: 도커 이미지 생성</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우와, 우리 API가 로컬에서 작동하고 있어요! 이제 클라우드에서 실행할 수 있도록 다음 단계를 진행해 봐요.</p>
<p>이를 위해서 API용 Docker 이미지를 생성할 거에요. 이를 위해 Dockerfile, requirements.txt, 그리고 app/<strong>init</strong>.py 이 3가지 파일을 만들어야 해요. 우리 디렉토리는 아래와 같이 보여야 해요.</p>
<p><img src="/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_2.png" alt="이미지"></p>
<p>Dockerfile은 Docker 이미지를 실행하는 단계별 지침을 포함하고 있어요. requirements.txt는 API를 실행하는 데 필요한 Python 라이브러리(버전 포함)를 지정해요. 마지막으로 app/<strong>init</strong>.py 파일은 app 폴더를 Python 패키지로 지정해주어, 컨테이너에서 실행될 때 Python이 API 코드를 찾고 적절하게 가져올 수 있도록 해줘요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다음은 Dockerfile 내부의 내용입니다.</p>
<pre><code class="hljs language-js"># python 기본 이미지에서 시작
<span class="hljs-variable constant_">FROM</span> <span class="hljs-attr">python</span>:<span class="hljs-number">3.10</span>-slim

# 작업 디렉토리 변경
<span class="hljs-variable constant_">WORKDIR</span> /code

# 요구 사항 파일을 이미지에 추가
<span class="hljs-variable constant_">COPY</span> ./requirements.<span class="hljs-property">txt</span> /code/requirements.<span class="hljs-property">txt</span>

# <span class="hljs-title class_">Python</span> 라이브러리 설치
<span class="hljs-variable constant_">RUN</span> pip install --no-cache-dir --upgrade -r /code/requirements.<span class="hljs-property">txt</span>

# <span class="hljs-title class_">Python</span> 코드 추가
<span class="hljs-variable constant_">COPY</span> ./app/ <span class="hljs-regexp">/code/</span>app/

# 기본 명령어 지정
<span class="hljs-variable constant_">CMD</span> [<span class="hljs-string">"uvicorn"</span>, <span class="hljs-string">"app.main:app"</span>, <span class="hljs-string">"--host"</span>, <span class="hljs-string">"0.0.0.0"</span>, <span class="hljs-string">"--port"</span>, <span class="hljs-string">"8080"</span>]
</code></pre>
<p>첫 번째 줄은 기존에 Python 3.10이 설치된 이미지 위에 저희의 이미지를 부트스트랩합니다. 다음으로 작업 디렉토리를 루트에서 /code로 변경합니다.</p>
<p>그런 다음 요구 사항 파일을 코드베이스에서 Docker 이미지로 복사합니다. 이를 통해 pip를 사용하여 요구 사항을 설치할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그 다음으로, API에 대한 모든 코드를 복사합니다.</p>
<p>참고: Python 패키지를 먼저 복사하고 설치했습니다. 이렇게 함으로써 요구 사항의 설치를 캐시할 수 있습니다. 개발 중에 빠르게 Docker 이미지를 실행할 때 의존성을 설치하는 데 몇 분을 기다릴 필요가 없도록 도와줍니다.</p>
<p>마지막으로, 개발 중에 API를 실행할 때 지역에서 실행했던 것과 동일한 기본 명령을 지정합니다.</p>
<h2>단계 3: Google Cloud에 배포</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 시점에서 우리는 Docker 이미지를 빌드하고 Docker Hub에 푸시하여 여러 다른 클라우드 서비스에 쉽게 배포할 수 있습니다. 하지만 여기서는 대안 전략을 따를 거에요.</p>
<p>대신에, 우리 모든 코드를 GitHub에 푸시할 거에요. 그럼 바로 이 코드를 Google Cloud Run에 컨테이너 배포할 수 있어요. 이 방법에는 두 가지 주요 장점이 있어요.</p>
<p>첫째로, 로컬 시스템과 Google Cloud Run이 사용하는 시스템 아키텍처 간의 차이를 해결하느라 시간을 들일 필요가 없어요 (특히 저는 Mac이 ARM64로 동작하기 때문에 이 문제가 있었어요). 둘째로, GitHub 리포지토리에서 배포함으로써 지속적인 배포가 가능해져요. 그래서 API를 업데이트하고 싶다면, 그냥 새 코드를 리포지토리에 푸시하면 새 컨테이너가 자동적으로 생성돼요.</p>
<p>우리는 새 GitHub 리포지토리를 만들면서 시작해볼게요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_3.png">
<p>이제 리포지토리를 복제하고 코드를 추가한 후 GitHub로 푸시합니다. 코드를 추가한 후 디렉토리 구조는 다음과 같이 보입니다.</p>
<img src="/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_4.png">
<p>코드가 준비되었으면 새 Google Cloud Platform 프로젝트를 만들 수 있습니다. GCP 콘솔로 이동하여 프로젝트 목록을 클릭한 다음 "새 프로젝트"를 선택하여 진행합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_5.png">
<p>프로젝트가 생성되면 해당 프로젝트를 열고 검색 창에 "cloud run"을 입력할 수 있습니다.</p>
<img src="/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_6.png">
<p>그것을 열면 "CREAT SERVICE"를 클릭할 것입니다. 이렇게 하면 서비스를 구성할 수 있는 페이지가 열립니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>먼저 GitHub에서 서비스를 배포할 옵션을 선택합니다. 그런 다음 "CLOUD BUILD로 설정"을 클릭하세요.</p>
<p><a href="/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_7.png">이미지</a></p>
<p>저장소 소스로는 GitHub을 선택하고 방금 만든 저장소를 선택합니다.</p>
<p><a href="/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_8.png">이미지</a></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>지점을 ^main$으로 유지하고 "Build Type"을 Dockerfile로 선택합니다.</p>
<p><img src="/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_9.png" alt="이미지"></p>
<p>다음으로, 서비스 구성 화면으로 돌아갑니다. 서비스의 이름을 마음대로 지정할 수 있습니다 (저는 자동 생성된 이름을 그대로 두겠습니다). 지역은 us-central1로 남겨두겠습니다. 이 지역은 가장 저렴한 컴퓨팅 옵션을 제공하는 Tier 1이기 때문에 이 예시에서는 무료입니다.</p>
<p>간단히 유지하려면 "인증되지 않은 호출 허용"을 선택합니다. 물론 대부분의 시스템에는 인증이 필요할 것입니다. 그런 다음, 나머지를 기본값으로 남겨둡니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 "컨테이너, 볼륨, 네트워킹, 보안" 아래에서 컨테이너를 편집하여 1 GiB의 메모리를 할당하세요. Dockerfile에서 구성한 대로 PORT가 8080으로 설정되어 있기 때문에 이것을 변경하시면 안 됩니다.</p>
<p>나머지 설정은 기본값으로 그대로 두고 화면 아래의 "생성"을 클릭하세요. 수 분 후 컨테이너가 활성화될 것입니다!</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_12.png" alt="image"></p>
<p>그런 다음 페이지 상단 근처에 지정된 URL을 사용하여 API에 액세스할 수 있습니다. 링크를 클릭하면 루트 엔드포인트가 열립니다. 이 엔드포인트는 건강 상태 확인이었습니다.</p>
<p><img src="/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_13.png" alt="image"></p>
<p>다음 URL을 사용하여 검색 API에 대한 GET 요청을 수동으로 실행할 수 있습니다: [여기에 앱의 URL 입력]/search?query=LLMs. 이를 통해 LLMs와 관련된 비디오를 검색할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_14.png">
<h2>보너스: UI에 통합하기</h2>
<p>API 백엔드를 설정한 후, 사용자 친화적 인터페이스에 연결할 수 있습니다. 저는 Hugging Face Spaces를 통해 이를 수행합니다. 이 곳은 완전히 무료로 ML 앱을 호스팅합니다.</p>
<p>이것이 같은 검색이 UI를 통해 어떻게 보이는지입니다. 여기서 UI를 테스트하고 코드를 확인할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="https://miro.medium.com/v2/resize:fit:1200/1*St0OCAxBpqORc95WDpq4Pg.gif" alt="image"></p>
<h1>결론</h1>
<p>데이터 과학은 멋진 모델을 훈련시키는 것 이상의 의미를 가지고 있습니다. 문제를 해결하고 가치를 창출하는 것이 중요합니다. 종종, 이를 위해서는 모델을 배포하여 최대 효과를 발휘할 수 있는 환경으로 이전해야 합니다. 여기에서는 FastAPI, Docker 및 GCP를 사용하여 ML 모델을 배포하는 간단한 3단계 전략을 살펴보았습니다.</p>
<p>풀 스택 데이터 과학 시리즈를 마치는 글이지만, 이 글들은 이 검색 도구를 생성하는 과정에 관련된 실험에 대한 보너스 비디오가 포함된 YouTube 플레이리스트와 함께 제공됩니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Full Stack Data Science에 관해 더 알아보기 👇</p>
<h1>자료</h1>
<p>연결하기: <a href="%EB%A7%81%ED%81%AC">내 웹사이트</a> | 전화 상담 예약</p>
<p>소셜 미디어: <a href="%EB%A7%81%ED%81%AC">YouTube 🎥</a> | <a href="%EB%A7%81%ED%81%AC">LinkedIn</a> | <a href="%EB%A7%81%ED%81%AC">Twitter</a></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Support: 커피 한 잔 사주세요 ☕️</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"FastAPI, Docker, 그리고 GCP를 활용하여 ML 솔루션 배포하는 방법","description":"","date":"2024-06-19 12:40","slug":"2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP","content":"\nFull Stack Data Science의 시리즈 중 5번째 기사입니다. 이 기사에서는 ML 기반 검색 API의 배포 방법을 안내합니다. 무수히 많은 방법으로 수행할 수 있지만, 여기에서는 거의 모든 머신 러닝 솔루션에 적용할 수 있는 간단한 3단계 접근법에 대해 설명합니다. 예시 코드는 GitHub 저장소에서 자유롭게 이용할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_0.png)\n\n머신 러닝이 모델 훈련에 관한 멋진 모델만이 아니라는 것을 생각하면, 실제로 모델 스스로는 가치를 만들어내지 않습니다. ML 모델을 ML 솔루션(즉, 가치 있는 것)으로 만들기 위해 \"배포\"해야 합니다.\n\n이를 다양한 형태로 구현할 수 있습니다. 예를 들어 사용자가 모델과 상호 작용할 수 있는 웹 인터페이스를 생성하거나, 기존 소프트웨어 시스템에 모델을 통합하거나, 개발자가 모델에 액세스할 수 있는 API를 설정하는 것 등이 있습니다 (OpenAI와 같은 사례를 생각해보세요).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 설명하는 3단계 전략은 모든 예제와 호환됩니다. 이는 다음으로 구성됩니다:\n\n- 추론 API 생성 (FastAPI 사용)\n- API 컨테이너화 (도커를 통해)\n- 클라우드 플랫폼에서 컨테이너 실행 (여기서는 GCP 사용)\n\n# FastAPI\n\n이 배포 전략의 첫 번째 단계는 모델을 API(즉, 응용 프로그램 프로그래밍 인터페이스)로 랩핑하는 것입니다. 간단히 말해, API를 사용하면 응용 프로그램과 프로그래밍 방식으로 상호 작용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 단계를 수행하는 한 가지 방법은 파이썬 함수를 API 엔드포인트로 변환하는 매우 쉬운 방법을 제공하는 Python 라이브러리인 FastAPI를 사용하는 것입니다. 아래 코드는 구체적인 예제를 제공합니다.\n\n## Docker\n\n우리의 추론 API를 직접 클라우드에 배포할 수 있지만, 먼저 \"컨테이너화\"하는 것이 좋습니다. 이때 Docker가 필요합니다.\n\nDocker를 사용하면 API의 종속성을 모두 포함하는 가벼운 래퍼를 생성할 수 있어서 새로운 컴퓨터에서 더 쉽게 구동할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n작업은 2 단계 프로세스를 통해 수행됩니다. 첫째, 우리는 Docker 이미지를 생성합니다. 이는 기본적으로 시스템에 API를 제로에서 어떻게 구동할지 알려주는 레시피입니다 (걱정하지 마세요, 만들기 쉽습니다). 둘째, Docker가 설치된 시스템에서 이미지를 실행할 수 있습니다. 실행 중인 이미지를 컨테이너라고 하며, 이는 더 큰 시스템에 있는 작은 가상 머신과 같습니다.\n\n# Google Cloud Run\n\n마지막으로, Docker 이미지를 실행할 컴퓨팅 리소스가 필요합니다. 물론 노트북에서 이 작업을 수행할 수도 있지만 (아마 좋은 아이디어는 아닙니다), 온프레미스 서버나 클라우드 제공업체를 통해 이를 수행할 수 있습니다.\n\n여기서는 Google Cloud Run을 사용하여 Docker 컨테이너를 실행하는 GCP 서비스를 사용합니다. 이 서비스에는 무료 티어도 있으므로 불필요한 비용이 발생하지 않고 프로젝트를 배포할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 예시 코드: 시맨틱 검색 API 배포하기\n\n기본 개념을 이해했으니, 실제 코드에서 이 프로세스가 어떻게 보이는지 살펴봅시다. 아래 예시는 이 시리즈의 이전 기사들을 바탕으로 구축되었으며, 제 유튜브 비디오의 제목과 대본을 가져와 텍스트 임베딩으로 변환한 것을 사용합니다.\n\n간단히 말해, 텍스트 임베딩은 텍스트의 의미론적인 의미 있는 숫자 표현으로, 새로운 종류의 검색(시맨틱 검색이라고도 함)을 가능하게 합니다.\n\n여기에서는 제 유튜브 비디오의 모든 제목과 대본에 대한 시맨틱 검색 시스템을 위한 API를 구축하고 배포할 것입니다. 이 API는 Hugging Face spaces에서 실행되는 실시간 검색 애플리케이션의 백엔드입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 앱의 백엔드와 프론트엔드의 코드 저장소가 모두 무료로 제공됩니다.\n\n## 단계 1: API 만들기\n\nFastAPI를 사용하면 기존의 Python 스크립트를 몇 줄의 추가 코드로 API로 변환하는 것이 매우 쉽습니다. 이게 바로 그 모습입니다.\n\n먼저 유용한 라이브러리를 import할 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom fastapi import FastAPI\nimport polars as pl\nfrom sentence_transformers import SentenceTransformer\nfrom sklearn.metrics import DistanceMetric\nimport numpy as np\nfrom app.functions import returnSearchResultIndexes\n```\n\n이제 우리는 시맨틱 검색 기능의 구성 요소를 정의할 겁니다. 구체적으로 텍스트 임베딩 모델, 우리가 검색하려는 비디오들의 제목 및 대본 임베딩, 그리고 사용자 쿼리에 가장 관련성 높은 비디오를 평가하는 거리 측정 기준입니다. 시맨틱 검색에 대해 더 깊게 알아보고 싶다면, 이에 대해 이전에 다룬 글을 참조해주세요.\n\n```js\n# define model info\nmodel_name = 'all-MiniLM-L6-v2'\n\n# load model\nmodel = SentenceTransformer(model_name)\n\n# load video index\ndf = pl.scan_parquet('app/data/video-index.parquet')\n\n# create distance metric object\ndist_name = 'manhattan'\ndist = DistanceMetric.get_metric(dist_name)\n```\n\n이제 API 작업을 정의합니다. 여기서 3개의 GET 요청을 생성할 것입니다. 첫 번째 요청은 아래 코드 블록에 표시되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\n# FastAPI 객체 생성\napp = FastAPI()\n\n# API 동작\n@app.get(\"/\")\ndef health_check():\n    return {'health_check': 'OK'}\n```\n\n위 블록에서는 FastAPI() 클래스를 사용하여 새 FastAPI 애플리케이션을 초기화하고 \"health check\" 엔드포인트를 만듭니다.\n\n이를 위해 입력이 없고 \"health_check\" 키와 값이 \"OK\"인 사전을 반환하는 Python 함수를 정의합니다. 이 함수를 API 엔드포인트로 변환하려면 단순히 데코레이터를 추가하고 엔드포인트의 경로를 지정하면 됩니다. 여기서는 루트인 즉, \"/\"를 사용합니다.\n\n또 다른 예제를 살펴보겠습니다. 여기서는 API에 대한 자세한 정보를 반환하는 info라는 엔드포인트가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n@app.get(\"/info\")\ndef info():\n    return {'name': 'yt-search', 'description': \"Shaw Talebi의 YouTube 비디오를 검색하는 API입니다.\"}\n```\n\n이 엔드포인트는 헬스 체크와 매우 유사한 것을 볼 수 있습니다. 그러나 이것은 \"/info\" 엔드포인트에 위치합니다.\n\n마지막으로 사용자 쿼리를 받아 가장 관련 있는 비디오의 제목과 ID를 반환하는 검색 엔드포인트를 만들어 봅시다.\n\n```js\n@app.get(\"/search\")\ndef search(query: str):\n    idx_result = returnSearchResultIndexes(query, df, model, dist)\n    return df.select(['title', 'video_id']).collect()[idx_result].to_dict(as_series=False)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 엔드포인트에는 입력이 필요합니다: 사용자의 쿼리입니다. 이 쿼리는 다른 스크립트에 정의된 또 다른 Python 함수로 전달됩니다. 이 함수는 검색에 대한 모든 수학 연산을 수행합니다. 여기서 자세히 다루지는 않겠지만, 궁금한 독자는 코드를 GitHub에서 볼 수도 있고 YouTube에서 검색 함수의 코드 설명을 볼 수도 있습니다.\n\n이 함수는 검색 결과의 행 번호만 df 데이터프레임에서 반환하므로, 우리는 이 출력을 사용하여 관심 있는 제목과 비디오 ID를 가져와서 이를 Python 사전으로 반환해야 합니다. API 엔드포인트의 모든 출력이 사전이어야 하는데요, 이는 API의 표준 JSON 형식을 준수하기 때문입니다.\n\n위 코드 블록에서 설명한대로, 두 개의 외부 파일인 app/functions.py 및 app/data/video-index.parquet을 참조합니다. 이는 다음 디렉토리 구조를 시사합니다.\n\n![image](https://example.com/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 API를 로컬에서 실행하려면 루트 디렉토리로 이동하여 다음 명령을 실행할 수 있습니다.\n\n```js\nuvicorn app.main:app --host 0.0.0.0 --port 8080\n```\n\nuvicorn은 FastAPI를 사용하여 작성한 웹 애플리케이션을 실행할 수 있게 해주는 파이썬 라이브러리입니다. 이 명령은 이 API를 로컬에서 http://0.0.0.0:8080에서 실행합니다. 나중에 Google Cloud Run에 배포할 때 이 호스트와 포트를 사용하는 이유를 나준내게 될 것입니다.\n\n## 단계 2: 도커 이미지 생성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우와, 우리 API가 로컬에서 작동하고 있어요! 이제 클라우드에서 실행할 수 있도록 다음 단계를 진행해 봐요.\n\n이를 위해서 API용 Docker 이미지를 생성할 거에요. 이를 위해 Dockerfile, requirements.txt, 그리고 app/**init**.py 이 3가지 파일을 만들어야 해요. 우리 디렉토리는 아래와 같이 보여야 해요.\n\n![이미지](/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_2.png)\n\nDockerfile은 Docker 이미지를 실행하는 단계별 지침을 포함하고 있어요. requirements.txt는 API를 실행하는 데 필요한 Python 라이브러리(버전 포함)를 지정해요. 마지막으로 app/**init**.py 파일은 app 폴더를 Python 패키지로 지정해주어, 컨테이너에서 실행될 때 Python이 API 코드를 찾고 적절하게 가져올 수 있도록 해줘요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 Dockerfile 내부의 내용입니다.\n\n```js\n# python 기본 이미지에서 시작\nFROM python:3.10-slim\n\n# 작업 디렉토리 변경\nWORKDIR /code\n\n# 요구 사항 파일을 이미지에 추가\nCOPY ./requirements.txt /code/requirements.txt\n\n# Python 라이브러리 설치\nRUN pip install --no-cache-dir --upgrade -r /code/requirements.txt\n\n# Python 코드 추가\nCOPY ./app/ /code/app/\n\n# 기본 명령어 지정\nCMD [\"uvicorn\", \"app.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8080\"]\n```\n\n첫 번째 줄은 기존에 Python 3.10이 설치된 이미지 위에 저희의 이미지를 부트스트랩합니다. 다음으로 작업 디렉토리를 루트에서 /code로 변경합니다.\n\n그런 다음 요구 사항 파일을 코드베이스에서 Docker 이미지로 복사합니다. 이를 통해 pip를 사용하여 요구 사항을 설치할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 다음으로, API에 대한 모든 코드를 복사합니다.\n\n참고: Python 패키지를 먼저 복사하고 설치했습니다. 이렇게 함으로써 요구 사항의 설치를 캐시할 수 있습니다. 개발 중에 빠르게 Docker 이미지를 실행할 때 의존성을 설치하는 데 몇 분을 기다릴 필요가 없도록 도와줍니다.\n\n마지막으로, 개발 중에 API를 실행할 때 지역에서 실행했던 것과 동일한 기본 명령을 지정합니다.\n\n## 단계 3: Google Cloud에 배포\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 시점에서 우리는 Docker 이미지를 빌드하고 Docker Hub에 푸시하여 여러 다른 클라우드 서비스에 쉽게 배포할 수 있습니다. 하지만 여기서는 대안 전략을 따를 거에요.\n\n대신에, 우리 모든 코드를 GitHub에 푸시할 거에요. 그럼 바로 이 코드를 Google Cloud Run에 컨테이너 배포할 수 있어요. 이 방법에는 두 가지 주요 장점이 있어요.\n\n첫째로, 로컬 시스템과 Google Cloud Run이 사용하는 시스템 아키텍처 간의 차이를 해결하느라 시간을 들일 필요가 없어요 (특히 저는 Mac이 ARM64로 동작하기 때문에 이 문제가 있었어요). 둘째로, GitHub 리포지토리에서 배포함으로써 지속적인 배포가 가능해져요. 그래서 API를 업데이트하고 싶다면, 그냥 새 코드를 리포지토리에 푸시하면 새 컨테이너가 자동적으로 생성돼요.\n\n우리는 새 GitHub 리포지토리를 만들면서 시작해볼게요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_3.png\" /\u003e\n\n이제 리포지토리를 복제하고 코드를 추가한 후 GitHub로 푸시합니다. 코드를 추가한 후 디렉토리 구조는 다음과 같이 보입니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_4.png\" /\u003e\n\n코드가 준비되었으면 새 Google Cloud Platform 프로젝트를 만들 수 있습니다. GCP 콘솔로 이동하여 프로젝트 목록을 클릭한 다음 \"새 프로젝트\"를 선택하여 진행합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_5.png\" /\u003e\n\n프로젝트가 생성되면 해당 프로젝트를 열고 검색 창에 \"cloud run\"을 입력할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_6.png\" /\u003e\n\n그것을 열면 \"CREAT SERVICE\"를 클릭할 것입니다. 이렇게 하면 서비스를 구성할 수 있는 페이지가 열립니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저 GitHub에서 서비스를 배포할 옵션을 선택합니다. 그런 다음 \"CLOUD BUILD로 설정\"을 클릭하세요.\n\n[이미지](/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_7.png)\n\n저장소 소스로는 GitHub을 선택하고 방금 만든 저장소를 선택합니다.\n\n[이미지](/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_8.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지점을 ^main$으로 유지하고 \"Build Type\"을 Dockerfile로 선택합니다.\n\n![이미지](/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_9.png)\n\n다음으로, 서비스 구성 화면으로 돌아갑니다. 서비스의 이름을 마음대로 지정할 수 있습니다 (저는 자동 생성된 이름을 그대로 두겠습니다). 지역은 us-central1로 남겨두겠습니다. 이 지역은 가장 저렴한 컴퓨팅 옵션을 제공하는 Tier 1이기 때문에 이 예시에서는 무료입니다.\n\n간단히 유지하려면 \"인증되지 않은 호출 허용\"을 선택합니다. 물론 대부분의 시스템에는 인증이 필요할 것입니다. 그런 다음, 나머지를 기본값으로 남겨둡니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 \"컨테이너, 볼륨, 네트워킹, 보안\" 아래에서 컨테이너를 편집하여 1 GiB의 메모리를 할당하세요. Dockerfile에서 구성한 대로 PORT가 8080으로 설정되어 있기 때문에 이것을 변경하시면 안 됩니다.\n\n나머지 설정은 기본값으로 그대로 두고 화면 아래의 \"생성\"을 클릭하세요. 수 분 후 컨테이너가 활성화될 것입니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_12.png)\n\n그런 다음 페이지 상단 근처에 지정된 URL을 사용하여 API에 액세스할 수 있습니다. 링크를 클릭하면 루트 엔드포인트가 열립니다. 이 엔드포인트는 건강 상태 확인이었습니다.\n\n![image](/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_13.png)\n\n다음 URL을 사용하여 검색 API에 대한 GET 요청을 수동으로 실행할 수 있습니다: [여기에 앱의 URL 입력]/search?query=LLMs. 이를 통해 LLMs와 관련된 비디오를 검색할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_14.png\" /\u003e\n\n## 보너스: UI에 통합하기\n\nAPI 백엔드를 설정한 후, 사용자 친화적 인터페이스에 연결할 수 있습니다. 저는 Hugging Face Spaces를 통해 이를 수행합니다. 이 곳은 완전히 무료로 ML 앱을 호스팅합니다.\n\n이것이 같은 검색이 UI를 통해 어떻게 보이는지입니다. 여기서 UI를 테스트하고 코드를 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*St0OCAxBpqORc95WDpq4Pg.gif)\n\n# 결론\n\n데이터 과학은 멋진 모델을 훈련시키는 것 이상의 의미를 가지고 있습니다. 문제를 해결하고 가치를 창출하는 것이 중요합니다. 종종, 이를 위해서는 모델을 배포하여 최대 효과를 발휘할 수 있는 환경으로 이전해야 합니다. 여기에서는 FastAPI, Docker 및 GCP를 사용하여 ML 모델을 배포하는 간단한 3단계 전략을 살펴보았습니다.\n\n풀 스택 데이터 과학 시리즈를 마치는 글이지만, 이 글들은 이 검색 도구를 생성하는 과정에 관련된 실험에 대한 보너스 비디오가 포함된 YouTube 플레이리스트와 함께 제공됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFull Stack Data Science에 관해 더 알아보기 👇\n\n# 자료\n\n연결하기: [내 웹사이트](링크) | 전화 상담 예약\n\n소셜 미디어: [YouTube 🎥](링크) | [LinkedIn](링크) | [Twitter](링크)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSupport: 커피 한 잔 사주세요 ☕️\n","ogImage":{"url":"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_0.png","tag":["Tech"],"readingTime":16},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003eFull Stack Data Science의 시리즈 중 5번째 기사입니다. 이 기사에서는 ML 기반 검색 API의 배포 방법을 안내합니다. 무수히 많은 방법으로 수행할 수 있지만, 여기에서는 거의 모든 머신 러닝 솔루션에 적용할 수 있는 간단한 3단계 접근법에 대해 설명합니다. 예시 코드는 GitHub 저장소에서 자유롭게 이용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e머신 러닝이 모델 훈련에 관한 멋진 모델만이 아니라는 것을 생각하면, 실제로 모델 스스로는 가치를 만들어내지 않습니다. ML 모델을 ML 솔루션(즉, 가치 있는 것)으로 만들기 위해 \"배포\"해야 합니다.\u003c/p\u003e\n\u003cp\u003e이를 다양한 형태로 구현할 수 있습니다. 예를 들어 사용자가 모델과 상호 작용할 수 있는 웹 인터페이스를 생성하거나, 기존 소프트웨어 시스템에 모델을 통합하거나, 개발자가 모델에 액세스할 수 있는 API를 설정하는 것 등이 있습니다 (OpenAI와 같은 사례를 생각해보세요).\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e여기서 설명하는 3단계 전략은 모든 예제와 호환됩니다. 이는 다음으로 구성됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e추론 API 생성 (FastAPI 사용)\u003c/li\u003e\n\u003cli\u003eAPI 컨테이너화 (도커를 통해)\u003c/li\u003e\n\u003cli\u003e클라우드 플랫폼에서 컨테이너 실행 (여기서는 GCP 사용)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eFastAPI\u003c/h1\u003e\n\u003cp\u003e이 배포 전략의 첫 번째 단계는 모델을 API(즉, 응용 프로그램 프로그래밍 인터페이스)로 랩핑하는 것입니다. 간단히 말해, API를 사용하면 응용 프로그램과 프로그래밍 방식으로 상호 작용할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e첫 번째 단계를 수행하는 한 가지 방법은 파이썬 함수를 API 엔드포인트로 변환하는 매우 쉬운 방법을 제공하는 Python 라이브러리인 FastAPI를 사용하는 것입니다. 아래 코드는 구체적인 예제를 제공합니다.\u003c/p\u003e\n\u003ch2\u003eDocker\u003c/h2\u003e\n\u003cp\u003e우리의 추론 API를 직접 클라우드에 배포할 수 있지만, 먼저 \"컨테이너화\"하는 것이 좋습니다. 이때 Docker가 필요합니다.\u003c/p\u003e\n\u003cp\u003eDocker를 사용하면 API의 종속성을 모두 포함하는 가벼운 래퍼를 생성할 수 있어서 새로운 컴퓨터에서 더 쉽게 구동할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e작업은 2 단계 프로세스를 통해 수행됩니다. 첫째, 우리는 Docker 이미지를 생성합니다. 이는 기본적으로 시스템에 API를 제로에서 어떻게 구동할지 알려주는 레시피입니다 (걱정하지 마세요, 만들기 쉽습니다). 둘째, Docker가 설치된 시스템에서 이미지를 실행할 수 있습니다. 실행 중인 이미지를 컨테이너라고 하며, 이는 더 큰 시스템에 있는 작은 가상 머신과 같습니다.\u003c/p\u003e\n\u003ch1\u003eGoogle Cloud Run\u003c/h1\u003e\n\u003cp\u003e마지막으로, Docker 이미지를 실행할 컴퓨팅 리소스가 필요합니다. 물론 노트북에서 이 작업을 수행할 수도 있지만 (아마 좋은 아이디어는 아닙니다), 온프레미스 서버나 클라우드 제공업체를 통해 이를 수행할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e여기서는 Google Cloud Run을 사용하여 Docker 컨테이너를 실행하는 GCP 서비스를 사용합니다. 이 서비스에는 무료 티어도 있으므로 불필요한 비용이 발생하지 않고 프로젝트를 배포할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e예시 코드: 시맨틱 검색 API 배포하기\u003c/h1\u003e\n\u003cp\u003e기본 개념을 이해했으니, 실제 코드에서 이 프로세스가 어떻게 보이는지 살펴봅시다. 아래 예시는 이 시리즈의 이전 기사들을 바탕으로 구축되었으며, 제 유튜브 비디오의 제목과 대본을 가져와 텍스트 임베딩으로 변환한 것을 사용합니다.\u003c/p\u003e\n\u003cp\u003e간단히 말해, 텍스트 임베딩은 텍스트의 의미론적인 의미 있는 숫자 표현으로, 새로운 종류의 검색(시맨틱 검색이라고도 함)을 가능하게 합니다.\u003c/p\u003e\n\u003cp\u003e여기에서는 제 유튜브 비디오의 모든 제목과 대본에 대한 시맨틱 검색 시스템을 위한 API를 구축하고 배포할 것입니다. 이 API는 Hugging Face spaces에서 실행되는 실시간 검색 애플리케이션의 백엔드입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 앱의 백엔드와 프론트엔드의 코드 저장소가 모두 무료로 제공됩니다.\u003c/p\u003e\n\u003ch2\u003e단계 1: API 만들기\u003c/h2\u003e\n\u003cp\u003eFastAPI를 사용하면 기존의 Python 스크립트를 몇 줄의 추가 코드로 API로 변환하는 것이 매우 쉽습니다. 이게 바로 그 모습입니다.\u003c/p\u003e\n\u003cp\u003e먼저 유용한 라이브러리를 import할 거에요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e fastapi \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFastAPI\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e polars \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pl\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e sentence_transformers \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSentenceTransformer\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e sklearn.\u003cspan class=\"hljs-property\"\u003emetrics\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDistanceMetric\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e numpy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e np\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e app.\u003cspan class=\"hljs-property\"\u003efunctions\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e returnSearchResultIndexes\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 우리는 시맨틱 검색 기능의 구성 요소를 정의할 겁니다. 구체적으로 텍스트 임베딩 모델, 우리가 검색하려는 비디오들의 제목 및 대본 임베딩, 그리고 사용자 쿼리에 가장 관련성 높은 비디오를 평가하는 거리 측정 기준입니다. 시맨틱 검색에 대해 더 깊게 알아보고 싶다면, 이에 대해 이전에 다룬 글을 참조해주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# define model info\nmodel_name = \u003cspan class=\"hljs-string\"\u003e'all-MiniLM-L6-v2'\u003c/span\u003e\n\n# load model\nmodel = \u003cspan class=\"hljs-title class_\"\u003eSentenceTransformer\u003c/span\u003e(model_name)\n\n# load video index\ndf = pl.\u003cspan class=\"hljs-title function_\"\u003escan_parquet\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'app/data/video-index.parquet'\u003c/span\u003e)\n\n# create distance metric object\ndist_name = \u003cspan class=\"hljs-string\"\u003e'manhattan'\u003c/span\u003e\ndist = \u003cspan class=\"hljs-title class_\"\u003eDistanceMetric\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget_metric\u003c/span\u003e(dist_name)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 API 작업을 정의합니다. 여기서 3개의 GET 요청을 생성할 것입니다. 첫 번째 요청은 아래 코드 블록에 표시되어 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-comment\"\u003e# FastAPI 객체 생성\u003c/span\u003e\napp = FastAPI()\n\n\u003cspan class=\"hljs-comment\"\u003e# API 동작\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@app.get(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e\u003c/span\u003e)\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehealth_check\u003c/span\u003e():\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\u003cspan class=\"hljs-string\"\u003e'health_check'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'OK'\u003c/span\u003e}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 블록에서는 FastAPI() 클래스를 사용하여 새 FastAPI 애플리케이션을 초기화하고 \"health check\" 엔드포인트를 만듭니다.\u003c/p\u003e\n\u003cp\u003e이를 위해 입력이 없고 \"health_check\" 키와 값이 \"OK\"인 사전을 반환하는 Python 함수를 정의합니다. 이 함수를 API 엔드포인트로 변환하려면 단순히 데코레이터를 추가하고 엔드포인트의 경로를 지정하면 됩니다. 여기서는 루트인 즉, \"/\"를 사용합니다.\u003c/p\u003e\n\u003cp\u003e또 다른 예제를 살펴보겠습니다. 여기서는 API에 대한 자세한 정보를 반환하는 info라는 엔드포인트가 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@app.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/info\"\u003c/span\u003e)\ndef \u003cspan class=\"hljs-title function_\"\u003einfo\u003c/span\u003e():\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'yt-search'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'description'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Shaw Talebi의 YouTube 비디오를 검색하는 API입니다.\"\u003c/span\u003e}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 엔드포인트는 헬스 체크와 매우 유사한 것을 볼 수 있습니다. 그러나 이것은 \"/info\" 엔드포인트에 위치합니다.\u003c/p\u003e\n\u003cp\u003e마지막으로 사용자 쿼리를 받아 가장 관련 있는 비디오의 제목과 ID를 반환하는 검색 엔드포인트를 만들어 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@app.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/search\"\u003c/span\u003e)\ndef \u003cspan class=\"hljs-title function_\"\u003esearch\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003equery\u003c/span\u003e: str):\n    idx_result = \u003cspan class=\"hljs-title function_\"\u003ereturnSearchResultIndexes\u003c/span\u003e(query, df, model, dist)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e df.\u003cspan class=\"hljs-title function_\"\u003eselect\u003c/span\u003e([\u003cspan class=\"hljs-string\"\u003e'title'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'video_id'\u003c/span\u003e]).\u003cspan class=\"hljs-title function_\"\u003ecollect\u003c/span\u003e()[idx_result].\u003cspan class=\"hljs-title function_\"\u003eto_dict\u003c/span\u003e(as_series=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 엔드포인트에는 입력이 필요합니다: 사용자의 쿼리입니다. 이 쿼리는 다른 스크립트에 정의된 또 다른 Python 함수로 전달됩니다. 이 함수는 검색에 대한 모든 수학 연산을 수행합니다. 여기서 자세히 다루지는 않겠지만, 궁금한 독자는 코드를 GitHub에서 볼 수도 있고 YouTube에서 검색 함수의 코드 설명을 볼 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e이 함수는 검색 결과의 행 번호만 df 데이터프레임에서 반환하므로, 우리는 이 출력을 사용하여 관심 있는 제목과 비디오 ID를 가져와서 이를 Python 사전으로 반환해야 합니다. API 엔드포인트의 모든 출력이 사전이어야 하는데요, 이는 API의 표준 JSON 형식을 준수하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e위 코드 블록에서 설명한대로, 두 개의 외부 파일인 app/functions.py 및 app/data/video-index.parquet을 참조합니다. 이는 다음 디렉토리 구조를 시사합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://example.com/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 API를 로컬에서 실행하려면 루트 디렉토리로 이동하여 다음 명령을 실행할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003euvicorn app.\u003cspan class=\"hljs-property\"\u003emain\u003c/span\u003e:app --host \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e --port \u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003euvicorn은 FastAPI를 사용하여 작성한 웹 애플리케이션을 실행할 수 있게 해주는 파이썬 라이브러리입니다. 이 명령은 이 API를 로컬에서 \u003ca href=\"http://0.0.0.0:8080%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://0.0.0.0:8080에서\u003c/a\u003e 실행합니다. 나중에 Google Cloud Run에 배포할 때 이 호스트와 포트를 사용하는 이유를 나준내게 될 것입니다.\u003c/p\u003e\n\u003ch2\u003e단계 2: 도커 이미지 생성\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우와, 우리 API가 로컬에서 작동하고 있어요! 이제 클라우드에서 실행할 수 있도록 다음 단계를 진행해 봐요.\u003c/p\u003e\n\u003cp\u003e이를 위해서 API용 Docker 이미지를 생성할 거에요. 이를 위해 Dockerfile, requirements.txt, 그리고 app/\u003cstrong\u003einit\u003c/strong\u003e.py 이 3가지 파일을 만들어야 해요. 우리 디렉토리는 아래와 같이 보여야 해요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eDockerfile은 Docker 이미지를 실행하는 단계별 지침을 포함하고 있어요. requirements.txt는 API를 실행하는 데 필요한 Python 라이브러리(버전 포함)를 지정해요. 마지막으로 app/\u003cstrong\u003einit\u003c/strong\u003e.py 파일은 app 폴더를 Python 패키지로 지정해주어, 컨테이너에서 실행될 때 Python이 API 코드를 찾고 적절하게 가져올 수 있도록 해줘요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다음은 Dockerfile 내부의 내용입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# python 기본 이미지에서 시작\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epython\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e3.10\u003c/span\u003e-slim\n\n# 작업 디렉토리 변경\n\u003cspan class=\"hljs-variable constant_\"\u003eWORKDIR\u003c/span\u003e /code\n\n# 요구 사항 파일을 이미지에 추가\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e ./requirements.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e /code/requirements.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e\n\n# \u003cspan class=\"hljs-title class_\"\u003ePython\u003c/span\u003e 라이브러리 설치\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e pip install --no-cache-dir --upgrade -r /code/requirements.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e\n\n# \u003cspan class=\"hljs-title class_\"\u003ePython\u003c/span\u003e 코드 추가\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e ./app/ \u003cspan class=\"hljs-regexp\"\u003e/code/\u003c/span\u003eapp/\n\n# 기본 명령어 지정\n\u003cspan class=\"hljs-variable constant_\"\u003eCMD\u003c/span\u003e [\u003cspan class=\"hljs-string\"\u003e\"uvicorn\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"app.main:app\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"--host\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"0.0.0.0\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"--port\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"8080\"\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e첫 번째 줄은 기존에 Python 3.10이 설치된 이미지 위에 저희의 이미지를 부트스트랩합니다. 다음으로 작업 디렉토리를 루트에서 /code로 변경합니다.\u003c/p\u003e\n\u003cp\u003e그런 다음 요구 사항 파일을 코드베이스에서 Docker 이미지로 복사합니다. 이를 통해 pip를 사용하여 요구 사항을 설치할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그 다음으로, API에 대한 모든 코드를 복사합니다.\u003c/p\u003e\n\u003cp\u003e참고: Python 패키지를 먼저 복사하고 설치했습니다. 이렇게 함으로써 요구 사항의 설치를 캐시할 수 있습니다. 개발 중에 빠르게 Docker 이미지를 실행할 때 의존성을 설치하는 데 몇 분을 기다릴 필요가 없도록 도와줍니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, 개발 중에 API를 실행할 때 지역에서 실행했던 것과 동일한 기본 명령을 지정합니다.\u003c/p\u003e\n\u003ch2\u003e단계 3: Google Cloud에 배포\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 시점에서 우리는 Docker 이미지를 빌드하고 Docker Hub에 푸시하여 여러 다른 클라우드 서비스에 쉽게 배포할 수 있습니다. 하지만 여기서는 대안 전략을 따를 거에요.\u003c/p\u003e\n\u003cp\u003e대신에, 우리 모든 코드를 GitHub에 푸시할 거에요. 그럼 바로 이 코드를 Google Cloud Run에 컨테이너 배포할 수 있어요. 이 방법에는 두 가지 주요 장점이 있어요.\u003c/p\u003e\n\u003cp\u003e첫째로, 로컬 시스템과 Google Cloud Run이 사용하는 시스템 아키텍처 간의 차이를 해결하느라 시간을 들일 필요가 없어요 (특히 저는 Mac이 ARM64로 동작하기 때문에 이 문제가 있었어요). 둘째로, GitHub 리포지토리에서 배포함으로써 지속적인 배포가 가능해져요. 그래서 API를 업데이트하고 싶다면, 그냥 새 코드를 리포지토리에 푸시하면 새 컨테이너가 자동적으로 생성돼요.\u003c/p\u003e\n\u003cp\u003e우리는 새 GitHub 리포지토리를 만들면서 시작해볼게요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_3.png\"\u003e\n\u003cp\u003e이제 리포지토리를 복제하고 코드를 추가한 후 GitHub로 푸시합니다. 코드를 추가한 후 디렉토리 구조는 다음과 같이 보입니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_4.png\"\u003e\n\u003cp\u003e코드가 준비되었으면 새 Google Cloud Platform 프로젝트를 만들 수 있습니다. GCP 콘솔로 이동하여 프로젝트 목록을 클릭한 다음 \"새 프로젝트\"를 선택하여 진행합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_5.png\"\u003e\n\u003cp\u003e프로젝트가 생성되면 해당 프로젝트를 열고 검색 창에 \"cloud run\"을 입력할 수 있습니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_6.png\"\u003e\n\u003cp\u003e그것을 열면 \"CREAT SERVICE\"를 클릭할 것입니다. 이렇게 하면 서비스를 구성할 수 있는 페이지가 열립니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e먼저 GitHub에서 서비스를 배포할 옵션을 선택합니다. 그런 다음 \"CLOUD BUILD로 설정\"을 클릭하세요.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_7.png\"\u003e이미지\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e저장소 소스로는 GitHub을 선택하고 방금 만든 저장소를 선택합니다.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_8.png\"\u003e이미지\u003c/a\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e지점을 ^main$으로 유지하고 \"Build Type\"을 Dockerfile로 선택합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_9.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e다음으로, 서비스 구성 화면으로 돌아갑니다. 서비스의 이름을 마음대로 지정할 수 있습니다 (저는 자동 생성된 이름을 그대로 두겠습니다). 지역은 us-central1로 남겨두겠습니다. 이 지역은 가장 저렴한 컴퓨팅 옵션을 제공하는 Tier 1이기 때문에 이 예시에서는 무료입니다.\u003c/p\u003e\n\u003cp\u003e간단히 유지하려면 \"인증되지 않은 호출 허용\"을 선택합니다. 물론 대부분의 시스템에는 인증이 필요할 것입니다. 그런 다음, 나머지를 기본값으로 남겨둡니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 \"컨테이너, 볼륨, 네트워킹, 보안\" 아래에서 컨테이너를 편집하여 1 GiB의 메모리를 할당하세요. Dockerfile에서 구성한 대로 PORT가 8080으로 설정되어 있기 때문에 이것을 변경하시면 안 됩니다.\u003c/p\u003e\n\u003cp\u003e나머지 설정은 기본값으로 그대로 두고 화면 아래의 \"생성\"을 클릭하세요. 수 분 후 컨테이너가 활성화될 것입니다!\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_12.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e그런 다음 페이지 상단 근처에 지정된 URL을 사용하여 API에 액세스할 수 있습니다. 링크를 클릭하면 루트 엔드포인트가 열립니다. 이 엔드포인트는 건강 상태 확인이었습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_13.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e다음 URL을 사용하여 검색 API에 대한 GET 요청을 수동으로 실행할 수 있습니다: [여기에 앱의 URL 입력]/search?query=LLMs. 이를 통해 LLMs와 관련된 비디오를 검색할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_14.png\"\u003e\n\u003ch2\u003e보너스: UI에 통합하기\u003c/h2\u003e\n\u003cp\u003eAPI 백엔드를 설정한 후, 사용자 친화적 인터페이스에 연결할 수 있습니다. 저는 Hugging Face Spaces를 통해 이를 수행합니다. 이 곳은 완전히 무료로 ML 앱을 호스팅합니다.\u003c/p\u003e\n\u003cp\u003e이것이 같은 검색이 UI를 통해 어떻게 보이는지입니다. 여기서 UI를 테스트하고 코드를 확인할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1200/1*St0OCAxBpqORc95WDpq4Pg.gif\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e데이터 과학은 멋진 모델을 훈련시키는 것 이상의 의미를 가지고 있습니다. 문제를 해결하고 가치를 창출하는 것이 중요합니다. 종종, 이를 위해서는 모델을 배포하여 최대 효과를 발휘할 수 있는 환경으로 이전해야 합니다. 여기에서는 FastAPI, Docker 및 GCP를 사용하여 ML 모델을 배포하는 간단한 3단계 전략을 살펴보았습니다.\u003c/p\u003e\n\u003cp\u003e풀 스택 데이터 과학 시리즈를 마치는 글이지만, 이 글들은 이 검색 도구를 생성하는 과정에 관련된 실험에 대한 보너스 비디오가 포함된 YouTube 플레이리스트와 함께 제공됩니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eFull Stack Data Science에 관해 더 알아보기 👇\u003c/p\u003e\n\u003ch1\u003e자료\u003c/h1\u003e\n\u003cp\u003e연결하기: \u003ca href=\"%EB%A7%81%ED%81%AC\"\u003e내 웹사이트\u003c/a\u003e | 전화 상담 예약\u003c/p\u003e\n\u003cp\u003e소셜 미디어: \u003ca href=\"%EB%A7%81%ED%81%AC\"\u003eYouTube 🎥\u003c/a\u003e | \u003ca href=\"%EB%A7%81%ED%81%AC\"\u003eLinkedIn\u003c/a\u003e | \u003ca href=\"%EB%A7%81%ED%81%AC\"\u003eTwitter\u003c/a\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eSupport: 커피 한 잔 사주세요 ☕️\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP"},"buildId":"T_Nz0g9U1yttYMSEma95P","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>