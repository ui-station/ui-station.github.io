<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>라즈베리 파이로 쿠버네티스 클러스터 구축 가이드 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="라즈베리 파이로 쿠버네티스 클러스터 구축 가이드 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="라즈베리 파이로 쿠버네티스 클러스터 구축 가이드 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis" data-gatsby-head="true"/><meta name="twitter:title" content="라즈베리 파이로 쿠버네티스 클러스터 구축 가이드 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-18 19:08" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-561ae49ab5aab7f5.js" defer=""></script><script src="/_next/static/ll1cGyplNwh83dpggeai1/_buildManifest.js" defer=""></script><script src="/_next/static/ll1cGyplNwh83dpggeai1/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">라즈베리 파이로 쿠버네티스 클러스터 구축 가이드</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="라즈베리 파이로 쿠버네티스 클러스터 구축 가이드" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 18, 2024</span><span class="posts_reading_time__f7YPP">15<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p>몇 년 전에 라즈베리 파이에서 Kubernetes 클러스터를 세팅했었어요. 당시 라즈베리 파이의 ARM 아키텍처는 몇 가지 어려움을 야기했죠. ARM을 지원하는 애플리케이션을 찾는 건 어려운 과제였는데, 그래서 필요한 애플리케이션과 컨테이너를 직접 빌드해야 했던 적이 많았어요.</p>
<p>그런데 그 이후로 상황이 크게 개선되었어요! 새로운 64비트 라즈베리 파이 OS의 등장과 ARM의 저렴함으로 클라우드 배포에 많이 사용되는 산업에서의 인기 상승으로, 라즈베리 파이 클러스터 구축이 훨씬 간단해졌어요. 저는 클러스터를 다시 구축하기로 결정했고, 64비트 OS 및 최신 버전의 Kubernetes와 Docker로 업데이트했어요.</p>
<p>여러분이 자체 라즈베리 파이 Kubernetes 클러스터를 설정하는 방법에 대한 가이드를 작성했어요. 집에서 클러스터를 구축하는 여정에 유용하길 바랍니다! 🚀</p>
<h1>요구 사항</h1>
<div class="content-ad"></div>
<p>클러스터를 설정하기 위해서는 하드웨어가 필요합니다. 필요한 것들은 다음과 같아요:</p>
<ul>
<li>라즈베리 파이(저는 4 모델 B를 사용했어요)</li>
<li>SD 카드 1장 / 라즈베리 파이</li>
<li>이더넷 케이블 1개 / 라즈베리 파이</li>
<li>라우터 및/또는 네트워크 스위치</li>
<li>USB 허브</li>
<li>(선택 사항) 케이스</li>
</ul>
<p>이 안내서는 Kubernetes 1.26.6, Docker 24.0.2 및 라즈베리 파이 Lite(64비트) 불자이에 맞춰 작성되었어요.</p>
<h1>OS 설정</h1>
<div class="content-ad"></div>
<p>첫 번째 단계는 모든 Raspberry Pi에 OS를 설정해야 합니다. 그렇지 않으면 Raspberry Pi는 기본적으로 부팅할 시스템이 없습니다.</p>
<p>Raspberry Pi Imager를 다운로드하십시오. 이 편리한 애플리케이션은 Raspberry Pi의 다운로드와 플래싱에 사용됩니다. 이 가이드에서는 Raspberry Pi OS (Debian의 파생 버전)의 64비트 헤드리스 버전을 사용할 것입니다.</p>
<p>최신 Raspberry Pi와 호환되는지 확인한 후에 SD 카드를 플래싱해야 합니다.</p>
<p><img src="/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_0.png" alt="Raspberry Pi Imager"/></p>
<div class="content-ad"></div>
<p>SD 카드를 선택하고 OS를 플래싱하기 시작하세요. 모든 SD 카드에 대해 이 작업을 완료할 때까지 반복해주세요.</p>
<h2>SSH 활성화 및 기본 사용자 생성</h2>
<p>각 Pi를 원격으로 구성할 수 있게끔 SSH를 설정해야 합니다.</p>
<p>SSH를 활성화하려면 SD 카드의 부트 파티션에 확장자 없이 ssh라는 빈 파일을 생성하세요.</p>
<div class="content-ad"></div>
<p>로그인 사용자를 설정하기 위해, SD 카드의 부팅 파티션에 userconf라는 파일을 생성하세요. 이 파일은 &#x27;name&#x27;:&#x27;encrypted-password&#x27;로 구성된 텍스트 한 줄을 포함해야 합니다. 로그인 사용자로 노드를 사용했지만 원하는 대로 사용하셔도 됩니다.</p>
<p>encrypted-password를 생성하려면 다음 명령을 OpenSSL과 함께 실행하세요:</p>
<pre><code class="hljs language-js">echo <span class="hljs-string">&#x27;{password}&#x27;</span> | openssl passwd -<span class="hljs-number">6</span> -stdin
</code></pre>
<p>파일을 저장하고 SD 카드를 제거하세요. 그리고 라즈베리 파이에 SD 카드를 삽입하고 전원을 켜세요. 개인 네트워크의 라우터나 네트워크 스위치에 연결되어 있는지 확인하세요.</p>
<div class="content-ad"></div>
<h1>첫 번째 부팅 및 초기 구성</h1>
<p>라즈베리 파이의 IP를 얻어야 합니다. 이를 위해 라우터를 확인할 수 있습니다. 제 경우, OpenWrt를 사용하며 DHCP 설정에서 기억하기 쉬운 정적 IP를 만듭니다.</p>
<p><img src="/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_1.png" alt="image"/></p>
<p>첫 번째 노드에 SSH로 연결합니다. 이 노드는 클러스터의 제어 평면을 실행하는 마스터 노드가 됩니다. 라즈베리 파이로 터널링한 후에 설정을 시작할 수 있습니다!</p>
<div class="content-ad"></div>
<p>다음 명령어를 사용하여 사용자를 sudo 그룹에 추가해주세요.</p>
<pre><code class="hljs language-js">sudo usermod -aG sudo node
</code></pre>
<p>이제 rasp-config를 업데이트하여 node 사용자로 자동 부팅하도록 설정해봅시다.</p>
<pre><code class="hljs language-js">sudo raspi-config
</code></pre>
<div class="content-ad"></div>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*XG-oT3YeryzngA-Xv3JY9w.gif" alt="image"/></p>
<p>“System Options” → “Boot / Auto Login” 으로 이동하여 “Console Autologin”을 선택해주세요.</p>
<h1>Docker &amp; Kubernetes 초기 설정</h1>
<p>기본적으로 cgroup 메모리 옵션이 비활성화되어 있으므로 Docker가 메모리 사용량을 제한할 수 있도록 업데이트해야 합니다. /boot/cmdline.txt를 열고 cgroup_enable=memory cgroup_memory=1을 추가해주세요.</p>
<div class="content-ad"></div>
<p>이제 우리의 apt 저장소를 업데이트하고 Kubernetes 저장소를 포함시킬 차례입니다.</p>
<pre><code class="hljs language-js">curl -s <span class="hljs-attr">https</span>:<span class="hljs-comment">//packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -</span>
echo <span class="hljs-string">&quot;deb http://apt.kubernetes.io/ kubernetes-xenial main&quot;</span> | sudo tee -a /etc/apt/sources.<span class="hljs-property">list</span>.<span class="hljs-property">d</span>/kubernetes.<span class="hljs-property">list</span>
sudo apt update &amp;&amp; sudo apt upgrade -y
</code></pre>
<p>Docker 설치:</p>
<pre><code class="hljs language-js">curl -sSL <span class="hljs-attr">https</span>:<span class="hljs-comment">//get.docker.com | sh</span>
sudo usermod -aG docker node
</code></pre>
<div class="content-ad"></div>
<p>Kubernetes 1.20부터는 dockershim이 폐기되고 있습니다. Mirantis에서 제공하는 cri-dockerd라는 클러스터용 오픈 소스 CRI를 사용할 수 있습니다. cri-dockerd를 설치하고 서비스를 설정하려면 다음 명령을 실행하세요:</p>
<pre><code class="hljs language-js">wget <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/Mirantis/cri-dockerd/releases/download/v0.3.4/cri-dockerd-0.3.4.arm64.tgz</span>
tar -xvzf cri-dockerd-<span class="hljs-number">0.3</span><span class="hljs-number">.4</span>.<span class="hljs-property">arm64</span>.<span class="hljs-property">tgz</span>
sudo mv cri-dockerd/cri-dockerd /usr/bin/cri-dockerd
sudo chmod +x /usr/bin/cri-dockerd
wget <span class="hljs-attr">https</span>:<span class="hljs-comment">//raw.githubusercontent.com/Mirantis/cri-dockerd/master/packaging/systemd/cri-docker.service</span>
wget <span class="hljs-attr">https</span>:<span class="hljs-comment">//raw.githubusercontent.com/Mirantis/cri-dockerd/master/packaging/systemd/cri-docker.socket</span>
sudo mv cri-docker.<span class="hljs-property">service</span> /etc/systemd/system/
sudo mv cri-docker.<span class="hljs-property">socket</span> /etc/systemd/system/
sudo systemctl enable cri-docker.<span class="hljs-property">service</span>
sudo systemctl enable cri-docker.<span class="hljs-property">socket</span>
sudo systemctl start cri-docker.<span class="hljs-property">service</span>
sudo systemctl start cri-docker.<span class="hljs-property">socket</span>
</code></pre>
<p>Kubernetes 스케줄러를 위해 노드에서 swap을 비활성화하는 것이 권장됩니다.</p>
<pre><code class="hljs language-js">sudo apt-get update &amp;&amp; sudo apt-get install dphys-swapfile &amp;&amp; sudo dphys-swapfile swapoff &amp;&amp; sudo dphys-swapfile uninstall &amp;&amp; sudo systemctl disable dphys-swapfile
</code></pre>
<div class="content-ad"></div>
<p>만약 cri-dockerd 설정에 문제가 발생하면, 이 안내서를 확인해보세요. 처음에 작성했을 때와 달라진 사항이 있을 수 있어요.</p>
<p>마지막으로, Kubernetes를 설치해봅시다!</p>
<pre><code class="hljs language-js">sudo apt install -y kubelet=<span class="hljs-number">1.26</span><span class="hljs-number">.6</span>-<span class="hljs-number">00</span> kubeadm=<span class="hljs-number">1.26</span><span class="hljs-number">.6</span>-<span class="hljs-number">00</span> kubectl=<span class="hljs-number">1.26</span><span class="hljs-number">.6</span>-<span class="hljs-number">00</span>
sudo apt-mark hold kubelet kubeadm kubectl
</code></pre>
<p>이 가이드에서는 모든 것이 1.26.6에서 작동하는지 테스트했어요. 1.24 이전 버전은 정상적으로 작동하지 않을 거예요. 이러한 패키지를 업데이트되지 않도록 표시할 거에요.</p>
<div class="content-ad"></div>
<p>차선으로, 랜처 랩스에서 만든 k3s는 가벼운 옵션으로 좋은 선택일 것입니다. 그 중 일부 장점은 작은 실행 파일 크기, 매우 낮은 자원 요구 사항 및 ARM용으로 최적화되어 있다는 것입니다. 이 가이드에서는 이를 테스트해보지 않았지만, 이후에 비슷한 설정이 될 것으로 생각합니다.</p>
<p>이제 클러스터를 초기화할 시간입니다. 이를 위해 InitConfiguration 및 ClusterConfiguration 설정이 포함된 파일을 만들겠습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-attr">apiVersion</span>: kubeadm.<span class="hljs-property">k8s</span>.<span class="hljs-property">io</span>/v1beta3
<span class="hljs-attr">bootstrapTokens</span>:
- <span class="hljs-attr">groups</span>:
  - <span class="hljs-attr">system</span>:<span class="hljs-attr">bootstrappers</span>:<span class="hljs-attr">kubeadm</span>:<span class="hljs-keyword">default</span>-node-token
  <span class="hljs-attr">token</span>: {token}
  <span class="hljs-attr">usages</span>:
  - signing
  - authentication
<span class="hljs-attr">kind</span>: <span class="hljs-title class_">InitConfiguration</span>
<span class="hljs-attr">localAPIEndpoint</span>:
  <span class="hljs-attr">advertiseAddress</span>: <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.100</span>
  <span class="hljs-attr">bindPort</span>: <span class="hljs-number">6443</span>
<span class="hljs-attr">nodeRegistration</span>:
  <span class="hljs-attr">criSocket</span>: <span class="hljs-attr">unix</span>:<span class="hljs-comment">///var/run/cri-dockerd.sock</span>
  <span class="hljs-attr">imagePullPolicy</span>: <span class="hljs-title class_">IfNotPresent</span>
  <span class="hljs-attr">name</span>: node-<span class="hljs-number">0</span>
---
<span class="hljs-attr">apiVersion</span>: kubeadm.<span class="hljs-property">k8s</span>.<span class="hljs-property">io</span>/v1beta3
<span class="hljs-attr">kind</span>: <span class="hljs-title class_">ClusterConfiguration</span>
<span class="hljs-attr">networking</span>:
  <span class="hljs-attr">podSubnet</span>: <span class="hljs-string">&quot;10.244.0.0/16&quot;</span> # --pod-network-cidr
</code></pre>
<p>이 파일에는 마스터 노드의 설정이 포함되어 있습니다. criSocket이 cri-dockerd를 사용하고, 나중에 네트워크 CIDR을 설정해두었음을 주목하십시오.</p>
<div class="content-ad"></div>
<p>이 노드에서 제어 평면을 초기화하려면 다음을 실행하세요.</p>
<pre><code class="hljs language-js">sudo kubeadm init --config kubeadm-config.<span class="hljs-property">yaml</span>
</code></pre>
<p>이 명령은 새 노드를 클러스터에 추가하는 설정 및 kube-config를 설정하는 방법을 보여줍니다.</p>
<p>명령에서 지시하는 방법에 따라 kube-config를 설정하고, 워크스테이션에 kube-config와 가입 명령을 복사하고 저장하세요. 나중에 필요할 것이니까요!</p>
<div class="content-ad"></div>
<h1>클러스터 네트워킹</h1>
<p>이제 클러스터에서 네트워킹을 설정해야 합니다. Pod들이 노드 간에 서로 통신할 수 있도록 하려면 네트워크 플러그인 (CNI 또는 컨테이너 네트워크 인터페이스로도 불림)이 필요합니다.</p>
<p>네트워크 플러그인은 IP 주소 할당, DNS 해결 및 네트워크 격리와 같은 기능을 Pod에 제공합니다.</p>
<p>우리는 이를 위해 Flannel을 사용할 것입니다.</p>
<div class="content-ad"></div>
<p>마스터 노드에서 다음을 실행해 주세요.</p>
<pre><code class="hljs language-js">kubectl apply -f <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml</span>
</code></pre>
<p>그게 다에요! 이제 마스터 노드가 완료되었으니, 클러스터에 새 노드를 추가하기 시작할 수 있어요. 이전에 출력된 조인 명령을 기억하고 있나요? 이제 그것이 필요할 거에요.</p>
<h1>클러스터에 새로운 노드 추가하기</h1>
<div class="content-ad"></div>
<p>클러스터에 새 노드를 추가하는 것은 꽤 간단합니다. 많은 노드를 추가하는 경우에는 tmux와 같은 도구를 사용하여 세션 명령을 다중화하는 것이 좋습니다.</p>
<p>&quot;첫 번째 부팅 및 초기 설정&quot;을 완료하고 &quot;도커 및 쿠버네티스 초기 설정&quot;을 진행하세요. 서로 다른 Kubernetes 구성 요소를 설치하는 단계 이후에 작업을 중지하세요. 이 시점에서 이전에 실행한 kubeadm join 명령을 실행해야 합니다. cri-socket 및 node-name 옵션을 포함하여 실행해 주세요.</p>
<pre><code class="hljs language-js">sudo kubeadm join <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.100</span>:<span class="hljs-number">6443</span> --token {token} --discovery-token-ca-cert-hash {hash} --cri-socket <span class="hljs-attr">unix</span>:<span class="hljs-comment">///var/run/cri-dockerd.sock --node-name {name}</span>
</code></pre>
<p>이제 마스터 노드에서 클러스터를 모니터링하고 모든 노드가 클러스터에 가입하는지 확인하세요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">&gt; kubectl get nodes를 watch합니다.
이제 귀하의 클러스터가 사용할 준비가 되었습니다! 그러나 <span class="hljs-variable constant_">SSH</span>를 통해가 아닌 워크스테이션에서 액세스하고 싶을 것입니다. 컴퓨터에서 이전에 설정한 kube-config를 설정할 수 있습니다.

기본 kube-config는 관리자 권한을 부여하며 다른 사람과 공유해서는 안됩니다.

먼저 프로필에 구성을 내보냅니다.
</code></pre>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-variable constant_">KUBECONFIG</span>=~<span class="hljs-regexp">/.kube/</span>config
</code></pre>
<p>컨텍스트 설정:</p>
<pre><code class="hljs language-js">kubectl config use-context kubernetes-admin@kubernetes
</code></pre>
<p>이제 원격으로 클러스터에 액세스할 수 있어야 합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">&gt; kubectl cluster-info
쿠버네티스 제어 평면이 <span class="hljs-attr">https</span>:<span class="hljs-comment">//10.0.0.100:6443 에서 실행 중입니다.</span>
<span class="hljs-title class_">CoreDNS</span>이 <span class="hljs-attr">https</span>:<span class="hljs-comment">//10.0.0.100:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy 에서 실행 중입니다.</span>

더 많은 디버깅 및 진단을 위해 <span class="hljs-string">&#x27;kubectl cluster-info dump&#x27;</span>를 사용하세요.
</code></pre>
<h1>도구 설정</h1>
<p>이제 밴자이라 클러스터를 일반에서 멋지게 업그레이드해 봅시다. 새 응용 프로그램을 쉽게 배포하고 클러스터를 모니터링할 수 있는 몇 가지 널리 사용되는 도구를 설정해 보겠습니다. 여기서 ArgoCD, Prometheus 및 Grafana 설치 방법을 안내하겠습니다! 이 세 가지 오픈소스 프로젝트가 우리의 클러스터를 다음 수준으로 끌어올립니다.</p>
<p>계속하기 전에, 이러한 도구들에 대한 모든 설정 변경 사항을 추적하기 위한 원격 git 저장소를 만들어 보시기를 권장합니다. 특히 ArgoCD를 사용할 때, 각 도구나 추가 응용 프로그램을 배포할 때마다 거기를 통해 추가합니다.```</p>
<div class="content-ad"></div>
<h1>ArgoCD</h1>
<p>각 도구에 대해 Helm을 리소스 템플릿팅 도구로 사용할 것입니다. 최신 버전(또는 적어도 Helm v3)을 설치하고 ArgoCD 저장소를 추가해 봅시다.</p>
<pre><code class="hljs language-js">helm repo add argo <span class="hljs-attr">https</span>:<span class="hljs-comment">//argoproj.github.io/argo-helm</span>
</code></pre>
<p>Values 파일을 생성하세요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-yaml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">serviceType:</span> <span class="hljs-string">NodePort</span>
  <span class="hljs-attr">httpNodePort:</span> <span class="hljs-number">30080</span>
  <span class="hljs-attr">httpsNodePort:</span> <span class="hljs-number">30443</span>
</code></pre>
<p>이 파일은 차트의 설정 중 하나를 재정의하는 데 사용할 수 있습니다. 이 경우에는 서비스를 ClusterIP 대신 NodePort로 실행하도록 변경하고 있습니다. 이렇게 하면 클러스터에서 지정한 포트를 외부에서 엑세스할 수 있도록 하여 리버스 프록시를 사용하지 않고도 개인 네트워크에서 해당 서비스에 액세스할 수 있습니다.</p>
<p>서비스를 설치하십시오.</p>
<pre><code class="hljs language-js">helm install argocd -n argocd -f values.<span class="hljs-property">yaml</span> argo/argocd
</code></pre>
<div class="content-ad"></div>
<p>그럼 관리자 사용자의 기본 암호를 가져와야 합니다.</p>
<pre><code class="hljs language-js">kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=<span class="hljs-string">&quot;{.data.password}&quot;</span> | base64 -d
</code></pre>
<p>OpenWrt를 사용하고 있기 때문에 클러스터에 호스트 이름 항목을 설정하고 https://cluster.home:30443에서 로그인 페이지에 액세스할 수 있습니다.</p>
<p><img src="/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_2.png" alt="그림"/></p>
<div class="content-ad"></div>
<p>ArgoCD에 로그인하고, 곧 돌아올게요.</p>
<p><img src="/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_3.png" alt="image"/></p>
<h1>Prometheus</h1>
<p>우리는 클러스터에 대한 정보 수집을 위해 타임 시리즈 메트릭 서버로 Prometheus를 사용할 거에요.</p>
<div class="content-ad"></div>
<p>설치하기 전에 Prometheus가 쿼리 데이터를 저장할 지속적인 볼륨을 설정해야 합니다. 집 클러스터에서는 예비 USB 드라이브를 사용하기로 결정했지만 원하는 것을 연결하여 사용할 수 있습니다.</p>
<p>마스터 노드에서 볼륨을 설정한 단계는 다음과 같습니다. 우리의 볼륨을 위한 경로를 만들고 실수를 막기 위해 변경 사항을 반영해야 할 fstab의 백업을 만듭니다.</p>
<pre><code class="hljs language-js">sudo mkdir /mnt/usb
sudo cp /etc/fstab /etc/fstab.<span class="hljs-property">bak</span>
</code></pre>
<p>장치를 연결한 다음 fstab을 변경 내용과 함께 수정합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-md">/dev/sda1 /mnt/usb vfat defaults,uid=youruid,gid=yourgid,dmask=002,fmask=113 0 0
</code></pre>
<p>이제 우리 노드 사용자의 사용자 및 그룹 설정으로 장치를 마운트합니다.</p>
<pre><code class="hljs language-md">sudo mount -o uid=youruid,gid=yourgid,dmask=002,fmask=113 /dev/sdX1 /mnt/usb
</code></pre>
<p>이제 우리는 PersistentVolume과 PersistentVolumeChain을 가진 Kubernetes 자원을 생성하려고 합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">prometheus-usb-pv</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">local</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">manual</span>
  <span class="hljs-attr">capacity:</span>
    <span class="hljs-attr">storage:</span> {<span class="hljs-string">device의</span> <span class="hljs-string">크기</span>}<span class="hljs-string">Gi</span>
  <span class="hljs-attr">accessModes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span>
  <span class="hljs-attr">persistentVolumeReclaimPolicy:</span> <span class="hljs-string">Retain</span>
  <span class="hljs-attr">hostPath:</span>
    <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;/mnt/usb&quot;</span>
<span class="hljs-meta">---</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">prometheus-usb-pvc</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">manual</span>
  <span class="hljs-attr">accessModes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span>
  <span class="hljs-attr">resources:</span>
    <span class="hljs-attr">requests:</span>
      <span class="hljs-attr">storage:</span> {<span class="hljs-string">device의</span> <span class="hljs-string">크기</span>}<span class="hljs-string">Gi</span>
</code></pre>
<p>만약 git 리포지토리를 사용 중이라면, 이 파일들을 template 디렉토리 안에 새로운 Helm Chart에 위치시켜주세요. 다음 단계를 따라 계속 진행해봐요.</p>
<p>이제 프로메테우스와 함께 차트를 설정해봅시다.</p>
<pre><code class="hljs language-bash">helm create prometheus
</code></pre>
<div class="content-ad"></div>
<p>Chart.yaml에 Prometheus subchart를 종속성으로 추가해주세요.</p>
<pre><code class="hljs language-yaml"><span class="hljs-attr">dependencies:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">prometheus</span>
    <span class="hljs-attr">version:</span> <span class="hljs-number">22.7</span><span class="hljs-number">.0</span>
    <span class="hljs-attr">repository:</span> <span class="hljs-string">https://prometheus-community.github.io/helm-charts</span>
</code></pre>
<p>이제 새 PV 및 PVC를 사용하도록 구성을 설정하고, 일부 권한을 수정하고 서버를 마스터 노드에만 배포하도록 확인할 수 있습니다.</p>
<pre><code class="hljs language-yaml"><span class="hljs-attr">prometheus:</span>
  <span class="hljs-attr">alertmanager:</span>
    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span>
  <span class="hljs-attr">prometheus-pushgateway:</span>
    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span>
  <span class="hljs-attr">configmapReload:</span>
    <span class="hljs-attr">prometheus:</span>
      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span>
  <span class="hljs-attr">server:</span>
    <span class="hljs-attr">nodeSelector:</span>
      <span class="hljs-attr">kubernetes.io/hostname:</span> {<span class="hljs-string">master</span> <span class="hljs-string">node</span>}
    <span class="hljs-attr">securityContext:</span>
      <span class="hljs-attr">runAsUser:</span> {<span class="hljs-string">userid</span>}
      <span class="hljs-attr">runAsNonRoot:</span> <span class="hljs-literal">true</span>
      <span class="hljs-attr">runAsGroup:</span> {<span class="hljs-string">groupid</span>}
      <span class="hljs-attr">fsGroup:</span> {<span class="hljs-string">fsid</span>}
    <span class="hljs-attr">persistentVolume:</span>
      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>
      <span class="hljs-attr">existingClaim:</span> <span class="hljs-string">&quot;prometheus-usb-pvc&quot;</span>
      <span class="hljs-attr">volumeName:</span> <span class="hljs-string">&quot;prometheus-usb-pv&quot;</span>
</code></pre>
<div class="content-ad"></div>
<p>일부 추가 서비스를 비활성화합니다. 예를 들어 alertmanager, pushgateway, 그리고 configmapreload가 이에 해당합니다. 필요한 경우 다른 시간에 이를 활성화할 수 있습니다. 비정상적으로 행동하는 경우 알림을 받을 수 있는 유용한 도구인 Alert Manager입니다.</p>
<p>이제 ArgoCD로 돌아가 &quot;새 앱&quot;을 만들어보겠습니다. Prometheus라는 이름의 앱을 만들고 깃 레포지토리를 소스로 추가하고 경로를 선택하세요. Grafana도 나중에 이 작업을 해야하므로 서로 다른 경로에 유지하세요.</p>
<p><img src="/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_4.png" alt="Image"/></p>
<p>생성한 사용자 정의 설정을 설정할 값 파일을 선택한 다음 앱을 생성하세요. 수동으로 동기화하도록 지정한 경우 동기화가 필요할 때 이를 수행해야 합니다. 이것은 업그레이드할 때 사용하거나 수동으로 릴리스하고자 할 때 유용합니다. 그 외에는 홈 프로젝트에 가장 적합한 CD용 자동 동기화 방법이 유용합니다.</p>
<div class="content-ad"></div>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*Ice0ZJGARkN6BdzAl1nGDQ.gif" alt="Grafana"/></p>
<p>마찬가지로 Prometheus와 비슷하게, git 레포지토리에서 새로운 Helm 차트를 생성하는 것부터 시작해보세요.</p>
<pre><code class="hljs language-js">helm create grafana
</code></pre>
<div class="content-ad"></div>
<p>헬름 리포지토리를 추가해주세요.</p>
<pre><code class="hljs language-js">helm repo add grafana <span class="hljs-attr">https</span>:<span class="hljs-comment">//grafana.github.io/helm-charts</span>
helm repo update
</code></pre>
<p>리포지토리를 통해 차트를 업데이트하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-attr">dependencies</span>:
  - <span class="hljs-attr">name</span>: grafana
    <span class="hljs-attr">version</span>: <span class="hljs-number">6.57</span><span class="hljs-number">.4</span>
    <span class="hljs-attr">repository</span>: <span class="hljs-attr">https</span>:<span class="hljs-comment">//grafana.github.io/helm-charts</span>
</code></pre>
<div class="content-ad"></div>
<p>values.yaml 파일을 추가해주세요.</p>
<pre><code class="hljs language-js"><span class="hljs-attr">grafana</span>:
  <span class="hljs-attr">service</span>:
    <span class="hljs-attr">enabled</span>: <span class="hljs-literal">true</span>
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">NodePort</span>
    <span class="hljs-attr">nodePort</span>: <span class="hljs-number">30180</span>
</code></pre>
<p>그런 다음 이전과 같이 ArgoCD를 통해 Grafana를 추가해주세요. 동기화를 진행하고 이제 두 개가 모두 실행 중이어야 합니다.</p>
<img src="/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_5.png"/>
<div class="content-ad"></div>
<p>Grafana를 사용하려면 관리자 비밀번호를 먼저 얻어야 합니다.</p>
<pre><code class="hljs language-js">kubectl get secret --namespace monitoring grafana -o jsonpath=<span class="hljs-string">&quot;{.data.admin-password}&quot;</span> | base64 --decode ; echo
</code></pre>
<p>출력에서 나온 관리자 사용자 이름과 비밀번호로 로그인해주세요.</p>
<p><img src="/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_6.png" alt="이미지"/></p>
<div class="content-ad"></div>
<p>이제 Prometheus 데이터 원본을 추가해 보겠습니다. Prometheus 서비스 URL은 모니터링을 설정한 네임스페이스인 클러스터에서 http://prometheus-server.monitoring.svc.cluster.local로 접근할 수 있습니다. &quot;Administration&quot; → &quot;Data sources&quot; → &quot;Add new data source&quot; 아래로 이동한 다음 URL을 추가하고 &quot;Save &amp; Test&quot;를 클릭하여 확인할 수 있습니다.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*VphOqjzSh30E4dKrnf2Q2A.gif" alt="image"/></p>
<p>만약 우리 클러스터의 상태를 간단히 확인하고 싶다면 Grafana Labs에서 제공하는 대시보드를 사용할 수 있습니다. 이를 통해 우리 클러스터에서 사용되는 리소스에 대한 간단한 뷰를 확인할 수 있을 것입니다.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*AIw7esBCtaz5koK_uJTU-w.gif" alt="image"/></p>
<div class="content-ad"></div>
<h1>다음 단계</h1>
<h2>사용자 정의 Docker 이미지</h2>
<p>당신의 클러스터를 운영하는 중요한 단계로, 공개 Docker.io 레지스트리에 없는 컨테이너나 사용자 정의 컨테이너를 배포할 수 있게 됩니다. 클러스터에 많은 컨테이너를 배포할 계획이라면, 무료 티어 Docker Hub의 제한을 피하기 위해 개인 컨테이너 레지스트리를 설정하는 것을 권장합니다. 이는 GCP의 Artifacts Repository와 같은 클라우드 공급업체나 Harbor와 같은 오픈 소스 docker 저장소로 구현할 수 있습니다.</p>
<h2>클러스터 자동화</h2>
<div class="content-ad"></div>
<p>이 안내서는 교육 목적이나 소규모 개인 클러스터를 관리할 때 이상적인 Kubernetes 클러스터 설정에 대한 수동 방법을 제공합니다. 그러나 프로덕션 클러스터를 배포하거나 이 안내서의 범위를 벗어나는 작업을 수행할 경우, Ansible과 같은 자동화 도구를 활용하는 것을 권장합니다. 이렇게하면 더 효율적이고 확장 가능하며 관리하기 쉬운 배포가 가능합니다.</p>
<h1>결론</h1>
<p>Kubernetes 클러스터를 설정하는 것은 쉽지 않을 수 있지만 한 번 완료되면 일반적인 독립형 서버를 뛰어넘는 확장 가능한 환경을 제공하는 장점이 있습니다.</p>
<p>Raspberry Pi는 비용이 저렴하고 전력 소비가 낮은 옵션이지만, 더 큰 응용 프로그램에 대한 확장성이 여전히 제한되어 있습니다. Kubernetes 클러스터의 장점은 동일한 하드웨어만 실행하는 것에 제한받지 않는다는 것입니다. 새로운 노드를 추가함으로써 다양한 하드웨어를 혼합하여 필요에 맞게 Raspberry Pi나 서버와 같은 다양한 하드웨어를 조합할 수 있습니다!</p>
<div class="content-ad"></div>
<p>그것이 좋은 시작점이 되었기를 바랍니다. 읽어 주셔서 감사합니다!</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"라즈베리 파이로 쿠버네티스 클러스터 구축 가이드","description":"","date":"2024-05-18 19:08","slug":"2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis","content":"\n\n몇 년 전에 라즈베리 파이에서 Kubernetes 클러스터를 세팅했었어요. 당시 라즈베리 파이의 ARM 아키텍처는 몇 가지 어려움을 야기했죠. ARM을 지원하는 애플리케이션을 찾는 건 어려운 과제였는데, 그래서 필요한 애플리케이션과 컨테이너를 직접 빌드해야 했던 적이 많았어요.\n\n그런데 그 이후로 상황이 크게 개선되었어요! 새로운 64비트 라즈베리 파이 OS의 등장과 ARM의 저렴함으로 클라우드 배포에 많이 사용되는 산업에서의 인기 상승으로, 라즈베리 파이 클러스터 구축이 훨씬 간단해졌어요. 저는 클러스터를 다시 구축하기로 결정했고, 64비트 OS 및 최신 버전의 Kubernetes와 Docker로 업데이트했어요.\n\n여러분이 자체 라즈베리 파이 Kubernetes 클러스터를 설정하는 방법에 대한 가이드를 작성했어요. 집에서 클러스터를 구축하는 여정에 유용하길 바랍니다! 🚀\n\n# 요구 사항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클러스터를 설정하기 위해서는 하드웨어가 필요합니다. 필요한 것들은 다음과 같아요:\n\n- 라즈베리 파이(저는 4 모델 B를 사용했어요)\n- SD 카드 1장 / 라즈베리 파이\n- 이더넷 케이블 1개 / 라즈베리 파이\n- 라우터 및/또는 네트워크 스위치\n- USB 허브\n- (선택 사항) 케이스\n\n이 안내서는 Kubernetes 1.26.6, Docker 24.0.2 및 라즈베리 파이 Lite(64비트) 불자이에 맞춰 작성되었어요.\n\n# OS 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫 번째 단계는 모든 Raspberry Pi에 OS를 설정해야 합니다. 그렇지 않으면 Raspberry Pi는 기본적으로 부팅할 시스템이 없습니다.\n\nRaspberry Pi Imager를 다운로드하십시오. 이 편리한 애플리케이션은 Raspberry Pi의 다운로드와 플래싱에 사용됩니다. 이 가이드에서는 Raspberry Pi OS (Debian의 파생 버전)의 64비트 헤드리스 버전을 사용할 것입니다.\n\n최신 Raspberry Pi와 호환되는지 확인한 후에 SD 카드를 플래싱해야 합니다. \n\n![Raspberry Pi Imager](/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSD 카드를 선택하고 OS를 플래싱하기 시작하세요. 모든 SD 카드에 대해 이 작업을 완료할 때까지 반복해주세요.\n\n## SSH 활성화 및 기본 사용자 생성\n\n각 Pi를 원격으로 구성할 수 있게끔 SSH를 설정해야 합니다.\n\nSSH를 활성화하려면 SD 카드의 부트 파티션에 확장자 없이 ssh라는 빈 파일을 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로그인 사용자를 설정하기 위해, SD 카드의 부팅 파티션에 userconf라는 파일을 생성하세요. 이 파일은 'name':'encrypted-password'로 구성된 텍스트 한 줄을 포함해야 합니다. 로그인 사용자로 노드를 사용했지만 원하는 대로 사용하셔도 됩니다.\n\nencrypted-password를 생성하려면 다음 명령을 OpenSSL과 함께 실행하세요:\n\n```js\necho '{password}' | openssl passwd -6 -stdin\n```\n\n파일을 저장하고 SD 카드를 제거하세요. 그리고 라즈베리 파이에 SD 카드를 삽입하고 전원을 켜세요. 개인 네트워크의 라우터나 네트워크 스위치에 연결되어 있는지 확인하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 첫 번째 부팅 및 초기 구성\n\n라즈베리 파이의 IP를 얻어야 합니다. 이를 위해 라우터를 확인할 수 있습니다. 제 경우, OpenWrt를 사용하며 DHCP 설정에서 기억하기 쉬운 정적 IP를 만듭니다.\n\n![image](/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_1.png)\n\n첫 번째 노드에 SSH로 연결합니다. 이 노드는 클러스터의 제어 평면을 실행하는 마스터 노드가 됩니다. 라즈베리 파이로 터널링한 후에 설정을 시작할 수 있습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 명령어를 사용하여 사용자를 sudo 그룹에 추가해주세요.\n\n```js\nsudo usermod -aG sudo node\n```\n\n이제 rasp-config를 업데이트하여 node 사용자로 자동 부팅하도록 설정해봅시다.\n\n```js\nsudo raspi-config\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*XG-oT3YeryzngA-Xv3JY9w.gif)\n\n“System Options” → “Boot / Auto Login” 으로 이동하여 “Console Autologin”을 선택해주세요.\n\n# Docker \u0026 Kubernetes 초기 설정\n\n기본적으로 cgroup 메모리 옵션이 비활성화되어 있으므로 Docker가 메모리 사용량을 제한할 수 있도록 업데이트해야 합니다. /boot/cmdline.txt를 열고 cgroup_enable=memory cgroup_memory=1을 추가해주세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 우리의 apt 저장소를 업데이트하고 Kubernetes 저장소를 포함시킬 차례입니다.\n\n```js\ncurl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -\necho \"deb http://apt.kubernetes.io/ kubernetes-xenial main\" | sudo tee -a /etc/apt/sources.list.d/kubernetes.list\nsudo apt update \u0026\u0026 sudo apt upgrade -y\n```\n\nDocker 설치:\n\n```js\ncurl -sSL https://get.docker.com | sh\nsudo usermod -aG docker node\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nKubernetes 1.20부터는 dockershim이 폐기되고 있습니다. Mirantis에서 제공하는 cri-dockerd라는 클러스터용 오픈 소스 CRI를 사용할 수 있습니다. cri-dockerd를 설치하고 서비스를 설정하려면 다음 명령을 실행하세요:\n\n```js\nwget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.4/cri-dockerd-0.3.4.arm64.tgz\ntar -xvzf cri-dockerd-0.3.4.arm64.tgz\nsudo mv cri-dockerd/cri-dockerd /usr/bin/cri-dockerd\nsudo chmod +x /usr/bin/cri-dockerd\nwget https://raw.githubusercontent.com/Mirantis/cri-dockerd/master/packaging/systemd/cri-docker.service\nwget https://raw.githubusercontent.com/Mirantis/cri-dockerd/master/packaging/systemd/cri-docker.socket\nsudo mv cri-docker.service /etc/systemd/system/\nsudo mv cri-docker.socket /etc/systemd/system/\nsudo systemctl enable cri-docker.service\nsudo systemctl enable cri-docker.socket\nsudo systemctl start cri-docker.service\nsudo systemctl start cri-docker.socket\n```\n\nKubernetes 스케줄러를 위해 노드에서 swap을 비활성화하는 것이 권장됩니다.\n\n```js\nsudo apt-get update \u0026\u0026 sudo apt-get install dphys-swapfile \u0026\u0026 sudo dphys-swapfile swapoff \u0026\u0026 sudo dphys-swapfile uninstall \u0026\u0026 sudo systemctl disable dphys-swapfile\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 cri-dockerd 설정에 문제가 발생하면, 이 안내서를 확인해보세요. 처음에 작성했을 때와 달라진 사항이 있을 수 있어요.\n\n마지막으로, Kubernetes를 설치해봅시다!\n\n```js\nsudo apt install -y kubelet=1.26.6-00 kubeadm=1.26.6-00 kubectl=1.26.6-00\nsudo apt-mark hold kubelet kubeadm kubectl\n```\n\n이 가이드에서는 모든 것이 1.26.6에서 작동하는지 테스트했어요. 1.24 이전 버전은 정상적으로 작동하지 않을 거예요. 이러한 패키지를 업데이트되지 않도록 표시할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n차선으로, 랜처 랩스에서 만든 k3s는 가벼운 옵션으로 좋은 선택일 것입니다. 그 중 일부 장점은 작은 실행 파일 크기, 매우 낮은 자원 요구 사항 및 ARM용으로 최적화되어 있다는 것입니다. 이 가이드에서는 이를 테스트해보지 않았지만, 이후에 비슷한 설정이 될 것으로 생각합니다.\n\n이제 클러스터를 초기화할 시간입니다. 이를 위해 InitConfiguration 및 ClusterConfiguration 설정이 포함된 파일을 만들겠습니다.\n\n```js\napiVersion: kubeadm.k8s.io/v1beta3\nbootstrapTokens:\n- groups:\n  - system:bootstrappers:kubeadm:default-node-token\n  token: {token}\n  usages:\n  - signing\n  - authentication\nkind: InitConfiguration\nlocalAPIEndpoint:\n  advertiseAddress: 10.0.0.100\n  bindPort: 6443\nnodeRegistration:\n  criSocket: unix:///var/run/cri-dockerd.sock\n  imagePullPolicy: IfNotPresent\n  name: node-0\n---\napiVersion: kubeadm.k8s.io/v1beta3\nkind: ClusterConfiguration\nnetworking:\n  podSubnet: \"10.244.0.0/16\" # --pod-network-cidr\n```\n\n이 파일에는 마스터 노드의 설정이 포함되어 있습니다. criSocket이 cri-dockerd를 사용하고, 나중에 네트워크 CIDR을 설정해두었음을 주목하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 노드에서 제어 평면을 초기화하려면 다음을 실행하세요.\n\n```js\nsudo kubeadm init --config kubeadm-config.yaml\n```\n\n이 명령은 새 노드를 클러스터에 추가하는 설정 및 kube-config를 설정하는 방법을 보여줍니다.\n\n명령에서 지시하는 방법에 따라 kube-config를 설정하고, 워크스테이션에 kube-config와 가입 명령을 복사하고 저장하세요. 나중에 필요할 것이니까요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 클러스터 네트워킹\n\n이제 클러스터에서 네트워킹을 설정해야 합니다. Pod들이 노드 간에 서로 통신할 수 있도록 하려면 네트워크 플러그인 (CNI 또는 컨테이너 네트워크 인터페이스로도 불림)이 필요합니다.\n\n네트워크 플러그인은 IP 주소 할당, DNS 해결 및 네트워크 격리와 같은 기능을 Pod에 제공합니다.\n\n우리는 이를 위해 Flannel을 사용할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마스터 노드에서 다음을 실행해 주세요.\n\n```js\nkubectl apply -f https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml\n```\n\n그게 다에요! 이제 마스터 노드가 완료되었으니, 클러스터에 새 노드를 추가하기 시작할 수 있어요. 이전에 출력된 조인 명령을 기억하고 있나요? 이제 그것이 필요할 거에요.\n\n# 클러스터에 새로운 노드 추가하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클러스터에 새 노드를 추가하는 것은 꽤 간단합니다. 많은 노드를 추가하는 경우에는 tmux와 같은 도구를 사용하여 세션 명령을 다중화하는 것이 좋습니다.\n\n\"첫 번째 부팅 및 초기 설정\"을 완료하고 \"도커 및 쿠버네티스 초기 설정\"을 진행하세요. 서로 다른 Kubernetes 구성 요소를 설치하는 단계 이후에 작업을 중지하세요. 이 시점에서 이전에 실행한 kubeadm join 명령을 실행해야 합니다. cri-socket 및 node-name 옵션을 포함하여 실행해 주세요. \n\n```js\nsudo kubeadm join 10.0.0.100:6443 --token {token} --discovery-token-ca-cert-hash {hash} --cri-socket unix:///var/run/cri-dockerd.sock --node-name {name}\n```\n\n이제 마스터 노드에서 클러스터를 모니터링하고 모든 노드가 클러스터에 가입하는지 확인하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003e kubectl get nodes를 watch합니다.\n이제 귀하의 클러스터가 사용할 준비가 되었습니다! 그러나 SSH를 통해가 아닌 워크스테이션에서 액세스하고 싶을 것입니다. 컴퓨터에서 이전에 설정한 kube-config를 설정할 수 있습니다.\n\n기본 kube-config는 관리자 권한을 부여하며 다른 사람과 공유해서는 안됩니다.\n\n먼저 프로필에 구성을 내보냅니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nexport KUBECONFIG=~/.kube/config\n```\n\n컨텍스트 설정:\n\n```js\nkubectl config use-context kubernetes-admin@kubernetes\n```\n\n이제 원격으로 클러스터에 액세스할 수 있어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003e kubectl cluster-info\n쿠버네티스 제어 평면이 https://10.0.0.100:6443 에서 실행 중입니다.\nCoreDNS이 https://10.0.0.100:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy 에서 실행 중입니다.\n\n더 많은 디버깅 및 진단을 위해 'kubectl cluster-info dump'를 사용하세요.\n```\n\n# 도구 설정\n\n이제 밴자이라 클러스터를 일반에서 멋지게 업그레이드해 봅시다. 새 응용 프로그램을 쉽게 배포하고 클러스터를 모니터링할 수 있는 몇 가지 널리 사용되는 도구를 설정해 보겠습니다. 여기서 ArgoCD, Prometheus 및 Grafana 설치 방법을 안내하겠습니다! 이 세 가지 오픈소스 프로젝트가 우리의 클러스터를 다음 수준으로 끌어올립니다.\n\n계속하기 전에, 이러한 도구들에 대한 모든 설정 변경 사항을 추적하기 위한 원격 git 저장소를 만들어 보시기를 권장합니다. 특히 ArgoCD를 사용할 때, 각 도구나 추가 응용 프로그램을 배포할 때마다 거기를 통해 추가합니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# ArgoCD\n\n각 도구에 대해 Helm을 리소스 템플릿팅 도구로 사용할 것입니다. 최신 버전(또는 적어도 Helm v3)을 설치하고 ArgoCD 저장소를 추가해 봅시다.\n\n```js\nhelm repo add argo https://argoproj.github.io/argo-helm\n```\n\nValues 파일을 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\nserver:\n  serviceType: NodePort\n  httpNodePort: 30080\n  httpsNodePort: 30443\n```\n\n이 파일은 차트의 설정 중 하나를 재정의하는 데 사용할 수 있습니다. 이 경우에는 서비스를 ClusterIP 대신 NodePort로 실행하도록 변경하고 있습니다. 이렇게 하면 클러스터에서 지정한 포트를 외부에서 엑세스할 수 있도록 하여 리버스 프록시를 사용하지 않고도 개인 네트워크에서 해당 서비스에 액세스할 수 있습니다.\n\n서비스를 설치하십시오.\n\n```js\nhelm install argocd -n argocd -f values.yaml argo/argocd\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 관리자 사용자의 기본 암호를 가져와야 합니다.\n\n```js\nkubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=\"{.data.password}\" | base64 -d\n```\n\nOpenWrt를 사용하고 있기 때문에 클러스터에 호스트 이름 항목을 설정하고 https://cluster.home:30443에서 로그인 페이지에 액세스할 수 있습니다.\n\n![그림](/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nArgoCD에 로그인하고, 곧 돌아올게요.\n\n![image](/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_3.png)\n\n# Prometheus\n\n우리는 클러스터에 대한 정보 수집을 위해 타임 시리즈 메트릭 서버로 Prometheus를 사용할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n설치하기 전에 Prometheus가 쿼리 데이터를 저장할 지속적인 볼륨을 설정해야 합니다. 집 클러스터에서는 예비 USB 드라이브를 사용하기로 결정했지만 원하는 것을 연결하여 사용할 수 있습니다.\n\n마스터 노드에서 볼륨을 설정한 단계는 다음과 같습니다. 우리의 볼륨을 위한 경로를 만들고 실수를 막기 위해 변경 사항을 반영해야 할 fstab의 백업을 만듭니다.\n\n```js\nsudo mkdir /mnt/usb\nsudo cp /etc/fstab /etc/fstab.bak\n```\n\n장치를 연결한 다음 fstab을 변경 내용과 함께 수정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```md\n/dev/sda1 /mnt/usb vfat defaults,uid=youruid,gid=yourgid,dmask=002,fmask=113 0 0\n```\n\n이제 우리 노드 사용자의 사용자 및 그룹 설정으로 장치를 마운트합니다.\n\n```md\nsudo mount -o uid=youruid,gid=yourgid,dmask=002,fmask=113 /dev/sdX1 /mnt/usb\n```\n\n이제 우리는 PersistentVolume과 PersistentVolumeChain을 가진 Kubernetes 자원을 생성하려고 합니다.\n \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: prometheus-usb-pv\n  labels:\n    type: local\nspec:\n  storageClassName: manual\n  capacity:\n    storage: {device의 크기}Gi\n  accessModes:\n    - ReadWriteOnce\n  persistentVolumeReclaimPolicy: Retain\n  hostPath:\n    path: \"/mnt/usb\"\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: prometheus-usb-pvc\nspec:\n  storageClassName: manual\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: {device의 크기}Gi\n```\n\n만약 git 리포지토리를 사용 중이라면, 이 파일들을 template 디렉토리 안에 새로운 Helm Chart에 위치시켜주세요. 다음 단계를 따라 계속 진행해봐요.\n\n이제 프로메테우스와 함께 차트를 설정해봅시다.\n\n```bash\nhelm create prometheus\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nChart.yaml에 Prometheus subchart를 종속성으로 추가해주세요.\n\n```yaml\ndependencies:\n  - name: prometheus\n    version: 22.7.0\n    repository: https://prometheus-community.github.io/helm-charts\n```\n\n이제 새 PV 및 PVC를 사용하도록 구성을 설정하고, 일부 권한을 수정하고 서버를 마스터 노드에만 배포하도록 확인할 수 있습니다.\n\n```yaml\nprometheus:\n  alertmanager:\n    enabled: false\n  prometheus-pushgateway:\n    enabled: false\n  configmapReload:\n    prometheus:\n      enabled: false\n  server:\n    nodeSelector:\n      kubernetes.io/hostname: {master node}\n    securityContext:\n      runAsUser: {userid}\n      runAsNonRoot: true\n      runAsGroup: {groupid}\n      fsGroup: {fsid}\n    persistentVolume:\n      enabled: true\n      existingClaim: \"prometheus-usb-pvc\"\n      volumeName: \"prometheus-usb-pv\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일부 추가 서비스를 비활성화합니다. 예를 들어 alertmanager, pushgateway, 그리고 configmapreload가 이에 해당합니다. 필요한 경우 다른 시간에 이를 활성화할 수 있습니다. 비정상적으로 행동하는 경우 알림을 받을 수 있는 유용한 도구인 Alert Manager입니다.\n\n이제 ArgoCD로 돌아가 \"새 앱\"을 만들어보겠습니다. Prometheus라는 이름의 앱을 만들고 깃 레포지토리를 소스로 추가하고 경로를 선택하세요. Grafana도 나중에 이 작업을 해야하므로 서로 다른 경로에 유지하세요.\n\n\n![Image](/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_4.png)\n\n\n생성한 사용자 정의 설정을 설정할 값 파일을 선택한 다음 앱을 생성하세요. 수동으로 동기화하도록 지정한 경우 동기화가 필요할 때 이를 수행해야 합니다. 이것은 업그레이드할 때 사용하거나 수동으로 릴리스하고자 할 때 유용합니다. 그 외에는 홈 프로젝트에 가장 적합한 CD용 자동 동기화 방법이 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Grafana](https://miro.medium.com/v2/resize:fit:1400/1*Ice0ZJGARkN6BdzAl1nGDQ.gif)\n\n마찬가지로 Prometheus와 비슷하게, git 레포지토리에서 새로운 Helm 차트를 생성하는 것부터 시작해보세요.\n\n```js\nhelm create grafana\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n헬름 리포지토리를 추가해주세요.\n\n```js\nhelm repo add grafana https://grafana.github.io/helm-charts\nhelm repo update\n```\n\n리포지토리를 통해 차트를 업데이트하세요.\n\n```js\ndependencies:\n  - name: grafana\n    version: 6.57.4\n    repository: https://grafana.github.io/helm-charts\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nvalues.yaml 파일을 추가해주세요.\n\n```js\ngrafana:\n  service:\n    enabled: true\n    type: NodePort\n    nodePort: 30180\n```\n\n그런 다음 이전과 같이 ArgoCD를 통해 Grafana를 추가해주세요. 동기화를 진행하고 이제 두 개가 모두 실행 중이어야 합니다.\n\n\u003cimg src=\"/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_5.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGrafana를 사용하려면 관리자 비밀번호를 먼저 얻어야 합니다.\n\n```js\nkubectl get secret --namespace monitoring grafana -o jsonpath=\"{.data.admin-password}\" | base64 --decode ; echo\n```\n\n출력에서 나온 관리자 사용자 이름과 비밀번호로 로그인해주세요.\n\n![이미지](/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 Prometheus 데이터 원본을 추가해 보겠습니다. Prometheus 서비스 URL은 모니터링을 설정한 네임스페이스인 클러스터에서 http://prometheus-server.monitoring.svc.cluster.local로 접근할 수 있습니다. \"Administration\" → \"Data sources\" → \"Add new data source\" 아래로 이동한 다음 URL을 추가하고 \"Save \u0026 Test\"를 클릭하여 확인할 수 있습니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*VphOqjzSh30E4dKrnf2Q2A.gif)\n\n만약 우리 클러스터의 상태를 간단히 확인하고 싶다면 Grafana Labs에서 제공하는 대시보드를 사용할 수 있습니다. 이를 통해 우리 클러스터에서 사용되는 리소스에 대한 간단한 뷰를 확인할 수 있을 것입니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*AIw7esBCtaz5koK_uJTU-w.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 다음 단계\n\n## 사용자 정의 Docker 이미지\n\n당신의 클러스터를 운영하는 중요한 단계로, 공개 Docker.io 레지스트리에 없는 컨테이너나 사용자 정의 컨테이너를 배포할 수 있게 됩니다. 클러스터에 많은 컨테이너를 배포할 계획이라면, 무료 티어 Docker Hub의 제한을 피하기 위해 개인 컨테이너 레지스트리를 설정하는 것을 권장합니다. 이는 GCP의 Artifacts Repository와 같은 클라우드 공급업체나 Harbor와 같은 오픈 소스 docker 저장소로 구현할 수 있습니다.\n\n## 클러스터 자동화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 안내서는 교육 목적이나 소규모 개인 클러스터를 관리할 때 이상적인 Kubernetes 클러스터 설정에 대한 수동 방법을 제공합니다. 그러나 프로덕션 클러스터를 배포하거나 이 안내서의 범위를 벗어나는 작업을 수행할 경우, Ansible과 같은 자동화 도구를 활용하는 것을 권장합니다. 이렇게하면 더 효율적이고 확장 가능하며 관리하기 쉬운 배포가 가능합니다.\n\n# 결론\n\nKubernetes 클러스터를 설정하는 것은 쉽지 않을 수 있지만 한 번 완료되면 일반적인 독립형 서버를 뛰어넘는 확장 가능한 환경을 제공하는 장점이 있습니다.\n\nRaspberry Pi는 비용이 저렴하고 전력 소비가 낮은 옵션이지만, 더 큰 응용 프로그램에 대한 확장성이 여전히 제한되어 있습니다. Kubernetes 클러스터의 장점은 동일한 하드웨어만 실행하는 것에 제한받지 않는다는 것입니다. 새로운 노드를 추가함으로써 다양한 하드웨어를 혼합하여 필요에 맞게 Raspberry Pi나 서버와 같은 다양한 하드웨어를 조합할 수 있습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그것이 좋은 시작점이 되었기를 바랍니다. 읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_0.png"},"coverImage":"/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_0.png","tag":["Tech"],"readingTime":15},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h1: \"h1\",\n    ul: \"ul\",\n    li: \"li\",\n    img: \"img\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"몇 년 전에 라즈베리 파이에서 Kubernetes 클러스터를 세팅했었어요. 당시 라즈베리 파이의 ARM 아키텍처는 몇 가지 어려움을 야기했죠. ARM을 지원하는 애플리케이션을 찾는 건 어려운 과제였는데, 그래서 필요한 애플리케이션과 컨테이너를 직접 빌드해야 했던 적이 많았어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그런데 그 이후로 상황이 크게 개선되었어요! 새로운 64비트 라즈베리 파이 OS의 등장과 ARM의 저렴함으로 클라우드 배포에 많이 사용되는 산업에서의 인기 상승으로, 라즈베리 파이 클러스터 구축이 훨씬 간단해졌어요. 저는 클러스터를 다시 구축하기로 결정했고, 64비트 OS 및 최신 버전의 Kubernetes와 Docker로 업데이트했어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여러분이 자체 라즈베리 파이 Kubernetes 클러스터를 설정하는 방법에 대한 가이드를 작성했어요. 집에서 클러스터를 구축하는 여정에 유용하길 바랍니다! 🚀\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"요구 사항\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"클러스터를 설정하기 위해서는 하드웨어가 필요합니다. 필요한 것들은 다음과 같아요:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"라즈베리 파이(저는 4 모델 B를 사용했어요)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"SD 카드 1장 / 라즈베리 파이\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이더넷 케이블 1개 / 라즈베리 파이\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"라우터 및/또는 네트워크 스위치\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"USB 허브\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"(선택 사항) 케이스\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 안내서는 Kubernetes 1.26.6, Docker 24.0.2 및 라즈베리 파이 Lite(64비트) 불자이에 맞춰 작성되었어요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"OS 설정\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"첫 번째 단계는 모든 Raspberry Pi에 OS를 설정해야 합니다. 그렇지 않으면 Raspberry Pi는 기본적으로 부팅할 시스템이 없습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Raspberry Pi Imager를 다운로드하십시오. 이 편리한 애플리케이션은 Raspberry Pi의 다운로드와 플래싱에 사용됩니다. 이 가이드에서는 Raspberry Pi OS (Debian의 파생 버전)의 64비트 헤드리스 버전을 사용할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"최신 Raspberry Pi와 호환되는지 확인한 후에 SD 카드를 플래싱해야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_0.png\",\n        alt: \"Raspberry Pi Imager\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"SD 카드를 선택하고 OS를 플래싱하기 시작하세요. 모든 SD 카드에 대해 이 작업을 완료할 때까지 반복해주세요.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"SSH 활성화 및 기본 사용자 생성\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"각 Pi를 원격으로 구성할 수 있게끔 SSH를 설정해야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"SSH를 활성화하려면 SD 카드의 부트 파티션에 확장자 없이 ssh라는 빈 파일을 생성하세요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"로그인 사용자를 설정하기 위해, SD 카드의 부팅 파티션에 userconf라는 파일을 생성하세요. 이 파일은 'name':'encrypted-password'로 구성된 텍스트 한 줄을 포함해야 합니다. 로그인 사용자로 노드를 사용했지만 원하는 대로 사용하셔도 됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"encrypted-password를 생성하려면 다음 명령을 OpenSSL과 함께 실행하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"echo \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'{password}'\"\n        }), \" | openssl passwd -\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \" -stdin\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"파일을 저장하고 SD 카드를 제거하세요. 그리고 라즈베리 파이에 SD 카드를 삽입하고 전원을 켜세요. 개인 네트워크의 라우터나 네트워크 스위치에 연결되어 있는지 확인하세요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"첫 번째 부팅 및 초기 구성\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"라즈베리 파이의 IP를 얻어야 합니다. 이를 위해 라우터를 확인할 수 있습니다. 제 경우, OpenWrt를 사용하며 DHCP 설정에서 기억하기 쉬운 정적 IP를 만듭니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_1.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"첫 번째 노드에 SSH로 연결합니다. 이 노드는 클러스터의 제어 평면을 실행하는 마스터 노드가 됩니다. 라즈베리 파이로 터널링한 후에 설정을 시작할 수 있습니다!\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 명령어를 사용하여 사용자를 sudo 그룹에 추가해주세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"sudo usermod -aG sudo node\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 rasp-config를 업데이트하여 node 사용자로 자동 부팅하도록 설정해봅시다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"sudo raspi-config\\n\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*XG-oT3YeryzngA-Xv3JY9w.gif\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"“System Options” → “Boot / Auto Login” 으로 이동하여 “Console Autologin”을 선택해주세요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Docker \u0026 Kubernetes 초기 설정\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"기본적으로 cgroup 메모리 옵션이 비활성화되어 있으므로 Docker가 메모리 사용량을 제한할 수 있도록 업데이트해야 합니다. /boot/cmdline.txt를 열고 cgroup_enable=memory cgroup_memory=1을 추가해주세요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 우리의 apt 저장소를 업데이트하고 Kubernetes 저장소를 포함시킬 차례입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"curl -s \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -\"\n        }), \"\\necho \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"deb http://apt.kubernetes.io/ kubernetes-xenial main\\\"\"\n        }), \" | sudo tee -a /etc/apt/sources.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"list\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"d\"\n        }), \"/kubernetes.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"list\"\n        }), \"\\nsudo apt update \u0026\u0026 sudo apt upgrade -y\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Docker 설치:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"curl -sSL \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//get.docker.com | sh\"\n        }), \"\\nsudo usermod -aG docker node\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Kubernetes 1.20부터는 dockershim이 폐기되고 있습니다. Mirantis에서 제공하는 cri-dockerd라는 클러스터용 오픈 소스 CRI를 사용할 수 있습니다. cri-dockerd를 설치하고 서비스를 설정하려면 다음 명령을 실행하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"wget \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//github.com/Mirantis/cri-dockerd/releases/download/v0.3.4/cri-dockerd-0.3.4.arm64.tgz\"\n        }), \"\\ntar -xvzf cri-dockerd-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.3\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".4\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"arm64\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"tgz\"\n        }), \"\\nsudo mv cri-dockerd/cri-dockerd /usr/bin/cri-dockerd\\nsudo chmod +x /usr/bin/cri-dockerd\\nwget \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//raw.githubusercontent.com/Mirantis/cri-dockerd/master/packaging/systemd/cri-docker.service\"\n        }), \"\\nwget \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//raw.githubusercontent.com/Mirantis/cri-dockerd/master/packaging/systemd/cri-docker.socket\"\n        }), \"\\nsudo mv cri-docker.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"service\"\n        }), \" /etc/systemd/system/\\nsudo mv cri-docker.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"socket\"\n        }), \" /etc/systemd/system/\\nsudo systemctl enable cri-docker.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"service\"\n        }), \"\\nsudo systemctl enable cri-docker.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"socket\"\n        }), \"\\nsudo systemctl start cri-docker.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"service\"\n        }), \"\\nsudo systemctl start cri-docker.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"socket\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Kubernetes 스케줄러를 위해 노드에서 swap을 비활성화하는 것이 권장됩니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"sudo apt-get update \u0026\u0026 sudo apt-get install dphys-swapfile \u0026\u0026 sudo dphys-swapfile swapoff \u0026\u0026 sudo dphys-swapfile uninstall \u0026\u0026 sudo systemctl disable dphys-swapfile\\n\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"만약 cri-dockerd 설정에 문제가 발생하면, 이 안내서를 확인해보세요. 처음에 작성했을 때와 달라진 사항이 있을 수 있어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막으로, Kubernetes를 설치해봅시다!\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"sudo apt install -y kubelet=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1.26\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".6\"\n        }), \"-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"00\"\n        }), \" kubeadm=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1.26\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".6\"\n        }), \"-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"00\"\n        }), \" kubectl=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1.26\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".6\"\n        }), \"-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"00\"\n        }), \"\\nsudo apt-mark hold kubelet kubeadm kubectl\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 가이드에서는 모든 것이 1.26.6에서 작동하는지 테스트했어요. 1.24 이전 버전은 정상적으로 작동하지 않을 거예요. 이러한 패키지를 업데이트되지 않도록 표시할 거에요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"차선으로, 랜처 랩스에서 만든 k3s는 가벼운 옵션으로 좋은 선택일 것입니다. 그 중 일부 장점은 작은 실행 파일 크기, 매우 낮은 자원 요구 사항 및 ARM용으로 최적화되어 있다는 것입니다. 이 가이드에서는 이를 테스트해보지 않았지만, 이후에 비슷한 설정이 될 것으로 생각합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 클러스터를 초기화할 시간입니다. 이를 위해 InitConfiguration 및 ClusterConfiguration 설정이 포함된 파일을 만들겠습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"apiVersion\"\n        }), \": kubeadm.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"k8s\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"io\"\n        }), \"/v1beta3\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"bootstrapTokens\"\n        }), \":\\n- \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"groups\"\n        }), \":\\n  - \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"system\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"bootstrappers\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"kubeadm\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"default\"\n        }), \"-node-token\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"token\"\n        }), \": {token}\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"usages\"\n        }), \":\\n  - signing\\n  - authentication\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"kind\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"InitConfiguration\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"localAPIEndpoint\"\n        }), \":\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"advertiseAddress\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10.0\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".0\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".100\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"bindPort\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6443\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"nodeRegistration\"\n        }), \":\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"criSocket\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"unix\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"///var/run/cri-dockerd.sock\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"imagePullPolicy\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"IfNotPresent\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": node-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\n---\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"apiVersion\"\n        }), \": kubeadm.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"k8s\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"io\"\n        }), \"/v1beta3\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"kind\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ClusterConfiguration\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"networking\"\n        }), \":\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"podSubnet\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"10.244.0.0/16\\\"\"\n        }), \" # --pod-network-cidr\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 파일에는 마스터 노드의 설정이 포함되어 있습니다. criSocket이 cri-dockerd를 사용하고, 나중에 네트워크 CIDR을 설정해두었음을 주목하십시오.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 노드에서 제어 평면을 초기화하려면 다음을 실행하세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"sudo kubeadm init --config kubeadm-config.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"yaml\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 명령은 새 노드를 클러스터에 추가하는 설정 및 kube-config를 설정하는 방법을 보여줍니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"명령에서 지시하는 방법에 따라 kube-config를 설정하고, 워크스테이션에 kube-config와 가입 명령을 복사하고 저장하세요. 나중에 필요할 것이니까요!\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"클러스터 네트워킹\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 클러스터에서 네트워킹을 설정해야 합니다. Pod들이 노드 간에 서로 통신할 수 있도록 하려면 네트워크 플러그인 (CNI 또는 컨테이너 네트워크 인터페이스로도 불림)이 필요합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"네트워크 플러그인은 IP 주소 할당, DNS 해결 및 네트워크 격리와 같은 기능을 Pod에 제공합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 이를 위해 Flannel을 사용할 것입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마스터 노드에서 다음을 실행해 주세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"kubectl apply -f \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그게 다에요! 이제 마스터 노드가 완료되었으니, 클러스터에 새 노드를 추가하기 시작할 수 있어요. 이전에 출력된 조인 명령을 기억하고 있나요? 이제 그것이 필요할 거에요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"클러스터에 새로운 노드 추가하기\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"클러스터에 새 노드를 추가하는 것은 꽤 간단합니다. 많은 노드를 추가하는 경우에는 tmux와 같은 도구를 사용하여 세션 명령을 다중화하는 것이 좋습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"\\\"첫 번째 부팅 및 초기 설정\\\"을 완료하고 \\\"도커 및 쿠버네티스 초기 설정\\\"을 진행하세요. 서로 다른 Kubernetes 구성 요소를 설치하는 단계 이후에 작업을 중지하세요. 이 시점에서 이전에 실행한 kubeadm join 명령을 실행해야 합니다. cri-socket 및 node-name 옵션을 포함하여 실행해 주세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"sudo kubeadm join \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10.0\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".0\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".100\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6443\"\n        }), \" --token {token} --discovery-token-ca-cert-hash {hash} --cri-socket \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"unix\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"///var/run/cri-dockerd.sock --node-name {name}\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 마스터 노드에서 클러스터를 모니터링하고 모든 노드가 클러스터에 가입하는지 확인하세요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"\u003e kubectl get nodes를 watch합니다.\\n이제 귀하의 클러스터가 사용할 준비가 되었습니다! 그러나 \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"SSH\"\n        }), \"를 통해가 아닌 워크스테이션에서 액세스하고 싶을 것입니다. 컴퓨터에서 이전에 설정한 kube-config를 설정할 수 있습니다.\\n\\n기본 kube-config는 관리자 권한을 부여하며 다른 사람과 공유해서는 안됩니다.\\n\\n먼저 프로필에 구성을 내보냅니다.\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"KUBECONFIG\"\n        }), \"=~\", _jsx(_components.span, {\n          className: \"hljs-regexp\",\n          children: \"/.kube/\"\n        }), \"config\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"컨텍스트 설정:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"kubectl config use-context kubernetes-admin@kubernetes\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 원격으로 클러스터에 액세스할 수 있어야 합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"\u003e kubectl cluster-info\\n쿠버네티스 제어 평면이 \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//10.0.0.100:6443 에서 실행 중입니다.\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"CoreDNS\"\n        }), \"이 \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//10.0.0.100:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy 에서 실행 중입니다.\"\n        }), \"\\n\\n더 많은 디버깅 및 진단을 위해 \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'kubectl cluster-info dump'\"\n        }), \"를 사용하세요.\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"도구 설정\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 밴자이라 클러스터를 일반에서 멋지게 업그레이드해 봅시다. 새 응용 프로그램을 쉽게 배포하고 클러스터를 모니터링할 수 있는 몇 가지 널리 사용되는 도구를 설정해 보겠습니다. 여기서 ArgoCD, Prometheus 및 Grafana 설치 방법을 안내하겠습니다! 이 세 가지 오픈소스 프로젝트가 우리의 클러스터를 다음 수준으로 끌어올립니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"계속하기 전에, 이러한 도구들에 대한 모든 설정 변경 사항을 추적하기 위한 원격 git 저장소를 만들어 보시기를 권장합니다. 특히 ArgoCD를 사용할 때, 각 도구나 추가 응용 프로그램을 배포할 때마다 거기를 통해 추가합니다.```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"ArgoCD\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"각 도구에 대해 Helm을 리소스 템플릿팅 도구로 사용할 것입니다. 최신 버전(또는 적어도 Helm v3)을 설치하고 ArgoCD 저장소를 추가해 봅시다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"helm repo add argo \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//argoproj.github.io/argo-helm\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Values 파일을 생성하세요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-yaml\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"server:\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"serviceType:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"NodePort\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"httpNodePort:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"30080\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"httpsNodePort:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"30443\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 파일은 차트의 설정 중 하나를 재정의하는 데 사용할 수 있습니다. 이 경우에는 서비스를 ClusterIP 대신 NodePort로 실행하도록 변경하고 있습니다. 이렇게 하면 클러스터에서 지정한 포트를 외부에서 엑세스할 수 있도록 하여 리버스 프록시를 사용하지 않고도 개인 네트워크에서 해당 서비스에 액세스할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"서비스를 설치하십시오.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"helm install argocd -n argocd -f values.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"yaml\"\n        }), \" argo/argocd\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그럼 관리자 사용자의 기본 암호를 가져와야 합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{.data.password}\\\"\"\n        }), \" | base64 -d\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"OpenWrt를 사용하고 있기 때문에 클러스터에 호스트 이름 항목을 설정하고 https://cluster.home:30443에서 로그인 페이지에 액세스할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_2.png\",\n        alt: \"그림\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ArgoCD에 로그인하고, 곧 돌아올게요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_3.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Prometheus\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 클러스터에 대한 정보 수집을 위해 타임 시리즈 메트릭 서버로 Prometheus를 사용할 거에요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"설치하기 전에 Prometheus가 쿼리 데이터를 저장할 지속적인 볼륨을 설정해야 합니다. 집 클러스터에서는 예비 USB 드라이브를 사용하기로 결정했지만 원하는 것을 연결하여 사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마스터 노드에서 볼륨을 설정한 단계는 다음과 같습니다. 우리의 볼륨을 위한 경로를 만들고 실수를 막기 위해 변경 사항을 반영해야 할 fstab의 백업을 만듭니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"sudo mkdir /mnt/usb\\nsudo cp /etc/fstab /etc/fstab.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"bak\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"장치를 연결한 다음 fstab을 변경 내용과 함께 수정합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-md\",\n        children: \"/dev/sda1 /mnt/usb vfat defaults,uid=youruid,gid=yourgid,dmask=002,fmask=113 0 0\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 우리 노드 사용자의 사용자 및 그룹 설정으로 장치를 마운트합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-md\",\n        children: \"sudo mount -o uid=youruid,gid=yourgid,dmask=002,fmask=113 /dev/sdX1 /mnt/usb\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 우리는 PersistentVolume과 PersistentVolumeChain을 가진 Kubernetes 자원을 생성하려고 합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-yaml\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"apiVersion:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"v1\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"kind:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"PersistentVolume\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"metadata:\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"prometheus-usb-pv\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"labels:\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"type:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"local\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"spec:\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"storageClassName:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"manual\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"capacity:\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"storage:\"\n        }), \" {\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"device의\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"크기\"\n        }), \"}\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"Gi\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"accessModes:\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-bullet\",\n          children: \"-\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"ReadWriteOnce\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"persistentVolumeReclaimPolicy:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"Retain\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"hostPath:\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"path:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"/mnt/usb\\\"\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"---\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"apiVersion:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"v1\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"kind:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"PersistentVolumeClaim\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"metadata:\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"prometheus-usb-pvc\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"spec:\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"storageClassName:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"manual\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"accessModes:\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-bullet\",\n          children: \"-\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"ReadWriteOnce\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"resources:\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"requests:\"\n        }), \"\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"storage:\"\n        }), \" {\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"device의\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"크기\"\n        }), \"}\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"Gi\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"만약 git 리포지토리를 사용 중이라면, 이 파일들을 template 디렉토리 안에 새로운 Helm Chart에 위치시켜주세요. 다음 단계를 따라 계속 진행해봐요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 프로메테우스와 함께 차트를 설정해봅시다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-bash\",\n        children: \"helm create prometheus\\n\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Chart.yaml에 Prometheus subchart를 종속성으로 추가해주세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-yaml\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"dependencies:\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-bullet\",\n          children: \"-\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"prometheus\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"version:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"22.7\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".0\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"repository:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"https://prometheus-community.github.io/helm-charts\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 새 PV 및 PVC를 사용하도록 구성을 설정하고, 일부 권한을 수정하고 서버를 마스터 노드에만 배포하도록 확인할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-yaml\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"prometheus:\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"alertmanager:\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"enabled:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"prometheus-pushgateway:\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"enabled:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"configmapReload:\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"prometheus:\"\n        }), \"\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"enabled:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"server:\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"nodeSelector:\"\n        }), \"\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"kubernetes.io/hostname:\"\n        }), \" {\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"master\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"node\"\n        }), \"}\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"securityContext:\"\n        }), \"\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"runAsUser:\"\n        }), \" {\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"userid\"\n        }), \"}\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"runAsNonRoot:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \"\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"runAsGroup:\"\n        }), \" {\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"groupid\"\n        }), \"}\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"fsGroup:\"\n        }), \" {\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"fsid\"\n        }), \"}\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"persistentVolume:\"\n        }), \"\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"enabled:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \"\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"existingClaim:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"prometheus-usb-pvc\\\"\"\n        }), \"\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"volumeName:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"prometheus-usb-pv\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"일부 추가 서비스를 비활성화합니다. 예를 들어 alertmanager, pushgateway, 그리고 configmapreload가 이에 해당합니다. 필요한 경우 다른 시간에 이를 활성화할 수 있습니다. 비정상적으로 행동하는 경우 알림을 받을 수 있는 유용한 도구인 Alert Manager입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 ArgoCD로 돌아가 \\\"새 앱\\\"을 만들어보겠습니다. Prometheus라는 이름의 앱을 만들고 깃 레포지토리를 소스로 추가하고 경로를 선택하세요. Grafana도 나중에 이 작업을 해야하므로 서로 다른 경로에 유지하세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_4.png\",\n        alt: \"Image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"생성한 사용자 정의 설정을 설정할 값 파일을 선택한 다음 앱을 생성하세요. 수동으로 동기화하도록 지정한 경우 동기화가 필요할 때 이를 수행해야 합니다. 이것은 업그레이드할 때 사용하거나 수동으로 릴리스하고자 할 때 유용합니다. 그 외에는 홈 프로젝트에 가장 적합한 CD용 자동 동기화 방법이 유용합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*Ice0ZJGARkN6BdzAl1nGDQ.gif\",\n        alt: \"Grafana\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마찬가지로 Prometheus와 비슷하게, git 레포지토리에서 새로운 Helm 차트를 생성하는 것부터 시작해보세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"helm create grafana\\n\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"헬름 리포지토리를 추가해주세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"helm repo add grafana \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//grafana.github.io/helm-charts\"\n        }), \"\\nhelm repo update\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"리포지토리를 통해 차트를 업데이트하세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"dependencies\"\n        }), \":\\n  - \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": grafana\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"version\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6.57\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".4\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"repository\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//grafana.github.io/helm-charts\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"values.yaml 파일을 추가해주세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"grafana\"\n        }), \":\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"service\"\n        }), \":\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"enabled\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"type\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NodePort\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"nodePort\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"30180\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그런 다음 이전과 같이 ArgoCD를 통해 Grafana를 추가해주세요. 동기화를 진행하고 이제 두 개가 모두 실행 중이어야 합니다.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_5.png\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Grafana를 사용하려면 관리자 비밀번호를 먼저 얻어야 합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"kubectl get secret --namespace monitoring grafana -o jsonpath=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{.data.admin-password}\\\"\"\n        }), \" | base64 --decode ; echo\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"출력에서 나온 관리자 사용자 이름과 비밀번호로 로그인해주세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_6.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 Prometheus 데이터 원본을 추가해 보겠습니다. Prometheus 서비스 URL은 모니터링을 설정한 네임스페이스인 클러스터에서 http://prometheus-server.monitoring.svc.cluster.local로 접근할 수 있습니다. \\\"Administration\\\" → \\\"Data sources\\\" → \\\"Add new data source\\\" 아래로 이동한 다음 URL을 추가하고 \\\"Save \u0026 Test\\\"를 클릭하여 확인할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*VphOqjzSh30E4dKrnf2Q2A.gif\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"만약 우리 클러스터의 상태를 간단히 확인하고 싶다면 Grafana Labs에서 제공하는 대시보드를 사용할 수 있습니다. 이를 통해 우리 클러스터에서 사용되는 리소스에 대한 간단한 뷰를 확인할 수 있을 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*AIw7esBCtaz5koK_uJTU-w.gif\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"다음 단계\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"사용자 정의 Docker 이미지\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"당신의 클러스터를 운영하는 중요한 단계로, 공개 Docker.io 레지스트리에 없는 컨테이너나 사용자 정의 컨테이너를 배포할 수 있게 됩니다. 클러스터에 많은 컨테이너를 배포할 계획이라면, 무료 티어 Docker Hub의 제한을 피하기 위해 개인 컨테이너 레지스트리를 설정하는 것을 권장합니다. 이는 GCP의 Artifacts Repository와 같은 클라우드 공급업체나 Harbor와 같은 오픈 소스 docker 저장소로 구현할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"클러스터 자동화\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 안내서는 교육 목적이나 소규모 개인 클러스터를 관리할 때 이상적인 Kubernetes 클러스터 설정에 대한 수동 방법을 제공합니다. 그러나 프로덕션 클러스터를 배포하거나 이 안내서의 범위를 벗어나는 작업을 수행할 경우, Ansible과 같은 자동화 도구를 활용하는 것을 권장합니다. 이렇게하면 더 효율적이고 확장 가능하며 관리하기 쉬운 배포가 가능합니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Kubernetes 클러스터를 설정하는 것은 쉽지 않을 수 있지만 한 번 완료되면 일반적인 독립형 서버를 뛰어넘는 확장 가능한 환경을 제공하는 장점이 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Raspberry Pi는 비용이 저렴하고 전력 소비가 낮은 옵션이지만, 더 큰 응용 프로그램에 대한 확장성이 여전히 제한되어 있습니다. Kubernetes 클러스터의 장점은 동일한 하드웨어만 실행하는 것에 제한받지 않는다는 것입니다. 새로운 노드를 추가함으로써 다양한 하드웨어를 혼합하여 필요에 맞게 Raspberry Pi나 서버와 같은 다양한 하드웨어를 조합할 수 있습니다!\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그것이 좋은 시작점이 되었기를 바랍니다. 읽어 주셔서 감사합니다!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis"},"buildId":"ll1cGyplNwh83dpggeai1","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>