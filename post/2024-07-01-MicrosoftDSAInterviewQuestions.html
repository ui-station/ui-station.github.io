<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Microsoft DSA 면접 질문 모음 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-07-01-MicrosoftDSAInterviewQuestions" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Microsoft DSA 면접 질문 모음 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Microsoft DSA 면접 질문 모음 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-07-01-MicrosoftDSAInterviewQuestions" data-gatsby-head="true"/><meta name="twitter:title" content="Microsoft DSA 면접 질문 모음 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-01 15:54" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_buildManifest.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Microsoft DSA 면접 질문 모음</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Microsoft DSA 면접 질문 모음" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 1, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-01-MicrosoftDSAInterviewQuestions&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>질문 1</h1>
<p><img src="/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_0.png" alt="이미지"></p>
<p>두 개의 동일한 길이를 가진 정수 배열 A와 B가 주어졌을 때, 시작점 j까지 A의 요소들의 누적 합이 B의 요소들의 누적 합과 같은 경우의 수를 반환하는 solution(A, B) 함수를 작성하십시오. 이때 다음 조건들을 만족해야 합니다:</p>
<ul>
<li>A의 요소들의 누적 합이 시작부터 j까지 B의 요소들의 누적 합과 동일합니다.</li>
<li>A의 요소들의 누적 합이 배열 A의 총 합의 절반과 동일합니다.</li>
<li>B의 요소들의 누적 합이 배열 B의 총 합의 절반과 동일합니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>방법,</h2>
<ul>
<li>총합 초기화: 주석은 sumA 및 sumB의 초기화 및 목적을 명확히 합니다.</li>
<li>총합 계산: 총합을 계산하는 루프에 대한 주석이 있습니다.</li>
<li>유효한 분할 지점 계산: count의 목적 및 유효한 분할 지점을 확인하는 논리에 대한 설명이 있습니다.</li>
<li>누적 합: tempA 및 tempB의 초기화 및 누적 합을 추적하는 역할을 명확히 하는 주석이 있습니다.</li>
<li>반복 및 조건 확인: 두 번째 요소부터 시작하는 루프, 유효한 분할 지점을 찾기 위해 확인된 조건 및 누적 합의 업데이트를 설명하는 주석이 있습니다.</li>
</ul>
<h2>실제 실행,</h2>
<pre><code class="hljs language-js">단계별 결과

총합 계산:
sumA 진행: <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>
sumB 진행: <span class="hljs-number">0</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>
최종 sumA = <span class="hljs-number">6</span>
최종 sumB = <span class="hljs-number">6</span>

누적 합 및 조건 확인:

초기화:
tempA = <span class="hljs-number">0</span>
tempB = <span class="hljs-number">0</span>

반복:

j = <span class="hljs-number">1</span>:
tempA = <span class="hljs-number">4</span>
tempB = -<span class="hljs-number">2</span>
조건 미충족

j = <span class="hljs-number">2</span>:
tempA = <span class="hljs-number">3</span>
tempB = <span class="hljs-number">3</span>
조건: tempA === tempB &#x26;&#x26; <span class="hljs-number">2</span> * tempA === sumA &#x26;&#x26; <span class="hljs-number">2</span> * tempB == sumB
<span class="hljs-number">3</span> === <span class="hljs-number">3</span> &#x26;&#x26; <span class="hljs-number">2</span> * <span class="hljs-number">3</span> === <span class="hljs-number">6</span> &#x26;&#x26; <span class="hljs-number">2</span> * <span class="hljs-number">3</span> == <span class="hljs-number">6</span> (참)
하지만, j !== <span class="hljs-number">1</span>이어야 조건이 검사됨

j = <span class="hljs-number">3</span>:
tempA = <span class="hljs-number">3</span>
tempB = <span class="hljs-number">3</span>
조건: tempA === tempB &#x26;&#x26; <span class="hljs-number">2</span> * tempA === sumA &#x26;&#x26; <span class="hljs-number">2</span> * tempB == sumB
<span class="hljs-number">3</span> === <span class="hljs-number">3</span> &#x26;&#x26; <span class="hljs-number">2</span> * <span class="hljs-number">3</span> === <span class="hljs-number">6</span> &#x26;&#x26; <span class="hljs-number">2</span> * <span class="hljs-number">3</span> == <span class="hljs-number">6</span> (참)
조건 충족, 그러나 j !== <span class="hljs-number">1</span>이므로 조건이 이 단계에서는 확인되지 않음

j = <span class="hljs-number">4</span>:
tempA = <span class="hljs-number">6</span>
tempB = <span class="hljs-number">6</span>
필요한 길이를 초과하여 조건 확인이 안 됨

최종 결과:
조건 j !== <span class="hljs-number">1</span> &#x26;&#x26; tempA === tempB &#x26;&#x26; <span class="hljs-number">2</span> * tempA === sumA &#x26;&#x26; <span class="hljs-number">2</span> * tempB == sumB이 전혀 충족되지 않아 count는 <span class="hljs-number">0</span>으로 남습니다.
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>구현,</h2>
<pre><code class="hljs language-js"><span class="hljs-attr">A</span>: [<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]
<span class="hljs-attr">B</span>: [<span class="hljs-number">0</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]

<span class="hljs-keyword">function</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">A, B</span>) {
  <span class="hljs-comment">// 배열 A와 B의 총합을 저장할 sumA와 sumB를 초기화합니다.</span>
  <span class="hljs-keyword">let</span> sumA = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> sumB = <span class="hljs-number">0</span>;

  <span class="hljs-comment">// 배열 A와 B의 요소 총합을 계산합니다.</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; A.<span class="hljs-property">length</span>; i++) {
    sumA += A[i]; <span class="hljs-comment">// 각 반복 후 sumA = [0, 4, 3, 3, 6]</span>
    sumB += B[i]; <span class="hljs-comment">// 각 반복 후 sumB = [0, -2, 3, 3, 6]</span>
  }

  <span class="hljs-comment">// sumA는 이제 6입니다.</span>
  <span class="hljs-comment">// sumB는 이제 6입니다.</span>

  <span class="hljs-comment">// 유효한 분할 지점의 수를 추적하는 count를 초기화합니다.</span>
  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;

  <span class="hljs-comment">// 현재 인덱스까지 누적 합을 저장할 tempA와 tempB를 초기화합니다.</span>
  <span class="hljs-keyword">let</span> tempA = A[<span class="hljs-number">0</span>]; <span class="hljs-comment">// tempA = 0</span>
  <span class="hljs-keyword">let</span> tempB = B[<span class="hljs-number">0</span>]; <span class="hljs-comment">// tempB = 0</span>

  <span class="hljs-comment">// 두 번째 요소부터 배열을 반복합니다.</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &#x3C; A.<span class="hljs-property">length</span>; j++) {
    <span class="hljs-comment">// 현재 누적 합(첫 번째 인덱스 제외)이 같고,</span>
    <span class="hljs-comment">// 서로의 배열 합의 절반인지 확인합니다.</span>
    <span class="hljs-keyword">if</span> (j !== <span class="hljs-number">1</span> &#x26;&#x26; tempA === tempB &#x26;&#x26; <span class="hljs-number">2</span> * tempA === sumA &#x26;&#x26; <span class="hljs-number">2</span> * tempB == sumB) {
      count++; <span class="hljs-comment">// 이 경우 조건이 충족되지 않아 count는 여전히 0입니다.</span>
    }

    <span class="hljs-comment">// 현재 요소로 누적 합을 업데이트합니다.</span>
    tempA += A[j]; <span class="hljs-comment">// 각 반복 후 tempA 값: [0, 4, 3, 3, 6]</span>
    tempB += B[j]; <span class="hljs-comment">// 각 반복 후 tempB 값: [0, -2, 3, 3, 6]</span>
  }

  <span class="hljs-comment">// 유효한 분할 지점의 수를 반환합니다.</span>
  <span class="hljs-keyword">return</span> count; <span class="hljs-comment">// 유효한 분할 지점을 찾지 못해 count는 0입니다.</span>
}

<span class="hljs-comment">// 사용 예시</span>
<span class="hljs-keyword">const</span> A = [<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> B = [<span class="hljs-number">0</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">solution</span>(A, B)); <span class="hljs-comment">// 출력: 0</span>
</code></pre>
<h1>두 번째 질문</h1>
<img src="/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_1.png">
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>단계별 접근 방법:</h2>
<p>초기화:</p>
<ul>
<li>각 요소가 이전 요소와 다음 요소보다 큰지를 추적하는 배열 isGreaterThanPrev 및 isGreaterThanNext를 초기화합니다.</li>
<li>이전 요소나 다음 요소와 비교할 요소가 없는 첫 번째 요소의 isGreaterThanPrev와 마지막 요소의 isGreaterThanNext를 -1로 초기화합니다.</li>
</ul>
<p>비교 배열 채우기:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>배열 Y를 순회하여 각 요소가 다음 요소보다 큰지 나타내는 isGreaterThanNext를 채웁니다.</li>
<li>배열 Y를 순회하여 각 요소가 이전 요소보다 큰지 나타내는 isGreaterThanPrev를 채웁니다.</li>
</ul>
<p>쌍(Pairs) 생성 및 정렬:</p>
<ul>
<li>각 Y의 요소에 대해 [값, 인덱스] 쌍을 포함하는 배열 v를 생성합니다.</li>
<li>배열 v를 요소의 값에 기반하여 내림차순으로 정렬합니다.</li>
</ul>
<p>변수 초기화:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>cur와 maxLines라는 변수를 초기화하여 현재 라인 수와 관찰된 최대 라인 수를 추적합니다.</li>
</ul>
<p>정렬된 요소 처리:</p>
<ul>
<li>동일한 값으로 처리할 요소를 처리하기 위해 정렬된 배열 v를 반복합니다.</li>
<li>각 요소에 대해 다음을 계산합니다:
<ul>
<li>down: 시작 부분에서 이전 요소보다 큰 요소 수 또는 끝 부분에서 다음 요소보다 큰 요소 수.</li>
<li>up: 시작 부분에서 다음 요소보다 크지 않은 요소 수 또는 끝 부분에서 이전 요소보다 크지 않은 요소 수.</li>
<li>peaks: 다음과 이전 요소보다 큰 요소 수.</li>
<li>valleys: 다음과 이전 요소보다 작은 요소 수.</li>
<li>peaks를 추가하고 valleys를 빼고 down/up 값을 통해 현재 라인 수 cur를 조정합니다.</li>
<li>현재 라인 수가 이전 최대값을 초과하면 최대 라인 수 maxLines를 업데이트합니다.</li>
</ul>
</li>
</ul>
<p>결과 반환:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>배열에서 각각의 peak(봉우리)와 valley(골짜기) 전환을 나타내는 비중복 라인(줄)의 최대 수인 maxLines를 반환합니다.</li>
</ul>
<h2>실행 과정,</h2>
<pre><code class="hljs language-js">중간 결과와 함께 설명:
초기화:

이전 요소보다 큰지, 이후 요소보다 큰지를 추적할 isGreaterThanPrev 및 isGreaterThanNext 배열이 생성됩니다.
isGreaterThanNext = [<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, -<span class="hljs-number">1</span>]
isGreaterThanPrev = [-<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>]
쌍 생성 및 정렬:

Y의 각 요소에 대해 [값, 인덱스] 쌍 생성합니다.
정렬 전 <span class="hljs-attr">v</span>: [[<span class="hljs-number">2</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]
값을 기준으로 v를 내림차순으로 정렬합니다.
정렬 후 <span class="hljs-attr">v</span>: [[<span class="hljs-number">6</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]]
정렬된 요소 처리:

요소 <span class="hljs-number">6</span> (인덱스 <span class="hljs-number">5</span>):
down = <span class="hljs-number">1</span>, 이전 요소보다 크고, 끝에 위치하므로
up = <span class="hljs-number">0</span>, 조건 충족 없음.
cur = <span class="hljs-number">1</span>, maxLines = <span class="hljs-number">1</span>
요소 <span class="hljs-number">5</span> (인덱스 <span class="hljs-number">4</span>와 <span class="hljs-number">6</span>):
인덱스 <span class="hljs-number">4</span>:
down = <span class="hljs-number">0</span>, up = <span class="hljs-number">0</span>
인덱스 <span class="hljs-number">6</span>:
down = <span class="hljs-number">0</span>, up = <span class="hljs-number">1</span>, 이전 요소보다 크지 않고, 끝에 위치하므로
봉우리 = <span class="hljs-number">0</span>, 골짜기 = <span class="hljs-number">0</span>
cur = <span class="hljs-number">1</span> - <span class="hljs-number">1</span> = <span class="hljs-number">0</span>, maxLines = <span class="hljs-number">1</span>
요소 <span class="hljs-number">3</span> (인덱스 <span class="hljs-number">1</span>):
down = <span class="hljs-number">0</span>, up = <span class="hljs-number">0</span>
봉우리 = <span class="hljs-number">1</span>, 이전과 이후 요소보다 크기 때문.
cur = <span class="hljs-number">0</span> + <span class="hljs-number">1</span> - <span class="hljs-number">0</span> = <span class="hljs-number">1</span>, maxLines = <span class="hljs-number">1</span>
요소 <span class="hljs-number">2</span> (인덱스 <span class="hljs-number">0</span>와 <span class="hljs-number">2</span>):
인덱스 <span class="hljs-number">0</span>:
down = <span class="hljs-number">0</span>, up = <span class="hljs-number">1</span>, 이후 요소보다 크지 않고, 시작에 위치하므로
인덱스 <span class="hljs-number">2</span>:
down = <span class="hljs-number">0</span>, up = <span class="hljs-number">0</span>
봉우리 = <span class="hljs-number">0</span>, 골짜기 = <span class="hljs-number">1</span>, 이전과 이후 요소보다 작기 때문.
cur = <span class="hljs-number">1</span> - <span class="hljs-number">1</span> - <span class="hljs-number">0</span> = <span class="hljs-number">0</span>, maxLines = <span class="hljs-number">1</span>
요소 <span class="hljs-number">1</span> (인덱스 <span class="hljs-number">3</span>):
down = <span class="hljs-number">0</span>, up = <span class="hljs-number">0</span>
봉우리 = <span class="hljs-number">0</span>, 골짜기 = <span class="hljs-number">0</span>
cur = <span class="hljs-number">0</span> + <span class="hljs-number">0</span> - <span class="hljs-number">0</span> = <span class="hljs-number">0</span>, maxLines = <span class="hljs-number">1</span>
최종 결과:

관측된 최대 라인 수는 <span class="hljs-number">1</span>이고, 따라서 maxLines = <span class="hljs-number">1</span>입니다.
</code></pre>
<h2>구현,</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">Y</span>) {
  <span class="hljs-keyword">let</span> n = Y.<span class="hljs-property">length</span>;

  <span class="hljs-comment">// 다음 요소보다 크다는지 이전 요소보다 크다는지 추적하는 배열</span>
  <span class="hljs-keyword">let</span> isGreaterThanPrev = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n);
  <span class="hljs-keyword">let</span> isGreaterThanNext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n);
  isGreaterThanNext[n - <span class="hljs-number">1</span>] = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 마지막 요소는 다음 요소가 없음</span>
  isGreaterThanPrev[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 첫 요소는 이전 요소가 없음</span>

  <span class="hljs-comment">// isGreaterThanNext 배열 작성</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; n - <span class="hljs-number">1</span>; i++) {
    isGreaterThanNext[i] = Y[i] > Y[i + <span class="hljs-number">1</span>];
  }

  <span class="hljs-comment">// isGreaterThanNext = [false, true, true, false, false, true, -1]</span>

  <span class="hljs-comment">// isGreaterThanPrev 배열 작성</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &#x3C; n; i++) {
    isGreaterThanPrev[i] = Y[i] > Y[i - <span class="hljs-number">1</span>];
  }

  <span class="hljs-comment">// isGreaterThanPrev = [-1, true, false, false, true, true, false]</span>

  <span class="hljs-comment">// [값, 인덱스] 쌍의 배열 생성</span>
  <span class="hljs-keyword">let</span> v = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; n; i++) {
    v.<span class="hljs-title function_">push</span>([Y[i], i]);
  }

  <span class="hljs-comment">// v = [[2, 0], [3, 1], [2, 2], [1, 3], [5, 4], [6, 5], [5, 6]]</span>

  <span class="hljs-comment">// 값 기준으로 내림차순 정렬</span>
  v.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =></span> b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">0</span>]);

  <span class="hljs-comment">// v = [[6, 5], [5, 4], [5, 6], [3, 1], [2, 0], [2, 2], [1, 3]]</span>

  <span class="hljs-keyword">let</span> cur = <span class="hljs-number">0</span>,
    maxLines = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; v.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">let</span> y = v[i][<span class="hljs-number">0</span>];

    <span class="hljs-keyword">let</span> peaks = <span class="hljs-number">0</span>,
      valleys = <span class="hljs-number">0</span>,
      down = <span class="hljs-number">0</span>,
      up = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 동일한 값 요소 처리</span>
    <span class="hljs-keyword">while</span> (i &#x3C; v.<span class="hljs-property">length</span> &#x26;&#x26; v[i][<span class="hljs-number">0</span>] === y) {
      <span class="hljs-keyword">let</span> idx = v[i][<span class="hljs-number">1</span>];

      <span class="hljs-comment">// 아래로 향하는 지점인지 확인</span>
      <span class="hljs-keyword">if</span> (
        (idx === <span class="hljs-number">0</span> &#x26;&#x26; isGreaterThanNext[idx]) ||
        (idx === n - <span class="hljs-number">1</span> &#x26;&#x26; isGreaterThanPrev[idx])
      ) {
        down++;
      }

      <span class="hljs-comment">// 올라가는 골짜기인지 확인</span>
      <span class="hljs-keyword">if</span> (
        (idx === <span class="hljs-number">0</span> &#x26;&#x26; !isGreaterThanNext[idx]) ||
        (idx === n - <span class="hljs-number">1</span> &#x26;&#x26; !isGreaterThanPrev[idx])
      ) {
        up++;
      }

      <span class="hljs-keyword">let</span> isNotEnd = idx > <span class="hljs-number">0</span> &#x26;&#x26; idx &#x3C; n - <span class="hljs-number">1</span>;

      <span class="hljs-comment">// 산인지 확인</span>
      <span class="hljs-keyword">if</span> (isNotEnd &#x26;&#x26; isGreaterThanNext[idx] &#x26;&#x26; isGreaterThanPrev[idx]) {
        peaks++;
      } 
      <span class="hljs-comment">// 계곡인지 확인</span>
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isNotEnd &#x26;&#x26; !isGreaterThanNext[idx] &#x26;&#x26; !isGreaterThanPrev[idx]) {
        valleys++;
      }
      i++;
    }

    i--;

    <span class="hljs-comment">// 현재 라인 수 계산</span>
    cur = cur + peaks - valleys + down;
    maxLines = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxLines, cur);

    cur = cur + peaks - valleys - up;
    maxLines = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxLines, cur);
  }

  <span class="hljs-keyword">return</span> maxLines;
}

<span class="hljs-comment">// 사용 예시</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">solution</span>([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>])); <span class="hljs-comment">// 출력: 2</span>
</code></pre>
<h1>읽어 주셔서 감사합니다</h1>
<ul>
<li>👏 이야기에 박수를 보내주시고 팔로우 부탁드립니다 👉</li>
<li>📰 자바스크립트, 자료 구조 및 알고리즘, 리액트, 인터뷰 준비 등 다양한 콘텐츠 확인해보세요</li>
<li>🔔 팔로우 링크: LinkedIn!</li>
</ul>
<p>늘 개선할 점이 있을텐데요. 의견을 자유롭게 공유해주세요. 😊</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Microsoft DSA 면접 질문 모음","description":"","date":"2024-07-01 15:54","slug":"2024-07-01-MicrosoftDSAInterviewQuestions","content":"\n\n# 질문 1\n\n![이미지](/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_0.png)\n\n두 개의 동일한 길이를 가진 정수 배열 A와 B가 주어졌을 때, 시작점 j까지 A의 요소들의 누적 합이 B의 요소들의 누적 합과 같은 경우의 수를 반환하는 solution(A, B) 함수를 작성하십시오. 이때 다음 조건들을 만족해야 합니다:\n\n- A의 요소들의 누적 합이 시작부터 j까지 B의 요소들의 누적 합과 동일합니다.\n- A의 요소들의 누적 합이 배열 A의 총 합의 절반과 동일합니다.\n- B의 요소들의 누적 합이 배열 B의 총 합의 절반과 동일합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 방법,\n\n- 총합 초기화: 주석은 sumA 및 sumB의 초기화 및 목적을 명확히 합니다.\n- 총합 계산: 총합을 계산하는 루프에 대한 주석이 있습니다.\n- 유효한 분할 지점 계산: count의 목적 및 유효한 분할 지점을 확인하는 논리에 대한 설명이 있습니다.\n- 누적 합: tempA 및 tempB의 초기화 및 누적 합을 추적하는 역할을 명확히 하는 주석이 있습니다.\n- 반복 및 조건 확인: 두 번째 요소부터 시작하는 루프, 유효한 분할 지점을 찾기 위해 확인된 조건 및 누적 합의 업데이트를 설명하는 주석이 있습니다.\n\n## 실제 실행,\n\n```js\n단계별 결과\n\n총합 계산:\nsumA 진행: 0, 4, 3, 3, 6\nsumB 진행: 0, -2, 3, 3, 6\n최종 sumA = 6\n최종 sumB = 6\n\n누적 합 및 조건 확인:\n\n초기화:\ntempA = 0\ntempB = 0\n\n반복:\n\nj = 1:\ntempA = 4\ntempB = -2\n조건 미충족\n\nj = 2:\ntempA = 3\ntempB = 3\n조건: tempA === tempB \u0026\u0026 2 * tempA === sumA \u0026\u0026 2 * tempB == sumB\n3 === 3 \u0026\u0026 2 * 3 === 6 \u0026\u0026 2 * 3 == 6 (참)\n하지만, j !== 1이어야 조건이 검사됨\n\nj = 3:\ntempA = 3\ntempB = 3\n조건: tempA === tempB \u0026\u0026 2 * tempA === sumA \u0026\u0026 2 * tempB == sumB\n3 === 3 \u0026\u0026 2 * 3 === 6 \u0026\u0026 2 * 3 == 6 (참)\n조건 충족, 그러나 j !== 1이므로 조건이 이 단계에서는 확인되지 않음\n\nj = 4:\ntempA = 6\ntempB = 6\n필요한 길이를 초과하여 조건 확인이 안 됨\n\n최종 결과:\n조건 j !== 1 \u0026\u0026 tempA === tempB \u0026\u0026 2 * tempA === sumA \u0026\u0026 2 * tempB == sumB이 전혀 충족되지 않아 count는 0으로 남습니다.\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 구현,\n\n```js\nA: [0,4,-1,0,3]\nB: [0,-2,5,0,3]\n\nfunction solution(A, B) {\n  // 배열 A와 B의 총합을 저장할 sumA와 sumB를 초기화합니다.\n  let sumA = 0;\n  let sumB = 0;\n\n  // 배열 A와 B의 요소 총합을 계산합니다.\n  for (let i = 0; i \u003c A.length; i++) {\n    sumA += A[i]; // 각 반복 후 sumA = [0, 4, 3, 3, 6]\n    sumB += B[i]; // 각 반복 후 sumB = [0, -2, 3, 3, 6]\n  }\n\n  // sumA는 이제 6입니다.\n  // sumB는 이제 6입니다.\n\n  // 유효한 분할 지점의 수를 추적하는 count를 초기화합니다.\n  let count = 0;\n\n  // 현재 인덱스까지 누적 합을 저장할 tempA와 tempB를 초기화합니다.\n  let tempA = A[0]; // tempA = 0\n  let tempB = B[0]; // tempB = 0\n\n  // 두 번째 요소부터 배열을 반복합니다.\n  for (let j = 1; j \u003c A.length; j++) {\n    // 현재 누적 합(첫 번째 인덱스 제외)이 같고,\n    // 서로의 배열 합의 절반인지 확인합니다.\n    if (j !== 1 \u0026\u0026 tempA === tempB \u0026\u0026 2 * tempA === sumA \u0026\u0026 2 * tempB == sumB) {\n      count++; // 이 경우 조건이 충족되지 않아 count는 여전히 0입니다.\n    }\n\n    // 현재 요소로 누적 합을 업데이트합니다.\n    tempA += A[j]; // 각 반복 후 tempA 값: [0, 4, 3, 3, 6]\n    tempB += B[j]; // 각 반복 후 tempB 값: [0, -2, 3, 3, 6]\n  }\n\n  // 유효한 분할 지점의 수를 반환합니다.\n  return count; // 유효한 분할 지점을 찾지 못해 count는 0입니다.\n}\n\n// 사용 예시\nconst A = [0, 4, -1, 0, 3];\nconst B = [0, -2, 5, 0, 3];\nconsole.log(solution(A, B)); // 출력: 0\n```\n\n# 두 번째 질문\n\n\u003cimg src=\"/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_1.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계별 접근 방법:\n\n초기화:\n\n- 각 요소가 이전 요소와 다음 요소보다 큰지를 추적하는 배열 isGreaterThanPrev 및 isGreaterThanNext를 초기화합니다.\n- 이전 요소나 다음 요소와 비교할 요소가 없는 첫 번째 요소의 isGreaterThanPrev와 마지막 요소의 isGreaterThanNext를 -1로 초기화합니다.\n\n비교 배열 채우기:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 배열 Y를 순회하여 각 요소가 다음 요소보다 큰지 나타내는 isGreaterThanNext를 채웁니다.\n- 배열 Y를 순회하여 각 요소가 이전 요소보다 큰지 나타내는 isGreaterThanPrev를 채웁니다.\n\n쌍(Pairs) 생성 및 정렬:\n\n- 각 Y의 요소에 대해 [값, 인덱스] 쌍을 포함하는 배열 v를 생성합니다.\n- 배열 v를 요소의 값에 기반하여 내림차순으로 정렬합니다.\n\n변수 초기화:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- cur와 maxLines라는 변수를 초기화하여 현재 라인 수와 관찰된 최대 라인 수를 추적합니다.\n\n정렬된 요소 처리:\n\n- 동일한 값으로 처리할 요소를 처리하기 위해 정렬된 배열 v를 반복합니다.\n- 각 요소에 대해 다음을 계산합니다:\n  - down: 시작 부분에서 이전 요소보다 큰 요소 수 또는 끝 부분에서 다음 요소보다 큰 요소 수.\n  - up: 시작 부분에서 다음 요소보다 크지 않은 요소 수 또는 끝 부분에서 이전 요소보다 크지 않은 요소 수.\n  - peaks: 다음과 이전 요소보다 큰 요소 수.\n  - valleys: 다음과 이전 요소보다 작은 요소 수.\n  - peaks를 추가하고 valleys를 빼고 down/up 값을 통해 현재 라인 수 cur를 조정합니다.\n  - 현재 라인 수가 이전 최대값을 초과하면 최대 라인 수 maxLines를 업데이트합니다.\n\n결과 반환:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 배열에서 각각의 peak(봉우리)와 valley(골짜기) 전환을 나타내는 비중복 라인(줄)의 최대 수인 maxLines를 반환합니다.\n\n## 실행 과정,\n\n```js\n중간 결과와 함께 설명:\n초기화:\n\n이전 요소보다 큰지, 이후 요소보다 큰지를 추적할 isGreaterThanPrev 및 isGreaterThanNext 배열이 생성됩니다.\nisGreaterThanNext = [false, true, true, false, false, true, -1]\nisGreaterThanPrev = [-1, true, false, false, true, true, false]\n쌍 생성 및 정렬:\n\nY의 각 요소에 대해 [값, 인덱스] 쌍 생성합니다.\n정렬 전 v: [[2, 0], [3, 1], [2, 2], [1, 3], [5, 4], [6, 5], [5, 6]]\n값을 기준으로 v를 내림차순으로 정렬합니다.\n정렬 후 v: [[6, 5], [5, 4], [5, 6], [3, 1], [2, 0], [2, 2], [1, 3]]\n정렬된 요소 처리:\n\n요소 6 (인덱스 5):\ndown = 1, 이전 요소보다 크고, 끝에 위치하므로\nup = 0, 조건 충족 없음.\ncur = 1, maxLines = 1\n요소 5 (인덱스 4와 6):\n인덱스 4:\ndown = 0, up = 0\n인덱스 6:\ndown = 0, up = 1, 이전 요소보다 크지 않고, 끝에 위치하므로\n봉우리 = 0, 골짜기 = 0\ncur = 1 - 1 = 0, maxLines = 1\n요소 3 (인덱스 1):\ndown = 0, up = 0\n봉우리 = 1, 이전과 이후 요소보다 크기 때문.\ncur = 0 + 1 - 0 = 1, maxLines = 1\n요소 2 (인덱스 0와 2):\n인덱스 0:\ndown = 0, up = 1, 이후 요소보다 크지 않고, 시작에 위치하므로\n인덱스 2:\ndown = 0, up = 0\n봉우리 = 0, 골짜기 = 1, 이전과 이후 요소보다 작기 때문.\ncur = 1 - 1 - 0 = 0, maxLines = 1\n요소 1 (인덱스 3):\ndown = 0, up = 0\n봉우리 = 0, 골짜기 = 0\ncur = 0 + 0 - 0 = 0, maxLines = 1\n최종 결과:\n\n관측된 최대 라인 수는 1이고, 따라서 maxLines = 1입니다.\r\n```\n\n## 구현,\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfunction solution(Y) {\n  let n = Y.length;\n\n  // 다음 요소보다 크다는지 이전 요소보다 크다는지 추적하는 배열\n  let isGreaterThanPrev = new Array(n);\n  let isGreaterThanNext = new Array(n);\n  isGreaterThanNext[n - 1] = -1; // 마지막 요소는 다음 요소가 없음\n  isGreaterThanPrev[0] = -1; // 첫 요소는 이전 요소가 없음\n\n  // isGreaterThanNext 배열 작성\n  for (let i = 0; i \u003c n - 1; i++) {\n    isGreaterThanNext[i] = Y[i] \u003e Y[i + 1];\n  }\n\n  // isGreaterThanNext = [false, true, true, false, false, true, -1]\n\n  // isGreaterThanPrev 배열 작성\n  for (let i = 1; i \u003c n; i++) {\n    isGreaterThanPrev[i] = Y[i] \u003e Y[i - 1];\n  }\n\n  // isGreaterThanPrev = [-1, true, false, false, true, true, false]\n\n  // [값, 인덱스] 쌍의 배열 생성\n  let v = [];\n  for (let i = 0; i \u003c n; i++) {\n    v.push([Y[i], i]);\n  }\n\n  // v = [[2, 0], [3, 1], [2, 2], [1, 3], [5, 4], [6, 5], [5, 6]]\n\n  // 값 기준으로 내림차순 정렬\n  v.sort((a, b) =\u003e b[0] - a[0]);\n\n  // v = [[6, 5], [5, 4], [5, 6], [3, 1], [2, 0], [2, 2], [1, 3]]\n\n  let cur = 0,\n    maxLines = 0;\n  for (let i = 0; i \u003c v.length; i++) {\n    let y = v[i][0];\n\n    let peaks = 0,\n      valleys = 0,\n      down = 0,\n      up = 0;\n\n    // 동일한 값 요소 처리\n    while (i \u003c v.length \u0026\u0026 v[i][0] === y) {\n      let idx = v[i][1];\n\n      // 아래로 향하는 지점인지 확인\n      if (\n        (idx === 0 \u0026\u0026 isGreaterThanNext[idx]) ||\n        (idx === n - 1 \u0026\u0026 isGreaterThanPrev[idx])\n      ) {\n        down++;\n      }\n\n      // 올라가는 골짜기인지 확인\n      if (\n        (idx === 0 \u0026\u0026 !isGreaterThanNext[idx]) ||\n        (idx === n - 1 \u0026\u0026 !isGreaterThanPrev[idx])\n      ) {\n        up++;\n      }\n\n      let isNotEnd = idx \u003e 0 \u0026\u0026 idx \u003c n - 1;\n\n      // 산인지 확인\n      if (isNotEnd \u0026\u0026 isGreaterThanNext[idx] \u0026\u0026 isGreaterThanPrev[idx]) {\n        peaks++;\n      } \n      // 계곡인지 확인\n      else if (isNotEnd \u0026\u0026 !isGreaterThanNext[idx] \u0026\u0026 !isGreaterThanPrev[idx]) {\n        valleys++;\n      }\n      i++;\n    }\n\n    i--;\n\n    // 현재 라인 수 계산\n    cur = cur + peaks - valleys + down;\n    maxLines = Math.max(maxLines, cur);\n\n    cur = cur + peaks - valleys - up;\n    maxLines = Math.max(maxLines, cur);\n  }\n\n  return maxLines;\n}\n\n// 사용 예시\nconsole.log(solution([2, 3, 2, 1, 5, 6, 5])); // 출력: 2\r\n```\n\n# 읽어 주셔서 감사합니다\n\n- 👏 이야기에 박수를 보내주시고 팔로우 부탁드립니다 👉\n- 📰 자바스크립트, 자료 구조 및 알고리즘, 리액트, 인터뷰 준비 등 다양한 콘텐츠 확인해보세요\n- 🔔 팔로우 링크: LinkedIn!\n\n늘 개선할 점이 있을텐데요. 의견을 자유롭게 공유해주세요. 😊\n","ogImage":{"url":"/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_0.png"},"coverImage":"/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_0.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003e질문 1\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e두 개의 동일한 길이를 가진 정수 배열 A와 B가 주어졌을 때, 시작점 j까지 A의 요소들의 누적 합이 B의 요소들의 누적 합과 같은 경우의 수를 반환하는 solution(A, B) 함수를 작성하십시오. 이때 다음 조건들을 만족해야 합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA의 요소들의 누적 합이 시작부터 j까지 B의 요소들의 누적 합과 동일합니다.\u003c/li\u003e\n\u003cli\u003eA의 요소들의 누적 합이 배열 A의 총 합의 절반과 동일합니다.\u003c/li\u003e\n\u003cli\u003eB의 요소들의 누적 합이 배열 B의 총 합의 절반과 동일합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e방법,\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e총합 초기화: 주석은 sumA 및 sumB의 초기화 및 목적을 명확히 합니다.\u003c/li\u003e\n\u003cli\u003e총합 계산: 총합을 계산하는 루프에 대한 주석이 있습니다.\u003c/li\u003e\n\u003cli\u003e유효한 분할 지점 계산: count의 목적 및 유효한 분할 지점을 확인하는 논리에 대한 설명이 있습니다.\u003c/li\u003e\n\u003cli\u003e누적 합: tempA 및 tempB의 초기화 및 누적 합을 추적하는 역할을 명확히 하는 주석이 있습니다.\u003c/li\u003e\n\u003cli\u003e반복 및 조건 확인: 두 번째 요소부터 시작하는 루프, 유효한 분할 지점을 찾기 위해 확인된 조건 및 누적 합의 업데이트를 설명하는 주석이 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e실제 실행,\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e단계별 결과\n\n총합 계산:\nsumA 진행: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e\nsumB 진행: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, -\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e\n최종 sumA = \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e\n최종 sumB = \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e\n\n누적 합 및 조건 확인:\n\n초기화:\ntempA = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\ntempB = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\n반복:\n\nj = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:\ntempA = \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e\ntempB = -\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n조건 미충족\n\nj = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e:\ntempA = \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\ntempB = \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\n조건: tempA === tempB \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * tempA === sumA \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * tempB == sumB\n\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e == \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e (참)\n하지만, j !== \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e이어야 조건이 검사됨\n\nj = \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e:\ntempA = \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\ntempB = \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\n조건: tempA === tempB \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * tempA === sumA \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * tempB == sumB\n\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e == \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e (참)\n조건 충족, 그러나 j !== \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e이므로 조건이 이 단계에서는 확인되지 않음\n\nj = \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e:\ntempA = \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e\ntempB = \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e\n필요한 길이를 초과하여 조건 확인이 안 됨\n\n최종 결과:\n조건 j !== \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u0026#x26;\u0026#x26; tempA === tempB \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * tempA === sumA \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * tempB == sumB이 전혀 충족되지 않아 count는 \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e으로 남습니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e구현,\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003eA\u003c/span\u003e: [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e]\n\u003cspan class=\"hljs-attr\"\u003eB\u003c/span\u003e: [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,-\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e]\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esolution\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eA, B\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 배열 A와 B의 총합을 저장할 sumA와 sumB를 초기화합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e sumA = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e sumB = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-comment\"\u003e// 배열 A와 B의 요소 총합을 계산합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026#x3C; A.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e; i++) {\n    sumA += A[i]; \u003cspan class=\"hljs-comment\"\u003e// 각 반복 후 sumA = [0, 4, 3, 3, 6]\u003c/span\u003e\n    sumB += B[i]; \u003cspan class=\"hljs-comment\"\u003e// 각 반복 후 sumB = [0, -2, 3, 3, 6]\u003c/span\u003e\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// sumA는 이제 6입니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// sumB는 이제 6입니다.\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// 유효한 분할 지점의 수를 추적하는 count를 초기화합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e count = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-comment\"\u003e// 현재 인덱스까지 누적 합을 저장할 tempA와 tempB를 초기화합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e tempA = A[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]; \u003cspan class=\"hljs-comment\"\u003e// tempA = 0\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e tempB = B[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]; \u003cspan class=\"hljs-comment\"\u003e// tempB = 0\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// 두 번째 요소부터 배열을 반복합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e j = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; j \u0026#x3C; A.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e; j++) {\n    \u003cspan class=\"hljs-comment\"\u003e// 현재 누적 합(첫 번째 인덱스 제외)이 같고,\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// 서로의 배열 합의 절반인지 확인합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (j !== \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u0026#x26;\u0026#x26; tempA === tempB \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * tempA === sumA \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * tempB == sumB) {\n      count++; \u003cspan class=\"hljs-comment\"\u003e// 이 경우 조건이 충족되지 않아 count는 여전히 0입니다.\u003c/span\u003e\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// 현재 요소로 누적 합을 업데이트합니다.\u003c/span\u003e\n    tempA += A[j]; \u003cspan class=\"hljs-comment\"\u003e// 각 반복 후 tempA 값: [0, 4, 3, 3, 6]\u003c/span\u003e\n    tempB += B[j]; \u003cspan class=\"hljs-comment\"\u003e// 각 반복 후 tempB 값: [0, -2, 3, 3, 6]\u003c/span\u003e\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// 유효한 분할 지점의 수를 반환합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e count; \u003cspan class=\"hljs-comment\"\u003e// 유효한 분할 지점을 찾지 못해 count는 0입니다.\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 사용 예시\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e A = [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e B = [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, -\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003esolution\u003c/span\u003e(A, B)); \u003cspan class=\"hljs-comment\"\u003e// 출력: 0\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e두 번째 질문\u003c/h1\u003e\n\u003cimg src=\"/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_1.png\"\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e단계별 접근 방법:\u003c/h2\u003e\n\u003cp\u003e초기화:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e각 요소가 이전 요소와 다음 요소보다 큰지를 추적하는 배열 isGreaterThanPrev 및 isGreaterThanNext를 초기화합니다.\u003c/li\u003e\n\u003cli\u003e이전 요소나 다음 요소와 비교할 요소가 없는 첫 번째 요소의 isGreaterThanPrev와 마지막 요소의 isGreaterThanNext를 -1로 초기화합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e비교 배열 채우기:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e배열 Y를 순회하여 각 요소가 다음 요소보다 큰지 나타내는 isGreaterThanNext를 채웁니다.\u003c/li\u003e\n\u003cli\u003e배열 Y를 순회하여 각 요소가 이전 요소보다 큰지 나타내는 isGreaterThanPrev를 채웁니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e쌍(Pairs) 생성 및 정렬:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e각 Y의 요소에 대해 [값, 인덱스] 쌍을 포함하는 배열 v를 생성합니다.\u003c/li\u003e\n\u003cli\u003e배열 v를 요소의 값에 기반하여 내림차순으로 정렬합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e변수 초기화:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003ecur와 maxLines라는 변수를 초기화하여 현재 라인 수와 관찰된 최대 라인 수를 추적합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e정렬된 요소 처리:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e동일한 값으로 처리할 요소를 처리하기 위해 정렬된 배열 v를 반복합니다.\u003c/li\u003e\n\u003cli\u003e각 요소에 대해 다음을 계산합니다:\n\u003cul\u003e\n\u003cli\u003edown: 시작 부분에서 이전 요소보다 큰 요소 수 또는 끝 부분에서 다음 요소보다 큰 요소 수.\u003c/li\u003e\n\u003cli\u003eup: 시작 부분에서 다음 요소보다 크지 않은 요소 수 또는 끝 부분에서 이전 요소보다 크지 않은 요소 수.\u003c/li\u003e\n\u003cli\u003epeaks: 다음과 이전 요소보다 큰 요소 수.\u003c/li\u003e\n\u003cli\u003evalleys: 다음과 이전 요소보다 작은 요소 수.\u003c/li\u003e\n\u003cli\u003epeaks를 추가하고 valleys를 빼고 down/up 값을 통해 현재 라인 수 cur를 조정합니다.\u003c/li\u003e\n\u003cli\u003e현재 라인 수가 이전 최대값을 초과하면 최대 라인 수 maxLines를 업데이트합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e결과 반환:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e배열에서 각각의 peak(봉우리)와 valley(골짜기) 전환을 나타내는 비중복 라인(줄)의 최대 수인 maxLines를 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e실행 과정,\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e중간 결과와 함께 설명:\n초기화:\n\n이전 요소보다 큰지, 이후 요소보다 큰지를 추적할 isGreaterThanPrev 및 isGreaterThanNext 배열이 생성됩니다.\nisGreaterThanNext = [\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\nisGreaterThanPrev = [-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e]\n쌍 생성 및 정렬:\n\nY의 각 요소에 대해 [값, 인덱스] 쌍 생성합니다.\n정렬 전 \u003cspan class=\"hljs-attr\"\u003ev\u003c/span\u003e: [[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], [\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], [\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e], [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e], [\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e], [\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e], [\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e]]\n값을 기준으로 v를 내림차순으로 정렬합니다.\n정렬 후 \u003cspan class=\"hljs-attr\"\u003ev\u003c/span\u003e: [[\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e], [\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e], [\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e], [\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], [\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], [\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e], [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e]]\n정렬된 요소 처리:\n\n요소 \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e (인덱스 \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e):\ndown = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, 이전 요소보다 크고, 끝에 위치하므로\nup = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, 조건 충족 없음.\ncur = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, maxLines = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n요소 \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e (인덱스 \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e와 \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e):\n인덱스 \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e:\ndown = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, up = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n인덱스 \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e:\ndown = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, up = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, 이전 요소보다 크지 않고, 끝에 위치하므로\n봉우리 = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, 골짜기 = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\ncur = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, maxLines = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n요소 \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e (인덱스 \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e):\ndown = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, up = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n봉우리 = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, 이전과 이후 요소보다 크기 때문.\ncur = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, maxLines = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n요소 \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e (인덱스 \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e와 \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e):\n인덱스 \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\ndown = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, up = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, 이후 요소보다 크지 않고, 시작에 위치하므로\n인덱스 \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e:\ndown = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, up = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n봉우리 = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, 골짜기 = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, 이전과 이후 요소보다 작기 때문.\ncur = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, maxLines = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n요소 \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e (인덱스 \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e):\ndown = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, up = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n봉우리 = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, 골짜기 = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\ncur = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, maxLines = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n최종 결과:\n\n관측된 최대 라인 수는 \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e이고, 따라서 maxLines = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e입니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e구현,\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esolution\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eY\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e n = Y.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-comment\"\u003e// 다음 요소보다 크다는지 이전 요소보다 크다는지 추적하는 배열\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e isGreaterThanPrev = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e(n);\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e isGreaterThanNext = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e(n);\n  isGreaterThanNext[n - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] = -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 마지막 요소는 다음 요소가 없음\u003c/span\u003e\n  isGreaterThanPrev[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] = -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 첫 요소는 이전 요소가 없음\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// isGreaterThanNext 배열 작성\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026#x3C; n - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; i++) {\n    isGreaterThanNext[i] = Y[i] \u003e Y[i + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// isGreaterThanNext = [false, true, true, false, false, true, -1]\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// isGreaterThanPrev 배열 작성\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; i \u0026#x3C; n; i++) {\n    isGreaterThanPrev[i] = Y[i] \u003e Y[i - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// isGreaterThanPrev = [-1, true, false, false, true, true, false]\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// [값, 인덱스] 쌍의 배열 생성\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e v = [];\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026#x3C; n; i++) {\n    v.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e([Y[i], i]);\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// v = [[2, 0], [3, 1], [2, 2], [1, 3], [5, 4], [6, 5], [5, 6]]\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// 값 기준으로 내림차순 정렬\u003c/span\u003e\n  v.\u003cspan class=\"hljs-title function_\"\u003esort\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ea, b\u003c/span\u003e) =\u003e\u003c/span\u003e b[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] - a[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]);\n\n  \u003cspan class=\"hljs-comment\"\u003e// v = [[6, 5], [5, 4], [5, 6], [3, 1], [2, 0], [2, 2], [1, 3]]\u003c/span\u003e\n\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e cur = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n    maxLines = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026#x3C; v.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e; i++) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e y = v[i][\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e];\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e peaks = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n      valleys = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n      down = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n      up = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 동일한 값 요소 처리\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (i \u0026#x3C; v.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e \u0026#x26;\u0026#x26; v[i][\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] === y) {\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e idx = v[i][\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n\n      \u003cspan class=\"hljs-comment\"\u003e// 아래로 향하는 지점인지 확인\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\n        (idx === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u0026#x26;\u0026#x26; isGreaterThanNext[idx]) ||\n        (idx === n - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u0026#x26;\u0026#x26; isGreaterThanPrev[idx])\n      ) {\n        down++;\n      }\n\n      \u003cspan class=\"hljs-comment\"\u003e// 올라가는 골짜기인지 확인\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\n        (idx === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u0026#x26;\u0026#x26; !isGreaterThanNext[idx]) ||\n        (idx === n - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u0026#x26;\u0026#x26; !isGreaterThanPrev[idx])\n      ) {\n        up++;\n      }\n\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e isNotEnd = idx \u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u0026#x26;\u0026#x26; idx \u0026#x3C; n - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\n      \u003cspan class=\"hljs-comment\"\u003e// 산인지 확인\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isNotEnd \u0026#x26;\u0026#x26; isGreaterThanNext[idx] \u0026#x26;\u0026#x26; isGreaterThanPrev[idx]) {\n        peaks++;\n      } \n      \u003cspan class=\"hljs-comment\"\u003e// 계곡인지 확인\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isNotEnd \u0026#x26;\u0026#x26; !isGreaterThanNext[idx] \u0026#x26;\u0026#x26; !isGreaterThanPrev[idx]) {\n        valleys++;\n      }\n      i++;\n    }\n\n    i--;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 현재 라인 수 계산\u003c/span\u003e\n    cur = cur + peaks - valleys + down;\n    maxLines = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(maxLines, cur);\n\n    cur = cur + peaks - valleys - up;\n    maxLines = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(maxLines, cur);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e maxLines;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 사용 예시\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003esolution\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e])); \u003cspan class=\"hljs-comment\"\u003e// 출력: 2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e읽어 주셔서 감사합니다\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e👏 이야기에 박수를 보내주시고 팔로우 부탁드립니다 👉\u003c/li\u003e\n\u003cli\u003e📰 자바스크립트, 자료 구조 및 알고리즘, 리액트, 인터뷰 준비 등 다양한 콘텐츠 확인해보세요\u003c/li\u003e\n\u003cli\u003e🔔 팔로우 링크: LinkedIn!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e늘 개선할 점이 있을텐데요. 의견을 자유롭게 공유해주세요. 😊\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-01-MicrosoftDSAInterviewQuestions"},"buildId":"GsgRekSb--BvxYwv9FPn6","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>