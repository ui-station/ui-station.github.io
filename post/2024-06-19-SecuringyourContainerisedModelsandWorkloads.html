<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>컨테이너화된 모델과 작업 보안하기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-19-SecuringyourContainerisedModelsandWorkloads" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="컨테이너화된 모델과 작업 보안하기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="컨테이너화된 모델과 작업 보안하기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-19-SecuringyourContainerisedModelsandWorkloads" data-gatsby-head="true"/><meta name="twitter:title" content="컨테이너화된 모델과 작업 보안하기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 12:37" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/YUMR4jSyk_WlOHHc7UfOk/_buildManifest.js" defer=""></script><script src="/_next/static/YUMR4jSyk_WlOHHc7UfOk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">컨테이너화된 모델과 작업 보안하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="컨테이너화된 모델과 작업 보안하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">13<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-SecuringyourContainerisedModelsandWorkloads&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>컨테이너화는 이제 많은 어플리케이션을 배포하는 주요 수단이 되었으며, Docker가 이를 주도하며 보급되고 있습니다. 그 인기에 따라 공격 위험이 증가하고 있습니다. 따라서 Docker 어플리케이션을 안전하게 지킬 필요가 있습니다. 이를 위한 가장 기본적인 방법은 컨테이너 내 사용자를 루트 사용자가 아닌 일반 사용자로 설정하는 것입니다.</p>
<pre><code class="hljs language-js">컨텐츠
========

왜 루트 사용자가 아닌 사용자를 사용해야 하는가?

기본 일반 사용자로서 할 수 있는 일과 할 수 없는 일

네 가지 시나리오
  <span class="hljs-number">1</span>) 호스트에서 모델 제공 (읽기 전용)
  <span class="hljs-number">2</span>) 데이터 처리 파이프라인 실행 (컨테이너 내에서 쓰기)
  <span class="hljs-number">3</span>) 라이브러리가 자동으로 파일 작성 (컨테이너 내에서 쓰기)
  <span class="hljs-number">4</span>) 훈련된 모델 저장 (호스트에 쓰기)

요약
</code></pre>
<h1>왜 루트 사용자가 아닌 사용자를 사용해야 하는가?</h1>
<p>혹은 왜 루트 사용자를 사용하지 말아야 하는가? 아래의 가짜 아키텍처 예제를 살펴봅시다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_0.png" alt="Containerized Security"></p>
<p>보안은 종종 다층 접근법으로 간주됩니다. 공격자가 컨테이너에 들어갈 경우 사용자로서 가지는 권한이 첫 번째 방어층이 됩니다. 만약 컨테이너 사용자가 루트 액세스를 할당받는다면, 공격자는 컨테이너 내 모든 것을 자유롭게 제어할 수 있습니다. 이러한 넓은 액세스로 인해 잠재적인 취약점을 이용하여 호스트로 탈출하고 모든 연결된 시스템에 완전한 액세스를 획들할 수도 있습니다. 그 결과는 심각하며 다음과 같습니다:</p>
<ul>
<li>저장된 비밀 정보를 회수</li>
<li>트래픽을 가로채거나 방해</li>
<li>암호화 채굴과 같은 악성 서비스 실행</li>
<li>데이터베이스와 같은 연결된 민감한 서비스에 액세스 획득</li>
</ul>
<p><img src="/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_1.png" alt="Containerized Security"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>와우, 그건 정말 무섭게 들리네요! 그러나 해결 방법은 간단합니다. 컨테이너를 루트 사용자가 아닌 다른 사용자로 변경하세요!</p>
<p>우리가 나머지 기사를 읽기 전에, 리눅스 권한과 액세스 권한에 대한 좋은 이해가 없다면, 제 이전 기사를 꼭 확인해 보세요 [2].</p>
<h1>기본 비루트 사용자로서 할 수 있고 할 수 없는 것</h1>
<p>기본 비루트 사용자로 간단한 도커 어플리케이션을 만들어 보겠습니다. 아래의 도커 파일을 사용하세요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-docker"><span class="hljs-comment"># Dockerfile</span>
<span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.11</span>-slim

<span class="hljs-keyword">WORKDIR</span><span class="bash"> /app</span>

<span class="hljs-comment"># create a dummy py file</span>
<span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"print('I can run an existing py file')"</span> > example.py</span>

<span class="hljs-comment"># create &#x26; switch to non-root user</span>
<span class="hljs-keyword">RUN</span><span class="bash"> adduser --no-create-home nonroot</span>
<span class="hljs-keyword">USER</span> nonroot
</code></pre>
<p>Make sure to build the image and create a container using the following commands:</p>
<pre><code class="hljs language-docker">docker build -t test .
docker <span class="hljs-keyword">run</span><span class="bash"> -it <span class="hljs-built_in">test</span> bash</span>
</code></pre>
<p>Once you are inside the container, feel free to try out various commands. Keep in mind that certain actions like writing to restricted directories or installing software may not be permitted due to restricted permissions.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_2.png">
<p>반대로, 우리는 모든 종류의 읽기 권한을 실행할 수 있습니다.</p>
<img src="/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_3.png">
<p>파이썬이 설치되어 있기 때문에 약간 독특합니다. ls -l $(which python)을 실행하면 파이썬 인터프리터에 완전한 권한이 있음을 볼 수 있습니다. 따라서 Dockerfile에서 처음에 만든 example.py 파일과 같은 기존의 파이썬 파일을 실행할 수 있습니다. 심지어 파이썬 콘솔에 들어가 간단한 명령을 실행할 수도 있습니다. 그러나 비 루트 사용자로 전환하면 다른 시스템 쓰기 권한이 제거된 것을 알 수 있습니다. 그렇기 때문에 스크립트를 생성하거나 수정하거나 파이썬을 사용해 쓰기 명령을 실행할 수 없음을 확인할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_4.png" alt="image"></p>
<p>시스템 전반적인 제한은 보안에 좋지만, 특정 파일 및 디렉터리에 대한 쓰기 권한이 필요한 경우가 많이 발생하며, 그러한 허용 사항에 대응해야 합니다.</p>
<p>다음 섹션에서는 기계 학습 운영 수명 주기의 네 가지 시나리오 예제를 제공합니다. 이러한 예제를 통해 대부분의 다른 경우에 대한 구현 방법을 이해할 수 있을 것입니다.</p>
<h1>네 가지 시나리오</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>1) 호스트에서 모델 제공하기 — 읽기 전용</h2>
<p>모델을 제공할 때, 추론 및 서빙 스크립트를 활용하여 모델을 로드하고 API를 통해 노출시킵니다 (예: Flask, FastAPI) 입력을 받도록 합니다. 때로는 모델이 호스트 머신에서 로드되어 이미지와 분리되어 이미지 크기가 최적으로 작고, 이미지를 다시 로드할 경우 반복적인 모델 다운로드 없이 최적으로 빠르게 할 수 있도록 합니다. 그런 다음 모델은 바인드-마운트 볼륨을 통해 컨테이너로 전달되어 로드되고 제공됩니다.</p>
<img src="/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_5.png">
<p>이것은 비루한 사용자를 구현하는 가장 번거롭지 않은 방법일 것입니다. 기본적으로 모든 사용자에게 부여되는 읽기 권한만 필요하기 때문입니다. 아래는 그 작업이 어떻게 이루어지는지를 보여주는 샘플 Dockerfile입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>Dockerfile</h1>
<p>FROM python:3.11-slim</p>
<p>WORKDIR /app</p>
<p>COPY requirements.txt .
RUN pip3 install --no-cache-dir --upgrade pip~=23.2.1 <br>
&#x26;&#x26; pip3 install --no-cache-dir -r requirements.txt</p>
<p>COPY ./project/ /app</p>
<h1>add non-root user ---------------------</h1>
<p>RUN adduser --no-create-home nonroot</p>
<h1>switch from root to non-root user -----</h1>
<p>USER nonroot</p>
<p>CMD ["python", "inference.py"]</p>
<p>이 Dockerfile은 먼저 nonroot라는 새로운 시스템 사용자를 만드는 두 가지 간단한 명령어를 가지고 있습니다. 두 번째로, 마지막 CMD 라인 바로 전에 루트에서 nonroot 사용자로 전환됩니다. 기본 non-root 사용자의 경우 쓰기 및 실행 권한이 없기 때문에, 이전 단계에서 필요한 파일을 설치하거나 복사하거나 조작할 수 없습니다.</p>
<p>이제 Docker에서 non-root 사용자를 할당하는 방법을 알았으니, 다음 단계로 넘어가 봅시다.</p>
<h2>2) 데이터 처리 파이프라인 실행하기 — 컨테이너 내에서 작성</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>가끔은 작업을 실행하기 위해 일시적인 파일을 저장하고 싶을 때가 있습니다. 예를 들어, 데이터 전처리 작업을 한다고 가정해봅시다. 파일을 추가하고 삭제하는 작업으로 이루어져 있죠. 파일이 영구적이지 않기 때문에 이런 작업은 컨테이너 내에서 수행할 수 있습니다.</p>
<p><img src="/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_6.png" alt="이미지"></p>
<p>그러나 루트가 아닌 사용자를 사용한다면 쓰기 권한이 필요할 것입니다. 이를 위해 chown(소유자 변경) 명령을 사용하여 쓰기 액세스가 필요한 특정 폴더에 소유권을 할당해야 합니다. 이 작업을 완료하면 사용자를 루트가 아닌 사용자로 전환할 수 있습니다.</p>
<pre><code class="hljs language-Dockerfile"><span class="hljs-comment"># Dockerfile</span>

<span class="hljs-comment"># ....</span>

<span class="hljs-comment"># 루트가 아닌 사용자 추가 및 처리 폴더에 소유권 부여</span>
<span class="hljs-keyword">RUN</span><span class="bash"> adduser --no-create-home nonroot &#x26;&#x26; \
    <span class="hljs-built_in">mkdir</span> processing &#x26;&#x26; \
    <span class="hljs-built_in">chown</span> nonroot processing</span>

<span class="hljs-comment"># 루트에서 루트가 아닌 사용자로 전환</span>
<span class="hljs-keyword">USER</span> nonroot

<span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"python"</span>, <span class="hljs-string">"preprocess.py"</span>]</span>
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>3) 라이브러리가 파일을 자동으로 작성하는 경우 - 컨테이너 내에서 작성</h2>
<p>이전 예시에서는 우리가 직접 만든 파일을 작성하는 방법을 보여줬어요. 그러나 사용하는 라이브러리가 파일과 디렉토리를 자동으로 만드는 경우가 흔합니다. 컨테이너를 실행해 보고 쓰기 권한이 거부되는 것을 알 수 있을 때 그것들이 만들어진 것임을 알게 될 거예요.</p>
<p>저는 두 가지 예시를 보여드릴 거에요. 하나는 여러 프로세스를 관리하는 데 사용되는 supervisor에서 가져왔고, 다른 하나는 huggingface에서 모델을 다운로드할 때 사용하는 huggingface-hub에서 가져왔어요. 이러한 권한 오류들은 우리가 루트가 아닌 사용자로 전환할 때 볼 수 있을 거에요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_8.png" alt="Securing your Containerised Models and Workloads"></p>
<p><img src="/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_9.png" alt="Securing your Containerised Models and Workloads"></p>
<p>두 개의 슈퍼바이저 파일에 대해서 먼저 빈 파일로 생성하고 소유권 권한을 할당할 수 있습니다. Huggingface-hub 다운로드 문제에 대해 이미 오류 로그에서 TRANSFORMERS_CACHE 변수를 통해 다운로드 디렉토리를 변경할 수 있다는 힌트가 있었습니다. 따라서 먼저 디렉토리 변수를 할당하고, 디렉토리를 생성한 후 소유권을 할당할 수 있습니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Dockerfile</span>

# ....

# non-root 사용자 추가 ................
# huggingface 다운로드 디렉토리 변경
<span class="hljs-variable constant_">ENV</span> <span class="hljs-variable constant_">TRANSFORMERS_CACHE</span>=<span class="hljs-regexp">/app/m</span>odel

<span class="hljs-variable constant_">RUN</span> adduser --no-create-home nonroot &#x26;&#x26; \
    # 슈퍼바이저 파일 및 huggingfacehub 디렉토리 생성
    touch /app/supervisord.<span class="hljs-property">log</span> /app/supervisord.<span class="hljs-property">pid</span> &#x26;&#x26; \
    mkdir $TRANSFORMERS_CACHE &#x26;&#x26; \
    # 슈퍼바이저 및 huggingfacehub 쓰기 권한 부여
    chown nonroot /app/supervisord.<span class="hljs-property">log</span> &#x26;&#x26; \
    chown nonroot /app/supervisord.<span class="hljs-property">pid</span> &#x26;&#x26; \
    chown nonroot $TRANSFORMERS_CACHE
<span class="hljs-variable constant_">USER</span> nonroot

<span class="hljs-variable constant_">CMD</span> [<span class="hljs-string">"supervisord"</span>, <span class="hljs-string">"-c"</span>, <span class="hljs-string">"conf/supervisord.conf"</span>]
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>물론 여기에 제시된 것과 약간 다른 다른 예제가 있을 수 있습니다만, 쓰기 권한을 최소화하는 개념은 동일할 것입니다.</p>
<h2>4) 훈련된 모델 저장하기 — 호스트에 쓰기</h2>
<p>모델을 훈련하는 데 컨테이너를 사용하고 그 모델을 호스트에 쓰기를 원한다고 가정해 봅시다. 예를 들어, 모델을 준비하여 다른 작업에서 평가하거나 배포하기 위해 호스트에 쓰려고 하는 경우입니다. 이 경우에는 모델 파일을 쓰기 위해 컨테이너 디렉토리를 호스트 디렉토리에 연결하여 모델 파일을 기록해야 합니다. 이를 바인드 마운트라고도 합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>먼저, 우리는 nonroot를 위한 그룹과 사용자를 만들어야 합니다. 각각에 대해 고유한 ID를 지정하는데, 이 경우에 우리는 1001을 사용합니다 (1000 이상의 아무 숫자나 상관없습니다). 그런 다음, 모델을 저장할 모델 디렉토리를 생성합니다.</p>
<p>Scenario 2와 비교하여 여기서의 차이점은 모델 디렉토리에 대해 쓰기 권한을 설정하는 데 chown이 필요하지 않다는 것입니다. 왜냐하면?</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Dockerfile</span>

# ....
# add non-root group/user &#x26; create model folder
<span class="hljs-variable constant_">ENV</span> <span class="hljs-variable constant_">UID</span>=<span class="hljs-number">1001</span>
<span class="hljs-variable constant_">RUN</span> addgroup --gid $UID nonroot &#x26;&#x26; \
    adduser --uid $UID --gid $UID --no-create-home nonroot &#x26;&#x26; \
    mkdir model

# <span class="hljs-keyword">switch</span> <span class="hljs-keyword">from</span> root to non-root user
<span class="hljs-variable constant_">USER</span> nonroot

<span class="hljs-variable constant_">CMD</span> [<span class="hljs-string">"python"</span>, <span class="hljs-string">"train.py"</span>]
</code></pre>
<p>이는 bind-mounted 디렉토리의 권한이 호스트 디렉토리에서 결정되기 때문입니다. 따라서 우리는 호스트에서 다시 동일한 사용자를 만들어야 하며, 사용자 ID가 동일한지 확인해야 합니다. 그런 다음에 호스트에 모델 디렉토리를 만들고 nonroot 사용자에게 소유자 권한을 부여합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"># 호스트 터미널에서

# 동일한 사용자 및 그룹 추가
addgroup --gid <span class="hljs-number">1001</span>
adduser --uid <span class="hljs-number">1001</span> --gid <span class="hljs-number">1001</span> --no-create-home nonroot
# 바인드 마운트할 모델 디렉토리 만들고 nonroot를 소유자로 설정
mkdir /home/model
chown nonroot /home/model
</code></pre>
<p>바인드 마운트는 보다 유연성을 제공하기 위해 일반적으로 docker-compose.yml 파일이나 docker run 명령어에서 지정됩니다. 아래는 전자의 예시입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-attr">version</span>: <span class="hljs-string">"3.5"</span>

<span class="hljs-attr">services</span>:
    <span class="hljs-attr">modeltraining</span>:
        <span class="hljs-attr">container_name</span>: modeltraining
        <span class="hljs-attr">build</span>:
            <span class="hljs-attr">dockerfile</span>: <span class="hljs-title class_">Dockerfile</span>
        <span class="hljs-attr">volumes</span>:
            - <span class="hljs-attr">type</span>: bind
              <span class="hljs-attr">source</span>: <span class="hljs-regexp">/home/m</span>odel # 호스트 디렉토리
              <span class="hljs-attr">target</span>: <span class="hljs-regexp">/app/m</span>odel  # 컨테이너 디렉토리
</code></pre>
<p>그리고 후자에 대한 예시는 다음과 같습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-docker">docker <span class="hljs-keyword">run</span><span class="bash"> -d --name modeltraining -v /home/model:/app/model &#x3C;image_name></span>
</code></pre>
<p>아무거나 실행하시면, 비루트 사용자로 스크립트를 실행할 수 있음을 확인하실 수 있을 거예요.</p>
<h1>요약</h1>
<p>우리는 비루트 사용자를 할당하고도 컨테이너가 원하는 작업을 수행할 수 있는 방법을 살펴보았어요. 이는 특정 쓰기 권한이 필요할 때 주로 관련이 있어요. 그저 두 가지 기본 개념만 알면 돼요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>컨테이너에서의 쓰기 권한을 위해서는 Dockerfile에서 chown을 사용하세요.</li>
<li>바인드 마운트를 위한 쓰기 권한은 호스트에서 동일한 비루트 사용자를 생성하고 호스트 디렉토리에서 chown을 사용하세요.</li>
</ul>
<p>루트 사용자로 일부 테스트를 실행하기 위해 도커 컨테이너로 들어가야할 때 다음 명령어를 사용할 수 있어요.</p>
<pre><code class="hljs language-js">docker exec -it -u <span class="hljs-number">0</span> &#x3C;컨테이너_아이디/이름> bash
</code></pre>
<h1>참고자료</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>[1] Wong et al. (2023) 컨테이너 보안에 관한: 위협 모델링, 공격 분석 및 완화 전략. 컴퓨터 및 보안, 제 128권.</li>
<li>[2] Linux 권한 및 접근 권한에 관한 이전 게시물: <a href="https://medium.com/@teosiyang/securing-linux-servers-with-two-commands-de5b565dc104" rel="nofollow" target="_blank">https://medium.com/@teosiyang/securing-linux-servers-with-two-commands-de5b565dc104</a></li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"컨테이너화된 모델과 작업 보안하기","description":"","date":"2024-06-19 12:37","slug":"2024-06-19-SecuringyourContainerisedModelsandWorkloads","content":"\n컨테이너화는 이제 많은 어플리케이션을 배포하는 주요 수단이 되었으며, Docker가 이를 주도하며 보급되고 있습니다. 그 인기에 따라 공격 위험이 증가하고 있습니다. 따라서 Docker 어플리케이션을 안전하게 지킬 필요가 있습니다. 이를 위한 가장 기본적인 방법은 컨테이너 내 사용자를 루트 사용자가 아닌 일반 사용자로 설정하는 것입니다.\n\n```js\n컨텐츠\n========\n\n왜 루트 사용자가 아닌 사용자를 사용해야 하는가?\n\n기본 일반 사용자로서 할 수 있는 일과 할 수 없는 일\n\n네 가지 시나리오\n  1) 호스트에서 모델 제공 (읽기 전용)\n  2) 데이터 처리 파이프라인 실행 (컨테이너 내에서 쓰기)\n  3) 라이브러리가 자동으로 파일 작성 (컨테이너 내에서 쓰기)\n  4) 훈련된 모델 저장 (호스트에 쓰기)\n\n요약\n```\n\n# 왜 루트 사용자가 아닌 사용자를 사용해야 하는가?\n\n혹은 왜 루트 사용자를 사용하지 말아야 하는가? 아래의 가짜 아키텍처 예제를 살펴봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Containerized Security](/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_0.png)\n\n보안은 종종 다층 접근법으로 간주됩니다. 공격자가 컨테이너에 들어갈 경우 사용자로서 가지는 권한이 첫 번째 방어층이 됩니다. 만약 컨테이너 사용자가 루트 액세스를 할당받는다면, 공격자는 컨테이너 내 모든 것을 자유롭게 제어할 수 있습니다. 이러한 넓은 액세스로 인해 잠재적인 취약점을 이용하여 호스트로 탈출하고 모든 연결된 시스템에 완전한 액세스를 획들할 수도 있습니다. 그 결과는 심각하며 다음과 같습니다:\n\n- 저장된 비밀 정보를 회수\n- 트래픽을 가로채거나 방해\n- 암호화 채굴과 같은 악성 서비스 실행\n- 데이터베이스와 같은 연결된 민감한 서비스에 액세스 획득\n\n![Containerized Security](/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n와우, 그건 정말 무섭게 들리네요! 그러나 해결 방법은 간단합니다. 컨테이너를 루트 사용자가 아닌 다른 사용자로 변경하세요!\n\n우리가 나머지 기사를 읽기 전에, 리눅스 권한과 액세스 권한에 대한 좋은 이해가 없다면, 제 이전 기사를 꼭 확인해 보세요 [2].\n\n# 기본 비루트 사용자로서 할 수 있고 할 수 없는 것\n\n기본 비루트 사용자로 간단한 도커 어플리케이션을 만들어 보겠습니다. 아래의 도커 파일을 사용하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```docker\n# Dockerfile\nFROM python:3.11-slim\n\nWORKDIR /app\n\n# create a dummy py file\nRUN echo \"print('I can run an existing py file')\" \u003e example.py\n\n# create \u0026 switch to non-root user\nRUN adduser --no-create-home nonroot\nUSER nonroot\n```\n\nMake sure to build the image and create a container using the following commands:\n\n```docker\ndocker build -t test .\ndocker run -it test bash\n```\n\nOnce you are inside the container, feel free to try out various commands. Keep in mind that certain actions like writing to restricted directories or installing software may not be permitted due to restricted permissions.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_2.png\" /\u003e\n\n반대로, 우리는 모든 종류의 읽기 권한을 실행할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_3.png\" /\u003e\n\n파이썬이 설치되어 있기 때문에 약간 독특합니다. ls -l $(which python)을 실행하면 파이썬 인터프리터에 완전한 권한이 있음을 볼 수 있습니다. 따라서 Dockerfile에서 처음에 만든 example.py 파일과 같은 기존의 파이썬 파일을 실행할 수 있습니다. 심지어 파이썬 콘솔에 들어가 간단한 명령을 실행할 수도 있습니다. 그러나 비 루트 사용자로 전환하면 다른 시스템 쓰기 권한이 제거된 것을 알 수 있습니다. 그렇기 때문에 스크립트를 생성하거나 수정하거나 파이썬을 사용해 쓰기 명령을 실행할 수 없음을 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_4.png)\n\n시스템 전반적인 제한은 보안에 좋지만, 특정 파일 및 디렉터리에 대한 쓰기 권한이 필요한 경우가 많이 발생하며, 그러한 허용 사항에 대응해야 합니다.\n\n다음 섹션에서는 기계 학습 운영 수명 주기의 네 가지 시나리오 예제를 제공합니다. 이러한 예제를 통해 대부분의 다른 경우에 대한 구현 방법을 이해할 수 있을 것입니다.\n\n# 네 가지 시나리오\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 1) 호스트에서 모델 제공하기 — 읽기 전용\n\n모델을 제공할 때, 추론 및 서빙 스크립트를 활용하여 모델을 로드하고 API를 통해 노출시킵니다 (예: Flask, FastAPI) 입력을 받도록 합니다. 때로는 모델이 호스트 머신에서 로드되어 이미지와 분리되어 이미지 크기가 최적으로 작고, 이미지를 다시 로드할 경우 반복적인 모델 다운로드 없이 최적으로 빠르게 할 수 있도록 합니다. 그런 다음 모델은 바인드-마운트 볼륨을 통해 컨테이너로 전달되어 로드되고 제공됩니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_5.png\" /\u003e\n\n이것은 비루한 사용자를 구현하는 가장 번거롭지 않은 방법일 것입니다. 기본적으로 모든 사용자에게 부여되는 읽기 권한만 필요하기 때문입니다. 아래는 그 작업이 어떻게 이루어지는지를 보여주는 샘플 Dockerfile입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Dockerfile\n\nFROM python:3.11-slim\n\nWORKDIR /app\n\nCOPY requirements.txt .\nRUN pip3 install --no-cache-dir --upgrade pip~=23.2.1 \\\n \u0026\u0026 pip3 install --no-cache-dir -r requirements.txt\n\nCOPY ./project/ /app\n\n# add non-root user ---------------------\n\nRUN adduser --no-create-home nonroot\n\n# switch from root to non-root user -----\n\nUSER nonroot\n\nCMD [\"python\", \"inference.py\"]\n\n이 Dockerfile은 먼저 nonroot라는 새로운 시스템 사용자를 만드는 두 가지 간단한 명령어를 가지고 있습니다. 두 번째로, 마지막 CMD 라인 바로 전에 루트에서 nonroot 사용자로 전환됩니다. 기본 non-root 사용자의 경우 쓰기 및 실행 권한이 없기 때문에, 이전 단계에서 필요한 파일을 설치하거나 복사하거나 조작할 수 없습니다.\n\n이제 Docker에서 non-root 사용자를 할당하는 방법을 알았으니, 다음 단계로 넘어가 봅시다.\n\n## 2) 데이터 처리 파이프라인 실행하기 — 컨테이너 내에서 작성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가끔은 작업을 실행하기 위해 일시적인 파일을 저장하고 싶을 때가 있습니다. 예를 들어, 데이터 전처리 작업을 한다고 가정해봅시다. 파일을 추가하고 삭제하는 작업으로 이루어져 있죠. 파일이 영구적이지 않기 때문에 이런 작업은 컨테이너 내에서 수행할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_6.png)\n\n그러나 루트가 아닌 사용자를 사용한다면 쓰기 권한이 필요할 것입니다. 이를 위해 chown(소유자 변경) 명령을 사용하여 쓰기 액세스가 필요한 특정 폴더에 소유권을 할당해야 합니다. 이 작업을 완료하면 사용자를 루트가 아닌 사용자로 전환할 수 있습니다.\n\n```Dockerfile\n# Dockerfile\n\n# ....\n\n# 루트가 아닌 사용자 추가 및 처리 폴더에 소유권 부여\nRUN adduser --no-create-home nonroot \u0026\u0026 \\\n    mkdir processing \u0026\u0026 \\\n    chown nonroot processing\n\n# 루트에서 루트가 아닌 사용자로 전환\nUSER nonroot\n\nCMD [\"python\", \"preprocess.py\"]\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 3) 라이브러리가 파일을 자동으로 작성하는 경우 - 컨테이너 내에서 작성\n\n이전 예시에서는 우리가 직접 만든 파일을 작성하는 방법을 보여줬어요. 그러나 사용하는 라이브러리가 파일과 디렉토리를 자동으로 만드는 경우가 흔합니다. 컨테이너를 실행해 보고 쓰기 권한이 거부되는 것을 알 수 있을 때 그것들이 만들어진 것임을 알게 될 거예요.\n\n저는 두 가지 예시를 보여드릴 거에요. 하나는 여러 프로세스를 관리하는 데 사용되는 supervisor에서 가져왔고, 다른 하나는 huggingface에서 모델을 다운로드할 때 사용하는 huggingface-hub에서 가져왔어요. 이러한 권한 오류들은 우리가 루트가 아닌 사용자로 전환할 때 볼 수 있을 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Securing your Containerised Models and Workloads](/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_8.png)\n\n![Securing your Containerised Models and Workloads](/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_9.png)\n\n두 개의 슈퍼바이저 파일에 대해서 먼저 빈 파일로 생성하고 소유권 권한을 할당할 수 있습니다. Huggingface-hub 다운로드 문제에 대해 이미 오류 로그에서 TRANSFORMERS_CACHE 변수를 통해 다운로드 디렉토리를 변경할 수 있다는 힌트가 있었습니다. 따라서 먼저 디렉토리 변수를 할당하고, 디렉토리를 생성한 후 소유권을 할당할 수 있습니다.\n\n```js\n# Dockerfile\n\n# ....\n\n# non-root 사용자 추가 ................\n# huggingface 다운로드 디렉토리 변경\nENV TRANSFORMERS_CACHE=/app/model\n\nRUN adduser --no-create-home nonroot \u0026\u0026 \\\n    # 슈퍼바이저 파일 및 huggingfacehub 디렉토리 생성\n    touch /app/supervisord.log /app/supervisord.pid \u0026\u0026 \\\n    mkdir $TRANSFORMERS_CACHE \u0026\u0026 \\\n    # 슈퍼바이저 및 huggingfacehub 쓰기 권한 부여\n    chown nonroot /app/supervisord.log \u0026\u0026 \\\n    chown nonroot /app/supervisord.pid \u0026\u0026 \\\n    chown nonroot $TRANSFORMERS_CACHE\nUSER nonroot\n\nCMD [\"supervisord\", \"-c\", \"conf/supervisord.conf\"]\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n물론 여기에 제시된 것과 약간 다른 다른 예제가 있을 수 있습니다만, 쓰기 권한을 최소화하는 개념은 동일할 것입니다.\n\n## 4) 훈련된 모델 저장하기 — 호스트에 쓰기\n\n모델을 훈련하는 데 컨테이너를 사용하고 그 모델을 호스트에 쓰기를 원한다고 가정해 봅시다. 예를 들어, 모델을 준비하여 다른 작업에서 평가하거나 배포하기 위해 호스트에 쓰려고 하는 경우입니다. 이 경우에는 모델 파일을 쓰기 위해 컨테이너 디렉토리를 호스트 디렉토리에 연결하여 모델 파일을 기록해야 합니다. 이를 바인드 마운트라고도 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저, 우리는 nonroot를 위한 그룹과 사용자를 만들어야 합니다. 각각에 대해 고유한 ID를 지정하는데, 이 경우에 우리는 1001을 사용합니다 (1000 이상의 아무 숫자나 상관없습니다). 그런 다음, 모델을 저장할 모델 디렉토리를 생성합니다.\n\nScenario 2와 비교하여 여기서의 차이점은 모델 디렉토리에 대해 쓰기 권한을 설정하는 데 chown이 필요하지 않다는 것입니다. 왜냐하면?\n\n```js\n# Dockerfile\n\n# ....\n# add non-root group/user \u0026 create model folder\nENV UID=1001\nRUN addgroup --gid $UID nonroot \u0026\u0026 \\\n    adduser --uid $UID --gid $UID --no-create-home nonroot \u0026\u0026 \\\n    mkdir model\n\n# switch from root to non-root user\nUSER nonroot\n\nCMD [\"python\", \"train.py\"]\n```\n\n이는 bind-mounted 디렉토리의 권한이 호스트 디렉토리에서 결정되기 때문입니다. 따라서 우리는 호스트에서 다시 동일한 사용자를 만들어야 하며, 사용자 ID가 동일한지 확인해야 합니다. 그런 다음에 호스트에 모델 디렉토리를 만들고 nonroot 사용자에게 소유자 권한을 부여합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 호스트 터미널에서\n\n# 동일한 사용자 및 그룹 추가\naddgroup --gid 1001\nadduser --uid 1001 --gid 1001 --no-create-home nonroot\n# 바인드 마운트할 모델 디렉토리 만들고 nonroot를 소유자로 설정\nmkdir /home/model\nchown nonroot /home/model\n```\n\n바인드 마운트는 보다 유연성을 제공하기 위해 일반적으로 docker-compose.yml 파일이나 docker run 명령어에서 지정됩니다. 아래는 전자의 예시입니다.\n\n```js\nversion: \"3.5\"\n\nservices:\n    modeltraining:\n        container_name: modeltraining\n        build:\n            dockerfile: Dockerfile\n        volumes:\n            - type: bind\n              source: /home/model # 호스트 디렉토리\n              target: /app/model  # 컨테이너 디렉토리\n```\n\n그리고 후자에 대한 예시는 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```docker\ndocker run -d --name modeltraining -v /home/model:/app/model \u003cimage_name\u003e\n```\n\n아무거나 실행하시면, 비루트 사용자로 스크립트를 실행할 수 있음을 확인하실 수 있을 거예요.\n\n# 요약\n\n우리는 비루트 사용자를 할당하고도 컨테이너가 원하는 작업을 수행할 수 있는 방법을 살펴보았어요. 이는 특정 쓰기 권한이 필요할 때 주로 관련이 있어요. 그저 두 가지 기본 개념만 알면 돼요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 컨테이너에서의 쓰기 권한을 위해서는 Dockerfile에서 chown을 사용하세요.\n- 바인드 마운트를 위한 쓰기 권한은 호스트에서 동일한 비루트 사용자를 생성하고 호스트 디렉토리에서 chown을 사용하세요.\n\n루트 사용자로 일부 테스트를 실행하기 위해 도커 컨테이너로 들어가야할 때 다음 명령어를 사용할 수 있어요.\n\n```js\ndocker exec -it -u 0 \u003c컨테이너_아이디/이름\u003e bash\n```\n\n# 참고자료\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- [1] Wong et al. (2023) 컨테이너 보안에 관한: 위협 모델링, 공격 분석 및 완화 전략. 컴퓨터 및 보안, 제 128권.\n- [2] Linux 권한 및 접근 권한에 관한 이전 게시물: https://medium.com/@teosiyang/securing-linux-servers-with-two-commands-de5b565dc104\n","ogImage":{"url":"/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_0.png"},"coverImage":"/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_0.png","tag":["Tech"],"readingTime":13},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e컨테이너화는 이제 많은 어플리케이션을 배포하는 주요 수단이 되었으며, Docker가 이를 주도하며 보급되고 있습니다. 그 인기에 따라 공격 위험이 증가하고 있습니다. 따라서 Docker 어플리케이션을 안전하게 지킬 필요가 있습니다. 이를 위한 가장 기본적인 방법은 컨테이너 내 사용자를 루트 사용자가 아닌 일반 사용자로 설정하는 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e컨텐츠\n========\n\n왜 루트 사용자가 아닌 사용자를 사용해야 하는가?\n\n기본 일반 사용자로서 할 수 있는 일과 할 수 없는 일\n\n네 가지 시나리오\n  \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) 호스트에서 모델 제공 (읽기 전용)\n  \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) 데이터 처리 파이프라인 실행 (컨테이너 내에서 쓰기)\n  \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e) 라이브러리가 자동으로 파일 작성 (컨테이너 내에서 쓰기)\n  \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e) 훈련된 모델 저장 (호스트에 쓰기)\n\n요약\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e왜 루트 사용자가 아닌 사용자를 사용해야 하는가?\u003c/h1\u003e\n\u003cp\u003e혹은 왜 루트 사용자를 사용하지 말아야 하는가? 아래의 가짜 아키텍처 예제를 살펴봅시다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_0.png\" alt=\"Containerized Security\"\u003e\u003c/p\u003e\n\u003cp\u003e보안은 종종 다층 접근법으로 간주됩니다. 공격자가 컨테이너에 들어갈 경우 사용자로서 가지는 권한이 첫 번째 방어층이 됩니다. 만약 컨테이너 사용자가 루트 액세스를 할당받는다면, 공격자는 컨테이너 내 모든 것을 자유롭게 제어할 수 있습니다. 이러한 넓은 액세스로 인해 잠재적인 취약점을 이용하여 호스트로 탈출하고 모든 연결된 시스템에 완전한 액세스를 획들할 수도 있습니다. 그 결과는 심각하며 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e저장된 비밀 정보를 회수\u003c/li\u003e\n\u003cli\u003e트래픽을 가로채거나 방해\u003c/li\u003e\n\u003cli\u003e암호화 채굴과 같은 악성 서비스 실행\u003c/li\u003e\n\u003cli\u003e데이터베이스와 같은 연결된 민감한 서비스에 액세스 획득\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_1.png\" alt=\"Containerized Security\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e와우, 그건 정말 무섭게 들리네요! 그러나 해결 방법은 간단합니다. 컨테이너를 루트 사용자가 아닌 다른 사용자로 변경하세요!\u003c/p\u003e\n\u003cp\u003e우리가 나머지 기사를 읽기 전에, 리눅스 권한과 액세스 권한에 대한 좋은 이해가 없다면, 제 이전 기사를 꼭 확인해 보세요 [2].\u003c/p\u003e\n\u003ch1\u003e기본 비루트 사용자로서 할 수 있고 할 수 없는 것\u003c/h1\u003e\n\u003cp\u003e기본 비루트 사용자로 간단한 도커 어플리케이션을 만들어 보겠습니다. 아래의 도커 파일을 사용하세요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-docker\"\u003e\u003cspan class=\"hljs-comment\"\u003e# Dockerfile\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e python:\u003cspan class=\"hljs-number\"\u003e3.11\u003c/span\u003e-slim\n\n\u003cspan class=\"hljs-keyword\"\u003eWORKDIR\u003c/span\u003e\u003cspan class=\"bash\"\u003e /app\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# create a dummy py file\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e \u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"print('I can run an existing py file')\"\u003c/span\u003e \u003e example.py\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# create \u0026#x26; switch to non-root user\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e adduser --no-create-home nonroot\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eUSER\u003c/span\u003e nonroot\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMake sure to build the image and create a container using the following commands:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-docker\"\u003edocker build -t test .\ndocker \u003cspan class=\"hljs-keyword\"\u003erun\u003c/span\u003e\u003cspan class=\"bash\"\u003e -it \u003cspan class=\"hljs-built_in\"\u003etest\u003c/span\u003e bash\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOnce you are inside the container, feel free to try out various commands. Keep in mind that certain actions like writing to restricted directories or installing software may not be permitted due to restricted permissions.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_2.png\"\u003e\n\u003cp\u003e반대로, 우리는 모든 종류의 읽기 권한을 실행할 수 있습니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_3.png\"\u003e\n\u003cp\u003e파이썬이 설치되어 있기 때문에 약간 독특합니다. ls -l $(which python)을 실행하면 파이썬 인터프리터에 완전한 권한이 있음을 볼 수 있습니다. 따라서 Dockerfile에서 처음에 만든 example.py 파일과 같은 기존의 파이썬 파일을 실행할 수 있습니다. 심지어 파이썬 콘솔에 들어가 간단한 명령을 실행할 수도 있습니다. 그러나 비 루트 사용자로 전환하면 다른 시스템 쓰기 권한이 제거된 것을 알 수 있습니다. 그렇기 때문에 스크립트를 생성하거나 수정하거나 파이썬을 사용해 쓰기 명령을 실행할 수 없음을 확인할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_4.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e시스템 전반적인 제한은 보안에 좋지만, 특정 파일 및 디렉터리에 대한 쓰기 권한이 필요한 경우가 많이 발생하며, 그러한 허용 사항에 대응해야 합니다.\u003c/p\u003e\n\u003cp\u003e다음 섹션에서는 기계 학습 운영 수명 주기의 네 가지 시나리오 예제를 제공합니다. 이러한 예제를 통해 대부분의 다른 경우에 대한 구현 방법을 이해할 수 있을 것입니다.\u003c/p\u003e\n\u003ch1\u003e네 가지 시나리오\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e1) 호스트에서 모델 제공하기 — 읽기 전용\u003c/h2\u003e\n\u003cp\u003e모델을 제공할 때, 추론 및 서빙 스크립트를 활용하여 모델을 로드하고 API를 통해 노출시킵니다 (예: Flask, FastAPI) 입력을 받도록 합니다. 때로는 모델이 호스트 머신에서 로드되어 이미지와 분리되어 이미지 크기가 최적으로 작고, 이미지를 다시 로드할 경우 반복적인 모델 다운로드 없이 최적으로 빠르게 할 수 있도록 합니다. 그런 다음 모델은 바인드-마운트 볼륨을 통해 컨테이너로 전달되어 로드되고 제공됩니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_5.png\"\u003e\n\u003cp\u003e이것은 비루한 사용자를 구현하는 가장 번거롭지 않은 방법일 것입니다. 기본적으로 모든 사용자에게 부여되는 읽기 권한만 필요하기 때문입니다. 아래는 그 작업이 어떻게 이루어지는지를 보여주는 샘플 Dockerfile입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eDockerfile\u003c/h1\u003e\n\u003cp\u003eFROM python:3.11-slim\u003c/p\u003e\n\u003cp\u003eWORKDIR /app\u003c/p\u003e\n\u003cp\u003eCOPY requirements.txt .\nRUN pip3 install --no-cache-dir --upgrade pip~=23.2.1 \u003cbr\u003e\n\u0026#x26;\u0026#x26; pip3 install --no-cache-dir -r requirements.txt\u003c/p\u003e\n\u003cp\u003eCOPY ./project/ /app\u003c/p\u003e\n\u003ch1\u003eadd non-root user ---------------------\u003c/h1\u003e\n\u003cp\u003eRUN adduser --no-create-home nonroot\u003c/p\u003e\n\u003ch1\u003eswitch from root to non-root user -----\u003c/h1\u003e\n\u003cp\u003eUSER nonroot\u003c/p\u003e\n\u003cp\u003eCMD [\"python\", \"inference.py\"]\u003c/p\u003e\n\u003cp\u003e이 Dockerfile은 먼저 nonroot라는 새로운 시스템 사용자를 만드는 두 가지 간단한 명령어를 가지고 있습니다. 두 번째로, 마지막 CMD 라인 바로 전에 루트에서 nonroot 사용자로 전환됩니다. 기본 non-root 사용자의 경우 쓰기 및 실행 권한이 없기 때문에, 이전 단계에서 필요한 파일을 설치하거나 복사하거나 조작할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e이제 Docker에서 non-root 사용자를 할당하는 방법을 알았으니, 다음 단계로 넘어가 봅시다.\u003c/p\u003e\n\u003ch2\u003e2) 데이터 처리 파이프라인 실행하기 — 컨테이너 내에서 작성\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e가끔은 작업을 실행하기 위해 일시적인 파일을 저장하고 싶을 때가 있습니다. 예를 들어, 데이터 전처리 작업을 한다고 가정해봅시다. 파일을 추가하고 삭제하는 작업으로 이루어져 있죠. 파일이 영구적이지 않기 때문에 이런 작업은 컨테이너 내에서 수행할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e그러나 루트가 아닌 사용자를 사용한다면 쓰기 권한이 필요할 것입니다. 이를 위해 chown(소유자 변경) 명령을 사용하여 쓰기 액세스가 필요한 특정 폴더에 소유권을 할당해야 합니다. 이 작업을 완료하면 사용자를 루트가 아닌 사용자로 전환할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-Dockerfile\"\u003e\u003cspan class=\"hljs-comment\"\u003e# Dockerfile\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# ....\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# 루트가 아닌 사용자 추가 및 처리 폴더에 소유권 부여\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"bash\"\u003e adduser --no-create-home nonroot \u0026#x26;\u0026#x26; \\\n    \u003cspan class=\"hljs-built_in\"\u003emkdir\u003c/span\u003e processing \u0026#x26;\u0026#x26; \\\n    \u003cspan class=\"hljs-built_in\"\u003echown\u003c/span\u003e nonroot processing\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# 루트에서 루트가 아닌 사용자로 전환\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eUSER\u003c/span\u003e nonroot\n\n\u003cspan class=\"hljs-keyword\"\u003eCMD\u003c/span\u003e\u003cspan class=\"bash\"\u003e [\u003cspan class=\"hljs-string\"\u003e\"python\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"preprocess.py\"\u003c/span\u003e]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e3) 라이브러리가 파일을 자동으로 작성하는 경우 - 컨테이너 내에서 작성\u003c/h2\u003e\n\u003cp\u003e이전 예시에서는 우리가 직접 만든 파일을 작성하는 방법을 보여줬어요. 그러나 사용하는 라이브러리가 파일과 디렉토리를 자동으로 만드는 경우가 흔합니다. 컨테이너를 실행해 보고 쓰기 권한이 거부되는 것을 알 수 있을 때 그것들이 만들어진 것임을 알게 될 거예요.\u003c/p\u003e\n\u003cp\u003e저는 두 가지 예시를 보여드릴 거에요. 하나는 여러 프로세스를 관리하는 데 사용되는 supervisor에서 가져왔고, 다른 하나는 huggingface에서 모델을 다운로드할 때 사용하는 huggingface-hub에서 가져왔어요. 이러한 권한 오류들은 우리가 루트가 아닌 사용자로 전환할 때 볼 수 있을 거에요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_8.png\" alt=\"Securing your Containerised Models and Workloads\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-SecuringyourContainerisedModelsandWorkloads_9.png\" alt=\"Securing your Containerised Models and Workloads\"\u003e\u003c/p\u003e\n\u003cp\u003e두 개의 슈퍼바이저 파일에 대해서 먼저 빈 파일로 생성하고 소유권 권한을 할당할 수 있습니다. Huggingface-hub 다운로드 문제에 대해 이미 오류 로그에서 TRANSFORMERS_CACHE 변수를 통해 다운로드 디렉토리를 변경할 수 있다는 힌트가 있었습니다. 따라서 먼저 디렉토리 변수를 할당하고, 디렉토리를 생성한 후 소유권을 할당할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eDockerfile\u003c/span\u003e\n\n# ....\n\n# non-root 사용자 추가 ................\n# huggingface 다운로드 디렉토리 변경\n\u003cspan class=\"hljs-variable constant_\"\u003eENV\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTRANSFORMERS_CACHE\u003c/span\u003e=\u003cspan class=\"hljs-regexp\"\u003e/app/m\u003c/span\u003eodel\n\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e adduser --no-create-home nonroot \u0026#x26;\u0026#x26; \\\n    # 슈퍼바이저 파일 및 huggingfacehub 디렉토리 생성\n    touch /app/supervisord.\u003cspan class=\"hljs-property\"\u003elog\u003c/span\u003e /app/supervisord.\u003cspan class=\"hljs-property\"\u003epid\u003c/span\u003e \u0026#x26;\u0026#x26; \\\n    mkdir $TRANSFORMERS_CACHE \u0026#x26;\u0026#x26; \\\n    # 슈퍼바이저 및 huggingfacehub 쓰기 권한 부여\n    chown nonroot /app/supervisord.\u003cspan class=\"hljs-property\"\u003elog\u003c/span\u003e \u0026#x26;\u0026#x26; \\\n    chown nonroot /app/supervisord.\u003cspan class=\"hljs-property\"\u003epid\u003c/span\u003e \u0026#x26;\u0026#x26; \\\n    chown nonroot $TRANSFORMERS_CACHE\n\u003cspan class=\"hljs-variable constant_\"\u003eUSER\u003c/span\u003e nonroot\n\n\u003cspan class=\"hljs-variable constant_\"\u003eCMD\u003c/span\u003e [\u003cspan class=\"hljs-string\"\u003e\"supervisord\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"-c\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"conf/supervisord.conf\"\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e물론 여기에 제시된 것과 약간 다른 다른 예제가 있을 수 있습니다만, 쓰기 권한을 최소화하는 개념은 동일할 것입니다.\u003c/p\u003e\n\u003ch2\u003e4) 훈련된 모델 저장하기 — 호스트에 쓰기\u003c/h2\u003e\n\u003cp\u003e모델을 훈련하는 데 컨테이너를 사용하고 그 모델을 호스트에 쓰기를 원한다고 가정해 봅시다. 예를 들어, 모델을 준비하여 다른 작업에서 평가하거나 배포하기 위해 호스트에 쓰려고 하는 경우입니다. 이 경우에는 모델 파일을 쓰기 위해 컨테이너 디렉토리를 호스트 디렉토리에 연결하여 모델 파일을 기록해야 합니다. 이를 바인드 마운트라고도 합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e먼저, 우리는 nonroot를 위한 그룹과 사용자를 만들어야 합니다. 각각에 대해 고유한 ID를 지정하는데, 이 경우에 우리는 1001을 사용합니다 (1000 이상의 아무 숫자나 상관없습니다). 그런 다음, 모델을 저장할 모델 디렉토리를 생성합니다.\u003c/p\u003e\n\u003cp\u003eScenario 2와 비교하여 여기서의 차이점은 모델 디렉토리에 대해 쓰기 권한을 설정하는 데 chown이 필요하지 않다는 것입니다. 왜냐하면?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eDockerfile\u003c/span\u003e\n\n# ....\n# add non-root group/user \u0026#x26; create model folder\n\u003cspan class=\"hljs-variable constant_\"\u003eENV\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eUID\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e1001\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e addgroup --gid $UID nonroot \u0026#x26;\u0026#x26; \\\n    adduser --uid $UID --gid $UID --no-create-home nonroot \u0026#x26;\u0026#x26; \\\n    mkdir model\n\n# \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e root to non-root user\n\u003cspan class=\"hljs-variable constant_\"\u003eUSER\u003c/span\u003e nonroot\n\n\u003cspan class=\"hljs-variable constant_\"\u003eCMD\u003c/span\u003e [\u003cspan class=\"hljs-string\"\u003e\"python\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"train.py\"\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 bind-mounted 디렉토리의 권한이 호스트 디렉토리에서 결정되기 때문입니다. 따라서 우리는 호스트에서 다시 동일한 사용자를 만들어야 하며, 사용자 ID가 동일한지 확인해야 합니다. 그런 다음에 호스트에 모델 디렉토리를 만들고 nonroot 사용자에게 소유자 권한을 부여합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 호스트 터미널에서\n\n# 동일한 사용자 및 그룹 추가\naddgroup --gid \u003cspan class=\"hljs-number\"\u003e1001\u003c/span\u003e\nadduser --uid \u003cspan class=\"hljs-number\"\u003e1001\u003c/span\u003e --gid \u003cspan class=\"hljs-number\"\u003e1001\u003c/span\u003e --no-create-home nonroot\n# 바인드 마운트할 모델 디렉토리 만들고 nonroot를 소유자로 설정\nmkdir /home/model\nchown nonroot /home/model\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e바인드 마운트는 보다 유연성을 제공하기 위해 일반적으로 docker-compose.yml 파일이나 docker run 명령어에서 지정됩니다. 아래는 전자의 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003eversion\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"3.5\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-attr\"\u003eservices\u003c/span\u003e:\n    \u003cspan class=\"hljs-attr\"\u003emodeltraining\u003c/span\u003e:\n        \u003cspan class=\"hljs-attr\"\u003econtainer_name\u003c/span\u003e: modeltraining\n        \u003cspan class=\"hljs-attr\"\u003ebuild\u003c/span\u003e:\n            \u003cspan class=\"hljs-attr\"\u003edockerfile\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDockerfile\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003evolumes\u003c/span\u003e:\n            - \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: bind\n              \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-regexp\"\u003e/home/m\u003c/span\u003eodel # 호스트 디렉토리\n              \u003cspan class=\"hljs-attr\"\u003etarget\u003c/span\u003e: \u003cspan class=\"hljs-regexp\"\u003e/app/m\u003c/span\u003eodel  # 컨테이너 디렉토리\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 후자에 대한 예시는 다음과 같습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-docker\"\u003edocker \u003cspan class=\"hljs-keyword\"\u003erun\u003c/span\u003e\u003cspan class=\"bash\"\u003e -d --name modeltraining -v /home/model:/app/model \u0026#x3C;image_name\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아무거나 실행하시면, 비루트 사용자로 스크립트를 실행할 수 있음을 확인하실 수 있을 거예요.\u003c/p\u003e\n\u003ch1\u003e요약\u003c/h1\u003e\n\u003cp\u003e우리는 비루트 사용자를 할당하고도 컨테이너가 원하는 작업을 수행할 수 있는 방법을 살펴보았어요. 이는 특정 쓰기 권한이 필요할 때 주로 관련이 있어요. 그저 두 가지 기본 개념만 알면 돼요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e컨테이너에서의 쓰기 권한을 위해서는 Dockerfile에서 chown을 사용하세요.\u003c/li\u003e\n\u003cli\u003e바인드 마운트를 위한 쓰기 권한은 호스트에서 동일한 비루트 사용자를 생성하고 호스트 디렉토리에서 chown을 사용하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e루트 사용자로 일부 테스트를 실행하기 위해 도커 컨테이너로 들어가야할 때 다음 명령어를 사용할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker exec -it -u \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u0026#x3C;컨테이너_아이디/이름\u003e bash\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e참고자료\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e[1] Wong et al. (2023) 컨테이너 보안에 관한: 위협 모델링, 공격 분석 및 완화 전략. 컴퓨터 및 보안, 제 128권.\u003c/li\u003e\n\u003cli\u003e[2] Linux 권한 및 접근 권한에 관한 이전 게시물: \u003ca href=\"https://medium.com/@teosiyang/securing-linux-servers-with-two-commands-de5b565dc104\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://medium.com/@teosiyang/securing-linux-servers-with-two-commands-de5b565dc104\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-SecuringyourContainerisedModelsandWorkloads"},"buildId":"YUMR4jSyk_WlOHHc7UfOk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>