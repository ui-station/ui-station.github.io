<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Swift 동시성 뒤엉킨 것들 풀어내기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-27-SwiftConcurrencyUn-tangledup" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Swift 동시성 뒤엉킨 것들 풀어내기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Swift 동시성 뒤엉킨 것들 풀어내기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-27-SwiftConcurrencyUn-tangledup_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-27-SwiftConcurrencyUn-tangledup" data-gatsby-head="true"/><meta name="twitter:title" content="Swift 동시성 뒤엉킨 것들 풀어내기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-27-SwiftConcurrencyUn-tangledup_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-27 16:24" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_buildManifest.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Swift 동시성 뒤엉킨 것들 풀어내기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Swift 동시성 뒤엉킨 것들 풀어내기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 27, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-27-SwiftConcurrencyUn-tangledup&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-05-27-SwiftConcurrencyUn-tangledup_0.png">
<p>Swift 5.5부터는 concurrent programming을 위해 async/await 접근 방식이 도입되어 비동기 작업 관리가 변경되었습니다. 이 방식은 올바르게 구현할 때 많은 이점을 제공하며 고려해야 할 사항도 몇 가지 있습니다.</p>
<h1>이것은 무엇인가요?</h1>
<p>Concurrency는 concurrent code를 처리하는 도구를 제공하는 라이브러리로, 이러한 도구는 쓰레드를 다룰 때 안전성을 제공하기 위한 것입니다. 이는 쓰레드를 관리할 때 발생하는 모든 종류의 문제를 포함하며, 흔한 문제 몇 가지를 들자면 다음과 같습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>데이터 레이스(Data races). 여러 스레드가 동시에 동일한 데이터 조각에 액세스하여 조작하려고 할 때 발생합니다.</li>
<li>데드락(Deadlocks). 여러 스레드가 서로가 완료되기를 기다리고 계속 지장을 일으킬 때 발생합니다.</li>
<li>우선순위 역전(Priority inversion). 낮은 우선순위 작업이 높은 우선순위 작업의 실행을 차단할 때 발생합니다.</li>
</ul>
<h2>병렬성 vs 순차성</h2>
<p>예제를 시작하기 전에, 이 주제 아래에서 두 가지 개념, 병렬성과 순차성을 이해해야 합니다.</p>
<ul>
<li>병렬 코드는 다른 작업이 끝나기를 기다릴 필요 없이 동시에 실행될 수 있는 코드입니다.</li>
<li>순차 코드는 이전 결과가 완료되어야 다음 작업을 계속할 수 있는 코드입니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>구현 방법</h1>
<h2>비동기 및 대기</h2>
<p>이 프레임워크는 두 가지 주요 키워드 async와 await를 사용합니다. 각각은 다른 목적으로 사용됩니다.</p>
<ul>
<li>Async는 비동기 작업을 표시하는 데 주로 사용되며, 작업 내에서 가능한 비동기 기능을 노출하는 데도 사용됩니다. 다시 말해, async 메서드 안에는 비동기 작업이 포함될 수 있습니다.</li>
<li>Await은 현재 컨텍스트의 실행이 중지될 수 있는 가능성이 있는 중단 지점을 표시하는 데 사용되며, 그 시간 동안 리소스를 사용하여 다른 작업을 수행할 수 있습니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>예를 들어, 일반적인 데이터 가져오기 방법은 완료될 때까지 시간이 걸릴 수 있습니다. 왜냐하면 로컬이거나 클라우드인 데이터베이스에 도달해야 하기 때문이죠.</p>
<pre><code class="hljs language-js">func <span class="hljs-title function_">fetchData</span>(<span class="hljs-params">completion: @escaping (Result&#x3C;Data, <span class="hljs-built_in">Error</span>>) -> Void</span>) {
    <span class="hljs-keyword">let</span> url = <span class="hljs-title function_">URL</span>(<span class="hljs-attr">string</span>: <span class="hljs-string">"https://itunes.apple.com/search/media=music&#x26;entity=song&#x26;term=avicii"</span>)!

    <span class="hljs-title class_">URLSession</span>.<span class="hljs-property">shared</span>.<span class="hljs-title function_">dataTask</span>(<span class="hljs-params"><span class="hljs-keyword">with</span>: url</span>) { data, response, error <span class="hljs-keyword">in</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> error {
            <span class="hljs-keyword">return</span> <span class="hljs-title function_">completion</span>(.<span class="hljs-title function_">failure</span>(error))
        }
        guard <span class="hljs-keyword">let</span> data <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-title function_">completion</span>(.<span class="hljs-title function_">failure</span>(<span class="hljs-title class_">URLError</span>(.<span class="hljs-property">unknown</span>)))
        }
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">completion</span>(.<span class="hljs-title function_">success</span>(data))
    }.<span class="hljs-title function_">resume</span>() <span class="hljs-comment">// 항상 세션 작업을 재개하는 것을 기억하세요 :)</span>
}

fetchData { result <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">switch</span> result {
    <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> .<span class="hljs-title function_">success</span>(data):
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"Itunes 정보를 가져왔습니다: \(data.description)"</span>)
    <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> .<span class="hljs-title function_">failure</span>(error):
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"문제가 발생했습니다: \(error.localizedDescription)"</span>)
    }
}

<span class="hljs-comment">// 출력: "Itunes 정보를 가져왔습니다: 80075 bytes"</span>
</code></pre>
<p>이는 원격 서버에서 정보를 가져오는 비동기 작업을 완료하기 위해 기다리는 일반적인 패턴입니다. 완료 핸들러는 한 번 작업이 완료되면 호출되는 익명 함수(클로저)입니다. 그러나 이러한 패턴은 중첩된 클로저로 코드베이스를 쉽게 더럽힐 수 있습니다(콜백 지옥).</p>
<p>비동기/대기 접근 방식을 사용하면 다음과 같이 개선될 수 있습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>모든 시간이 걸릴 수 있는 작업 또는 다른 시간이 많이 소요되는 작업을 async로 표시하여 컴파일러가 가능한 비동기 작업을 알 수 있게 합니다.</li>
<li>await로 가능한 중단 지점을 찾아보세요. 이 경우 URLSession은 이미 async/await 버전의 dataTask(with:)를 제공합니다. async context 내에서 사용할 수 있으며 완료까지 시간이 소요됩니다.</li>
<li>처리될 함수를 async context 내에서 호출하세요.</li>
</ul>
<pre><code class="hljs language-js">func <span class="hljs-title function_">fetchData</span>() <span class="hljs-keyword">async</span> throws -> <span class="hljs-title class_">Data</span> { <span class="hljs-comment">// 1</span>
    <span class="hljs-keyword">let</span> url = <span class="hljs-title function_">URL</span>(<span class="hljs-attr">string</span>: <span class="hljs-string">"https://itunes.apple.com/search/media=music&#x26;entity=song&#x26;term=avicii"</span>)!
    <span class="hljs-keyword">let</span> (data, _) = <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> <span class="hljs-title class_">URLSession</span>.<span class="hljs-property">shared</span>.<span class="hljs-title function_">data</span>(<span class="hljs-attr">from</span>: url) <span class="hljs-comment">// 2</span>
    <span class="hljs-keyword">return</span> data
}

<span class="hljs-title class_">Task</span> { <span class="hljs-comment">// 3</span>
    <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>()
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"Itunes info has been retreived: \(data.description)"</span>)
    } <span class="hljs-keyword">catch</span> {
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"Something went wrong: \(error.localizedDescription)"</span>)
    }
}
</code></pre>
<p>여기 몇 가지 향상된 점이 있습니다:</p>
<ul>
<li>오류가 발생할 수 있는 가능성을 나타내기 위해 throws를 사용하세요.</li>
<li>이러한 오류를 처리하세요(예: do-catch 블록 사용)</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>혜택 및 고려 사항은 무엇인가요?</h1>
<p>이 기능은 많은 혜택을 제공하며, 구현할 때 고려해야 할 몇 가지 사항이 있습니다. async/await 방식을 사용하면</p>
<ul>
<li>가독성 개선. 주요 키워드를 쉽게 식별하고 특정 작업에서 무슨 일이 일어나고 있는지 이해할 수 있어 중첩 코드를 줄이고 유지보수성을 향상시킵니다.</li>
<li>스레드 관리 오류 감소. 단순화된 접근 방식은 동기화 작업을 조작할 때 로직 오류를 줄이는 데 도움이 되어 신뢰성을 향상시킵니다.</li>
<li>성능 향상. 동시성 코드 작성시의 정확성이 향상되어 컴파일러가 실행 시간이 아닌 컴파일 시간에 문제를 감지할 수 있습니다.</li>
</ul>
<h2>고려 사항</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>호환성. Async/Await을 사용하는 데 일부 우려 사항이 있는데, 이는 Swift 5.5부터 지원되며, 더 최신 버전은 사용법과 기능을 개선합니다.</li>
<li>Actors. 여러 동시 작업에서 액세스해서는 안 되는 기능을 격리하기 위해 액터의 사용을 고려해보세요.</li>
<li>구조화된 및 구조화되지 않은 동시성. 그룹 및 오류 처리는 동시 작업의 사용 및 상호 작용을 조직화하는 데 도움이 되며, 반면 구조화되지 않은 작업은 자유롭지만 가능한 문제를 처리하기 위해 수동 지원이 필요합니다.</li>
</ul>
<h1>결론</h1>
<p>Swift는 매년 업데이트로 발전하는 쓰레드 안전한 언어가 되고 있습니다. 더욱 명확한 문법을 제공하여 이해하고 유지하기 쉽게되었습니다. 이러한 라이브러리와 같은 특정 도구를 통해 개발을 개선할 수 있습니다. 이 모든 것은 모든 지원 플랫폼에서 사용할 수 있으며 특히 iOS, macOS 및 watchOS와 같은 플랫폼에서 운영 가능합니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Swift 동시성 뒤엉킨 것들 풀어내기","description":"","date":"2024-05-27 16:24","slug":"2024-05-27-SwiftConcurrencyUn-tangledup","content":"\n\u003cimg src=\"/assets/img/2024-05-27-SwiftConcurrencyUn-tangledup_0.png\" /\u003e\n\nSwift 5.5부터는 concurrent programming을 위해 async/await 접근 방식이 도입되어 비동기 작업 관리가 변경되었습니다. 이 방식은 올바르게 구현할 때 많은 이점을 제공하며 고려해야 할 사항도 몇 가지 있습니다.\n\n# 이것은 무엇인가요?\n\nConcurrency는 concurrent code를 처리하는 도구를 제공하는 라이브러리로, 이러한 도구는 쓰레드를 다룰 때 안전성을 제공하기 위한 것입니다. 이는 쓰레드를 관리할 때 발생하는 모든 종류의 문제를 포함하며, 흔한 문제 몇 가지를 들자면 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 데이터 레이스(Data races). 여러 스레드가 동시에 동일한 데이터 조각에 액세스하여 조작하려고 할 때 발생합니다.\n- 데드락(Deadlocks). 여러 스레드가 서로가 완료되기를 기다리고 계속 지장을 일으킬 때 발생합니다.\n- 우선순위 역전(Priority inversion). 낮은 우선순위 작업이 높은 우선순위 작업의 실행을 차단할 때 발생합니다.\n\n## 병렬성 vs 순차성\n\n예제를 시작하기 전에, 이 주제 아래에서 두 가지 개념, 병렬성과 순차성을 이해해야 합니다.\n\n- 병렬 코드는 다른 작업이 끝나기를 기다릴 필요 없이 동시에 실행될 수 있는 코드입니다.\n- 순차 코드는 이전 결과가 완료되어야 다음 작업을 계속할 수 있는 코드입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 구현 방법\n\n## 비동기 및 대기\n\n이 프레임워크는 두 가지 주요 키워드 async와 await를 사용합니다. 각각은 다른 목적으로 사용됩니다.\n\n- Async는 비동기 작업을 표시하는 데 주로 사용되며, 작업 내에서 가능한 비동기 기능을 노출하는 데도 사용됩니다. 다시 말해, async 메서드 안에는 비동기 작업이 포함될 수 있습니다.\n- Await은 현재 컨텍스트의 실행이 중지될 수 있는 가능성이 있는 중단 지점을 표시하는 데 사용되며, 그 시간 동안 리소스를 사용하여 다른 작업을 수행할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 일반적인 데이터 가져오기 방법은 완료될 때까지 시간이 걸릴 수 있습니다. 왜냐하면 로컬이거나 클라우드인 데이터베이스에 도달해야 하기 때문이죠.\n\n```js\nfunc fetchData(completion: @escaping (Result\u003cData, Error\u003e) -\u003e Void) {\n    let url = URL(string: \"https://itunes.apple.com/search/media=music\u0026entity=song\u0026term=avicii\")!\n\n    URLSession.shared.dataTask(with: url) { data, response, error in\n        if let error {\n            return completion(.failure(error))\n        }\n        guard let data else {\n            return completion(.failure(URLError(.unknown)))\n        }\n        return completion(.success(data))\n    }.resume() // 항상 세션 작업을 재개하는 것을 기억하세요 :)\n}\n\nfetchData { result in\n    switch result {\n    case let .success(data):\n        print(\"Itunes 정보를 가져왔습니다: \\(data.description)\")\n    case let .failure(error):\n        print(\"문제가 발생했습니다: \\(error.localizedDescription)\")\n    }\n}\n\n// 출력: \"Itunes 정보를 가져왔습니다: 80075 bytes\"\n```\n\n이는 원격 서버에서 정보를 가져오는 비동기 작업을 완료하기 위해 기다리는 일반적인 패턴입니다. 완료 핸들러는 한 번 작업이 완료되면 호출되는 익명 함수(클로저)입니다. 그러나 이러한 패턴은 중첩된 클로저로 코드베이스를 쉽게 더럽힐 수 있습니다(콜백 지옥).\n\n비동기/대기 접근 방식을 사용하면 다음과 같이 개선될 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 모든 시간이 걸릴 수 있는 작업 또는 다른 시간이 많이 소요되는 작업을 async로 표시하여 컴파일러가 가능한 비동기 작업을 알 수 있게 합니다.\n- await로 가능한 중단 지점을 찾아보세요. 이 경우 URLSession은 이미 async/await 버전의 dataTask(with:)를 제공합니다. async context 내에서 사용할 수 있으며 완료까지 시간이 소요됩니다.\n- 처리될 함수를 async context 내에서 호출하세요.\n\n```js\nfunc fetchData() async throws -\u003e Data { // 1\n    let url = URL(string: \"https://itunes.apple.com/search/media=music\u0026entity=song\u0026term=avicii\")!\n    let (data, _) = try await URLSession.shared.data(from: url) // 2\n    return data\n}\n\nTask { // 3\n    do {\n        let data = try await fetchData()\n        print(\"Itunes info has been retreived: \\(data.description)\")\n    } catch {\n        print(\"Something went wrong: \\(error.localizedDescription)\")\n    }\n}\n```\n\n여기 몇 가지 향상된 점이 있습니다:\n\n- 오류가 발생할 수 있는 가능성을 나타내기 위해 throws를 사용하세요.\n- 이러한 오류를 처리하세요(예: do-catch 블록 사용)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 혜택 및 고려 사항은 무엇인가요?\n\n이 기능은 많은 혜택을 제공하며, 구현할 때 고려해야 할 몇 가지 사항이 있습니다. async/await 방식을 사용하면\n\n- 가독성 개선. 주요 키워드를 쉽게 식별하고 특정 작업에서 무슨 일이 일어나고 있는지 이해할 수 있어 중첩 코드를 줄이고 유지보수성을 향상시킵니다.\n- 스레드 관리 오류 감소. 단순화된 접근 방식은 동기화 작업을 조작할 때 로직 오류를 줄이는 데 도움이 되어 신뢰성을 향상시킵니다.\n- 성능 향상. 동시성 코드 작성시의 정확성이 향상되어 컴파일러가 실행 시간이 아닌 컴파일 시간에 문제를 감지할 수 있습니다.\n\n## 고려 사항\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 호환성. Async/Await을 사용하는 데 일부 우려 사항이 있는데, 이는 Swift 5.5부터 지원되며, 더 최신 버전은 사용법과 기능을 개선합니다.\n- Actors. 여러 동시 작업에서 액세스해서는 안 되는 기능을 격리하기 위해 액터의 사용을 고려해보세요.\n- 구조화된 및 구조화되지 않은 동시성. 그룹 및 오류 처리는 동시 작업의 사용 및 상호 작용을 조직화하는 데 도움이 되며, 반면 구조화되지 않은 작업은 자유롭지만 가능한 문제를 처리하기 위해 수동 지원이 필요합니다.\n\n# 결론\n\nSwift는 매년 업데이트로 발전하는 쓰레드 안전한 언어가 되고 있습니다. 더욱 명확한 문법을 제공하여 이해하고 유지하기 쉽게되었습니다. 이러한 라이브러리와 같은 특정 도구를 통해 개발을 개선할 수 있습니다. 이 모든 것은 모든 지원 플랫폼에서 사용할 수 있으며 특히 iOS, macOS 및 watchOS와 같은 플랫폼에서 운영 가능합니다.\n","ogImage":{"url":"/assets/img/2024-05-27-SwiftConcurrencyUn-tangledup_0.png"},"coverImage":"/assets/img/2024-05-27-SwiftConcurrencyUn-tangledup_0.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-05-27-SwiftConcurrencyUn-tangledup_0.png\"\u003e\n\u003cp\u003eSwift 5.5부터는 concurrent programming을 위해 async/await 접근 방식이 도입되어 비동기 작업 관리가 변경되었습니다. 이 방식은 올바르게 구현할 때 많은 이점을 제공하며 고려해야 할 사항도 몇 가지 있습니다.\u003c/p\u003e\n\u003ch1\u003e이것은 무엇인가요?\u003c/h1\u003e\n\u003cp\u003eConcurrency는 concurrent code를 처리하는 도구를 제공하는 라이브러리로, 이러한 도구는 쓰레드를 다룰 때 안전성을 제공하기 위한 것입니다. 이는 쓰레드를 관리할 때 발생하는 모든 종류의 문제를 포함하며, 흔한 문제 몇 가지를 들자면 다음과 같습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e데이터 레이스(Data races). 여러 스레드가 동시에 동일한 데이터 조각에 액세스하여 조작하려고 할 때 발생합니다.\u003c/li\u003e\n\u003cli\u003e데드락(Deadlocks). 여러 스레드가 서로가 완료되기를 기다리고 계속 지장을 일으킬 때 발생합니다.\u003c/li\u003e\n\u003cli\u003e우선순위 역전(Priority inversion). 낮은 우선순위 작업이 높은 우선순위 작업의 실행을 차단할 때 발생합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e병렬성 vs 순차성\u003c/h2\u003e\n\u003cp\u003e예제를 시작하기 전에, 이 주제 아래에서 두 가지 개념, 병렬성과 순차성을 이해해야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e병렬 코드는 다른 작업이 끝나기를 기다릴 필요 없이 동시에 실행될 수 있는 코드입니다.\u003c/li\u003e\n\u003cli\u003e순차 코드는 이전 결과가 완료되어야 다음 작업을 계속할 수 있는 코드입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e구현 방법\u003c/h1\u003e\n\u003ch2\u003e비동기 및 대기\u003c/h2\u003e\n\u003cp\u003e이 프레임워크는 두 가지 주요 키워드 async와 await를 사용합니다. 각각은 다른 목적으로 사용됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAsync는 비동기 작업을 표시하는 데 주로 사용되며, 작업 내에서 가능한 비동기 기능을 노출하는 데도 사용됩니다. 다시 말해, async 메서드 안에는 비동기 작업이 포함될 수 있습니다.\u003c/li\u003e\n\u003cli\u003eAwait은 현재 컨텍스트의 실행이 중지될 수 있는 가능성이 있는 중단 지점을 표시하는 데 사용되며, 그 시간 동안 리소스를 사용하여 다른 작업을 수행할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e예를 들어, 일반적인 데이터 가져오기 방법은 완료될 때까지 시간이 걸릴 수 있습니다. 왜냐하면 로컬이거나 클라우드인 데이터베이스에 도달해야 하기 때문이죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efunc \u003cspan class=\"hljs-title function_\"\u003efetchData\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecompletion: @escaping (Result\u0026#x3C;Data, \u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e\u003e) -\u003e Void\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e url = \u003cspan class=\"hljs-title function_\"\u003eURL\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003estring\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"https://itunes.apple.com/search/media=music\u0026#x26;entity=song\u0026#x26;term=avicii\"\u003c/span\u003e)!\n\n    \u003cspan class=\"hljs-title class_\"\u003eURLSession\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eshared\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edataTask\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e: url\u003c/span\u003e) { data, response, error \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e error {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecompletion\u003c/span\u003e(.\u003cspan class=\"hljs-title function_\"\u003efailure\u003c/span\u003e(error))\n        }\n        guard \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e data \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecompletion\u003c/span\u003e(.\u003cspan class=\"hljs-title function_\"\u003efailure\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eURLError\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003eunknown\u003c/span\u003e)))\n        }\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecompletion\u003c/span\u003e(.\u003cspan class=\"hljs-title function_\"\u003esuccess\u003c/span\u003e(data))\n    }.\u003cspan class=\"hljs-title function_\"\u003eresume\u003c/span\u003e() \u003cspan class=\"hljs-comment\"\u003e// 항상 세션 작업을 재개하는 것을 기억하세요 :)\u003c/span\u003e\n}\n\nfetchData { result \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e result {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e .\u003cspan class=\"hljs-title function_\"\u003esuccess\u003c/span\u003e(data):\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Itunes 정보를 가져왔습니다: \\(data.description)\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e .\u003cspan class=\"hljs-title function_\"\u003efailure\u003c/span\u003e(error):\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"문제가 발생했습니다: \\(error.localizedDescription)\"\u003c/span\u003e)\n    }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 출력: \"Itunes 정보를 가져왔습니다: 80075 bytes\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 원격 서버에서 정보를 가져오는 비동기 작업을 완료하기 위해 기다리는 일반적인 패턴입니다. 완료 핸들러는 한 번 작업이 완료되면 호출되는 익명 함수(클로저)입니다. 그러나 이러한 패턴은 중첩된 클로저로 코드베이스를 쉽게 더럽힐 수 있습니다(콜백 지옥).\u003c/p\u003e\n\u003cp\u003e비동기/대기 접근 방식을 사용하면 다음과 같이 개선될 수 있습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e모든 시간이 걸릴 수 있는 작업 또는 다른 시간이 많이 소요되는 작업을 async로 표시하여 컴파일러가 가능한 비동기 작업을 알 수 있게 합니다.\u003c/li\u003e\n\u003cli\u003eawait로 가능한 중단 지점을 찾아보세요. 이 경우 URLSession은 이미 async/await 버전의 dataTask(with:)를 제공합니다. async context 내에서 사용할 수 있으며 완료까지 시간이 소요됩니다.\u003c/li\u003e\n\u003cli\u003e처리될 함수를 async context 내에서 호출하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efunc \u003cspan class=\"hljs-title function_\"\u003efetchData\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e throws -\u003e \u003cspan class=\"hljs-title class_\"\u003eData\u003c/span\u003e { \u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e url = \u003cspan class=\"hljs-title function_\"\u003eURL\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003estring\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"https://itunes.apple.com/search/media=music\u0026#x26;entity=song\u0026#x26;term=avicii\"\u003c/span\u003e)!\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e (data, _) = \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eURLSession\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eshared\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edata\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003efrom\u003c/span\u003e: url) \u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e data\n}\n\n\u003cspan class=\"hljs-title class_\"\u003eTask\u003c/span\u003e { \u003cspan class=\"hljs-comment\"\u003e// 3\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003edo\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchData\u003c/span\u003e()\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Itunes info has been retreived: \\(data.description)\"\u003c/span\u003e)\n    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e {\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Something went wrong: \\(error.localizedDescription)\"\u003c/span\u003e)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기 몇 가지 향상된 점이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e오류가 발생할 수 있는 가능성을 나타내기 위해 throws를 사용하세요.\u003c/li\u003e\n\u003cli\u003e이러한 오류를 처리하세요(예: do-catch 블록 사용)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e혜택 및 고려 사항은 무엇인가요?\u003c/h1\u003e\n\u003cp\u003e이 기능은 많은 혜택을 제공하며, 구현할 때 고려해야 할 몇 가지 사항이 있습니다. async/await 방식을 사용하면\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e가독성 개선. 주요 키워드를 쉽게 식별하고 특정 작업에서 무슨 일이 일어나고 있는지 이해할 수 있어 중첩 코드를 줄이고 유지보수성을 향상시킵니다.\u003c/li\u003e\n\u003cli\u003e스레드 관리 오류 감소. 단순화된 접근 방식은 동기화 작업을 조작할 때 로직 오류를 줄이는 데 도움이 되어 신뢰성을 향상시킵니다.\u003c/li\u003e\n\u003cli\u003e성능 향상. 동시성 코드 작성시의 정확성이 향상되어 컴파일러가 실행 시간이 아닌 컴파일 시간에 문제를 감지할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e고려 사항\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e호환성. Async/Await을 사용하는 데 일부 우려 사항이 있는데, 이는 Swift 5.5부터 지원되며, 더 최신 버전은 사용법과 기능을 개선합니다.\u003c/li\u003e\n\u003cli\u003eActors. 여러 동시 작업에서 액세스해서는 안 되는 기능을 격리하기 위해 액터의 사용을 고려해보세요.\u003c/li\u003e\n\u003cli\u003e구조화된 및 구조화되지 않은 동시성. 그룹 및 오류 처리는 동시 작업의 사용 및 상호 작용을 조직화하는 데 도움이 되며, 반면 구조화되지 않은 작업은 자유롭지만 가능한 문제를 처리하기 위해 수동 지원이 필요합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003eSwift는 매년 업데이트로 발전하는 쓰레드 안전한 언어가 되고 있습니다. 더욱 명확한 문법을 제공하여 이해하고 유지하기 쉽게되었습니다. 이러한 라이브러리와 같은 특정 도구를 통해 개발을 개선할 수 있습니다. 이 모든 것은 모든 지원 플랫폼에서 사용할 수 있으며 특히 iOS, macOS 및 watchOS와 같은 플랫폼에서 운영 가능합니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-27-SwiftConcurrencyUn-tangledup"},"buildId":"GsgRekSb--BvxYwv9FPn6","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>