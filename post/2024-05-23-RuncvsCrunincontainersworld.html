<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>컨테이너 세계에서 Runc 대 Crun | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-23-RuncvsCrunincontainersworld" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="컨테이너 세계에서 Runc 대 Crun | ui-station" data-gatsby-head="true"/><meta property="og:title" content="컨테이너 세계에서 Runc 대 Crun | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-23-RuncvsCrunincontainersworld_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-23-RuncvsCrunincontainersworld" data-gatsby-head="true"/><meta name="twitter:title" content="컨테이너 세계에서 Runc 대 Crun | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-23-RuncvsCrunincontainersworld_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-23 14:15" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-561ae49ab5aab7f5.js" defer=""></script><script src="/_next/static/R1x9p1CQYDDJESXyLXKOK/_buildManifest.js" defer=""></script><script src="/_next/static/R1x9p1CQYDDJESXyLXKOK/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">컨테이너 세계에서 Runc 대 Crun</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="컨테이너 세계에서 Runc 대 Crun" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 23, 2024</span><span class="posts_reading_time__f7YPP">2<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-23-RuncvsCrunincontainersworld&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p>만약 컨테이너화 기술에 흥미가 있다면, runc에 대해 들어봤을 수도 있어요.</p>
<p>자세한 내용을 설명해 들어가기 전에 컨테이너가 정확히 무엇인지 알려드릴게요.</p>
<p>주로 두 가지 리눅스 커널 모듈, 네임스페이스와 cgroup으로 만들어진 환경 안에서 가상 감옥 또는 격리된 환경을 만들어낸답니다.</p>
<ul>
<li>네임스페이스: 볼 수 있거나 접근할 수 있는 것을 제어합니다.</li>
</ul>
<div class="content-ad"></div>
<p>Cgroup: 리소스(예: RAM 및 CPU) 얼마나 사용하는지 확인하는 데 사용됩니다.</p>
<p><img src="/assets/img/2024-05-23-RuncvsCrunincontainersworld_0.png" alt="Image"/></p>
<p>컨테이너 런타임이 무엇인가요?</p>
<p>컨테이너 런타임은 이미 이야기한 컨테이너라고 불리는 격리된 환경을 관리하는 데 도움을 주는 소프트웨어입니다.</p>
<div class="content-ad"></div>
<p>Runc과 Crun은 현재 사용되는 두 가지 주요 컨테이너 런타임입니다.</p>
<p>그렇다면 containerd 또는 cri-o란 무엇인가요?</p>
<p>이 둘은 모두 runc 위에서 작동하는 컨테이너 런타임의 추상화된 레이어입니다. 이것들은 컨테이너를 관리하기 위한 프론트 엔드로, 즉 컨테이너를 생성, 제거, 시작 및 중지하는 역할을 담당합니다.</p>
<p><img src="/assets/img/2024-05-23-RuncvsCrunincontainersworld_1.png" alt="이미지"/></p>
<div class="content-ad"></div>
<p>크리올(Containerd)과 크라이오(CRI-O)는 둘 다 컨테이너 런타임으로 runc를 사용합니다.</p>
<p>지금까지는 runc와 crun이 무엇인지 알아보았습니다; 이제 차이를 살펴봅시다.</p>
<p>둘 다 컨테이너 런타임이며 컨테이너를 처리하는 데 동일한 작업을 수행합니다.</p>
<p>하지만 차이점은 다음과 같습니다:</p>
<div class="content-ad"></div>
<ol>
<li>
<p>runc은 Go로 작성되었고 crun은 C로 작성되어서 Linux 커널과 더 호환성이 높아요.</p>
</li>
<li>
<p>runc는 도커에 의해 개발되었고 crun은 RedHat에 의해 개발되었어요.</p>
</li>
<li>
<p>crun은 더 가벼워서 메모리 소비가 낮아요. crun은 300K이고 runc는 15M이에요.</p>
</li>
</ol>
<p>Podman은 어떠세요?</p>
<div class="content-ad"></div>
<p>포드맨은 컨테이너를 관리하는 데 책임이 있는 crun의 frontend 역할을 하는 도커와 비슷한 유틸리티입니다.</p>
<h2>요약</h2>
<p><img src="/assets/img/2024-05-23-RuncvsCrunincontainersworld_2.png" alt="RuncvsCrunincontainersworld_2"/></p>
<p>결론</p>
<div class="content-ad"></div>
<p>어떤 것을 사용해야 할까요?</p>
<p>개발 및 프로덕션 환경 모두에서 추가 구성 요소 없이 가볍게 사용할 컨테이너 엔진이 필요하다면 Podman을 선택하세요.</p>
<p>특히 이미지를 생성할 필요가 없는 프로덕션 환경에서는 Podman을 선택하는 것이 좋습니다. 이미지 빌드 구성 요소는 불필요하고 자원을 소비하는 소프트웨어로 간주될 수 있습니다.</p>
<p>그리고 이것이 Docker를 프로덕션 환경에서 사용하지 않아야 하는 또 다른 이유입니다.</p>
<div class="content-ad"></div>
<p>하지만 쿠버네티스를 사용 중이라면 cri-o를 선택하세요. 그리고 runc에 만족스럽지 않다면 C 언어로 된 가벼운 런타임을 원한다면 crun으로 런타임을 쉽게 전환할 수 있습니다.</p>
<p>kloudino.com (메디 탈레가니)가 작성함</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"컨테이너 세계에서 Runc 대 Crun","description":"","date":"2024-05-23 14:15","slug":"2024-05-23-RuncvsCrunincontainersworld","content":"\n\n만약 컨테이너화 기술에 흥미가 있다면, runc에 대해 들어봤을 수도 있어요.\n\n자세한 내용을 설명해 들어가기 전에 컨테이너가 정확히 무엇인지 알려드릴게요.\n\n주로 두 가지 리눅스 커널 모듈, 네임스페이스와 cgroup으로 만들어진 환경 안에서 가상 감옥 또는 격리된 환경을 만들어낸답니다.\n\n- 네임스페이스: 볼 수 있거나 접근할 수 있는 것을 제어합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCgroup: 리소스(예: RAM 및 CPU) 얼마나 사용하는지 확인하는 데 사용됩니다.\n\n![Image](/assets/img/2024-05-23-RuncvsCrunincontainersworld_0.png)\n\n컨테이너 런타임이 무엇인가요?\n\n컨테이너 런타임은 이미 이야기한 컨테이너라고 불리는 격리된 환경을 관리하는 데 도움을 주는 소프트웨어입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRunc과 Crun은 현재 사용되는 두 가지 주요 컨테이너 런타임입니다.\n\n그렇다면 containerd 또는 cri-o란 무엇인가요?\n\n이 둘은 모두 runc 위에서 작동하는 컨테이너 런타임의 추상화된 레이어입니다. 이것들은 컨테이너를 관리하기 위한 프론트 엔드로, 즉 컨테이너를 생성, 제거, 시작 및 중지하는 역할을 담당합니다.\n\n![이미지](/assets/img/2024-05-23-RuncvsCrunincontainersworld_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n크리올(Containerd)과 크라이오(CRI-O)는 둘 다 컨테이너 런타임으로 runc를 사용합니다.\n\n지금까지는 runc와 crun이 무엇인지 알아보았습니다; 이제 차이를 살펴봅시다.\n\n둘 다 컨테이너 런타임이며 컨테이너를 처리하는 데 동일한 작업을 수행합니다.\n\n하지만 차이점은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1) runc은 Go로 작성되었고 crun은 C로 작성되어서 Linux 커널과 더 호환성이 높아요.\n\n2) runc는 도커에 의해 개발되었고 crun은 RedHat에 의해 개발되었어요.\n\n3) crun은 더 가벼워서 메모리 소비가 낮아요. crun은 300K이고 runc는 15M이에요.\n\nPodman은 어떠세요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n포드맨은 컨테이너를 관리하는 데 책임이 있는 crun의 frontend 역할을 하는 도커와 비슷한 유틸리티입니다.\n\n## 요약\n\n![RuncvsCrunincontainersworld_2](/assets/img/2024-05-23-RuncvsCrunincontainersworld_2.png)\n\n결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어떤 것을 사용해야 할까요?\n\n개발 및 프로덕션 환경 모두에서 추가 구성 요소 없이 가볍게 사용할 컨테이너 엔진이 필요하다면 Podman을 선택하세요.\n\n특히 이미지를 생성할 필요가 없는 프로덕션 환경에서는 Podman을 선택하는 것이 좋습니다. 이미지 빌드 구성 요소는 불필요하고 자원을 소비하는 소프트웨어로 간주될 수 있습니다.\n\n그리고 이것이 Docker를 프로덕션 환경에서 사용하지 않아야 하는 또 다른 이유입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 쿠버네티스를 사용 중이라면 cri-o를 선택하세요. 그리고 runc에 만족스럽지 않다면 C 언어로 된 가벼운 런타임을 원한다면 crun으로 런타임을 쉽게 전환할 수 있습니다.\n\nkloudino.com (메디 탈레가니)가 작성함","ogImage":{"url":"/assets/img/2024-05-23-RuncvsCrunincontainersworld_0.png"},"coverImage":"/assets/img/2024-05-23-RuncvsCrunincontainersworld_0.png","tag":["Tech"],"readingTime":2},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    img: \"img\",\n    ol: \"ol\",\n    h2: \"h2\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"만약 컨테이너화 기술에 흥미가 있다면, runc에 대해 들어봤을 수도 있어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"자세한 내용을 설명해 들어가기 전에 컨테이너가 정확히 무엇인지 알려드릴게요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"주로 두 가지 리눅스 커널 모듈, 네임스페이스와 cgroup으로 만들어진 환경 안에서 가상 감옥 또는 격리된 환경을 만들어낸답니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"네임스페이스: 볼 수 있거나 접근할 수 있는 것을 제어합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Cgroup: 리소스(예: RAM 및 CPU) 얼마나 사용하는지 확인하는 데 사용됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-RuncvsCrunincontainersworld_0.png\",\n        alt: \"Image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"컨테이너 런타임이 무엇인가요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"컨테이너 런타임은 이미 이야기한 컨테이너라고 불리는 격리된 환경을 관리하는 데 도움을 주는 소프트웨어입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Runc과 Crun은 현재 사용되는 두 가지 주요 컨테이너 런타임입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그렇다면 containerd 또는 cri-o란 무엇인가요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 둘은 모두 runc 위에서 작동하는 컨테이너 런타임의 추상화된 레이어입니다. 이것들은 컨테이너를 관리하기 위한 프론트 엔드로, 즉 컨테이너를 생성, 제거, 시작 및 중지하는 역할을 담당합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-RuncvsCrunincontainersworld_1.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"크리올(Containerd)과 크라이오(CRI-O)는 둘 다 컨테이너 런타임으로 runc를 사용합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금까지는 runc와 crun이 무엇인지 알아보았습니다; 이제 차이를 살펴봅시다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"둘 다 컨테이너 런타임이며 컨테이너를 처리하는 데 동일한 작업을 수행합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 차이점은 다음과 같습니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"runc은 Go로 작성되었고 crun은 C로 작성되어서 Linux 커널과 더 호환성이 높아요.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"runc는 도커에 의해 개발되었고 crun은 RedHat에 의해 개발되었어요.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"crun은 더 가벼워서 메모리 소비가 낮아요. crun은 300K이고 runc는 15M이에요.\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Podman은 어떠세요?\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"포드맨은 컨테이너를 관리하는 데 책임이 있는 crun의 frontend 역할을 하는 도커와 비슷한 유틸리티입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"요약\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-RuncvsCrunincontainersworld_2.png\",\n        alt: \"RuncvsCrunincontainersworld_2\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"어떤 것을 사용해야 할까요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"개발 및 프로덕션 환경 모두에서 추가 구성 요소 없이 가볍게 사용할 컨테이너 엔진이 필요하다면 Podman을 선택하세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"특히 이미지를 생성할 필요가 없는 프로덕션 환경에서는 Podman을 선택하는 것이 좋습니다. 이미지 빌드 구성 요소는 불필요하고 자원을 소비하는 소프트웨어로 간주될 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 이것이 Docker를 프로덕션 환경에서 사용하지 않아야 하는 또 다른 이유입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 쿠버네티스를 사용 중이라면 cri-o를 선택하세요. 그리고 runc에 만족스럽지 않다면 C 언어로 된 가벼운 런타임을 원한다면 crun으로 런타임을 쉽게 전환할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"kloudino.com (메디 탈레가니)가 작성함\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-23-RuncvsCrunincontainersworld"},"buildId":"R1x9p1CQYDDJESXyLXKOK","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>