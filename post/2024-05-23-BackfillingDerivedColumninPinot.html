<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>핀오프에서 파생 열backfilling derived column 채우기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-23-BackfillingDerivedColumninPinot" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="핀오프에서 파생 열backfilling derived column 채우기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="핀오프에서 파생 열backfilling derived column 채우기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-23-BackfillingDerivedColumninPinot_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-23-BackfillingDerivedColumninPinot" data-gatsby-head="true"/><meta name="twitter:title" content="핀오프에서 파생 열backfilling derived column 채우기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-23-BackfillingDerivedColumninPinot_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-23 15:51" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-561ae49ab5aab7f5.js" defer=""></script><script src="/_next/static/R1x9p1CQYDDJESXyLXKOK/_buildManifest.js" defer=""></script><script src="/_next/static/R1x9p1CQYDDJESXyLXKOK/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">핀오프에서 파생 열backfilling derived column 채우기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="핀오프에서 파생 열backfilling derived column 채우기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 23, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-23-BackfillingDerivedColumninPinot&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p>데이터 엔지니어링 세계에서 백필링은 일반적인 시나리오입니다. 최근에 Pinot의 실시간 테이블에서 작업하던 중에 다른 JSON 기반 열에 존재하는 값을 추출하고있는데, 해당 속성이 깊은 중첩 안에 숨겨져 있어서 꽤 어려운 상황에 빠졌었죠.</p>
<img src="/assets/img/2024-05-23-BackfillingDerivedColumninPinot_0.png"/>
<p>이제 매번 이 테이블을 쿼리하고 원하는 속성을 필요로 할 때마다 해당 속성의 값을 추출하는 옵션은 항상 존재했습니다. 그러나 우리가 쿼리를 발전시키고자 했던 방식은 이 새로운 속성을 <code>where</code> 절에서도 사용하는 것이었습니다. 따라서, 이 속성에 대한 새로운 열을 만들어 이 열에 인덱스를 넣는 것이 좋은 지연 경험을 얻을 수 있는 가장 좋은 옵션이었습니다.</p>
<p>이 새로운 열을 도입하는 것은 원활할 수 있지만, 각 들어오는 항목마다 이 새로운 열을 채우기 시작할 수 있으며, 또한 이미 테이블에 존재하는 레코드에 대해서도 이 열을 백필하는 작업이 필요했습니다. 이는 실시간 테이블이었기 때문에 다소 어려웠고, 누군가가 이를 이전에 수행한 문서나 블로그가 없었습니다. 그래서 저는 이 여정에 착수하여 Pinot에서 파생 열을 위한 백필을 달성하는 데 관련된 모든 세부 사항을 파악했습니다. 실시간 테이블에 대해 이 문제를 해결했지만, 과정은 배치 테이블에 대해서도 유사할 것입니다.</p>
<div class="content-ad"></div>
<h1>문제 설명</h1>
<p>다음과 같은 <code>orders</code> 테이블이 있다고 가정해 봅시다:</p>
<p><img src="/assets/img/2024-05-23-BackfillingDerivedColumninPinot_1.png" alt="테이블"/></p>
<p>이제 우리는 <code>productDetails</code> 열에서 <code>brand</code> 속성을 유도하고, 이를 고유한 열로 만들고 싶습니다. 기존 레코드는 모두 원하는 값을 <code>productDetails</code> 열에서 추출하여 backfilling해야 합니다.</p>
<div class="content-ad"></div>
<p>브랜드 값이 없는 제품도 있을 수 있으니 해당 경우 파생 값을 null로 처리해야 합니다.</p>
<p>최종 테이블은 다음과 같이 보일 것입니다:</p>
<p><img src="/assets/img/2024-05-23-BackfillingDerivedColumninPinot_2.png" alt="테이블"/></p>
<h1>스키마에 새 열 추가하기</h1>
<div class="content-ad"></div>
<p>첫 번째로 할 일이네요! <code>orders</code> 테이블 스키마에 이 새로운 열을 추가하세요.
예를 들어, 기존 스키마가 다음과 같다면:</p>
<pre><code class="hljs language-js">{
   <span class="hljs-string">&quot;schemaName&quot;</span>: <span class="hljs-string">&quot;orders&quot;</span>,
   <span class="hljs-string">&quot;enableColumnBasedNullHandling&quot;</span>: <span class="hljs-literal">false</span>,
   <span class="hljs-string">&quot;dimensionFieldSpecs&quot;</span>: [
     {
       <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;orderId&quot;</span>,
       <span class="hljs-string">&quot;dataType&quot;</span>: <span class="hljs-string">&quot;INT&quot;</span>,
       <span class="hljs-string">&quot;notNull&quot;</span>: <span class="hljs-literal">false</span>
     },
     {
       <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;productId&quot;</span>,
       <span class="hljs-string">&quot;dataType&quot;</span>: <span class="hljs-string">&quot;INT&quot;</span>,
       <span class="hljs-string">&quot;notNull&quot;</span>: <span class="hljs-literal">false</span>
     },
     {
       <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;amount&quot;</span>,
       <span class="hljs-string">&quot;dataType&quot;</span>: <span class="hljs-string">&quot;LONG&quot;</span>,
       <span class="hljs-string">&quot;notNull&quot;</span>: <span class="hljs-literal">false</span>
     },
     {
       <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;productDetails&quot;</span>,
       <span class="hljs-string">&quot;dataType&quot;</span>: <span class="hljs-string">&quot;JSON&quot;</span>,
       <span class="hljs-string">&quot;notNull&quot;</span>: <span class="hljs-literal">false</span>
     }
   ],
   <span class="hljs-string">&quot;dateTimeFieldSpecs&quot;</span>: [
     {
       <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;createdAt&quot;</span>,
       <span class="hljs-string">&quot;dataType&quot;</span>: <span class="hljs-string">&quot;TIMESTAMP&quot;</span>,
       <span class="hljs-string">&quot;notNull&quot;</span>: <span class="hljs-literal">false</span>,
       <span class="hljs-string">&quot;format&quot;</span>: <span class="hljs-string">&quot;1:MILLISECONDS:EPOCH&quot;</span>,
       <span class="hljs-string">&quot;granularity&quot;</span>: <span class="hljs-string">&quot;1:MILLISECONDS&quot;</span>
     }
   ]
}
</code></pre>
<p>&quot;브랜드&quot;라는 새로운 열은 &quot;UI에서 스키마 편집&quot; 옵션을 사용하거나 해당 REST API를 사용하여 스키마에 추가할 수 있습니다. 이 열의 <code>notNull</code> 값을 false로 설정해야 합니다. 새로운 스키마는 다음과 같이 보일 것입니다:</p>
<pre><code class="hljs language-js">{
   <span class="hljs-string">&quot;schemaName&quot;</span>: <span class="hljs-string">&quot;orders&quot;</span>,
   <span class="hljs-string">&quot;enableColumnBasedNullHandling&quot;</span>: <span class="hljs-literal">false</span>,
   <span class="hljs-string">&quot;dimensionFieldSpecs&quot;</span>: [
     {
       <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;orderId&quot;</span>,
       <span class="hljs-string">&quot;dataType&quot;</span>: <span class="hljs-string">&quot;INT&quot;</span>,
       <span class="hljs-string">&quot;notNull&quot;</span>: <span class="hljs-literal">false</span>
     },
     {
       <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;productId&quot;</span>,
       <span class="hljs-string">&quot;dataType&quot;</span>: <span class="hljs-string">&quot;INT&quot;</span>,
       <span class="hljs-string">&quot;notNull&quot;</span>: <span class="hljs-literal">false</span>
     },
     {
       <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;amount&quot;</span>,
       <span class="hljs-string">&quot;dataType&quot;</span>: <span class="hljs-string">&quot;LONG&quot;</span>,
       <span class="hljs-string">&quot;notNull&quot;</span>: <span class="hljs-literal">false</span>
     },
     {
       <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;brand&quot;</span>,
       <span class="hljs-string">&quot;dataType&quot;</span>: <span class="hljs-string">&quot;STRING&quot;</span>,
       <span class="hljs-string">&quot;notNull&quot;</span>: <span class="hljs-literal">false</span>
     },
     {
       <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;productDetails&quot;</span>,
       <span class="hljs-string">&quot;dataType&quot;</span>: <span class="hljs-string">&quot;JSON&quot;</span>,
       <span class="hljs-string">&quot;notNull&quot;</span>: <span class="hljs-literal">false</span>
     }
   ],
   <span class="hljs-string">&quot;dateTimeFieldSpecs&quot;</span>: [
     {
       <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;createdAt&quot;</span>,
       <span class="hljs-string">&quot;dataType&quot;</span>: <span class="hljs-string">&quot;TIMESTAMP&quot;</span>,
       <span class="hljs-string">&quot;notNull&quot;</span>: <span class="hljs-literal">false</span>,
       <span class="hljs-string">&quot;format&quot;</span>: <span class="hljs-string">&quot;1:MILLISECONDS:EPOCH&quot;</span>,
       <span class="hljs-string">&quot;granularity&quot;</span>: <span class="hljs-string">&quot;1:MILLISECONDS&quot;</span>
     }
   ]
}
</code></pre>
<div class="content-ad"></div>
<h1>변환 구성 설정하기</h1>
<p>이것은 프로세스에서 가장 중요한 단계 중 하나입니다. 새 열에 필요한 변환 구성을 찾아야 합니다. 이 경우 다음 변환 구성을 사용할 수 있습니다:</p>
<pre><code class="hljs language-js">{
   <span class="hljs-string">&quot;columnName&quot;</span>: <span class="hljs-string">&quot;brand&quot;</span>,
   <span class="hljs-string">&quot;transformFunction&quot;</span>: <span class="hljs-string">&quot;jsonPathString(json_format(productDetails), &#x27;$.details.brand&#x27;, &#x27;null&#x27;)&quot;</span>
}
</code></pre>
<p>이 변환을 통해 우리는 <code>productDetails</code> 열에서 <code>brand</code> 속성을 추출할 것입니다. 이 속성이 없는 경우 <code>brand</code> 열에 문자열 <code>null</code>을 넣을 것입니다.</p>
<div class="content-ad"></div>
<p>상기 언급된 변환 구성은 테이블 구성의 &quot;ingestionConfig&quot; - &quot;transformationConfigs&quot; 섹션에 추가할 수 있습니다.</p>
<h1>파생 열 역추적</h1>
<p>이것은 역추적이 발생하는 실제 단계입니다. 역추적이 이루어지려면 모든 세그먼트를 다시로드해야 합니다. 이 작업은 테이블 페이지의 &quot;모든 세그먼트 다시로드&quot; 버튼을 클릭하거나 REST API(POST) <code>/segments/&#x27;tableName&#x27;/reload</code>을 호출하여 수행할 수 있습니다.</p>
<p>일반적으로 이 작업은 1분 미만이 소요되지만, 매우 큰 테이블의 경우 조금 더 오랜 시간이 걸릴 수 있습니다. 이 작업의 상태를 확인하려면 테이블 페이지에서 &quot;다시로드 상태&quot; 버튼을 클릭할 수 있습니다. 다시로드 상태를 확인하는 해당 API는 <code>/segments/segmentReloadStatus/&#x27;jobId&#x27;</code>입니다.</p>
<div class="content-ad"></div>
<p>작업이 완료되면 모든 레코드에 값이 포함된 파생 컬럼을 볼 수 있어야 합니다.</p>
<h1>주의 사항</h1>
<p>다음은 프로세스의 오류 포인트 중 일부입니다(제가 고생하며 배웠습니다). 리로드 세그먼트 작업은 새로 추가된 컬럼에만 영향을 미칩니다. 한 번 리로드 세그먼트 작업을 실행하고 변환 구성에 버그가 있는 것을 발견하면 해당 테이블에 무용지물 컬럼이 남게 됩니다. 이제 이 컬럼의 변환 구성을 수정하고 다시 리로드 세그먼트를 트리거하면 해당 컬럼에 값이 없는 것을 확인할 수 있습니다. 리로드 세그먼트 작업은 모든 세그먼트에 대해 성공했다는 상태를 표시할지라도 실제로는 아무 작업도 수행하지 않을 것입니다. Pinot이 역호환성 문제에 대해 불평하고 해당 컬럼을 삭제할 수 없도록 막을 것입니다.</p>
<p>이를 해결하기 위해 테이블의 사본을 만들고 해당 테이블 사본에 백필을 수행하여 변환 구성이 올바른지 확인하는 것을 강력히 권장합니다. 변환 구성에 만족하면 해당 테이블에 필요한 단계를 수행하십시오.</p>
<div class="content-ad"></div>
<h1>결론</h1>
<p>전반적으로 Pinot은 이 블로그에서 설명된 것처럼 파생 열을 백필링하는 등 여러 기능을 지원하는 강력한 OLAP 데이터 스토어입니다. 그러나 위대한 능력에는 큰 책임이 따릅니다! 새롭게 추가된 열에 대해 백필링을 수행할 때 매우 주의해야 합니다. 새로 추가된 열에 대해 리로드를 한 번만 실행할 수 있습니다.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"핀오프에서 파생 열backfilling derived column 채우기","description":"","date":"2024-05-23 15:51","slug":"2024-05-23-BackfillingDerivedColumninPinot","content":"\n\n데이터 엔지니어링 세계에서 백필링은 일반적인 시나리오입니다. 최근에 Pinot의 실시간 테이블에서 작업하던 중에 다른 JSON 기반 열에 존재하는 값을 추출하고있는데, 해당 속성이 깊은 중첩 안에 숨겨져 있어서 꽤 어려운 상황에 빠졌었죠.\n\n\u003cimg src=\"/assets/img/2024-05-23-BackfillingDerivedColumninPinot_0.png\" /\u003e\n\n이제 매번 이 테이블을 쿼리하고 원하는 속성을 필요로 할 때마다 해당 속성의 값을 추출하는 옵션은 항상 존재했습니다. 그러나 우리가 쿼리를 발전시키고자 했던 방식은 이 새로운 속성을 `where` 절에서도 사용하는 것이었습니다. 따라서, 이 속성에 대한 새로운 열을 만들어 이 열에 인덱스를 넣는 것이 좋은 지연 경험을 얻을 수 있는 가장 좋은 옵션이었습니다.\n\n이 새로운 열을 도입하는 것은 원활할 수 있지만, 각 들어오는 항목마다 이 새로운 열을 채우기 시작할 수 있으며, 또한 이미 테이블에 존재하는 레코드에 대해서도 이 열을 백필하는 작업이 필요했습니다. 이는 실시간 테이블이었기 때문에 다소 어려웠고, 누군가가 이를 이전에 수행한 문서나 블로그가 없었습니다. 그래서 저는 이 여정에 착수하여 Pinot에서 파생 열을 위한 백필을 달성하는 데 관련된 모든 세부 사항을 파악했습니다. 실시간 테이블에 대해 이 문제를 해결했지만, 과정은 배치 테이블에 대해서도 유사할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 문제 설명\n\n다음과 같은 `orders` 테이블이 있다고 가정해 봅시다:\n\n![테이블](/assets/img/2024-05-23-BackfillingDerivedColumninPinot_1.png)\n\n이제 우리는 `productDetails` 열에서 `brand` 속성을 유도하고, 이를 고유한 열로 만들고 싶습니다. 기존 레코드는 모두 원하는 값을 `productDetails` 열에서 추출하여 backfilling해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n브랜드 값이 없는 제품도 있을 수 있으니 해당 경우 파생 값을 null로 처리해야 합니다.\n\n최종 테이블은 다음과 같이 보일 것입니다:\n\n![테이블](/assets/img/2024-05-23-BackfillingDerivedColumninPinot_2.png)\n\n# 스키마에 새 열 추가하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫 번째로 할 일이네요! `orders` 테이블 스키마에 이 새로운 열을 추가하세요.\n예를 들어, 기존 스키마가 다음과 같다면:\n\n```js\n{\n   \"schemaName\": \"orders\",\n   \"enableColumnBasedNullHandling\": false,\n   \"dimensionFieldSpecs\": [\n     {\n       \"name\": \"orderId\",\n       \"dataType\": \"INT\",\n       \"notNull\": false\n     },\n     {\n       \"name\": \"productId\",\n       \"dataType\": \"INT\",\n       \"notNull\": false\n     },\n     {\n       \"name\": \"amount\",\n       \"dataType\": \"LONG\",\n       \"notNull\": false\n     },\n     {\n       \"name\": \"productDetails\",\n       \"dataType\": \"JSON\",\n       \"notNull\": false\n     }\n   ],\n   \"dateTimeFieldSpecs\": [\n     {\n       \"name\": \"createdAt\",\n       \"dataType\": \"TIMESTAMP\",\n       \"notNull\": false,\n       \"format\": \"1:MILLISECONDS:EPOCH\",\n       \"granularity\": \"1:MILLISECONDS\"\n     }\n   ]\n}\n```\n\n\"브랜드\"라는 새로운 열은 \"UI에서 스키마 편집\" 옵션을 사용하거나 해당 REST API를 사용하여 스키마에 추가할 수 있습니다. 이 열의 `notNull` 값을 false로 설정해야 합니다. 새로운 스키마는 다음과 같이 보일 것입니다:\n\n```js\n{\n   \"schemaName\": \"orders\",\n   \"enableColumnBasedNullHandling\": false,\n   \"dimensionFieldSpecs\": [\n     {\n       \"name\": \"orderId\",\n       \"dataType\": \"INT\",\n       \"notNull\": false\n     },\n     {\n       \"name\": \"productId\",\n       \"dataType\": \"INT\",\n       \"notNull\": false\n     },\n     {\n       \"name\": \"amount\",\n       \"dataType\": \"LONG\",\n       \"notNull\": false\n     },\n     {\n       \"name\": \"brand\",\n       \"dataType\": \"STRING\",\n       \"notNull\": false\n     },\n     {\n       \"name\": \"productDetails\",\n       \"dataType\": \"JSON\",\n       \"notNull\": false\n     }\n   ],\n   \"dateTimeFieldSpecs\": [\n     {\n       \"name\": \"createdAt\",\n       \"dataType\": \"TIMESTAMP\",\n       \"notNull\": false,\n       \"format\": \"1:MILLISECONDS:EPOCH\",\n       \"granularity\": \"1:MILLISECONDS\"\n     }\n   ]\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 변환 구성 설정하기\n\n이것은 프로세스에서 가장 중요한 단계 중 하나입니다. 새 열에 필요한 변환 구성을 찾아야 합니다. 이 경우 다음 변환 구성을 사용할 수 있습니다:\n\n```js\n{\n   \"columnName\": \"brand\",\n   \"transformFunction\": \"jsonPathString(json_format(productDetails), '$.details.brand', 'null')\"\n}\n```\n\n이 변환을 통해 우리는 `productDetails` 열에서 `brand` 속성을 추출할 것입니다. 이 속성이 없는 경우 `brand` 열에 문자열 `null`을 넣을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n상기 언급된 변환 구성은 테이블 구성의 \"ingestionConfig\" - \"transformationConfigs\" 섹션에 추가할 수 있습니다.\n\n# 파생 열 역추적\n\n이것은 역추적이 발생하는 실제 단계입니다. 역추적이 이루어지려면 모든 세그먼트를 다시로드해야 합니다. 이 작업은 테이블 페이지의 \"모든 세그먼트 다시로드\" 버튼을 클릭하거나 REST API(POST) `/segments/'tableName'/reload`을 호출하여 수행할 수 있습니다.\n\n일반적으로 이 작업은 1분 미만이 소요되지만, 매우 큰 테이블의 경우 조금 더 오랜 시간이 걸릴 수 있습니다. 이 작업의 상태를 확인하려면 테이블 페이지에서 \"다시로드 상태\" 버튼을 클릭할 수 있습니다. 다시로드 상태를 확인하는 해당 API는 `/segments/segmentReloadStatus/'jobId'`입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n작업이 완료되면 모든 레코드에 값이 포함된 파생 컬럼을 볼 수 있어야 합니다.\n\n# 주의 사항\n\n다음은 프로세스의 오류 포인트 중 일부입니다(제가 고생하며 배웠습니다). 리로드 세그먼트 작업은 새로 추가된 컬럼에만 영향을 미칩니다. 한 번 리로드 세그먼트 작업을 실행하고 변환 구성에 버그가 있는 것을 발견하면 해당 테이블에 무용지물 컬럼이 남게 됩니다. 이제 이 컬럼의 변환 구성을 수정하고 다시 리로드 세그먼트를 트리거하면 해당 컬럼에 값이 없는 것을 확인할 수 있습니다. 리로드 세그먼트 작업은 모든 세그먼트에 대해 성공했다는 상태를 표시할지라도 실제로는 아무 작업도 수행하지 않을 것입니다. Pinot이 역호환성 문제에 대해 불평하고 해당 컬럼을 삭제할 수 없도록 막을 것입니다.\n\n이를 해결하기 위해 테이블의 사본을 만들고 해당 테이블 사본에 백필을 수행하여 변환 구성이 올바른지 확인하는 것을 강력히 권장합니다. 변환 구성에 만족하면 해당 테이블에 필요한 단계를 수행하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n전반적으로 Pinot은 이 블로그에서 설명된 것처럼 파생 열을 백필링하는 등 여러 기능을 지원하는 강력한 OLAP 데이터 스토어입니다. 그러나 위대한 능력에는 큰 책임이 따릅니다! 새롭게 추가된 열에 대해 백필링을 수행할 때 매우 주의해야 합니다. 새로 추가된 열에 대해 리로드를 한 번만 실행할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-23-BackfillingDerivedColumninPinot_0.png"},"coverImage":"/assets/img/2024-05-23-BackfillingDerivedColumninPinot_0.png","tag":["Tech"],"readingTime":5},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\",\n    h1: \"h1\",\n    img: \"img\",\n    pre: \"pre\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"데이터 엔지니어링 세계에서 백필링은 일반적인 시나리오입니다. 최근에 Pinot의 실시간 테이블에서 작업하던 중에 다른 JSON 기반 열에 존재하는 값을 추출하고있는데, 해당 속성이 깊은 중첩 안에 숨겨져 있어서 꽤 어려운 상황에 빠졌었죠.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-23-BackfillingDerivedColumninPinot_0.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이제 매번 이 테이블을 쿼리하고 원하는 속성을 필요로 할 때마다 해당 속성의 값을 추출하는 옵션은 항상 존재했습니다. 그러나 우리가 쿼리를 발전시키고자 했던 방식은 이 새로운 속성을 \", _jsx(_components.code, {\n        children: \"where\"\n      }), \" 절에서도 사용하는 것이었습니다. 따라서, 이 속성에 대한 새로운 열을 만들어 이 열에 인덱스를 넣는 것이 좋은 지연 경험을 얻을 수 있는 가장 좋은 옵션이었습니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 새로운 열을 도입하는 것은 원활할 수 있지만, 각 들어오는 항목마다 이 새로운 열을 채우기 시작할 수 있으며, 또한 이미 테이블에 존재하는 레코드에 대해서도 이 열을 백필하는 작업이 필요했습니다. 이는 실시간 테이블이었기 때문에 다소 어려웠고, 누군가가 이를 이전에 수행한 문서나 블로그가 없었습니다. 그래서 저는 이 여정에 착수하여 Pinot에서 파생 열을 위한 백필을 달성하는 데 관련된 모든 세부 사항을 파악했습니다. 실시간 테이블에 대해 이 문제를 해결했지만, 과정은 배치 테이블에 대해서도 유사할 것입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"문제 설명\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"다음과 같은 \", _jsx(_components.code, {\n        children: \"orders\"\n      }), \" 테이블이 있다고 가정해 봅시다:\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-BackfillingDerivedColumninPinot_1.png\",\n        alt: \"테이블\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이제 우리는 \", _jsx(_components.code, {\n        children: \"productDetails\"\n      }), \" 열에서 \", _jsx(_components.code, {\n        children: \"brand\"\n      }), \" 속성을 유도하고, 이를 고유한 열로 만들고 싶습니다. 기존 레코드는 모두 원하는 값을 \", _jsx(_components.code, {\n        children: \"productDetails\"\n      }), \" 열에서 추출하여 backfilling해야 합니다.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"브랜드 값이 없는 제품도 있을 수 있으니 해당 경우 파생 값을 null로 처리해야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"최종 테이블은 다음과 같이 보일 것입니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-BackfillingDerivedColumninPinot_2.png\",\n        alt: \"테이블\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"스키마에 새 열 추가하기\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"첫 번째로 할 일이네요! \", _jsx(_components.code, {\n        children: \"orders\"\n      }), \" 테이블 스키마에 이 새로운 열을 추가하세요.\\n예를 들어, 기존 스키마가 다음과 같다면:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"{\\n   \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"schemaName\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"orders\\\"\"\n        }), \",\\n   \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"enableColumnBasedNullHandling\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \",\\n   \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"dimensionFieldSpecs\\\"\"\n        }), \": [\\n     {\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"orderId\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"dataType\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"INT\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"notNull\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \"\\n     },\\n     {\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"productId\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"dataType\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"INT\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"notNull\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \"\\n     },\\n     {\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"amount\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"dataType\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"LONG\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"notNull\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \"\\n     },\\n     {\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"productDetails\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"dataType\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"JSON\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"notNull\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \"\\n     }\\n   ],\\n   \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"dateTimeFieldSpecs\\\"\"\n        }), \": [\\n     {\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"createdAt\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"dataType\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"TIMESTAMP\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"notNull\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"format\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"1:MILLISECONDS:EPOCH\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"granularity\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"1:MILLISECONDS\\\"\"\n        }), \"\\n     }\\n   ]\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"\\\"브랜드\\\"라는 새로운 열은 \\\"UI에서 스키마 편집\\\" 옵션을 사용하거나 해당 REST API를 사용하여 스키마에 추가할 수 있습니다. 이 열의 \", _jsx(_components.code, {\n        children: \"notNull\"\n      }), \" 값을 false로 설정해야 합니다. 새로운 스키마는 다음과 같이 보일 것입니다:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"{\\n   \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"schemaName\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"orders\\\"\"\n        }), \",\\n   \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"enableColumnBasedNullHandling\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \",\\n   \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"dimensionFieldSpecs\\\"\"\n        }), \": [\\n     {\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"orderId\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"dataType\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"INT\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"notNull\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \"\\n     },\\n     {\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"productId\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"dataType\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"INT\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"notNull\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \"\\n     },\\n     {\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"amount\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"dataType\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"LONG\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"notNull\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \"\\n     },\\n     {\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"brand\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"dataType\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"STRING\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"notNull\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \"\\n     },\\n     {\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"productDetails\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"dataType\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"JSON\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"notNull\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \"\\n     }\\n   ],\\n   \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"dateTimeFieldSpecs\\\"\"\n        }), \": [\\n     {\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"createdAt\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"dataType\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"TIMESTAMP\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"notNull\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"format\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"1:MILLISECONDS:EPOCH\\\"\"\n        }), \",\\n       \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"granularity\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"1:MILLISECONDS\\\"\"\n        }), \"\\n     }\\n   ]\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"변환 구성 설정하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것은 프로세스에서 가장 중요한 단계 중 하나입니다. 새 열에 필요한 변환 구성을 찾아야 합니다. 이 경우 다음 변환 구성을 사용할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"{\\n   \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"columnName\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"brand\\\"\"\n        }), \",\\n   \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"transformFunction\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"jsonPathString(json_format(productDetails), '$.details.brand', 'null')\\\"\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이 변환을 통해 우리는 \", _jsx(_components.code, {\n        children: \"productDetails\"\n      }), \" 열에서 \", _jsx(_components.code, {\n        children: \"brand\"\n      }), \" 속성을 추출할 것입니다. 이 속성이 없는 경우 \", _jsx(_components.code, {\n        children: \"brand\"\n      }), \" 열에 문자열 \", _jsx(_components.code, {\n        children: \"null\"\n      }), \"을 넣을 것입니다.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"상기 언급된 변환 구성은 테이블 구성의 \\\"ingestionConfig\\\" - \\\"transformationConfigs\\\" 섹션에 추가할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"파생 열 역추적\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이것은 역추적이 발생하는 실제 단계입니다. 역추적이 이루어지려면 모든 세그먼트를 다시로드해야 합니다. 이 작업은 테이블 페이지의 \\\"모든 세그먼트 다시로드\\\" 버튼을 클릭하거나 REST API(POST) \", _jsx(_components.code, {\n        children: \"/segments/'tableName'/reload\"\n      }), \"을 호출하여 수행할 수 있습니다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"일반적으로 이 작업은 1분 미만이 소요되지만, 매우 큰 테이블의 경우 조금 더 오랜 시간이 걸릴 수 있습니다. 이 작업의 상태를 확인하려면 테이블 페이지에서 \\\"다시로드 상태\\\" 버튼을 클릭할 수 있습니다. 다시로드 상태를 확인하는 해당 API는 \", _jsx(_components.code, {\n        children: \"/segments/segmentReloadStatus/'jobId'\"\n      }), \"입니다.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"작업이 완료되면 모든 레코드에 값이 포함된 파생 컬럼을 볼 수 있어야 합니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"주의 사항\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음은 프로세스의 오류 포인트 중 일부입니다(제가 고생하며 배웠습니다). 리로드 세그먼트 작업은 새로 추가된 컬럼에만 영향을 미칩니다. 한 번 리로드 세그먼트 작업을 실행하고 변환 구성에 버그가 있는 것을 발견하면 해당 테이블에 무용지물 컬럼이 남게 됩니다. 이제 이 컬럼의 변환 구성을 수정하고 다시 리로드 세그먼트를 트리거하면 해당 컬럼에 값이 없는 것을 확인할 수 있습니다. 리로드 세그먼트 작업은 모든 세그먼트에 대해 성공했다는 상태를 표시할지라도 실제로는 아무 작업도 수행하지 않을 것입니다. Pinot이 역호환성 문제에 대해 불평하고 해당 컬럼을 삭제할 수 없도록 막을 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이를 해결하기 위해 테이블의 사본을 만들고 해당 테이블 사본에 백필을 수행하여 변환 구성이 올바른지 확인하는 것을 강력히 권장합니다. 변환 구성에 만족하면 해당 테이블에 필요한 단계를 수행하십시오.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"전반적으로 Pinot은 이 블로그에서 설명된 것처럼 파생 열을 백필링하는 등 여러 기능을 지원하는 강력한 OLAP 데이터 스토어입니다. 그러나 위대한 능력에는 큰 책임이 따릅니다! 새롭게 추가된 열에 대해 백필링을 수행할 때 매우 주의해야 합니다. 새로 추가된 열에 대해 리로드를 한 번만 실행할 수 있습니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-23-BackfillingDerivedColumninPinot"},"buildId":"R1x9p1CQYDDJESXyLXKOK","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>