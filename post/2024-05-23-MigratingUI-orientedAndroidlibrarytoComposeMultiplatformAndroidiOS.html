<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>컴포즈 멀티플랫폼Android iOS으로 UI 중심 안드로이드 라이브러리 이주하기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="컴포즈 멀티플랫폼Android iOS으로 UI 중심 안드로이드 라이브러리 이주하기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="컴포즈 멀티플랫폼Android iOS으로 UI 중심 안드로이드 라이브러리 이주하기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS" data-gatsby-head="true"/><meta name="twitter:title" content="컴포즈 멀티플랫폼Android iOS으로 UI 중심 안드로이드 라이브러리 이주하기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-23 12:52" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_buildManifest.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">컴포즈 멀티플랫폼Android iOS으로 UI 중심 안드로이드 라이브러리 이주하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="컴포즈 멀티플랫폼Android iOS으로 UI 중심 안드로이드 라이브러리 이주하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 23, 2024</span><span class="posts_reading_time__f7YPP">11<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>연혁을 거듭하면서, Kotlin Multiplatform이 드디어 여기 머물 것 같습니다. 그러나 비즈니스 로직만 공유하는 것이 특히 React Native, Flutter 및 기타 기술이 더 많은 일을 할 수 있는 만큼 편리하고 경쟁력이 있다고 느끼는 어색한 느낌이 아직 남아 있었습니다. 그래서 매우 기대되었던 Compose Multiplatform for iOS의 첫 번째 알파 버전을 작년에 보게 되어 정말 기뻤습니다.</p>
<p>퍼즐이 마침내 맞추어졌습니다. 이제 안드로이드 개발자들은 최소한의 추가 노력으로 iOS 앱을 코틀린으로 만들 수 있습니다. 그러나 이게 정말 그럴까요? 알아봅시다. 여기서는 라이브러리 이전에 대해 설명하겠습니다. 전체 애플리케이션을 이전할 때 몇 가지 점이 다를 수 있습니다.</p>
<img src="/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_0.png">
<h2>내 경우에 관하여</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>안녕하세요! 안드로이드/Kotlin과 iOS/Swift 클라이언트가 있습니다. 두 클라이언트 모두 다음 UI 기능을 갖춘 자체 제작 라이브러리를 사용합니다:</p>
<ul>
<li>정적으로 로드할 수 있는 이미지</li>
<li>로드 가능한 GIF</li>
<li>비디오 (CDN으로부터 스트리밍 로딩)</li>
<li>모든 항목은 수직 목록에 수평 목록이 내장됩니다</li>
</ul>
<p>추가로:</p>
<ul>
<li>네트워크 통신</li>
<li>디스크 캐싱</li>
</ul>
<p>언제든지 물어보세요!</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="https://miro.medium.com/v2/resize:fit:472/1*4Eb5MmEXdZwZC8WkYBB6yA.gif" alt="image"></p>
<p>우리에게는 Compose Multiplatform 기능과 성능을 테스트하는 좋은 시작점이었습니다. 무엇이 문제가 될 수 있는지 알고 싶다면, 여기에서 확인해보세요.</p>
<h2>왜 Compose Multiplatform 인가요?</h2>
<p>일부 소스에서 Jetpack Compose를 선언적 API로 설명합니다. 저에게 있어 Jetpack Compose의 주요 장점은 전통적인 XML 레이아웃과 비교했을 때의 유연성입니다. 그리고 Jetpack Compose에서 레이아웃을 작성한 후에는 Compose Multiplatform로 이전하는 것이 정말 어렵지 않습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>비즈니스적인 관점에서 주요 방해 요인이 없이 코드베이스를 점진적으로 통합하는 것이 더 쉽습니다. 추가 개발자가 필요하지 않습니다. 그것이 Compose Multiplatform이 허용하는 것입니다.</p>
<p>Jetbrains에 따르면, 이것이 어떻게 작동하는지 간단히 상기시켜 드리겠습니다:</p>
<p><img src="/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_1.png" alt="Jetbrains Image"></p>
<h2>코드베이스에서의 장애물</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>가끔 우리는 모두 KMP 코드가 아닌 코드를 작성하거나 사용합니다. 때로는 많을 때도 있죠.</p>
<p>전형적인 예시는 다음과 같습니다:</p>
<ul>
<li>Java 코드</li>
<li>Dagger 2, RxJava, Retrofit 등과 같은 호환되지 않는 라이브러리 종속성</li>
<li>XML 레이아웃, 뷰, 프래그먼트</li>
<li>안드로이드 서비스, 푸시 알림, 인앱 구매</li>
<li>그 밖에도...</li>
</ul>
<p>여기에는 주로 2가지 해결책이 있습니다:</p>
<ul>
<li>코드를 다시 작성하거나 KMP 호환 라이브러리로 이전하여 commonMain 폴더에 넣습니다.</li>
<li>호환되지 않는 코드를 플랫폼별 서브모듈인 androidMain 및 iosMain에 넣습니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>사실 platform-specific 하위 모듈에 항상 코드를 넣을 수 있습니다. 그러나 이 경우에는 iOS용으로 코드를 작성하거나 iOS에서도 구현해야 합니다.</p>
<h2>iOS에 특정한 코드를 작성하는 방법은?</h2>
<p>iOS 플랫폼별 코드를 정의하거나 사용하는 데는 2가지 주요 옵션이 있습니다:</p>
<p>옵션 1.
iosMain 폴더에 구현된 Expect/actual 함수.
다음은 구조가 어떻게 보이는지 예시입니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_2.png">
<p>옵션 2.
iOS 측에서 호출할 수 있는 몇 가지 커넥터를 제공합니다.
다음은 commonMain에서 빈 로거를 정의하는 예입니다:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">object</span> Bridge {
    <span class="hljs-keyword">var</span> logger: (String) -> <span class="hljs-built_in">Unit</span> = {}
    ...
}
</code></pre>
<p>iOS/Swift 앱에서 로거에 대한 구현을 할당합니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> ...

<span class="hljs-title class_">Bridge</span>.<span class="hljs-property">shared</span>.<span class="hljs-property">logger</span> = {
    <span class="hljs-title function_">print</span>(<span class="hljs-string">"ios log: "</span> + $0)
}
</code></pre>
<p>그냥 간단한 경우일 뿐입니다. 사실 거의 모든 것을 이 방법으로 연결할 수 있습니다. commonMain에서 인터페이스를 정의하고 전체 구현을 별도로 Swift로 작성하는 것도 가능합니다.</p>
<p>물론 작성해야 하는 플랫폼별 코드가 많아질수록 더 나쁠 수 있습니다. 제 상황에서는 iosMain에 전체 라이브러리 코드의 약 9%가 있고, androidMain에는 약 13%가 있습니다. 이 비율은 여러분의 상황에서는 낮을 수도 있습니다.</p>
<h2>어떻게 마이그레이션을 시작할까요?</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우리는 Android/Kotlin 및 iOS/Swift 클라이언트를 보유하고 있습니다. 통합을 시작하는 방법은 무엇일까요?</p>
<p>Android의 경우, 기존 앱 또는 라이브러리에 KMP(코틀린 멀티플랫폼)과 호환되는 코드를 단계별로 다시 작성하여 통합할 수 있습니다. 언어는 그대로 유지되지만 의존하는 접근 방식과 라이브러리는 변경될 수 있습니다.</p>
<p>간단한 경우에는 다음과 같습니다:</p>
<ul>
<li>코드베이스에 KMP 모듈을 만듭니다.</li>
<li>코드를 공통 모듈(commonMain)로 순차적으로 이동시킵니다.</li>
<li>플랫폼에서 이동할 수 없는 부분에 대한 커넥터를 만듭니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우리는 우리의 경우에 iOS와 안드로이드 클라이언트가 의존하는 UI 중심 라이브러리를 마이그레이션하기로 결정했습니다. 그 라이브러리를 완전히 다시 작성해야 했던 이유는 RxJava와 XML 레이아웃을 기반으로 했기 때문이었습니다.</p>
<h2>우리의 주요 기술 변화</h2>
<p>RxJava → Coroutines / Flow
만약 Rx를 사용 중이라면 Flow로 마이그레이션하거나 Reaktive와 같은 KMP 대안을 사용해야 합니다.</p>
<p>Retrofit → Ktor
Ktor는 매우 편리한 네트워크 라이브러리입니다. 큰 문제는 없었습니다. 여러 번 검색해서 익숙했던 것을 어떻게 쓰는지 찾아보면 됩니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Room → Room?
제 경우에는 일반 디스크 캐싱을 Okio로 대체하는 것이 허용되었습니다. 하지만 사실 Room은 KMP도 지원합니다.</p>
<p>Glide → Coil 3 + iOS용 자체 GIF 구현.
Coil 3는 아직 알파 버전이지만 동작합니다. 제 경우 문제는 iOS에서 GIF를 재생할 수 없었던 것이었습니다. 안타깝게도 몇 일 동안 문제를 해결하고 디스크 캐싱을 통해 해결책을 구현하는 데 시간이 걸렸습니다.</p>
<p>제 경우 이미지에 대한 기본 계약:</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Composable</span>
expect fun <span class="hljs-title class_">LoadableImage</span>(
    <span class="hljs-attr">modifier</span>: <span class="hljs-title class_">Modifier</span>,
    <span class="hljs-attr">url</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">imageColorFilter</span>: <span class="hljs-title class_">ColorFilter</span>? = <span class="hljs-literal">null</span>,
    <span class="hljs-attr">size</span>: <span class="hljs-title class_">Size</span>? = <span class="hljs-literal">null</span>,
)
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Jetpack ExoPlayer → ExoPlayer + AVPlayer
우리는 각 플랫폼마다 플레이어를 대체하기 위해 expect/actual을 사용합니다.
ExoPlayer는 디스크 캐싱 및 스트리밍 재생 기능을 갖춘 안드로이드용 강력한 솔루션입니다.
AvPlayer는 iOS의 기본 솔루션입니다.</p>
<p>플레이어의 기본 계약:</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Composable</span>
expect fun <span class="hljs-title class_">VideoPlayer</span>(
    <span class="hljs-attr">modifier</span>: <span class="hljs-title class_">Modifier</span>,
    <span class="hljs-attr">url</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">volumeEnabled</span>: <span class="hljs-title class_">State</span>&#x3C;<span class="hljs-title class_">Boolean</span>>,
)
</code></pre>
<h2>안드로이드용 빌드 방법</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>안드로이드의 경우 일반적인 안드로이드 라이브러리와 유사합니다. 이 라이브러리는 애플리케이션의 모듈로 사용할 수 있습니다. 현재는 이것이 우리의 선택입니다.</p>
<p>다른 옵션으로 그레이들 복합 빌드를 사용할 수도 있습니다. 자세한 내용은 다음 기사를 참조하세요:</p>
<p>마지막으로, 그레이들 작업 bundleReleaseAar을 사용하여 라이브러리를 .aar 파일로 조립할 수 있습니다.</p>
<h2>iOS용 빌드 방법</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>로컬 개발 중에는 XCFramework을 빌드하고 iOS 프로젝트에 넣습니다. 프로세스는 여기에 설명되어 있습니다:</p>
<p>간단히 말하면 다음과 같습니다:</p>
<ul>
<li>Gradle 작업을 호출합니다.
로컬 빌드(빠름)의 경우 iosX64Binaries 또는 iosArm64Binaries를 사용하거나 최종 이진 파일의 경우 assembleReleaseXCFramework를 사용합니다(느림).</li>
<li>build/bin/iosArm64/releaseFramework (또는 유사한 경로)에서 결과물을 iOS 프로젝트로 복사합니다.</li>
<li>Xcode에 의해 동기화될 때까지 잠시 기다립니다.</li>
<li>완료. iOS 프로젝트에서 Kotlin 코드를 사용하세요.</li>
</ul>
<p>자동화된 CI/CD 파이프라인에서는 프로세스가 약간 다르지만 이는 다른 이야기입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>나의 경우의 결과</h2>
<p>현재 저희 이주 작업은 사전 제작 단계에 있지만, 이미 몇 가지 결론을 도출할 수 있습니다.</p>
<p>🟢 기능성.
저희 라이브러리의 모든 주요 기능이 이주되었습니다.
일부 비중요한 예외를 제외하고 기능 요구 사항이 충족되었습니다.</p>
<p>🟢 코드베이스.
이와 같이 재작성하는 것은 많은 레거시 코드를 제거할 수 있는 기회입니다.
숫자:
이주 이전: 10,000 줄 코드, 1,200 줄 XML
이후: 4,000 줄 코드
결과: 기존 버전과 비교했을 때 코드 양이 약 2.5배 감소했습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>🟢 성능.
iOS에서는 iPhone SE에서도 부드럽게 스크롤됩니다.
저사양 안드로이드 기기에서는 XML 버전과 비교했을 때 그렇게 부드럽지 않지만, 심각한 문제는 아닙니다.</p>
<p>🟡 개발 생산성.
일반적으로, 현대적인 안드로이드 개발과 Jetpack Compose에 익숙하다면 주요 문제가 없을 것입니다. 다만 제 경험상 한 가지 예외가 있습니다: Android Studio 및 IDEA에는 미리보기가 없습니다. Fleet에서는 작동하지만 AS/IDEA에서는 Composable 함수를 블라인드로 작성해야 합니다.</p>
<p>🟡 이진 크기.
Android APK: + 0.5 MB
iOS IPA: + 18 MB</p>
<p>🟡 라이브러리 크기.
거대한 XCFrameworks 크기. 300MB 이상입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>🔴 빌드 시간.
iOS의 빌드 시간이 길어요. 기계에 따라 다르지만 라이브러리 4k 줄의 코드를 가지고 17분 같은 숫자를 볼 수 있어요.</p>
<h2>결론</h2>
<p>2024년에는 Kotlin으로 크로스 플랫폼 UI를 작성하는 것이 전혀 가능합니다.</p>
<p>KMP와 Compose Multiplatform의 멋진 점은 Kotlin으로 코드를 작성해야 한다면, 왜 KMP 호환 방식으로 작성하지 않을까요?</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우리의 경우에는 결과가 수용 가능하며, 스트레스 테스트로 간주할 수 있습니다. 또한 iOS용 Compose Multiplatform이 알파 단계에 있고, Kotlin 2가 미래에 있음을 염두에 두어야 합니다.</p>
<p>읽어 주셔서 감사합니다!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"컴포즈 멀티플랫폼Android iOS으로 UI 중심 안드로이드 라이브러리 이주하기","description":"","date":"2024-05-23 12:52","slug":"2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS","content":"\n연혁을 거듭하면서, Kotlin Multiplatform이 드디어 여기 머물 것 같습니다. 그러나 비즈니스 로직만 공유하는 것이 특히 React Native, Flutter 및 기타 기술이 더 많은 일을 할 수 있는 만큼 편리하고 경쟁력이 있다고 느끼는 어색한 느낌이 아직 남아 있었습니다. 그래서 매우 기대되었던 Compose Multiplatform for iOS의 첫 번째 알파 버전을 작년에 보게 되어 정말 기뻤습니다.\n\n퍼즐이 마침내 맞추어졌습니다. 이제 안드로이드 개발자들은 최소한의 추가 노력으로 iOS 앱을 코틀린으로 만들 수 있습니다. 그러나 이게 정말 그럴까요? 알아봅시다. 여기서는 라이브러리 이전에 대해 설명하겠습니다. 전체 애플리케이션을 이전할 때 몇 가지 점이 다를 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_0.png\" /\u003e\n\n## 내 경우에 관하여\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 안드로이드/Kotlin과 iOS/Swift 클라이언트가 있습니다. 두 클라이언트 모두 다음 UI 기능을 갖춘 자체 제작 라이브러리를 사용합니다:\n\n- 정적으로 로드할 수 있는 이미지\n- 로드 가능한 GIF\n- 비디오 (CDN으로부터 스트리밍 로딩)\n- 모든 항목은 수직 목록에 수평 목록이 내장됩니다\n\n추가로:\n\n- 네트워크 통신\n- 디스크 캐싱\n\n언제든지 물어보세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:472/1*4Eb5MmEXdZwZC8WkYBB6yA.gif)\n\n우리에게는 Compose Multiplatform 기능과 성능을 테스트하는 좋은 시작점이었습니다. 무엇이 문제가 될 수 있는지 알고 싶다면, 여기에서 확인해보세요.\n\n## 왜 Compose Multiplatform 인가요?\n\n일부 소스에서 Jetpack Compose를 선언적 API로 설명합니다. 저에게 있어 Jetpack Compose의 주요 장점은 전통적인 XML 레이아웃과 비교했을 때의 유연성입니다. 그리고 Jetpack Compose에서 레이아웃을 작성한 후에는 Compose Multiplatform로 이전하는 것이 정말 어렵지 않습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n비즈니스적인 관점에서 주요 방해 요인이 없이 코드베이스를 점진적으로 통합하는 것이 더 쉽습니다. 추가 개발자가 필요하지 않습니다. 그것이 Compose Multiplatform이 허용하는 것입니다.\n\nJetbrains에 따르면, 이것이 어떻게 작동하는지 간단히 상기시켜 드리겠습니다:\n\n![Jetbrains Image](/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_1.png)\n\n## 코드베이스에서의 장애물\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가끔 우리는 모두 KMP 코드가 아닌 코드를 작성하거나 사용합니다. 때로는 많을 때도 있죠.\n\n전형적인 예시는 다음과 같습니다:\n\n- Java 코드\n- Dagger 2, RxJava, Retrofit 등과 같은 호환되지 않는 라이브러리 종속성\n- XML 레이아웃, 뷰, 프래그먼트\n- 안드로이드 서비스, 푸시 알림, 인앱 구매\n- 그 밖에도...\n\n여기에는 주로 2가지 해결책이 있습니다:\n\n- 코드를 다시 작성하거나 KMP 호환 라이브러리로 이전하여 commonMain 폴더에 넣습니다.\n- 호환되지 않는 코드를 플랫폼별 서브모듈인 androidMain 및 iosMain에 넣습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사실 platform-specific 하위 모듈에 항상 코드를 넣을 수 있습니다. 그러나 이 경우에는 iOS용으로 코드를 작성하거나 iOS에서도 구현해야 합니다.\n\n## iOS에 특정한 코드를 작성하는 방법은?\n\niOS 플랫폼별 코드를 정의하거나 사용하는 데는 2가지 주요 옵션이 있습니다:\n\n옵션 1.\niosMain 폴더에 구현된 Expect/actual 함수.\n다음은 구조가 어떻게 보이는지 예시입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_2.png\" /\u003e\n\n옵션 2.\niOS 측에서 호출할 수 있는 몇 가지 커넥터를 제공합니다.\n다음은 commonMain에서 빈 로거를 정의하는 예입니다:\n\n```kotlin\nobject Bridge {\n    var logger: (String) -\u003e Unit = {}\n    ...\n}\n```\n\niOS/Swift 앱에서 로거에 대한 구현을 할당합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport ...\n\nBridge.shared.logger = {\n    print(\"ios log: \" + $0)\n}\n```\n\n그냥 간단한 경우일 뿐입니다. 사실 거의 모든 것을 이 방법으로 연결할 수 있습니다. commonMain에서 인터페이스를 정의하고 전체 구현을 별도로 Swift로 작성하는 것도 가능합니다.\n\n물론 작성해야 하는 플랫폼별 코드가 많아질수록 더 나쁠 수 있습니다. 제 상황에서는 iosMain에 전체 라이브러리 코드의 약 9%가 있고, androidMain에는 약 13%가 있습니다. 이 비율은 여러분의 상황에서는 낮을 수도 있습니다.\n\n## 어떻게 마이그레이션을 시작할까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 Android/Kotlin 및 iOS/Swift 클라이언트를 보유하고 있습니다. 통합을 시작하는 방법은 무엇일까요?\n\nAndroid의 경우, 기존 앱 또는 라이브러리에 KMP(코틀린 멀티플랫폼)과 호환되는 코드를 단계별로 다시 작성하여 통합할 수 있습니다. 언어는 그대로 유지되지만 의존하는 접근 방식과 라이브러리는 변경될 수 있습니다.\n\n간단한 경우에는 다음과 같습니다:\n\n- 코드베이스에 KMP 모듈을 만듭니다.\n- 코드를 공통 모듈(commonMain)로 순차적으로 이동시킵니다.\n- 플랫폼에서 이동할 수 없는 부분에 대한 커넥터를 만듭니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 우리의 경우에 iOS와 안드로이드 클라이언트가 의존하는 UI 중심 라이브러리를 마이그레이션하기로 결정했습니다. 그 라이브러리를 완전히 다시 작성해야 했던 이유는 RxJava와 XML 레이아웃을 기반으로 했기 때문이었습니다.\n\n## 우리의 주요 기술 변화\n\nRxJava → Coroutines / Flow\n만약 Rx를 사용 중이라면 Flow로 마이그레이션하거나 Reaktive와 같은 KMP 대안을 사용해야 합니다.\n\nRetrofit → Ktor\nKtor는 매우 편리한 네트워크 라이브러리입니다. 큰 문제는 없었습니다. 여러 번 검색해서 익숙했던 것을 어떻게 쓰는지 찾아보면 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nRoom → Room?\n제 경우에는 일반 디스크 캐싱을 Okio로 대체하는 것이 허용되었습니다. 하지만 사실 Room은 KMP도 지원합니다.\n\nGlide → Coil 3 + iOS용 자체 GIF 구현.\nCoil 3는 아직 알파 버전이지만 동작합니다. 제 경우 문제는 iOS에서 GIF를 재생할 수 없었던 것이었습니다. 안타깝게도 몇 일 동안 문제를 해결하고 디스크 캐싱을 통해 해결책을 구현하는 데 시간이 걸렸습니다.\n\n제 경우 이미지에 대한 기본 계약:\n\n```js\n@Composable\nexpect fun LoadableImage(\n    modifier: Modifier,\n    url: String,\n    imageColorFilter: ColorFilter? = null,\n    size: Size? = null,\n)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJetpack ExoPlayer → ExoPlayer + AVPlayer\n우리는 각 플랫폼마다 플레이어를 대체하기 위해 expect/actual을 사용합니다.\nExoPlayer는 디스크 캐싱 및 스트리밍 재생 기능을 갖춘 안드로이드용 강력한 솔루션입니다.\nAvPlayer는 iOS의 기본 솔루션입니다.\n\n플레이어의 기본 계약:\n\n```js\n@Composable\nexpect fun VideoPlayer(\n    modifier: Modifier,\n    url: String,\n    volumeEnabled: State\u003cBoolean\u003e,\n)\n```\n\n## 안드로이드용 빌드 방법\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안드로이드의 경우 일반적인 안드로이드 라이브러리와 유사합니다. 이 라이브러리는 애플리케이션의 모듈로 사용할 수 있습니다. 현재는 이것이 우리의 선택입니다.\n\n다른 옵션으로 그레이들 복합 빌드를 사용할 수도 있습니다. 자세한 내용은 다음 기사를 참조하세요:\n\n마지막으로, 그레이들 작업 bundleReleaseAar을 사용하여 라이브러리를 .aar 파일로 조립할 수 있습니다.\n\n## iOS용 빌드 방법\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n로컬 개발 중에는 XCFramework을 빌드하고 iOS 프로젝트에 넣습니다. 프로세스는 여기에 설명되어 있습니다:\n\n간단히 말하면 다음과 같습니다:\n\n- Gradle 작업을 호출합니다.\n  로컬 빌드(빠름)의 경우 iosX64Binaries 또는 iosArm64Binaries를 사용하거나 최종 이진 파일의 경우 assembleReleaseXCFramework를 사용합니다(느림).\n- build/bin/iosArm64/releaseFramework (또는 유사한 경로)에서 결과물을 iOS 프로젝트로 복사합니다.\n- Xcode에 의해 동기화될 때까지 잠시 기다립니다.\n- 완료. iOS 프로젝트에서 Kotlin 코드를 사용하세요.\n\n자동화된 CI/CD 파이프라인에서는 프로세스가 약간 다르지만 이는 다른 이야기입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 나의 경우의 결과\n\n현재 저희 이주 작업은 사전 제작 단계에 있지만, 이미 몇 가지 결론을 도출할 수 있습니다.\n\n🟢 기능성.\n저희 라이브러리의 모든 주요 기능이 이주되었습니다.\n일부 비중요한 예외를 제외하고 기능 요구 사항이 충족되었습니다.\n\n🟢 코드베이스.\n이와 같이 재작성하는 것은 많은 레거시 코드를 제거할 수 있는 기회입니다.\n숫자:\n이주 이전: 10,000 줄 코드, 1,200 줄 XML\n이후: 4,000 줄 코드\n결과: 기존 버전과 비교했을 때 코드 양이 약 2.5배 감소했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n🟢 성능.\niOS에서는 iPhone SE에서도 부드럽게 스크롤됩니다.\n저사양 안드로이드 기기에서는 XML 버전과 비교했을 때 그렇게 부드럽지 않지만, 심각한 문제는 아닙니다.\n\n🟡 개발 생산성.\n일반적으로, 현대적인 안드로이드 개발과 Jetpack Compose에 익숙하다면 주요 문제가 없을 것입니다. 다만 제 경험상 한 가지 예외가 있습니다: Android Studio 및 IDEA에는 미리보기가 없습니다. Fleet에서는 작동하지만 AS/IDEA에서는 Composable 함수를 블라인드로 작성해야 합니다.\n\n🟡 이진 크기.\nAndroid APK: + 0.5 MB\niOS IPA: + 18 MB\n\n🟡 라이브러리 크기.\n거대한 XCFrameworks 크기. 300MB 이상입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n🔴 빌드 시간.\niOS의 빌드 시간이 길어요. 기계에 따라 다르지만 라이브러리 4k 줄의 코드를 가지고 17분 같은 숫자를 볼 수 있어요.\n\n## 결론\n\n2024년에는 Kotlin으로 크로스 플랫폼 UI를 작성하는 것이 전혀 가능합니다.\n\nKMP와 Compose Multiplatform의 멋진 점은 Kotlin으로 코드를 작성해야 한다면, 왜 KMP 호환 방식으로 작성하지 않을까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리의 경우에는 결과가 수용 가능하며, 스트레스 테스트로 간주할 수 있습니다. 또한 iOS용 Compose Multiplatform이 알파 단계에 있고, Kotlin 2가 미래에 있음을 염두에 두어야 합니다.\n\n읽어 주셔서 감사합니다!\n","ogImage":{"url":"/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_0.png"},"coverImage":"/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_0.png","tag":["Tech"],"readingTime":11},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e연혁을 거듭하면서, Kotlin Multiplatform이 드디어 여기 머물 것 같습니다. 그러나 비즈니스 로직만 공유하는 것이 특히 React Native, Flutter 및 기타 기술이 더 많은 일을 할 수 있는 만큼 편리하고 경쟁력이 있다고 느끼는 어색한 느낌이 아직 남아 있었습니다. 그래서 매우 기대되었던 Compose Multiplatform for iOS의 첫 번째 알파 버전을 작년에 보게 되어 정말 기뻤습니다.\u003c/p\u003e\n\u003cp\u003e퍼즐이 마침내 맞추어졌습니다. 이제 안드로이드 개발자들은 최소한의 추가 노력으로 iOS 앱을 코틀린으로 만들 수 있습니다. 그러나 이게 정말 그럴까요? 알아봅시다. 여기서는 라이브러리 이전에 대해 설명하겠습니다. 전체 애플리케이션을 이전할 때 몇 가지 점이 다를 수 있습니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_0.png\"\u003e\n\u003ch2\u003e내 경우에 관하여\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e안녕하세요! 안드로이드/Kotlin과 iOS/Swift 클라이언트가 있습니다. 두 클라이언트 모두 다음 UI 기능을 갖춘 자체 제작 라이브러리를 사용합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e정적으로 로드할 수 있는 이미지\u003c/li\u003e\n\u003cli\u003e로드 가능한 GIF\u003c/li\u003e\n\u003cli\u003e비디오 (CDN으로부터 스트리밍 로딩)\u003c/li\u003e\n\u003cli\u003e모든 항목은 수직 목록에 수평 목록이 내장됩니다\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e추가로:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e네트워크 통신\u003c/li\u003e\n\u003cli\u003e디스크 캐싱\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e언제든지 물어보세요!\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:472/1*4Eb5MmEXdZwZC8WkYBB6yA.gif\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e우리에게는 Compose Multiplatform 기능과 성능을 테스트하는 좋은 시작점이었습니다. 무엇이 문제가 될 수 있는지 알고 싶다면, 여기에서 확인해보세요.\u003c/p\u003e\n\u003ch2\u003e왜 Compose Multiplatform 인가요?\u003c/h2\u003e\n\u003cp\u003e일부 소스에서 Jetpack Compose를 선언적 API로 설명합니다. 저에게 있어 Jetpack Compose의 주요 장점은 전통적인 XML 레이아웃과 비교했을 때의 유연성입니다. 그리고 Jetpack Compose에서 레이아웃을 작성한 후에는 Compose Multiplatform로 이전하는 것이 정말 어렵지 않습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e비즈니스적인 관점에서 주요 방해 요인이 없이 코드베이스를 점진적으로 통합하는 것이 더 쉽습니다. 추가 개발자가 필요하지 않습니다. 그것이 Compose Multiplatform이 허용하는 것입니다.\u003c/p\u003e\n\u003cp\u003eJetbrains에 따르면, 이것이 어떻게 작동하는지 간단히 상기시켜 드리겠습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_1.png\" alt=\"Jetbrains Image\"\u003e\u003c/p\u003e\n\u003ch2\u003e코드베이스에서의 장애물\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e가끔 우리는 모두 KMP 코드가 아닌 코드를 작성하거나 사용합니다. 때로는 많을 때도 있죠.\u003c/p\u003e\n\u003cp\u003e전형적인 예시는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eJava 코드\u003c/li\u003e\n\u003cli\u003eDagger 2, RxJava, Retrofit 등과 같은 호환되지 않는 라이브러리 종속성\u003c/li\u003e\n\u003cli\u003eXML 레이아웃, 뷰, 프래그먼트\u003c/li\u003e\n\u003cli\u003e안드로이드 서비스, 푸시 알림, 인앱 구매\u003c/li\u003e\n\u003cli\u003e그 밖에도...\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e여기에는 주로 2가지 해결책이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e코드를 다시 작성하거나 KMP 호환 라이브러리로 이전하여 commonMain 폴더에 넣습니다.\u003c/li\u003e\n\u003cli\u003e호환되지 않는 코드를 플랫폼별 서브모듈인 androidMain 및 iosMain에 넣습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e사실 platform-specific 하위 모듈에 항상 코드를 넣을 수 있습니다. 그러나 이 경우에는 iOS용으로 코드를 작성하거나 iOS에서도 구현해야 합니다.\u003c/p\u003e\n\u003ch2\u003eiOS에 특정한 코드를 작성하는 방법은?\u003c/h2\u003e\n\u003cp\u003eiOS 플랫폼별 코드를 정의하거나 사용하는 데는 2가지 주요 옵션이 있습니다:\u003c/p\u003e\n\u003cp\u003e옵션 1.\niosMain 폴더에 구현된 Expect/actual 함수.\n다음은 구조가 어떻게 보이는지 예시입니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_2.png\"\u003e\n\u003cp\u003e옵션 2.\niOS 측에서 호출할 수 있는 몇 가지 커넥터를 제공합니다.\n다음은 commonMain에서 빈 로거를 정의하는 예입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-keyword\"\u003eobject\u003c/span\u003e Bridge {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e logger: (String) -\u003e \u003cspan class=\"hljs-built_in\"\u003eUnit\u003c/span\u003e = {}\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eiOS/Swift 앱에서 로거에 대한 구현을 할당합니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e ...\n\n\u003cspan class=\"hljs-title class_\"\u003eBridge\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eshared\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elogger\u003c/span\u003e = {\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"ios log: \"\u003c/span\u003e + $0)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그냥 간단한 경우일 뿐입니다. 사실 거의 모든 것을 이 방법으로 연결할 수 있습니다. commonMain에서 인터페이스를 정의하고 전체 구현을 별도로 Swift로 작성하는 것도 가능합니다.\u003c/p\u003e\n\u003cp\u003e물론 작성해야 하는 플랫폼별 코드가 많아질수록 더 나쁠 수 있습니다. 제 상황에서는 iosMain에 전체 라이브러리 코드의 약 9%가 있고, androidMain에는 약 13%가 있습니다. 이 비율은 여러분의 상황에서는 낮을 수도 있습니다.\u003c/p\u003e\n\u003ch2\u003e어떻게 마이그레이션을 시작할까요?\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우리는 Android/Kotlin 및 iOS/Swift 클라이언트를 보유하고 있습니다. 통합을 시작하는 방법은 무엇일까요?\u003c/p\u003e\n\u003cp\u003eAndroid의 경우, 기존 앱 또는 라이브러리에 KMP(코틀린 멀티플랫폼)과 호환되는 코드를 단계별로 다시 작성하여 통합할 수 있습니다. 언어는 그대로 유지되지만 의존하는 접근 방식과 라이브러리는 변경될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e간단한 경우에는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e코드베이스에 KMP 모듈을 만듭니다.\u003c/li\u003e\n\u003cli\u003e코드를 공통 모듈(commonMain)로 순차적으로 이동시킵니다.\u003c/li\u003e\n\u003cli\u003e플랫폼에서 이동할 수 없는 부분에 대한 커넥터를 만듭니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우리는 우리의 경우에 iOS와 안드로이드 클라이언트가 의존하는 UI 중심 라이브러리를 마이그레이션하기로 결정했습니다. 그 라이브러리를 완전히 다시 작성해야 했던 이유는 RxJava와 XML 레이아웃을 기반으로 했기 때문이었습니다.\u003c/p\u003e\n\u003ch2\u003e우리의 주요 기술 변화\u003c/h2\u003e\n\u003cp\u003eRxJava → Coroutines / Flow\n만약 Rx를 사용 중이라면 Flow로 마이그레이션하거나 Reaktive와 같은 KMP 대안을 사용해야 합니다.\u003c/p\u003e\n\u003cp\u003eRetrofit → Ktor\nKtor는 매우 편리한 네트워크 라이브러리입니다. 큰 문제는 없었습니다. 여러 번 검색해서 익숙했던 것을 어떻게 쓰는지 찾아보면 됩니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eRoom → Room?\n제 경우에는 일반 디스크 캐싱을 Okio로 대체하는 것이 허용되었습니다. 하지만 사실 Room은 KMP도 지원합니다.\u003c/p\u003e\n\u003cp\u003eGlide → Coil 3 + iOS용 자체 GIF 구현.\nCoil 3는 아직 알파 버전이지만 동작합니다. 제 경우 문제는 iOS에서 GIF를 재생할 수 없었던 것이었습니다. 안타깝게도 몇 일 동안 문제를 해결하고 디스크 캐싱을 통해 해결책을 구현하는 데 시간이 걸렸습니다.\u003c/p\u003e\n\u003cp\u003e제 경우 이미지에 대한 기본 계약:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eComposable\u003c/span\u003e\nexpect fun \u003cspan class=\"hljs-title class_\"\u003eLoadableImage\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003emodifier\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eModifier\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eurl\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eimageColorFilter\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eColorFilter\u003c/span\u003e? = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003esize\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSize\u003c/span\u003e? = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eJetpack ExoPlayer → ExoPlayer + AVPlayer\n우리는 각 플랫폼마다 플레이어를 대체하기 위해 expect/actual을 사용합니다.\nExoPlayer는 디스크 캐싱 및 스트리밍 재생 기능을 갖춘 안드로이드용 강력한 솔루션입니다.\nAvPlayer는 iOS의 기본 솔루션입니다.\u003c/p\u003e\n\u003cp\u003e플레이어의 기본 계약:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eComposable\u003c/span\u003e\nexpect fun \u003cspan class=\"hljs-title class_\"\u003eVideoPlayer\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003emodifier\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eModifier\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eurl\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003evolumeEnabled\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eBoolean\u003c/span\u003e\u003e,\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e안드로이드용 빌드 방법\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e안드로이드의 경우 일반적인 안드로이드 라이브러리와 유사합니다. 이 라이브러리는 애플리케이션의 모듈로 사용할 수 있습니다. 현재는 이것이 우리의 선택입니다.\u003c/p\u003e\n\u003cp\u003e다른 옵션으로 그레이들 복합 빌드를 사용할 수도 있습니다. 자세한 내용은 다음 기사를 참조하세요:\u003c/p\u003e\n\u003cp\u003e마지막으로, 그레이들 작업 bundleReleaseAar을 사용하여 라이브러리를 .aar 파일로 조립할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003eiOS용 빌드 방법\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e로컬 개발 중에는 XCFramework을 빌드하고 iOS 프로젝트에 넣습니다. 프로세스는 여기에 설명되어 있습니다:\u003c/p\u003e\n\u003cp\u003e간단히 말하면 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGradle 작업을 호출합니다.\n로컬 빌드(빠름)의 경우 iosX64Binaries 또는 iosArm64Binaries를 사용하거나 최종 이진 파일의 경우 assembleReleaseXCFramework를 사용합니다(느림).\u003c/li\u003e\n\u003cli\u003ebuild/bin/iosArm64/releaseFramework (또는 유사한 경로)에서 결과물을 iOS 프로젝트로 복사합니다.\u003c/li\u003e\n\u003cli\u003eXcode에 의해 동기화될 때까지 잠시 기다립니다.\u003c/li\u003e\n\u003cli\u003e완료. iOS 프로젝트에서 Kotlin 코드를 사용하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e자동화된 CI/CD 파이프라인에서는 프로세스가 약간 다르지만 이는 다른 이야기입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e나의 경우의 결과\u003c/h2\u003e\n\u003cp\u003e현재 저희 이주 작업은 사전 제작 단계에 있지만, 이미 몇 가지 결론을 도출할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e🟢 기능성.\n저희 라이브러리의 모든 주요 기능이 이주되었습니다.\n일부 비중요한 예외를 제외하고 기능 요구 사항이 충족되었습니다.\u003c/p\u003e\n\u003cp\u003e🟢 코드베이스.\n이와 같이 재작성하는 것은 많은 레거시 코드를 제거할 수 있는 기회입니다.\n숫자:\n이주 이전: 10,000 줄 코드, 1,200 줄 XML\n이후: 4,000 줄 코드\n결과: 기존 버전과 비교했을 때 코드 양이 약 2.5배 감소했습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e🟢 성능.\niOS에서는 iPhone SE에서도 부드럽게 스크롤됩니다.\n저사양 안드로이드 기기에서는 XML 버전과 비교했을 때 그렇게 부드럽지 않지만, 심각한 문제는 아닙니다.\u003c/p\u003e\n\u003cp\u003e🟡 개발 생산성.\n일반적으로, 현대적인 안드로이드 개발과 Jetpack Compose에 익숙하다면 주요 문제가 없을 것입니다. 다만 제 경험상 한 가지 예외가 있습니다: Android Studio 및 IDEA에는 미리보기가 없습니다. Fleet에서는 작동하지만 AS/IDEA에서는 Composable 함수를 블라인드로 작성해야 합니다.\u003c/p\u003e\n\u003cp\u003e🟡 이진 크기.\nAndroid APK: + 0.5 MB\niOS IPA: + 18 MB\u003c/p\u003e\n\u003cp\u003e🟡 라이브러리 크기.\n거대한 XCFrameworks 크기. 300MB 이상입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e🔴 빌드 시간.\niOS의 빌드 시간이 길어요. 기계에 따라 다르지만 라이브러리 4k 줄의 코드를 가지고 17분 같은 숫자를 볼 수 있어요.\u003c/p\u003e\n\u003ch2\u003e결론\u003c/h2\u003e\n\u003cp\u003e2024년에는 Kotlin으로 크로스 플랫폼 UI를 작성하는 것이 전혀 가능합니다.\u003c/p\u003e\n\u003cp\u003eKMP와 Compose Multiplatform의 멋진 점은 Kotlin으로 코드를 작성해야 한다면, 왜 KMP 호환 방식으로 작성하지 않을까요?\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우리의 경우에는 결과가 수용 가능하며, 스트레스 테스트로 간주할 수 있습니다. 또한 iOS용 Compose Multiplatform이 알파 단계에 있고, Kotlin 2가 미래에 있음을 염두에 두어야 합니다.\u003c/p\u003e\n\u003cp\u003e읽어 주셔서 감사합니다!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS"},"buildId":"GsgRekSb--BvxYwv9FPn6","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>