<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>실무에서 활용하는 MAX_BY의 DBSQL 사용 사례 - Gold Layer Views | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-18-RealWorldUseCaseforMAX_BYinDBSQLGoldLayerViews" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="실무에서 활용하는 MAX_BY의 DBSQL 사용 사례 - Gold Layer Views | ui-station" data-gatsby-head="true"/><meta property="og:title" content="실무에서 활용하는 MAX_BY의 DBSQL 사용 사례 - Gold Layer Views | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-18-RealWorldUseCaseforMAX_BYinDBSQLGoldLayerViews_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-18-RealWorldUseCaseforMAX_BYinDBSQLGoldLayerViews" data-gatsby-head="true"/><meta name="twitter:title" content="실무에서 활용하는 MAX_BY의 DBSQL 사용 사례 - Gold Layer Views | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-18-RealWorldUseCaseforMAX_BYinDBSQLGoldLayerViews_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-18 16:29" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-561ae49ab5aab7f5.js" defer=""></script><script src="/_next/static/0asLlD6on3tm8cIfzBaxd/_buildManifest.js" defer=""></script><script src="/_next/static/0asLlD6on3tm8cIfzBaxd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">실무에서 활용하는 MAX_BY의 DBSQL 사용 사례 - Gold Layer Views</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="실무에서 활용하는 MAX_BY의 DBSQL 사용 사례 - Gold Layer Views" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 18, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-18-RealWorldUseCaseforMAX_BYinDBSQLGoldLayerViews&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p>제가 SQL에서 MAX_BY의 가장 좋아하는 사용 사례는 데이터의 골드 레벨 뷰를 열별로 제어하는 것입니다.</p>
<p><img src="/assets/img/2024-05-18-RealWorldUseCaseforMAX_BYinDBSQLGoldLayerViews_0.png" alt="image"/></p>
<h2>작성자:</h2>
<p>Cody Austin Davis</p>
<h2>소개</h2>
<div class="content-ad"></div>
<p>이 글은 MAX_BY/MIN_BY 집계 함수를 사용하는 가장 일반적인 실제 사용 사례 중 하나를 설명하는 짧고 간결한 글입니다. 이 함수는 종종 발견되지 않는다고 생각되며, 주로 사람들이 존재를 모르기 때문에 덜 주목 받습니다. 이 함수는 알려지지 않은 훌륭한 함수일 뿐만 아니라, 한 번 알게 되면 데이터를 효과적으로 사용하는 여러 방법을 보게 될 것입니다. 오늘은 가장 많이 본다고 생각하는 하나를 다룰 것입니다 — 데이터 소스 간에 데이터에 대한 통합된 뷰를 만드는 것입니다.</p>
<h2>어떤 사용 사례인가요?</h2>
<p>기업들은 자주 여러 데이터 소스를 갖습니다. CRM, 앱 데이터, 공개 데이터 소스, 심지어 공급망에서 다양한 고객/이해관계자로부터 받은 데이터도 마찬가지입니다. 이럴 때, 여러 데이터 소스에서 동일한 엔터티를 나타내는 데이터가 실제로 여러 곳에서 들어온다는 것은 흔합니다. 예를 들어, &quot;고객&quot;이라는 엔터티라고 가정해봅시다. 소매 웹사이트를 운영 중이라면, 여러 곳에서 고객 데이터를 얻을 수 있으며, 더 나아가 이러한 데이터 소스 간에 해당 고객에 대한 다양한 데이터 포인트를 얻을 수 있습니다. 주문, 고객 프로필, 반품, 리뷰 등이 있습니다. 분석에서 가장 가치 있는 통찰은 모든 이러한 데이터 소스를 특정 고객에 대한 완전하고 통합된 뷰로 펼치는 경우에만 얻을 수 있습니다. 이때 MAX_BY가 도움이 됩니다!</p>
<p>예제를 살펴보겠습니다. 여러 데이터 소스에서 고객 정보를 받아 &quot;고객&quot; 테이블에 입력하는 시스템을 가정해보겠습니다. 그런 다음 모든 이러한 데이터 소스에서 가져온 모든 고객 레코드를 &quot;통합된 뷰&quot;로 통합하여 각 &quot;마스터 고객&quot;에 대한 가장 최근의 정의를 나타내는 방식입니다.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-05-18-RealWorldUseCaseforMAX_BYinDBSQLGoldLayerViews_1.png" alt="Customer Table Example 1"/></p>
<p>Here is an example output of the customer table, assuming each record is from a separate data source:</p>
<p><img src="/assets/img/2024-05-18-RealWorldUseCaseforMAX_BYinDBSQLGoldLayerViews_2.png" alt="Customer Table Example 2"/></p>
<p>Usually, this requires a sort of fuzzy matching Entity Resolution (blog coming soon on this topic) system for this type of use case, but for the sake of brevity, we will assume that we are already able to “stitch” these disparate records together to identify entities that are the same and link them with a master_customer_id. This can also apply to other scenarios where we just want to create a unified view for an event across entities as well (customers, orders, returns, etc). We will review 3 ways to create the “Unified View”.</p>
<div class="content-ad"></div>
<h2>1 — 가장 최근 고객 레코드 선택하기</h2>
<p>가장 명백한 아이디어입니다. 우리는 그냥 가장 최근 업데이트된 레코드를 &quot;마스터 고객&quot; 레코드로 만들면 됩니다. 이것은 쉽고 이해하기 쉽지만, 모든 데이터 소스의 데이터를 동시에 효과적으로 활용할 수 없다는 단점이 있습니다. 예를 들어, Shipment 데이터 소스에 전화번호가 누락되어 있지만 Order 데이터 소스에는 전화번호가 있지만 Shipment 데이터 소스가 가장 최근 레코드인 경우, 우리의 뷰는 마스터 뷰에서 전화번호를 NULL로 표시할 것입니다. 우리의 그림은 완전하게 보이지 않고 견고하지 않습니다. 이 뷰와 출력의 SQL 예제는 다음과 같습니다:</p>
<pre><code class="hljs language-js">-- 윈도우 함수 및 <span class="hljs-variable constant_">QUALIFY</span>를 사용하여 가장 최근 마스터 id 레코드 선택하기
<span class="hljs-variable constant_">SELECT</span>
*
<span class="hljs-variable constant_">FROM</span> customers
<span class="hljs-variable constant_">QUALIFY</span> <span class="hljs-title function_">ROW_NUMBER</span>() 
  <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> master_customer_id <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> update_timestamp <span class="hljs-variable constant_">DESC</span>) = <span class="hljs-number">1</span>;
</code></pre>
<img src="/assets/img/2024-05-18-RealWorldUseCaseforMAX_BYinDBSQLGoldLayerViews_3.png"/>
<div class="content-ad"></div>
<p>이 방법에는 중요한 제한이 있습니다. 작은 예제에서는 일부 데이터가 누락되었습니다. SSN을 살펴보세요. 다른 데이터 소스에 이 속성이 있지만 가장 최근 레코드가 아닌 경우, 해당 데이터는 사용되지 않을 것입니다. 이 문제를 해결해 보겠습니다.</p>
<h2>2 — “마스터” 엔티티로 그룹화하고 각 열에서 랜덤 레코드 선택하기</h2>
<p>이것은 가장 일반적으로 볼 수 있는 구현 방법입니다. 일부 사용 사례에 적합하며, 단일 출력 레코드를 위해 모든 고객 데이터 소스에서 데이터를 활용할 수 있습니다. 따라서 1개의 데이터 소스에서 속성이 누락되었지만 다른 데이터 소스에 해당 속성이 있는 경우(예: Shipment 데이터 소스에 전화 번호가 누락되어 있지만 주문 데이터 소스에 전화 번호가 있는 경우), 데이터 소스 간에 공란을 채워 더 완전한 그림을 얻을 수 있습니다. 하지만 이는 각 열에 대해 가장 최근 레코드 업데이트를 선택하는 것은 아니므로 아주 강력한 구현은 아닙니다. 단지 각 열의 non-null 값을 선택하기 위해 MAX/MIN과 같은 단순한 집계 함수를 사용하는 것뿐입니다. 이 구현은 다음과 같습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span>
  master_customer_id,
  <span class="hljs-title function_">MAX</span>(customer_name) <span class="hljs-variable constant_">AS</span> customer_name,
  <span class="hljs-title function_">MAX</span>(state) <span class="hljs-variable constant_">AS</span> state,
  <span class="hljs-title function_">MAX</span>(city) <span class="hljs-variable constant_">AS</span> city,
  <span class="hljs-title function_">MAX</span>(postcode) <span class="hljs-variable constant_">AS</span> postcode,
  <span class="hljs-title function_">MAX</span>(street) <span class="hljs-variable constant_">AS</span> street,
  <span class="hljs-title function_">MAX</span>(<span class="hljs-string">`number`</span>) <span class="hljs-variable constant_">AS</span> number,
  <span class="hljs-title function_">MAX</span>(ship_to_address) <span class="hljs-variable constant_">AS</span> ship_to_address,
  <span class="hljs-title function_">MAX</span>(ssn) <span class="hljs-variable constant_">AS</span> ssn,
  <span class="hljs-title function_">MAX</span>(phone_number) <span class="hljs-variable constant_">AS</span> phone_number
<span class="hljs-variable constant_">FROM</span> raw_customers
<span class="hljs-variable constant_">GROUP</span> <span class="hljs-variable constant_">BY</span> master_customer_id;
</code></pre>
<div class="content-ad"></div>
<p>이렇게 하시면 좋습니다! 보다 복잡한 데이터 세트를 갖게 되었지만, 여전히 한 가지 문제가 남아 있습니다: 알파벳 순서 외에는 이 쿼리가 어떤 레코드를 선택하는지에 대한 제어권이 없습니다. 고객에 대한 통합된 뷰는 낡았거나 관련성이 낮은 데이터를 포함할 수 있습니다.</p>
<p>3 — MAX_BY를 사용하여 제어 및 목적으로 선택된 레코드를 정의</p>
<p>이것은 의도적으로 고객(또는 다른 레코드)에 대한 뷰를 만드는 가장 좋은 방법입니다. 우리는 각 열에 대해 가장 최근의 NOT NULL 레코드를 선택하기 위해 MAX_BY 함수와 선택적인 FILTER 절을 사용할 것입니다. 이 방법으로, 뷰는 데이터 소스와 상관없이 각 열별로 가장 최근의 NOT NULL 레코드를 선택하여 사용할 수 있게 됩니다. 그 방법은 다음과 같습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">-- <span class="hljs-string">&quot;final&quot;</span> 정리된 마스터 뷰에 나쁜 데이터가 들어가지 않도록 필터링 규칙 추가
<span class="hljs-variable constant_">SELECT</span>
  master_customer_id,
  <span class="hljs-title function_">MAX_BY</span>(customer_name, update_timestamp) <span class="hljs-variable constant_">FILTER</span> (<span class="hljs-variable constant_">WHERE</span> customer_name <span class="hljs-variable constant_">IS</span> <span class="hljs-variable constant_">NOT</span> <span class="hljs-variable constant_">NULL</span>) <span class="hljs-variable constant_">AS</span> customer_name,
  <span class="hljs-title function_">MAX_BY</span>(state, update_timestamp) <span class="hljs-variable constant_">FILTER</span> (<span class="hljs-variable constant_">WHERE</span> state <span class="hljs-variable constant_">IS</span> <span class="hljs-variable constant_">NOT</span> <span class="hljs-variable constant_">NULL</span>) <span class="hljs-variable constant_">AS</span> state,
  <span class="hljs-title function_">MAX_BY</span>(city, update_timestamp) <span class="hljs-variable constant_">FILTER</span> (<span class="hljs-variable constant_">WHERE</span> city <span class="hljs-variable constant_">IS</span> <span class="hljs-variable constant_">NOT</span> <span class="hljs-variable constant_">NULL</span>) <span class="hljs-variable constant_">AS</span> city,
  <span class="hljs-title function_">MAX_BY</span>(postcode, update_timestamp) <span class="hljs-variable constant_">FILTER</span> (<span class="hljs-variable constant_">WHERE</span> postcode <span class="hljs-variable constant_">IS</span> <span class="hljs-variable constant_">NOT</span> <span class="hljs-variable constant_">NULL</span>) <span class="hljs-variable constant_">AS</span> postcode,
  <span class="hljs-title function_">MAX_BY</span>(street, update_timestamp) <span class="hljs-variable constant_">FILTER</span> (<span class="hljs-variable constant_">WHERE</span> street <span class="hljs-variable constant_">IS</span> <span class="hljs-variable constant_">NOT</span> <span class="hljs-variable constant_">NULL</span>) <span class="hljs-variable constant_">AS</span> street,
  <span class="hljs-title function_">MAX_BY</span>(<span class="hljs-string">`number`</span>, update_timestamp) <span class="hljs-variable constant_">FILTER</span> (<span class="hljs-variable constant_">WHERE</span> <span class="hljs-string">`number`</span> <span class="hljs-variable constant_">IS</span> <span class="hljs-variable constant_">NOT</span> <span class="hljs-variable constant_">NULL</span>) <span class="hljs-variable constant_">AS</span> number,
  <span class="hljs-title function_">MAX_BY</span>(ship_to_address, update_timestamp) <span class="hljs-variable constant_">FILTER</span> (<span class="hljs-variable constant_">WHERE</span> ship_to_address <span class="hljs-variable constant_">IS</span> <span class="hljs-variable constant_">NOT</span> <span class="hljs-variable constant_">NULL</span>) <span class="hljs-variable constant_">AS</span> ship_to_address,
  
-- 예시의 형식을 확인함
  <span class="hljs-title function_">MAX_BY</span>(ssn, update_timestamp) 
      <span class="hljs-variable constant_">FILTER</span> (<span class="hljs-variable constant_">WHERE</span> ssn <span class="hljs-variable constant_">IS</span> <span class="hljs-variable constant_">NOT</span> <span class="hljs-variable constant_">NULL</span> 
              <span class="hljs-variable constant_">AND</span> <span class="hljs-title function_">length</span>(<span class="hljs-title function_">regexp_replace</span>(ssn, <span class="hljs-string">&#x27;\\D&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)) = <span class="hljs-number">9</span> ) <span class="hljs-variable constant_">AS</span> ssn,
  <span class="hljs-title function_">MAX_BY</span>(phone_number, update_timestamp) 
      <span class="hljs-variable constant_">FILTER</span> (<span class="hljs-variable constant_">WHERE</span> phone_number <span class="hljs-variable constant_">IS</span> <span class="hljs-variable constant_">NOT</span> <span class="hljs-variable constant_">NULL</span> 
                <span class="hljs-variable constant_">AND</span> <span class="hljs-title function_">length</span>(<span class="hljs-title function_">regexp_replace</span>(phone_number, <span class="hljs-string">&#x27;\\D&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)) = <span class="hljs-number">10</span>) <span class="hljs-variable constant_">AS</span> phone_number
<span class="hljs-variable constant_">FROM</span> raw_customers
<span class="hljs-variable constant_">GROUP</span> <span class="hljs-variable constant_">BY</span> master_customer_id;
</code></pre>
<p>이 코드는 더 견고하며 각 열의 가장 최근 레코드 값을 가져올 뿐만 아니라 선택된 레코드의 품질을 제어하기 위해 선택적인 FILTER 절을 추가할 수 있게 해줍니다. 위 예시에서는 각 열의 가장 최근 레코드를 선택합니다. 또한, 더 중요한 열에 대해 레코드를 선택하기 전에 품질을 확인하는 더 많은 규칙을 추가할 수 있습니다. 위 예시에서는 null이 아닌 가장 최근의 전화번호와 소셜 넘버를 선택합니다. 그리고 이는 데이터 자체의 컨텍스트에 따라 유효한 값을 가지는 레코드만 선택합니다. 이것은 Entity의 단일 뷰를 만드는 가장 견고한 방법입니다.</p>
<p>여기까지입니다! MAX_BY는 흔히 보기 어렵지만, 아마도 이것이 데이터 모델을 효과적이고 창의적으로 구축하는 데 도움이 될 것입니다.</p>
<p>노트북 예시의 전체 코드는 여기서 확인하실 수 있습니다.```</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"실무에서 활용하는 MAX_BY의 DBSQL 사용 사례 - Gold Layer Views","description":"","date":"2024-05-18 16:29","slug":"2024-05-18-RealWorldUseCaseforMAX_BYinDBSQLGoldLayerViews","content":"\n\n제가 SQL에서 MAX_BY의 가장 좋아하는 사용 사례는 데이터의 골드 레벨 뷰를 열별로 제어하는 것입니다.\n\n![image](/assets/img/2024-05-18-RealWorldUseCaseforMAX_BYinDBSQLGoldLayerViews_0.png)\n\n## 작성자:\nCody Austin Davis\n\n## 소개\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글은 MAX_BY/MIN_BY 집계 함수를 사용하는 가장 일반적인 실제 사용 사례 중 하나를 설명하는 짧고 간결한 글입니다. 이 함수는 종종 발견되지 않는다고 생각되며, 주로 사람들이 존재를 모르기 때문에 덜 주목 받습니다. 이 함수는 알려지지 않은 훌륭한 함수일 뿐만 아니라, 한 번 알게 되면 데이터를 효과적으로 사용하는 여러 방법을 보게 될 것입니다. 오늘은 가장 많이 본다고 생각하는 하나를 다룰 것입니다 — 데이터 소스 간에 데이터에 대한 통합된 뷰를 만드는 것입니다.\n\n## 어떤 사용 사례인가요?\n\n기업들은 자주 여러 데이터 소스를 갖습니다. CRM, 앱 데이터, 공개 데이터 소스, 심지어 공급망에서 다양한 고객/이해관계자로부터 받은 데이터도 마찬가지입니다. 이럴 때, 여러 데이터 소스에서 동일한 엔터티를 나타내는 데이터가 실제로 여러 곳에서 들어온다는 것은 흔합니다. 예를 들어, \"고객\"이라는 엔터티라고 가정해봅시다. 소매 웹사이트를 운영 중이라면, 여러 곳에서 고객 데이터를 얻을 수 있으며, 더 나아가 이러한 데이터 소스 간에 해당 고객에 대한 다양한 데이터 포인트를 얻을 수 있습니다. 주문, 고객 프로필, 반품, 리뷰 등이 있습니다. 분석에서 가장 가치 있는 통찰은 모든 이러한 데이터 소스를 특정 고객에 대한 완전하고 통합된 뷰로 펼치는 경우에만 얻을 수 있습니다. 이때 MAX_BY가 도움이 됩니다!\n\n예제를 살펴보겠습니다. 여러 데이터 소스에서 고객 정보를 받아 \"고객\" 테이블에 입력하는 시스템을 가정해보겠습니다. 그런 다음 모든 이러한 데이터 소스에서 가져온 모든 고객 레코드를 \"통합된 뷰\"로 통합하여 각 \"마스터 고객\"에 대한 가장 최근의 정의를 나타내는 방식입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Customer Table Example 1](/assets/img/2024-05-18-RealWorldUseCaseforMAX_BYinDBSQLGoldLayerViews_1.png)\n\nHere is an example output of the customer table, assuming each record is from a separate data source:\n\n![Customer Table Example 2](/assets/img/2024-05-18-RealWorldUseCaseforMAX_BYinDBSQLGoldLayerViews_2.png)\n\nUsually, this requires a sort of fuzzy matching Entity Resolution (blog coming soon on this topic) system for this type of use case, but for the sake of brevity, we will assume that we are already able to “stitch” these disparate records together to identify entities that are the same and link them with a master_customer_id. This can also apply to other scenarios where we just want to create a unified view for an event across entities as well (customers, orders, returns, etc). We will review 3 ways to create the “Unified View”.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 1 — 가장 최근 고객 레코드 선택하기\n\n가장 명백한 아이디어입니다. 우리는 그냥 가장 최근 업데이트된 레코드를 \"마스터 고객\" 레코드로 만들면 됩니다. 이것은 쉽고 이해하기 쉽지만, 모든 데이터 소스의 데이터를 동시에 효과적으로 활용할 수 없다는 단점이 있습니다. 예를 들어, Shipment 데이터 소스에 전화번호가 누락되어 있지만 Order 데이터 소스에는 전화번호가 있지만 Shipment 데이터 소스가 가장 최근 레코드인 경우, 우리의 뷰는 마스터 뷰에서 전화번호를 NULL로 표시할 것입니다. 우리의 그림은 완전하게 보이지 않고 견고하지 않습니다. 이 뷰와 출력의 SQL 예제는 다음과 같습니다:\n\n```js\n-- 윈도우 함수 및 QUALIFY를 사용하여 가장 최근 마스터 id 레코드 선택하기\nSELECT\n*\nFROM customers\nQUALIFY ROW_NUMBER() \n  OVER (PARTITION BY master_customer_id ORDER BY update_timestamp DESC) = 1;\n```\n\n\u003cimg src=\"/assets/img/2024-05-18-RealWorldUseCaseforMAX_BYinDBSQLGoldLayerViews_3.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법에는 중요한 제한이 있습니다. 작은 예제에서는 일부 데이터가 누락되었습니다. SSN을 살펴보세요. 다른 데이터 소스에 이 속성이 있지만 가장 최근 레코드가 아닌 경우, 해당 데이터는 사용되지 않을 것입니다. 이 문제를 해결해 보겠습니다.\n\n## 2 — “마스터” 엔티티로 그룹화하고 각 열에서 랜덤 레코드 선택하기\n\n이것은 가장 일반적으로 볼 수 있는 구현 방법입니다. 일부 사용 사례에 적합하며, 단일 출력 레코드를 위해 모든 고객 데이터 소스에서 데이터를 활용할 수 있습니다. 따라서 1개의 데이터 소스에서 속성이 누락되었지만 다른 데이터 소스에 해당 속성이 있는 경우(예: Shipment 데이터 소스에 전화 번호가 누락되어 있지만 주문 데이터 소스에 전화 번호가 있는 경우), 데이터 소스 간에 공란을 채워 더 완전한 그림을 얻을 수 있습니다. 하지만 이는 각 열에 대해 가장 최근 레코드 업데이트를 선택하는 것은 아니므로 아주 강력한 구현은 아닙니다. 단지 각 열의 non-null 값을 선택하기 위해 MAX/MIN과 같은 단순한 집계 함수를 사용하는 것뿐입니다. 이 구현은 다음과 같습니다:\n\n```js\nSELECT\n  master_customer_id,\n  MAX(customer_name) AS customer_name,\n  MAX(state) AS state,\n  MAX(city) AS city,\n  MAX(postcode) AS postcode,\n  MAX(street) AS street,\n  MAX(`number`) AS number,\n  MAX(ship_to_address) AS ship_to_address,\n  MAX(ssn) AS ssn,\n  MAX(phone_number) AS phone_number\nFROM raw_customers\nGROUP BY master_customer_id;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 하시면 좋습니다! 보다 복잡한 데이터 세트를 갖게 되었지만, 여전히 한 가지 문제가 남아 있습니다: 알파벳 순서 외에는 이 쿼리가 어떤 레코드를 선택하는지에 대한 제어권이 없습니다. 고객에 대한 통합된 뷰는 낡았거나 관련성이 낮은 데이터를 포함할 수 있습니다.\n\n3 — MAX_BY를 사용하여 제어 및 목적으로 선택된 레코드를 정의\n\n이것은 의도적으로 고객(또는 다른 레코드)에 대한 뷰를 만드는 가장 좋은 방법입니다. 우리는 각 열에 대해 가장 최근의 NOT NULL 레코드를 선택하기 위해 MAX_BY 함수와 선택적인 FILTER 절을 사용할 것입니다. 이 방법으로, 뷰는 데이터 소스와 상관없이 각 열별로 가장 최근의 NOT NULL 레코드를 선택하여 사용할 수 있게 됩니다. 그 방법은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n-- \"final\" 정리된 마스터 뷰에 나쁜 데이터가 들어가지 않도록 필터링 규칙 추가\nSELECT\n  master_customer_id,\n  MAX_BY(customer_name, update_timestamp) FILTER (WHERE customer_name IS NOT NULL) AS customer_name,\n  MAX_BY(state, update_timestamp) FILTER (WHERE state IS NOT NULL) AS state,\n  MAX_BY(city, update_timestamp) FILTER (WHERE city IS NOT NULL) AS city,\n  MAX_BY(postcode, update_timestamp) FILTER (WHERE postcode IS NOT NULL) AS postcode,\n  MAX_BY(street, update_timestamp) FILTER (WHERE street IS NOT NULL) AS street,\n  MAX_BY(`number`, update_timestamp) FILTER (WHERE `number` IS NOT NULL) AS number,\n  MAX_BY(ship_to_address, update_timestamp) FILTER (WHERE ship_to_address IS NOT NULL) AS ship_to_address,\n  \n-- 예시의 형식을 확인함\n  MAX_BY(ssn, update_timestamp) \n      FILTER (WHERE ssn IS NOT NULL \n              AND length(regexp_replace(ssn, '\\\\D','')) = 9 ) AS ssn,\n  MAX_BY(phone_number, update_timestamp) \n      FILTER (WHERE phone_number IS NOT NULL \n                AND length(regexp_replace(phone_number, '\\\\D','')) = 10) AS phone_number\nFROM raw_customers\nGROUP BY master_customer_id;\n```\n\n이 코드는 더 견고하며 각 열의 가장 최근 레코드 값을 가져올 뿐만 아니라 선택된 레코드의 품질을 제어하기 위해 선택적인 FILTER 절을 추가할 수 있게 해줍니다. 위 예시에서는 각 열의 가장 최근 레코드를 선택합니다. 또한, 더 중요한 열에 대해 레코드를 선택하기 전에 품질을 확인하는 더 많은 규칙을 추가할 수 있습니다. 위 예시에서는 null이 아닌 가장 최근의 전화번호와 소셜 넘버를 선택합니다. 그리고 이는 데이터 자체의 컨텍스트에 따라 유효한 값을 가지는 레코드만 선택합니다. 이것은 Entity의 단일 뷰를 만드는 가장 견고한 방법입니다.\n\n여기까지입니다! MAX_BY는 흔히 보기 어렵지만, 아마도 이것이 데이터 모델을 효과적이고 창의적으로 구축하는 데 도움이 될 것입니다.\n\n노트북 예시의 전체 코드는 여기서 확인하실 수 있습니다.```","ogImage":{"url":"/assets/img/2024-05-18-RealWorldUseCaseforMAX_BYinDBSQLGoldLayerViews_0.png"},"coverImage":"/assets/img/2024-05-18-RealWorldUseCaseforMAX_BYinDBSQLGoldLayerViews_0.png","tag":["Tech"],"readingTime":6},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"제가 SQL에서 MAX_BY의 가장 좋아하는 사용 사례는 데이터의 골드 레벨 뷰를 열별로 제어하는 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-RealWorldUseCaseforMAX_BYinDBSQLGoldLayerViews_0.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"작성자:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Cody Austin Davis\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"소개\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 글은 MAX_BY/MIN_BY 집계 함수를 사용하는 가장 일반적인 실제 사용 사례 중 하나를 설명하는 짧고 간결한 글입니다. 이 함수는 종종 발견되지 않는다고 생각되며, 주로 사람들이 존재를 모르기 때문에 덜 주목 받습니다. 이 함수는 알려지지 않은 훌륭한 함수일 뿐만 아니라, 한 번 알게 되면 데이터를 효과적으로 사용하는 여러 방법을 보게 될 것입니다. 오늘은 가장 많이 본다고 생각하는 하나를 다룰 것입니다 — 데이터 소스 간에 데이터에 대한 통합된 뷰를 만드는 것입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"어떤 사용 사례인가요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"기업들은 자주 여러 데이터 소스를 갖습니다. CRM, 앱 데이터, 공개 데이터 소스, 심지어 공급망에서 다양한 고객/이해관계자로부터 받은 데이터도 마찬가지입니다. 이럴 때, 여러 데이터 소스에서 동일한 엔터티를 나타내는 데이터가 실제로 여러 곳에서 들어온다는 것은 흔합니다. 예를 들어, \\\"고객\\\"이라는 엔터티라고 가정해봅시다. 소매 웹사이트를 운영 중이라면, 여러 곳에서 고객 데이터를 얻을 수 있으며, 더 나아가 이러한 데이터 소스 간에 해당 고객에 대한 다양한 데이터 포인트를 얻을 수 있습니다. 주문, 고객 프로필, 반품, 리뷰 등이 있습니다. 분석에서 가장 가치 있는 통찰은 모든 이러한 데이터 소스를 특정 고객에 대한 완전하고 통합된 뷰로 펼치는 경우에만 얻을 수 있습니다. 이때 MAX_BY가 도움이 됩니다!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예제를 살펴보겠습니다. 여러 데이터 소스에서 고객 정보를 받아 \\\"고객\\\" 테이블에 입력하는 시스템을 가정해보겠습니다. 그런 다음 모든 이러한 데이터 소스에서 가져온 모든 고객 레코드를 \\\"통합된 뷰\\\"로 통합하여 각 \\\"마스터 고객\\\"에 대한 가장 최근의 정의를 나타내는 방식입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-RealWorldUseCaseforMAX_BYinDBSQLGoldLayerViews_1.png\",\n        alt: \"Customer Table Example 1\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here is an example output of the customer table, assuming each record is from a separate data source:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-RealWorldUseCaseforMAX_BYinDBSQLGoldLayerViews_2.png\",\n        alt: \"Customer Table Example 2\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Usually, this requires a sort of fuzzy matching Entity Resolution (blog coming soon on this topic) system for this type of use case, but for the sake of brevity, we will assume that we are already able to “stitch” these disparate records together to identify entities that are the same and link them with a master_customer_id. This can also apply to other scenarios where we just want to create a unified view for an event across entities as well (customers, orders, returns, etc). We will review 3 ways to create the “Unified View”.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"1 — 가장 최근 고객 레코드 선택하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"가장 명백한 아이디어입니다. 우리는 그냥 가장 최근 업데이트된 레코드를 \\\"마스터 고객\\\" 레코드로 만들면 됩니다. 이것은 쉽고 이해하기 쉽지만, 모든 데이터 소스의 데이터를 동시에 효과적으로 활용할 수 없다는 단점이 있습니다. 예를 들어, Shipment 데이터 소스에 전화번호가 누락되어 있지만 Order 데이터 소스에는 전화번호가 있지만 Shipment 데이터 소스가 가장 최근 레코드인 경우, 우리의 뷰는 마스터 뷰에서 전화번호를 NULL로 표시할 것입니다. 우리의 그림은 완전하게 보이지 않고 견고하지 않습니다. 이 뷰와 출력의 SQL 예제는 다음과 같습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"-- 윈도우 함수 및 \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"QUALIFY\"\n        }), \"를 사용하여 가장 최근 마스터 id 레코드 선택하기\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"SELECT\"\n        }), \"\\n*\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FROM\"\n        }), \" customers\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"QUALIFY\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"ROW_NUMBER\"\n        }), \"() \\n  \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"OVER\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"PARTITION\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BY\"\n        }), \" master_customer_id \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ORDER\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BY\"\n        }), \" update_timestamp \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"DESC\"\n        }), \") = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-18-RealWorldUseCaseforMAX_BYinDBSQLGoldLayerViews_3.png\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 방법에는 중요한 제한이 있습니다. 작은 예제에서는 일부 데이터가 누락되었습니다. SSN을 살펴보세요. 다른 데이터 소스에 이 속성이 있지만 가장 최근 레코드가 아닌 경우, 해당 데이터는 사용되지 않을 것입니다. 이 문제를 해결해 보겠습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2 — “마스터” 엔티티로 그룹화하고 각 열에서 랜덤 레코드 선택하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것은 가장 일반적으로 볼 수 있는 구현 방법입니다. 일부 사용 사례에 적합하며, 단일 출력 레코드를 위해 모든 고객 데이터 소스에서 데이터를 활용할 수 있습니다. 따라서 1개의 데이터 소스에서 속성이 누락되었지만 다른 데이터 소스에 해당 속성이 있는 경우(예: Shipment 데이터 소스에 전화 번호가 누락되어 있지만 주문 데이터 소스에 전화 번호가 있는 경우), 데이터 소스 간에 공란을 채워 더 완전한 그림을 얻을 수 있습니다. 하지만 이는 각 열에 대해 가장 최근 레코드 업데이트를 선택하는 것은 아니므로 아주 강력한 구현은 아닙니다. 단지 각 열의 non-null 값을 선택하기 위해 MAX/MIN과 같은 단순한 집계 함수를 사용하는 것뿐입니다. 이 구현은 다음과 같습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"SELECT\"\n        }), \"\\n  master_customer_id,\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MAX\"\n        }), \"(customer_name) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" customer_name,\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MAX\"\n        }), \"(state) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" state,\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MAX\"\n        }), \"(city) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" city,\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MAX\"\n        }), \"(postcode) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" postcode,\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MAX\"\n        }), \"(street) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" street,\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MAX\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"`number`\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" number,\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MAX\"\n        }), \"(ship_to_address) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" ship_to_address,\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MAX\"\n        }), \"(ssn) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" ssn,\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MAX\"\n        }), \"(phone_number) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" phone_number\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FROM\"\n        }), \" raw_customers\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"GROUP\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BY\"\n        }), \" master_customer_id;\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이렇게 하시면 좋습니다! 보다 복잡한 데이터 세트를 갖게 되었지만, 여전히 한 가지 문제가 남아 있습니다: 알파벳 순서 외에는 이 쿼리가 어떤 레코드를 선택하는지에 대한 제어권이 없습니다. 고객에 대한 통합된 뷰는 낡았거나 관련성이 낮은 데이터를 포함할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"3 — MAX_BY를 사용하여 제어 및 목적으로 선택된 레코드를 정의\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것은 의도적으로 고객(또는 다른 레코드)에 대한 뷰를 만드는 가장 좋은 방법입니다. 우리는 각 열에 대해 가장 최근의 NOT NULL 레코드를 선택하기 위해 MAX_BY 함수와 선택적인 FILTER 절을 사용할 것입니다. 이 방법으로, 뷰는 데이터 소스와 상관없이 각 열별로 가장 최근의 NOT NULL 레코드를 선택하여 사용할 수 있게 됩니다. 그 방법은 다음과 같습니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"-- \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"final\\\"\"\n        }), \" 정리된 마스터 뷰에 나쁜 데이터가 들어가지 않도록 필터링 규칙 추가\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"SELECT\"\n        }), \"\\n  master_customer_id,\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MAX_BY\"\n        }), \"(customer_name, update_timestamp) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FILTER\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"WHERE\"\n        }), \" customer_name \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"IS\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"NOT\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"NULL\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" customer_name,\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MAX_BY\"\n        }), \"(state, update_timestamp) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FILTER\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"WHERE\"\n        }), \" state \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"IS\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"NOT\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"NULL\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" state,\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MAX_BY\"\n        }), \"(city, update_timestamp) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FILTER\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"WHERE\"\n        }), \" city \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"IS\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"NOT\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"NULL\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" city,\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MAX_BY\"\n        }), \"(postcode, update_timestamp) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FILTER\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"WHERE\"\n        }), \" postcode \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"IS\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"NOT\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"NULL\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" postcode,\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MAX_BY\"\n        }), \"(street, update_timestamp) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FILTER\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"WHERE\"\n        }), \" street \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"IS\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"NOT\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"NULL\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" street,\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MAX_BY\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"`number`\"\n        }), \", update_timestamp) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FILTER\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"WHERE\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"`number`\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"IS\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"NOT\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"NULL\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" number,\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MAX_BY\"\n        }), \"(ship_to_address, update_timestamp) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FILTER\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"WHERE\"\n        }), \" ship_to_address \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"IS\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"NOT\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"NULL\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" ship_to_address,\\n  \\n-- 예시의 형식을 확인함\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MAX_BY\"\n        }), \"(ssn, update_timestamp) \\n      \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FILTER\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"WHERE\"\n        }), \" ssn \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"IS\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"NOT\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"NULL\"\n        }), \" \\n              \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AND\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"length\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"regexp_replace\"\n        }), \"(ssn, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'\\\\\\\\D'\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"''\"\n        }), \")) = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"9\"\n        }), \" ) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" ssn,\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MAX_BY\"\n        }), \"(phone_number, update_timestamp) \\n      \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FILTER\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"WHERE\"\n        }), \" phone_number \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"IS\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"NOT\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"NULL\"\n        }), \" \\n                \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AND\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"length\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"regexp_replace\"\n        }), \"(phone_number, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'\\\\\\\\D'\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"''\"\n        }), \")) = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" phone_number\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FROM\"\n        }), \" raw_customers\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"GROUP\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BY\"\n        }), \" master_customer_id;\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 코드는 더 견고하며 각 열의 가장 최근 레코드 값을 가져올 뿐만 아니라 선택된 레코드의 품질을 제어하기 위해 선택적인 FILTER 절을 추가할 수 있게 해줍니다. 위 예시에서는 각 열의 가장 최근 레코드를 선택합니다. 또한, 더 중요한 열에 대해 레코드를 선택하기 전에 품질을 확인하는 더 많은 규칙을 추가할 수 있습니다. 위 예시에서는 null이 아닌 가장 최근의 전화번호와 소셜 넘버를 선택합니다. 그리고 이는 데이터 자체의 컨텍스트에 따라 유효한 값을 가지는 레코드만 선택합니다. 이것은 Entity의 단일 뷰를 만드는 가장 견고한 방법입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기까지입니다! MAX_BY는 흔히 보기 어렵지만, 아마도 이것이 데이터 모델을 효과적이고 창의적으로 구축하는 데 도움이 될 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"노트북 예시의 전체 코드는 여기서 확인하실 수 있습니다.```\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-18-RealWorldUseCaseforMAX_BYinDBSQLGoldLayerViews"},"buildId":"0asLlD6on3tm8cIfzBaxd","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>