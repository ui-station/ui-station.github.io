<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Angular 17의 컴포넌트 스타일 정리 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-07-01-MythicalAngularComponentstylescleanupinAngular17" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Angular 17의 컴포넌트 스타일 정리 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Angular 17의 컴포넌트 스타일 정리 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-07-01-MythicalAngularComponentstylescleanupinAngular17" data-gatsby-head="true"/><meta name="twitter:title" content="Angular 17의 컴포넌트 스타일 정리 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-01 16:20" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_buildManifest.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Angular 17의 컴포넌트 스타일 정리 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Angular 17의 컴포넌트 스타일 정리 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 1, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-01-MythicalAngularComponentstylescleanupinAngular17&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>안녕하세요!</p>
<p>최신 릴리스 노트에 언급되지 않은 흥미로운 동작을 발견했습니다. 이 기사에서는 이것이 무엇인지 보여드리고, 왜 그것이 꽤 흥미로운 변화라고 생각하는지 알려드리겠습니다.</p>
<h1>스타일 정리 문제</h1>
<p>Angular가 동적으로 생성된 구성 요소를 제거한 후에도 스타일을 제거하지 않는 문제를 발견했습니다. 즉, 동적 구성 요소를 생성하면 (심지어 DOM에 연결할 필요도 없이), Angular가 스타일을 추가한 후 구성 요소가 제거될 때 스타일을 제거하지 않는다는 것이죠.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>검사하고 테스트하는 것은 매우 쉽습니다.</p>
<h1>테스트</h1>
<p>항상 모든 코드는 내 GitHub에서 제공됩니다. experiment-styles-cleanup 저장소를 찾아보세요.</p>
<p>저는 응용 프로그램에 스타일을 추가하는 것 외에 아무 것도 하지 않는 간단한 구성 요소로 테스트를 시작합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> {<span class="hljs-title class_">Component</span>, <span class="hljs-title class_">ViewEncapsulation</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

@<span class="hljs-title class_">Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-dynamic'</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">''</span>,
  <span class="hljs-attr">encapsulation</span>: <span class="hljs-title class_">ViewEncapsulation</span>.<span class="hljs-property">None</span>,
  <span class="hljs-attr">styles</span>: [<span class="hljs-string">`
    .test {
      background: red;
      color: white;
      border: 4px dashed black;
      font-weight: bold;
    }
  `</span>]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicComponent</span> {
}
</code></pre>
<p>여기서 볼 수 있듯이, 꽤 간단합니다. 템플릿도 로직도 없고, 스타일만 있습니다. 중요한 점은 ViewEncapsulation.None으로 캡슐화를 설정했기 때문에 이 스타일을 컴포넌트 외부에 적용할 수 있다는 것입니다.</p>
<p>다음으로, 루트 AppComponent를 수정해보겠습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> {<span class="hljs-title class_">Component</span>, <span class="hljs-title class_">ComponentFactoryResolver</span>, inject, <span class="hljs-title class_">Injector</span>, <span class="hljs-title class_">OnDestroy</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> {<span class="hljs-title class_">DynamicComponent</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">"./dynamic.component"</span>;

@<span class="hljs-title class_">Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-root'</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &#x3C;div class="test">
      이 상자가 빨간색일 때 스타일이 적용됩니다
    &#x3C;/div>

    &#x3C;button (click)="createComponent()">눌러보세요!&#x3C;/button>
  `</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppComponent</span> {
  private readonly componentFactoryResolver = <span class="hljs-title function_">inject</span>(<span class="hljs-title class_">ComponentFactoryResolver</span>);
  private readonly injector = <span class="hljs-title function_">inject</span>(<span class="hljs-title class_">Injector</span>);

  <span class="hljs-title function_">createComponent</span>(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">const</span> factory = <span class="hljs-variable language_">this</span>.<span class="hljs-property">componentFactoryResolver</span>.<span class="hljs-title function_">resolveComponentFactory</span>(<span class="hljs-title class_">DynamicComponent</span>);
    <span class="hljs-keyword">const</span> componentRef = factory.<span class="hljs-title function_">create</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">injector</span>);

    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> componentRef.<span class="hljs-title function_">destroy</span>(), <span class="hljs-number">5000</span>);
  }
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>AppComponent에서 두 가지가 있습니다.</p>
<p>첫 번째는 test 클래스가 있는 div입니다. Angular이 DynamicComponent에서 스타일을 추가할 때 스타일이 적용됩니다. 그래서 캡슐화를 ViewEncapsulation.None으로 설정했습니다.</p>
<p>두 번째로는 버튼이 있습니다. 클릭하면 ComponentFactoryResolver를 사용하여 동적으로 DynamicComponent를 생성한 후 5초 후에 제거합니다. setTimeout에 메모리 누수가 있음을 알고 있지만 이것은 테스트일 뿐이니 괜찮아요?</p>
<p>전체 테스트는 간단합니다. 버튼을 클릭하면 div에 스타일이 적용되어야 합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_0.png" alt="한국어"></p>
<p>5초간 기다리고, 두 가지 가능한 종료가 있습니다:</p>
<ul>
<li>div에 스타일이 있는 경우 - 해당 컴포넌트의 스타일이 제거되지 않았음을 의미합니다</li>
<li>div에 스타일이 없는 경우 - Angular가 컴포넌트 제거 후 정리를 수행 중임을 의미합니다</li>
</ul>
<h1>Angular 15 &#x26; 16</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아마도 예상했겠지만, Angular 15와 16에서는 컴포넌트와 함께 스타일이 제거되지 않습니다. experiment-styles-cleanup 저장소의 코드를 사용하여 직접 해볼 수 있어요. 주요 브랜치와 v16 브랜치를 사용해 보세요.</p>
<p><img src="/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_1.png" alt="이미지"></p>
<p>참고: 시간이 부족하다면 권장합니다. GitHub Pages를 통해 배포한 코드를 확인할 수 있어요. 다음은 링크입니다:</p>
<ul>
<li><a href="galczo5.github.io/experiment-styles-cleanup/v15">v15 링크</a></li>
<li><a href="galczo5.github.io/experiment-styles-cleanup/v16">v16 링크</a></li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>앵귤러 17</h1>
<p>앵귤러 17로 업그레이드한 후에 동작이 변경되었습니다. 이제 스타일은 컴포넌트와 함께 제거됩니다.</p>
<p>내 저장소의 v17 브랜치를 확인하거나 galczo5.github.io/experiment-styles-cleanup/v17 애플리케이션을 사용해보세요.</p>
<p><img src="/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_2.png" alt="이미지"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>Non-dynamic 컴포넌트와의 작업 방식은 어떤가요?</h1>
<p>가끔 이러한 경우는 특이한 경우라고 생각할 수 있고, 우리가 많은 동적 컴포넌트를 만들지 않기 때문에 중요하지 않을 수도 있어요.</p>
<p>일반 ngIf 문장으로 어떻게 작동하는지 확인해봅시다.</p>
<p>이를 확인하려면 AppComponent의 코드에 필요한 변경 사항을 적용해야 했어요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> {<span class="hljs-title class_">Component</span>, <span class="hljs-title class_">ComponentFactoryResolver</span>, inject, <span class="hljs-title class_">Injector</span>, <span class="hljs-title class_">OnDestroy</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> {<span class="hljs-title class_">DynamicComponent</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">"./dynamic.component"</span>;

@<span class="hljs-title class_">Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-root'</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &#x3C;div class="test">
      이 상자가 빨간색이 될 때 적용되는 스타일
    &#x3C;/div>

    &#x3C;app-dynamic *ngIf="visible"/>

    &#x3C;button (click)="createComponent()">클릭!&#x3C;/button>
  `</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppComponent</span> {
  visible = <span class="hljs-literal">false</span>;

  <span class="hljs-title function_">createComponent</span>(): <span class="hljs-keyword">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">visible</span> = <span class="hljs-literal">true</span>;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">visible</span> = <span class="hljs-literal">false</span>, <span class="hljs-number">5000</span>);
  }
}
</code></pre>
<p>결과는 예상대로입니다.</p>
<p>Angular 15 및 16 — 스타일이 제거되지 않음</p>
<ul>
<li>브랜치 v15-ngIf 및 galczo5.github.io/experiment-styles-cleanup/v15-ngIf/</li>
<li>브랜치 v16-ngIf 및 galczo5.github.io/experiment-styles-cleanup/v16-ngIf/</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>안녕하세요! 다음과 같이 테이블 태그를 마크다운 형식으로 변경해주세요.</p>
<p>Angular 17 — 컴포넌트가 파괴된 후에 스타일이 제거됩니다</p>
<ul>
<li>Branch 17-ngIf 및 galczo5.github.io/experiment-styles-cleanup/v17-ngIf/</li>
</ul>
<p>그래서, 동적으로 생성된 컴포넌트와 정확히 똑같이 동작합니다. 추가로 제거되지 않은 스타일이 브라우저에 얼마나 무겁게 작용하는지는 확신할 수 없지만, 스타일이 적을수록 처리하기 쉬울 것으로 예상됩니다. 아마 다음에는 측정해 볼 것입니다.</p>
<h1>캡슐화된 스타일에 대해 어떤가요?</h1>
<p>도움이 되었기를 바랍니다. 추가 설명이 필요하시면 언제든지 물어보세요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>내 모든 테스트에서는 ViewEncapsulation.None을 사용하여 어떻게 작동하는지 시각적으로 보여주었어. 기본으로 에뮬레이션된 캡슐화로 작동하는 지 확인하기 위해 컴포넌트 제거 후 DOM을 확인하기 위해 개발 도구를 사용했어. 문서의 <code>head</code> 부분에서 무슨 일이 일어나고 있는지 관찰해봐.</p>
<p>나에게 결과는 다음과 같았어:</p>
<ul>
<li>Angular 15 &#x26; 16 — 스타일이 제거되지 않아</li>
<li>Angular 17 — 스타일이 제거되어</li>
</ul>
<p>기본 캡슐화에서도 동일하게 작동해.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>요약</h1>
<p>솔직히 말해서, 컴포넌트를 파괴할 때 Angular가 기본적으로 스타일을 제거하지 않는다는 사실을 깨달을 때 약간 놀랐습니다. 몇 달 전에 물었더라면 Angular가 스타일을 제거한다고 베팅했을 것입니다.</p>
<p>제 생각으로는 Angular 17에서 도입된 변경 사항이 모든 개발자에게 더 직관적일 것으로 확신합니다.</p>
<p>요약하면, 제 테스트에 따르면 Angular 17 이전에 동적 컴포넌트든 ngIf를 사용하여 조건적으로 추가된 컴포넌트든 모든 컴포넌트가 파괴된 후에 추가된 모든 스타일이 제거되지 않았습니다. Angular 17은 이 동작을 변경하여 이제 컴포넌트 이후 불필요한 스타일이 정리됩니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Angular 17의 컴포넌트 스타일 정리 방법","description":"","date":"2024-07-01 16:20","slug":"2024-07-01-MythicalAngularComponentstylescleanupinAngular17","content":"\n\n안녕하세요!\n\n최신 릴리스 노트에 언급되지 않은 흥미로운 동작을 발견했습니다. 이 기사에서는 이것이 무엇인지 보여드리고, 왜 그것이 꽤 흥미로운 변화라고 생각하는지 알려드리겠습니다.\n\n# 스타일 정리 문제\n\nAngular가 동적으로 생성된 구성 요소를 제거한 후에도 스타일을 제거하지 않는 문제를 발견했습니다. 즉, 동적 구성 요소를 생성하면 (심지어 DOM에 연결할 필요도 없이), Angular가 스타일을 추가한 후 구성 요소가 제거될 때 스타일을 제거하지 않는다는 것이죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n검사하고 테스트하는 것은 매우 쉽습니다.\n\n# 테스트\n\n항상 모든 코드는 내 GitHub에서 제공됩니다. experiment-styles-cleanup 저장소를 찾아보세요.\n\n저는 응용 프로그램에 스타일을 추가하는 것 외에 아무 것도 하지 않는 간단한 구성 요소로 테스트를 시작합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\nimport {Component, ViewEncapsulation} from '@angular/core';\n\n@Component({\n  selector: 'app-dynamic',\n  template: '',\n  encapsulation: ViewEncapsulation.None,\n  styles: [`\n    .test {\n      background: red;\n      color: white;\n      border: 4px dashed black;\n      font-weight: bold;\n    }\n  `]\n})\nexport class DynamicComponent {\n}\r\n```\n\n여기서 볼 수 있듯이, 꽤 간단합니다. 템플릿도 로직도 없고, 스타일만 있습니다. 중요한 점은 ViewEncapsulation.None으로 캡슐화를 설정했기 때문에 이 스타일을 컴포넌트 외부에 적용할 수 있다는 것입니다.\n\n다음으로, 루트 AppComponent를 수정해보겠습니다.\n\n```js\r\nimport {Component, ComponentFactoryResolver, inject, Injector, OnDestroy} from '@angular/core';\nimport {DynamicComponent} from \"./dynamic.component\";\n\n@Component({\n  selector: 'app-root',\n  template: `\n    \u003cdiv class=\"test\"\u003e\n      이 상자가 빨간색일 때 스타일이 적용됩니다\n    \u003c/div\u003e\n\n    \u003cbutton (click)=\"createComponent()\"\u003e눌러보세요!\u003c/button\u003e\n  `\n})\nexport class AppComponent {\n  private readonly componentFactoryResolver = inject(ComponentFactoryResolver);\n  private readonly injector = inject(Injector);\n\n  createComponent(): void {\n    const factory = this.componentFactoryResolver.resolveComponentFactory(DynamicComponent);\n    const componentRef = factory.create(this.injector);\n\n    setTimeout(() =\u003e componentRef.destroy(), 5000);\n  }\n}\r\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAppComponent에서 두 가지가 있습니다.\n\n첫 번째는 test 클래스가 있는 div입니다. Angular이 DynamicComponent에서 스타일을 추가할 때 스타일이 적용됩니다. 그래서 캡슐화를 ViewEncapsulation.None으로 설정했습니다.\n\n두 번째로는 버튼이 있습니다. 클릭하면 ComponentFactoryResolver를 사용하여 동적으로 DynamicComponent를 생성한 후 5초 후에 제거합니다. setTimeout에 메모리 누수가 있음을 알고 있지만 이것은 테스트일 뿐이니 괜찮아요?\n\n전체 테스트는 간단합니다. 버튼을 클릭하면 div에 스타일이 적용되어야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![한국어](/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_0.png)\n\n5초간 기다리고, 두 가지 가능한 종료가 있습니다:\n\n- div에 스타일이 있는 경우 - 해당 컴포넌트의 스타일이 제거되지 않았음을 의미합니다\n- div에 스타일이 없는 경우 - Angular가 컴포넌트 제거 후 정리를 수행 중임을 의미합니다\n\n# Angular 15 \u0026 16\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아마도 예상했겠지만, Angular 15와 16에서는 컴포넌트와 함께 스타일이 제거되지 않습니다. experiment-styles-cleanup 저장소의 코드를 사용하여 직접 해볼 수 있어요. 주요 브랜치와 v16 브랜치를 사용해 보세요.\n\n![이미지](/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_1.png)\n\n참고: 시간이 부족하다면 권장합니다. GitHub Pages를 통해 배포한 코드를 확인할 수 있어요. 다음은 링크입니다:\n\n- [v15 링크](galczo5.github.io/experiment-styles-cleanup/v15)\n- [v16 링크](galczo5.github.io/experiment-styles-cleanup/v16)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 앵귤러 17\n\n앵귤러 17로 업그레이드한 후에 동작이 변경되었습니다. 이제 스타일은 컴포넌트와 함께 제거됩니다.\n\n내 저장소의 v17 브랜치를 확인하거나 galczo5.github.io/experiment-styles-cleanup/v17 애플리케이션을 사용해보세요.\n\n![이미지](/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Non-dynamic 컴포넌트와의 작업 방식은 어떤가요?\n\n가끔 이러한 경우는 특이한 경우라고 생각할 수 있고, 우리가 많은 동적 컴포넌트를 만들지 않기 때문에 중요하지 않을 수도 있어요.\n\n일반 ngIf 문장으로 어떻게 작동하는지 확인해봅시다.\n\n이를 확인하려면 AppComponent의 코드에 필요한 변경 사항을 적용해야 했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```javascript\nimport {Component, ComponentFactoryResolver, inject, Injector, OnDestroy} from '@angular/core';\nimport {DynamicComponent} from \"./dynamic.component\";\n\n@Component({\n  selector: 'app-root',\n  template: `\n    \u003cdiv class=\"test\"\u003e\n      이 상자가 빨간색이 될 때 적용되는 스타일\n    \u003c/div\u003e\n\n    \u003capp-dynamic *ngIf=\"visible\"/\u003e\n\n    \u003cbutton (click)=\"createComponent()\"\u003e클릭!\u003c/button\u003e\n  `\n})\nexport class AppComponent {\n  visible = false;\n\n  createComponent(): void {\n    this.visible = true;\n    setTimeout(() =\u003e this.visible = false, 5000);\n  }\n}\n```\n\n결과는 예상대로입니다.\n\nAngular 15 및 16 — 스타일이 제거되지 않음\n\n- 브랜치 v15-ngIf 및 galczo5.github.io/experiment-styles-cleanup/v15-ngIf/\n- 브랜치 v16-ngIf 및 galczo5.github.io/experiment-styles-cleanup/v16-ngIf/ \n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 다음과 같이 테이블 태그를 마크다운 형식으로 변경해주세요.\n\n\nAngular 17 — 컴포넌트가 파괴된 후에 스타일이 제거됩니다\n\n- Branch 17-ngIf 및 galczo5.github.io/experiment-styles-cleanup/v17-ngIf/\n\n그래서, 동적으로 생성된 컴포넌트와 정확히 똑같이 동작합니다. 추가로 제거되지 않은 스타일이 브라우저에 얼마나 무겁게 작용하는지는 확신할 수 없지만, 스타일이 적을수록 처리하기 쉬울 것으로 예상됩니다. 아마 다음에는 측정해 볼 것입니다.\n\n# 캡슐화된 스타일에 대해 어떤가요?\n\n\n도움이 되었기를 바랍니다. 추가 설명이 필요하시면 언제든지 물어보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 모든 테스트에서는 ViewEncapsulation.None을 사용하여 어떻게 작동하는지 시각적으로 보여주었어. 기본으로 에뮬레이션된 캡슐화로 작동하는 지 확인하기 위해 컴포넌트 제거 후 DOM을 확인하기 위해 개발 도구를 사용했어. 문서의 `head` 부분에서 무슨 일이 일어나고 있는지 관찰해봐.\n\n나에게 결과는 다음과 같았어:\n\n- Angular 15 \u0026 16 — 스타일이 제거되지 않아\n- Angular 17 — 스타일이 제거되어\n\n기본 캡슐화에서도 동일하게 작동해.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 요약\n\n솔직히 말해서, 컴포넌트를 파괴할 때 Angular가 기본적으로 스타일을 제거하지 않는다는 사실을 깨달을 때 약간 놀랐습니다. 몇 달 전에 물었더라면 Angular가 스타일을 제거한다고 베팅했을 것입니다.\n\n제 생각으로는 Angular 17에서 도입된 변경 사항이 모든 개발자에게 더 직관적일 것으로 확신합니다.\n\n요약하면, 제 테스트에 따르면 Angular 17 이전에 동적 컴포넌트든 ngIf를 사용하여 조건적으로 추가된 컴포넌트든 모든 컴포넌트가 파괴된 후에 추가된 모든 스타일이 제거되지 않았습니다. Angular 17은 이 동작을 변경하여 이제 컴포넌트 이후 불필요한 스타일이 정리됩니다.","ogImage":{"url":"/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_0.png"},"coverImage":"/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e안녕하세요!\u003c/p\u003e\n\u003cp\u003e최신 릴리스 노트에 언급되지 않은 흥미로운 동작을 발견했습니다. 이 기사에서는 이것이 무엇인지 보여드리고, 왜 그것이 꽤 흥미로운 변화라고 생각하는지 알려드리겠습니다.\u003c/p\u003e\n\u003ch1\u003e스타일 정리 문제\u003c/h1\u003e\n\u003cp\u003eAngular가 동적으로 생성된 구성 요소를 제거한 후에도 스타일을 제거하지 않는 문제를 발견했습니다. 즉, 동적 구성 요소를 생성하면 (심지어 DOM에 연결할 필요도 없이), Angular가 스타일을 추가한 후 구성 요소가 제거될 때 스타일을 제거하지 않는다는 것이죠.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e검사하고 테스트하는 것은 매우 쉽습니다.\u003c/p\u003e\n\u003ch1\u003e테스트\u003c/h1\u003e\n\u003cp\u003e항상 모든 코드는 내 GitHub에서 제공됩니다. experiment-styles-cleanup 저장소를 찾아보세요.\u003c/p\u003e\n\u003cp\u003e저는 응용 프로그램에 스타일을 추가하는 것 외에 아무 것도 하지 않는 간단한 구성 요소로 테스트를 시작합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eViewEncapsulation\u003c/span\u003e} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'app-dynamic'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eencapsulation\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eViewEncapsulation\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eNone\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003estyles\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e`\n    .test {\n      background: red;\n      color: white;\n      border: 4px dashed black;\n      font-weight: bold;\n    }\n  `\u003c/span\u003e]\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDynamicComponent\u003c/span\u003e {\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 볼 수 있듯이, 꽤 간단합니다. 템플릿도 로직도 없고, 스타일만 있습니다. 중요한 점은 ViewEncapsulation.None으로 캡슐화를 설정했기 때문에 이 스타일을 컴포넌트 외부에 적용할 수 있다는 것입니다.\u003c/p\u003e\n\u003cp\u003e다음으로, 루트 AppComponent를 수정해보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eComponentFactoryResolver\u003c/span\u003e, inject, \u003cspan class=\"hljs-title class_\"\u003eInjector\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eOnDestroy\u003c/span\u003e} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\u003cspan class=\"hljs-title class_\"\u003eDynamicComponent\u003c/span\u003e} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"./dynamic.component\"\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'app-root'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`\n    \u0026#x3C;div class=\"test\"\u003e\n      이 상자가 빨간색일 때 스타일이 적용됩니다\n    \u0026#x3C;/div\u003e\n\n    \u0026#x3C;button (click)=\"createComponent()\"\u003e눌러보세요!\u0026#x3C;/button\u003e\n  `\u003c/span\u003e\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAppComponent\u003c/span\u003e {\n  private readonly componentFactoryResolver = \u003cspan class=\"hljs-title function_\"\u003einject\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eComponentFactoryResolver\u003c/span\u003e);\n  private readonly injector = \u003cspan class=\"hljs-title function_\"\u003einject\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eInjector\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-title function_\"\u003ecreateComponent\u003c/span\u003e(): \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e factory = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecomponentFactoryResolver\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eresolveComponentFactory\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDynamicComponent\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e componentRef = factory.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einjector\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e componentRef.\u003cspan class=\"hljs-title function_\"\u003edestroy\u003c/span\u003e(), \u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eAppComponent에서 두 가지가 있습니다.\u003c/p\u003e\n\u003cp\u003e첫 번째는 test 클래스가 있는 div입니다. Angular이 DynamicComponent에서 스타일을 추가할 때 스타일이 적용됩니다. 그래서 캡슐화를 ViewEncapsulation.None으로 설정했습니다.\u003c/p\u003e\n\u003cp\u003e두 번째로는 버튼이 있습니다. 클릭하면 ComponentFactoryResolver를 사용하여 동적으로 DynamicComponent를 생성한 후 5초 후에 제거합니다. setTimeout에 메모리 누수가 있음을 알고 있지만 이것은 테스트일 뿐이니 괜찮아요?\u003c/p\u003e\n\u003cp\u003e전체 테스트는 간단합니다. 버튼을 클릭하면 div에 스타일이 적용되어야 합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_0.png\" alt=\"한국어\"\u003e\u003c/p\u003e\n\u003cp\u003e5초간 기다리고, 두 가지 가능한 종료가 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ediv에 스타일이 있는 경우 - 해당 컴포넌트의 스타일이 제거되지 않았음을 의미합니다\u003c/li\u003e\n\u003cli\u003ediv에 스타일이 없는 경우 - Angular가 컴포넌트 제거 후 정리를 수행 중임을 의미합니다\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eAngular 15 \u0026#x26; 16\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아마도 예상했겠지만, Angular 15와 16에서는 컴포넌트와 함께 스타일이 제거되지 않습니다. experiment-styles-cleanup 저장소의 코드를 사용하여 직접 해볼 수 있어요. 주요 브랜치와 v16 브랜치를 사용해 보세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e참고: 시간이 부족하다면 권장합니다. GitHub Pages를 통해 배포한 코드를 확인할 수 있어요. 다음은 링크입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"galczo5.github.io/experiment-styles-cleanup/v15\"\u003ev15 링크\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"galczo5.github.io/experiment-styles-cleanup/v16\"\u003ev16 링크\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e앵귤러 17\u003c/h1\u003e\n\u003cp\u003e앵귤러 17로 업그레이드한 후에 동작이 변경되었습니다. 이제 스타일은 컴포넌트와 함께 제거됩니다.\u003c/p\u003e\n\u003cp\u003e내 저장소의 v17 브랜치를 확인하거나 galczo5.github.io/experiment-styles-cleanup/v17 애플리케이션을 사용해보세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eNon-dynamic 컴포넌트와의 작업 방식은 어떤가요?\u003c/h1\u003e\n\u003cp\u003e가끔 이러한 경우는 특이한 경우라고 생각할 수 있고, 우리가 많은 동적 컴포넌트를 만들지 않기 때문에 중요하지 않을 수도 있어요.\u003c/p\u003e\n\u003cp\u003e일반 ngIf 문장으로 어떻게 작동하는지 확인해봅시다.\u003c/p\u003e\n\u003cp\u003e이를 확인하려면 AppComponent의 코드에 필요한 변경 사항을 적용해야 했어요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eComponentFactoryResolver\u003c/span\u003e, inject, \u003cspan class=\"hljs-title class_\"\u003eInjector\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eOnDestroy\u003c/span\u003e} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\u003cspan class=\"hljs-title class_\"\u003eDynamicComponent\u003c/span\u003e} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"./dynamic.component\"\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'app-root'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`\n    \u0026#x3C;div class=\"test\"\u003e\n      이 상자가 빨간색이 될 때 적용되는 스타일\n    \u0026#x3C;/div\u003e\n\n    \u0026#x3C;app-dynamic *ngIf=\"visible\"/\u003e\n\n    \u0026#x3C;button (click)=\"createComponent()\"\u003e클릭!\u0026#x3C;/button\u003e\n  `\u003c/span\u003e\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAppComponent\u003c/span\u003e {\n  visible = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-title function_\"\u003ecreateComponent\u003c/span\u003e(): \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003evisible\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003evisible\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e결과는 예상대로입니다.\u003c/p\u003e\n\u003cp\u003eAngular 15 및 16 — 스타일이 제거되지 않음\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e브랜치 v15-ngIf 및 galczo5.github.io/experiment-styles-cleanup/v15-ngIf/\u003c/li\u003e\n\u003cli\u003e브랜치 v16-ngIf 및 galczo5.github.io/experiment-styles-cleanup/v16-ngIf/\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e안녕하세요! 다음과 같이 테이블 태그를 마크다운 형식으로 변경해주세요.\u003c/p\u003e\n\u003cp\u003eAngular 17 — 컴포넌트가 파괴된 후에 스타일이 제거됩니다\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBranch 17-ngIf 및 galczo5.github.io/experiment-styles-cleanup/v17-ngIf/\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그래서, 동적으로 생성된 컴포넌트와 정확히 똑같이 동작합니다. 추가로 제거되지 않은 스타일이 브라우저에 얼마나 무겁게 작용하는지는 확신할 수 없지만, 스타일이 적을수록 처리하기 쉬울 것으로 예상됩니다. 아마 다음에는 측정해 볼 것입니다.\u003c/p\u003e\n\u003ch1\u003e캡슐화된 스타일에 대해 어떤가요?\u003c/h1\u003e\n\u003cp\u003e도움이 되었기를 바랍니다. 추가 설명이 필요하시면 언제든지 물어보세요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e내 모든 테스트에서는 ViewEncapsulation.None을 사용하여 어떻게 작동하는지 시각적으로 보여주었어. 기본으로 에뮬레이션된 캡슐화로 작동하는 지 확인하기 위해 컴포넌트 제거 후 DOM을 확인하기 위해 개발 도구를 사용했어. 문서의 \u003ccode\u003ehead\u003c/code\u003e 부분에서 무슨 일이 일어나고 있는지 관찰해봐.\u003c/p\u003e\n\u003cp\u003e나에게 결과는 다음과 같았어:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAngular 15 \u0026#x26; 16 — 스타일이 제거되지 않아\u003c/li\u003e\n\u003cli\u003eAngular 17 — 스타일이 제거되어\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e기본 캡슐화에서도 동일하게 작동해.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e요약\u003c/h1\u003e\n\u003cp\u003e솔직히 말해서, 컴포넌트를 파괴할 때 Angular가 기본적으로 스타일을 제거하지 않는다는 사실을 깨달을 때 약간 놀랐습니다. 몇 달 전에 물었더라면 Angular가 스타일을 제거한다고 베팅했을 것입니다.\u003c/p\u003e\n\u003cp\u003e제 생각으로는 Angular 17에서 도입된 변경 사항이 모든 개발자에게 더 직관적일 것으로 확신합니다.\u003c/p\u003e\n\u003cp\u003e요약하면, 제 테스트에 따르면 Angular 17 이전에 동적 컴포넌트든 ngIf를 사용하여 조건적으로 추가된 컴포넌트든 모든 컴포넌트가 파괴된 후에 추가된 모든 스타일이 제거되지 않았습니다. Angular 17은 이 동작을 변경하여 이제 컴포넌트 이후 불필요한 스타일이 정리됩니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-01-MythicalAngularComponentstylescleanupinAngular17"},"buildId":"GsgRekSb--BvxYwv9FPn6","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>