<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Kubernetes K8s ConfigMap 또는 Secret가 업데이트될 때 배포 자동 재시작하기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-19-KubernetesAutoRestartDeploymentswhenK8sConfigMaporSecretisUpdated" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Kubernetes K8s ConfigMap 또는 Secret가 업데이트될 때 배포 자동 재시작하기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Kubernetes K8s ConfigMap 또는 Secret가 업데이트될 때 배포 자동 재시작하기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-KubernetesAutoRestartDeploymentswhenK8sConfigMaporSecretisUpdated_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-19-KubernetesAutoRestartDeploymentswhenK8sConfigMaporSecretisUpdated" data-gatsby-head="true"/><meta name="twitter:title" content="Kubernetes K8s ConfigMap 또는 Secret가 업데이트될 때 배포 자동 재시작하기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-KubernetesAutoRestartDeploymentswhenK8sConfigMaporSecretisUpdated_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 13:11" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_buildManifest.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Kubernetes K8s ConfigMap 또는 Secret가 업데이트될 때 배포 자동 재시작하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Kubernetes K8s ConfigMap 또는 Secret가 업데이트될 때 배포 자동 재시작하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">19<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-KubernetesAutoRestartDeploymentswhenK8sConfigMaporSecretisUpdated&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>자동 롤아웃 재시작: K8s ConfigMap 또는 Secret가 업데이트될 때 배포 다시 시작하기</h2>
<p>쿠버네티스 배포는 모든 쿠버네티스 클러스터에서 가장 일반적인 리소스 중 하나입니다. 우리는 모두 pod를 K8s 배포를 사용하여 실행하여 높은 가용성을 보장하고, pod가 삭제되면 자동으로 생성되도록합니다.</p>
<p>애플리케이션이 항상 여러 환경에서 원활하게 실행되도록하기 위해 구성이 필요한 것은 매우 흔합니다. 데이터베이스 사용자 이름, 비밀번호 등과 같은 중요한 정보가 필요할 수도 있습니다. 쿠버네티스에서는 구성 맵과 시크릿을 사용하여 응용 프로그램별 데이터를 저장하고 pod로 주입하여 응용 프로그램에서 사용할 수 있도록 할 수 있습니다.</p>
<p>그렇다면 구성 맵이나 시크릿의 값을 업데이트했을 때는 어떨까요? 최신 값을 반영하려면 pod를 다시 시작해야합니다, 맞죠? 또는 롤아웃을 다시 시작하여 새로운 pod를 생성하게 할 수도 있습니다. 이제 상상해보세요. 공통 configmap 또는 secret을 사용하는 수백 개의 배포가 있고 그 값을 업데이트하고 사용하는 것이 최신 값이라는 것을 확실하게 해야한다고 가정해보세요.</p>
<p></p>
<p>저희는 AWS Secrets Manager에 비밀을 저장하고, Kubernetes Secrets Store CSI Driver를 위해 AWS Secrets 및 구성 제공자(ASCP)로부터 Kubernetes Secrets를 생성합니다.</p>
<p>이 블로그 게시물에서는 Secret 또는 ConfigMap이 업데이트될 때 Kubernetes 배포를 자동으로 롤아웃 및 다시 시작하는 방법에 대해 설명하겠습니다.</p>
<h1>아키텍처 다이어그램:</h1>
<p><img src="/assets/img/2024-06-19-KubernetesAutoRestartDeploymentswhenK8sConfigMaporSecretisUpdated_0.png" alt="Architecture Diagram"></p>
<p></p>
<h2>시작해 봅시다!</h2>
<h3>준비물:</h3>
<ul>
<li>EKS 클러스터</li>
<li>EKS를 위한 OIDC 제공자 구성 필요</li>
<li>Kubectl</li>
<li>AWS CLI</li>
</ul>
<h3>단계 1: ASCP를 위한 IAM 역할 및 정책 생성</h3>
<p></p>
<p>ASCP(Amazon EKS Security Token Service)는 Amazon EKS 파드 ID를 검색하여 IAM 역할로 교환합니다. 해당 IAM 역할에 대한 IAM 정책에서 권한을 설정합니다. ASCP가 IAM 역할을 가정하면 권한을 부여받은 시크릿에 액세스할 수 있습니다. 다른 컨테이너는 IAM 역할과 연결되지 않는 한 시크릿에 액세스할 수 없습니다.</p>
<ul>
<li>IAM 정책 문서 작성
"secrets_policy"라는 이름의 파일을 만들고 다음 내용을 추가하십시오.</li>
</ul>
<pre><code class="hljs language-js">{
    <span class="hljs-string">"Version"</span>: <span class="hljs-string">"2012-10-17"</span>,
    <span class="hljs-string">"Statement"</span>: [
        {
            <span class="hljs-string">"Action"</span>: [
                <span class="hljs-string">"secretsmanager:DescribeSecret"</span>,
                <span class="hljs-string">"secretsmanager:GetSecretValue"</span>
            ],
            <span class="hljs-string">"Effect"</span>: <span class="hljs-string">"Allow"</span>,
            <span class="hljs-string">"Resource"</span>: <span class="hljs-string">"*"</span>
        }
}
</code></pre>
<ol start="2">
<li>다음 명령을 실행하여 IAM 정책을 만듭니다.
IAM 정책을 IAM 역할에 연결할 때 policy ARN을 메모하십시오.</li>
</ol>
<p></p>
<pre><code class="hljs language-js">aws iam create-policy \
    --policy-name my-secret-manager-policy \
    --policy-<span class="hljs-variable language_">document</span> <span class="hljs-attr">file</span>:<span class="hljs-comment">//secrets_policy</span>
</code></pre>
<ol start="3">
<li>IAM 역할에 신뢰 정책 생성하기
"trust_policy"라는 이름의 파일을 생성하고 다음 내용을 추가하세요. 올바른 값으로 대체해야 합니다. <code>SERVICE_ACCOUNT_NAME</code>은 임의로 지정할 수 있지만 Kubernetes에서 실제 서비스 계정을 생성할 때 동일한 이름을 사용해야 합니다.</li>
</ol>
<pre><code class="hljs language-js">{
  <span class="hljs-string">"Version"</span>: <span class="hljs-string">"2012-10-17"</span>,
  <span class="hljs-string">"Statement"</span>: [
    {
      <span class="hljs-string">"Effect"</span>: <span class="hljs-string">"Allow"</span>,
      <span class="hljs-string">"Action"</span>: <span class="hljs-string">"sts:AssumeRoleWithWebIdentity"</span>,
      <span class="hljs-string">"Principal"</span>: {
        <span class="hljs-string">"Federated"</span>: <span class="hljs-string">"arn:aws:iam::&#x3C;AWS_ACCOUNT_ID>:oidc-provider/oidc.eks.&#x3C;AWS_REGION>.amazonaws.com/id/&#x3C;OIDC_ID>"</span>
      },
      <span class="hljs-string">"Condition"</span>: {
        <span class="hljs-string">"StringEquals"</span>: {
          <span class="hljs-string">"oidc.eks.&#x3C;AWS_REGION>.amazonaws.com/id/&#x3C;OIDC_ID>:aud"</span>: <span class="hljs-string">"sts.amazonaws.com"</span>,
          <span class="hljs-string">"oidc.eks.&#x3C;AWS_REGION>.amazonaws.com/id/&#x3C;OIDC_ID>:sub"</span>: <span class="hljs-string">"system:serviceaccount:&#x3C;K8S_NAMESPACE>:&#x3C;SERVICE_ACCOUNT_NAME>"</span>
        }
      }
    }
  ]
}
</code></pre>
<ol start="4">
<li>다음 명령어를 실행하여 IAM 역할을 만드세요.</li>
</ol>
<p></p>
<pre><code class="hljs language-js">aws iam create-role --role-name my-secret-manager-role --assume-role-policy-<span class="hljs-variable language_">document</span> <span class="hljs-attr">file</span>:<span class="hljs-comment">//trust_policy</span>
</code></pre>
<ol start="5">
<li>Attach IAM policy to IAM Role</li>
</ol>
<pre><code class="hljs language-js">aws iam attach-role-policy --policy-arn &#x3C;your_policy_arn> --role-name my-secret-manager-role
</code></pre>
<p>우리는 필요한 모든 IAM 역할과 정책을 생성했습니다.</p>
<p></p>
<h1>단계 2: ASCP 설치 및 구성</h1>
<p>이제 2개의 Helm 차트를 설치해야 합니다.</p>
<ul>
<li>AWS Secrets and Configuration Provider (ASCP) 차트 설치</li>
</ul>
<pre><code class="hljs language-js"># <span class="hljs-variable constant_">ASCP</span> <span class="hljs-title class_">Helm</span> 차트 리포지토리 추가
helm repo add aws-secrets-manager <span class="hljs-attr">https</span>:<span class="hljs-comment">//aws.github.io/secrets-store-csi-driver-provider-aws</span>

# <span class="hljs-variable constant_">ASCP</span> <span class="hljs-title class_">Helm</span> 차트 설치
helm install -n kube-system secrets-provider-aws aws-secrets-manager/secrets-store-csi-driver-provider-aws
</code></pre>
<p></p>
<ol start="2">
<li>Secrets Store CSI Driver 차트 설치</li>
</ol>
<ul>
<li>Secrets Store CSI Driver 차트를 위한 helm 레포지토리 추가</li>
</ul>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Secrets</span> <span class="hljs-title class_">Store</span> <span class="hljs-variable constant_">CSI</span> <span class="hljs-title class_">Driver</span> 차트 레포지토리 추가
helm repo add secrets-store-csi-driver <span class="hljs-attr">https</span>:<span class="hljs-comment">//kubernetes-sigs.github.io/secrets-store-csi-driver/charts</span>
</code></pre>
<ul>
<li>기본값 확인</li>
</ul>
<p></p>
<h1>기본 값 가져오기</h1>
<p>helm show values secrets-store-csi-driver/secrets-store-csi-driver > secrets-store-csi-driver.yaml</p>
<ul>
<li>secrets-store-csi-driver.yaml 파일에서 다음 값을 업데이트하세요.</li>
</ul>
<h2>K8S Secrets 동기화에 필요한 RBAC 역할 및 바인딩 설치 여부</h2>
<p>syncSecret:
enabled: true</p>
<h2>시크릿 로테이션 기능 활성화 [알파]</h2>
<p>enableSecretRotation: true</p>
<p>위의 구성은 "secrets-store-csi-driver"가 AWS Secret Manager에서 최신 값을 가져와 해당 값을 Kubernetes Secrets 객체에 업데이트할 수 있게 합니다.</p>
<p></p>
<p>회전-투표-간격은 기본적으로 2분으로 설정되어 있지만, 속성 rotationPollInterval을 설정함으로써 변경할 수 있습니다.</p>
<ul>
<li>Helm 차트 설치</li>
</ul>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Helm</span> 차트 설치
helm install -n kube-system csi-secrets-store secrets-store-csi-driver/secrets-store-csi-driver -f secrets-store-csi-driver.<span class="hljs-property">yaml</span>
</code></pre>
<h1>단계 3: AWS Secret Manager에 테스트 시크릿 생성</h1>
<p></p>
<p>AWS Secret Manager에서 테스트 시크릿을 생성할 것입니다.</p>
<pre><code class="hljs language-js">aws secretsmanager create-secret \
    --name my-test-secret \
    --description <span class="hljs-string">"CLI로 생성한 내 테스트 시크릿."</span> \
    --secret-string <span class="hljs-string">"{\"user\":\"my-user\",\"password\":\"예시-비밀번호\"}"</span>
</code></pre>
<h1>단계 4: Kubernetes ServiceAccount 생성</h1>
<p>이제 IAM 역할을 가정할 수 있도록 파드에 허용하는 ServiceAccount를 생성할 수 있습니다. 이 ServiceAccount는 K8s 배포에서 사용될 것입니다.</p>
<p></p>
<p>serviceaccount.yaml이라는 이름의 파일을 생성해주세요.</p>
<pre><code class="hljs language-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">&#x3C;your_service_account_name></span> <span class="hljs-comment"># 이 이름은 IAM 신뢰 정책을 만들 때 지정한 이름과 일치해야 합니다.</span>
  <span class="hljs-attr">annotations:</span>
    <span class="hljs-attr">eks.amazonaws.com/role-arn:</span> <span class="hljs-string">&#x3C;IAM_ROLE_ARN></span>
</code></pre>
<p>다음 명령을 실행하여 K8s에서 서비스 계정을 생성합니다.</p>
<pre><code class="hljs language-bash">kubectl apply -f serviceaccount.yaml
</code></pre>
<p></p>
<h1>단계 5: 테스트 객체 생성하기</h1>
<p>이제 필요한 모든 리소스를 배포했습니다. 이제 테스트 객체를 만들어 봅시다.</p>
<ul>
<li>이름이 “my-test-secret-manifest.yaml”인 파일 생성</li>
</ul>
<pre><code class="hljs language-js">---
<span class="hljs-attr">apiVersion</span>: secrets-store.<span class="hljs-property">csi</span>.<span class="hljs-property">x</span>-k8s.<span class="hljs-property">io</span>/v1
<span class="hljs-attr">kind</span>: <span class="hljs-title class_">SecretProviderClass</span>
<span class="hljs-attr">metadata</span>:
  <span class="hljs-attr">name</span>: aws-secrets-provider<span class="hljs-keyword">class</span>
<span class="hljs-title class_">spec</span>:
  <span class="hljs-attr">provider</span>: aws
  <span class="hljs-attr">secretObjects</span>:
    - <span class="hljs-attr">secretName</span>: my-test-k8s-secret
      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Opaque</span>
      <span class="hljs-attr">data</span>:
        - <span class="hljs-attr">objectName</span>: user
          <span class="hljs-attr">key</span>: user
        - <span class="hljs-attr">objectName</span>: password
          <span class="hljs-attr">key</span>: password
  <span class="hljs-attr">parameters</span>:
    <span class="hljs-attr">objects</span>: |
      - <span class="hljs-attr">objectName</span>: <span class="hljs-attr">arn</span>:<span class="hljs-attr">aws</span>:<span class="hljs-attr">secretsmanager</span>:&#x3C;<span class="hljs-variable constant_">AWS_REGION</span>>:&#x3C;<span class="hljs-variable constant_">AWS_ACCOUNT_ID</span>>:<span class="hljs-attr">secret</span>:my-test-secret
        <span class="hljs-attr">jmesPath</span>:
          - <span class="hljs-attr">path</span>: user
            <span class="hljs-attr">objectAlias</span>: user
          - <span class="hljs-attr">path</span>: password
            <span class="hljs-attr">objectAlias</span>: password
---
<span class="hljs-attr">apiVersion</span>: apps/v1
<span class="hljs-attr">kind</span>: <span class="hljs-title class_">Deployment</span>
<span class="hljs-attr">metadata</span>:
  <span class="hljs-attr">name</span>: secret-rotation-test-ubuntu-deployment
  <span class="hljs-attr">labels</span>:
    <span class="hljs-attr">app</span>: ubuntu
<span class="hljs-attr">spec</span>:
  <span class="hljs-attr">replicas</span>: <span class="hljs-number">1</span>
  <span class="hljs-attr">selector</span>:
    <span class="hljs-attr">matchLabels</span>:
      <span class="hljs-attr">app</span>: ubuntu
  <span class="hljs-attr">template</span>:
    <span class="hljs-attr">metadata</span>:
      <span class="hljs-attr">labels</span>:
        <span class="hljs-attr">app</span>: ubuntu
    <span class="hljs-attr">spec</span>:
      <span class="hljs-attr">serviceAccountName</span>: &#x3C;your_service_account_name> # 이 이름은 단계 <span class="hljs-number">4</span>에서 만든 서비스 계정 이름과 일치해야 합니다
      <span class="hljs-attr">volumes</span>:
      - <span class="hljs-attr">name</span>: mount-secrets-access
        <span class="hljs-attr">csi</span>:
          <span class="hljs-attr">driver</span>: secrets-store.<span class="hljs-property">csi</span>.<span class="hljs-property">k8s</span>.<span class="hljs-property">io</span>
          <span class="hljs-attr">readOnly</span>: <span class="hljs-literal">true</span>
          <span class="hljs-attr">volumeAttributes</span>:
            <span class="hljs-attr">secretProviderClass</span>: <span class="hljs-string">"aws-secrets-providerclass"</span>
      <span class="hljs-attr">containers</span>:
      - <span class="hljs-attr">name</span>: ubuntu
        <span class="hljs-attr">image</span>: ubuntu
        <span class="hljs-attr">command</span>: [<span class="hljs-string">"sleep"</span>, <span class="hljs-string">"123456"</span>]
        <span class="hljs-attr">env</span>:
        - <span class="hljs-attr">name</span>: <span class="hljs-variable constant_">USER</span>
          <span class="hljs-attr">valueFrom</span>:
            <span class="hljs-attr">secretKeyRef</span>:
              <span class="hljs-attr">name</span>: my-test-k8s-secret
              <span class="hljs-attr">key</span>: user
        - <span class="hljs-attr">name</span>: <span class="hljs-variable constant_">PASSWORD</span>
          <span class="hljs-attr">valueFrom</span>:
            <span class="hljs-attr">secretKeyRef</span>:
              <span class="hljs-attr">name</span>: my-test-k8s-secret
              <span class="hljs-attr">key</span>: password
        <span class="hljs-attr">volumeMounts</span>:
        - <span class="hljs-attr">name</span>: mount-secrets-access
          <span class="hljs-attr">mountPath</span>: <span class="hljs-string">"/mnt/aws-secrets"</span>
          <span class="hljs-attr">readOnly</span>: <span class="hljs-literal">true</span>
</code></pre>
<p></p>
<ol start="2">
<li>manifest를 적용하십시오</li>
</ol>
<pre><code class="hljs language-js">kubectl apply -f my-test-secret-manifest.<span class="hljs-property">yaml</span>
</code></pre>
<ol start="3">
<li>다음 리소스가 생성됩니다.</li>
</ol>
<ul>
<li>SecretProviderClass 리소스 - AWS Secret Manager에서 데이터를 가져와 K8s Secret를 생성합니다</li>
<li>볼륨 마운트가 있는 배포 - SecretProviderClass를 볼륨으로 마운트해야 합니다</li>
<li>Kubernetes Secret - 파드 내에서 환경 변수로 주입됩니다</li>
</ul>
<p></p>
<p>아래 다이어그램은 YAML을 적용할 때 뒷단에서 무슨 일이 벌어지는지 잘 시각화한 것입니다.</p>
<p><img src="/assets/img/2024-06-19-KubernetesAutoRestartDeploymentswhenK8sConfigMaporSecretisUpdated_1.png" alt="다이어그램"></p>
<ol start="4">
<li>모든 것이 배포되었는지 확인해보세요.</li>
</ol>
<pre><code class="hljs language-js"># <span class="hljs-title class_">SecretProviderClass</span> 확인
kubectl get <span class="hljs-title class_">SecretProviderClass</span> aws-secrets-providerclass -o yaml

# 배포 확인
kubectl get deploy secret-rotation-test-ubuntu-deployment -o yaml

# <span class="hljs-title class_">Pod</span> 확인
kubectl get po &#x3C;pod_name> -o yaml

# <span class="hljs-title class_">Secret</span> 가져오기
kubectl get secret my-test-k8s-secret -o yaml
</code></pre>
<p></p>
<h1>단계 6: Reloader 설치하기</h1>
<p>Reloader는 ConfigMap과 Secret의 변경 사항을 감지하고 관련된 DeploymentConfig, Deployment, DaemonSet, StatefulSet 및 Rollout과 함께 Pod의 롤링 업그레이드를 수행할 수 있습니다.</p>
<ul>
<li>Reloader Helm Repo 추가</li>
</ul>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Helm</span> <span class="hljs-title class_">Repo</span> 추가
helm repo add stakater <span class="hljs-attr">https</span>:<span class="hljs-comment">//stakater.github.io/stakater-charts</span>
</code></pre>
<p></p>
<ol start="2">
<li>기본값 가져오기</li>
</ol>
<pre><code class="hljs language-js"># 기본값 가져오기
helm show values stakater/reloader > reloader.<span class="hljs-property">yaml</span>
</code></pre>
<ol start="3">
<li>reloader.yaml 파일 업데이트하기</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-attr">reloader</span>:
  # 리더십 선출을 활성화하려면 <span class="hljs-literal">true</span>로 설정하여 여러 레플리카를 실행할 수 있습니다.
  <span class="hljs-attr">enableHA</span>: <span class="hljs-literal">true</span>
  <span class="hljs-attr">deployment</span>:
    # 여러 레플리카를 실행하려면 reloader.<span class="hljs-property">enableHA</span> = <span class="hljs-literal">true</span>로 설정합니다.
    <span class="hljs-attr">replicas</span>: <span class="hljs-number">2</span>
</code></pre>
<p></p>
<ol start="4">
<li>Helm 차트 설치</li>
</ol>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Helm</span> 차트 설치
helm install reloader -f reloader.<span class="hljs-property">yaml</span> stakater/reloader -n kube-system
</code></pre>
<h1>단계 7: Secret 업데이트로 테스트하기</h1>
<ul>
<li>Reloader는 주석에 영향을 받습니다.
기본 주석 reloader.stakater.com/auto는 주요 메타데이터에 있어야 합니다. 아래 명령을 사용하여 배포에 주석을 추가하세요.</li>
</ul>
<p></p>
<pre><code class="hljs language-js"># 배포 주석 추가
kubectl annotate deployment secret-rotation-test-ubuntu-deployment <span class="hljs-string">"reloader.stakater.com/auto=true"</span>
</code></pre>
<p>또는 다음 블록으로 배포 파일을 편집하고 적용할 수도 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-attr">metadata</span>:
  <span class="hljs-attr">annotations</span>:
    reloader.<span class="hljs-property">stakater</span>.<span class="hljs-property">com</span>/<span class="hljs-attr">auto</span>: <span class="hljs-string">"true"</span>
</code></pre>
<ol start="2">
<li>AWS Secret Manager에서 시크릿 업데이트하기</li>
</ol>
<p></p>
<pre><code class="hljs language-js">aws secretsmanager put-secret-value \
      --secret-id my-test-secret \
      --secret-string <span class="hljs-string">"{\"user\":\"diegor\",\"password\":\"SAMPLE-PASSWORD\"}"</span>
</code></pre>
<ol start="3">
<li>한 번 시크릿이 AWS 시크릿 스토어 csi 드라이버에 업데이트되면 K8s 시크릿이 즉시 업데이트됩니다. K8s 시크릿이 업데이트되면 Reloader가 롤아웃을 다시 시작하도록 트리거합니다.</li>
</ol>
<pre><code class="hljs language-js"># K8s 시크릿을 확인하세요. 새로운 값이 있어야 합니다.
kubectl get secret my-test-k8s-secret -o yaml

# <span class="hljs-title class_">Pod</span>를 확인하세요. 몇 초 전에 시작되었어야 합니다.
kubectl get po

# <span class="hljs-title class_">Reloader</span> 팟의 로그를 확인하세요.
kubectl logs &#x3C;reloader-pod-name> -n kube-system

# <span class="hljs-title class_">Pod</span>로 실행 후 새로운 값을 확인하세요.
kubectl exec -it &#x3C;pod_name> -- bash

# <span class="hljs-title class_">Pod</span>에 들어간 후 <span class="hljs-string">`env`</span> 명령을 실행하세요. <span class="hljs-title class_">Pod</span>에서 사용 가능한 모든 환경 변수가 출력됩니다.
</code></pre>
<h1>단계 8: ConfigMap 업데이트를 테스트하세요.</h1>
<p></p>
<ul>
<li>"my-test-cm-manifest.yaml" 파일을 생성해주세요.</li>
</ul>
<pre><code class="hljs language-yaml"><span class="hljs-meta">---</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-test-k8s-cm</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-attr">myvalue:</span> <span class="hljs-string">"Hello World"</span>
  <span class="hljs-attr">drink:</span> <span class="hljs-string">coffee</span>
<span class="hljs-meta">---</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">reloader-poc-ubuntu-deployment</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">ubuntu</span>
  <span class="hljs-attr">annotations:</span>
    <span class="hljs-attr">reloader.stakater.com/auto:</span> <span class="hljs-string">"true"</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">ubuntu</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">ubuntu</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ubuntu</span>
          <span class="hljs-attr">image:</span> <span class="hljs-string">ubuntu</span>
          <span class="hljs-attr">command:</span> [<span class="hljs-string">"sleep"</span>, <span class="hljs-string">"123456"</span>]
          <span class="hljs-attr">env:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">DRINK</span>
              <span class="hljs-attr">valueFrom:</span>
                <span class="hljs-attr">configMapKeyRef:</span>
                  <span class="hljs-attr">name:</span> <span class="hljs-string">my-test-k8s-cm</span>
                  <span class="hljs-attr">key:</span> <span class="hljs-string">drink</span>
            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">MYVALUE</span>
              <span class="hljs-attr">valueFrom:</span>
                <span class="hljs-attr">configMapKeyRef:</span>
                  <span class="hljs-attr">name:</span> <span class="hljs-string">my-test-k8s-cm</span>
                  <span class="hljs-attr">key:</span> <span class="hljs-string">myvalue</span>
</code></pre>
<ol start="2">
<li>매니페스트 적용</li>
</ol>
<pre><code class="hljs language-bash">kubectl apply -f my-test-cm-manifest.yaml
</code></pre>
<p></p>
<ol start="3">
<li>my-test-cm-manifest.yaml 파일에서 configmap을 업데이트하세요.</li>
</ol>
<pre><code class="hljs language-yaml"><span class="hljs-meta">---</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-test-k8s-cm</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-attr">myvalue:</span> <span class="hljs-string">"안녕하세요"</span>
  <span class="hljs-attr">drink:</span> <span class="hljs-string">차</span>
</code></pre>
<ol start="4">
<li>파일을 다시 적용하세요.</li>
</ol>
<pre><code class="hljs language-yaml"><span class="hljs-string">kubectl</span> <span class="hljs-string">apply</span> <span class="hljs-string">-f</span> <span class="hljs-string">my-test-cm-manifest.yaml</span>
</code></pre>
<p></p>
<ol start="5">
<li>확인</li>
</ol>
<pre><code class="hljs language-js"># <span class="hljs-title class_">ConfigMap</span> 확인
kubectl get cm my-test-k8s-cm -o yaml

# <span class="hljs-title class_">Pod</span> 확인
kubectl get po

# <span class="hljs-title class_">Pod</span>에 접속하여 새 값 확인
kubectl exec -it &#x3C;pod_name> -- bash

# <span class="hljs-title class_">Pod</span>에 들어간 후 <span class="hljs-string">`env`</span> 명령어를 실행하면 <span class="hljs-title class_">Pod</span> 내에서 사용 가능한 모든 환경 변수가 출력됩니다
</code></pre>
<p>축하합니다!!! secret-store-csi-driver와 reloader를 성공적으로 구성했습니다.</p>
<p>감사합니다!!!</p>
<p></p>
<h2>참고 자료:</h2>
<ul>
<li><a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/integrating_csi_driver.html" rel="nofollow" target="_blank">AWS 공식 문서 - CSI 드라이버 통합</a></li>
<li><a href="https://blog.bootlabstech.com/aws-secrets-manager-in-kubernetes-secret-rotation-and-reloader" rel="nofollow" target="_blank">Bootlabs 기술 블로그 - AWS Secrets Manager in Kubernetes 시크릿 회전과 리로더</a></li>
<li><a href="https://secrets-store-csi-driver.sigs.k8s.io/topics/secret-auto-rotation" rel="nofollow" target="_blank">Secrets Store CSI 드라이버 공식 홈페이지 - 시크릿 자동 회전</a></li>
<li><a href="https://github.com/kubernetes-sigs/secrets-store-csi-driver/blob/main/charts/secrets-store-csi-driver/values.yaml" rel="nofollow" target="_blank">Secrets Store CSI 드라이버 차트 값 설정 파일</a></li>
<li><a href="https://github.com/stakater/Reloader/tree/master" rel="nofollow" target="_blank">Reloader GitHub 저장소</a></li>
<li><a href="https://github.com/stakater/Reloader/blob/master/docs/Verify-Reloader-Working.md" rel="nofollow" target="_blank">Reloader 작동 확인 문서</a></li>
<li><a href="https://github.com/stakater/Reloader/blob/master/docs/How-it-works.md" rel="nofollow" target="_blank">Reloader 작동 방식 문서</a></li>
</ul>
<h1>간단히 말하자면 🚀</h1>
<p>In Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 계속 참여해 주세요:</p>
<p></p>
<ul>
<li>작가에게 박수를 보내고 팔로우를 눌러주세요 ️👏️️</li>
<li>팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter</li>
<li>다른 플랫폼에서 저희를 만나보세요: Stackademic | CoFeed | Venture | Cubed</li>
<li>알고리즘 콘텐츠를 다뤄야 하는 블로그 플랫폼에 지쳤나요? Differ를 시도해보세요</li>
<li>PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Kubernetes K8s ConfigMap 또는 Secret가 업데이트될 때 배포 자동 재시작하기","description":"","date":"2024-06-19 13:11","slug":"2024-06-19-KubernetesAutoRestartDeploymentswhenK8sConfigMaporSecretisUpdated","content":"\n## 자동 롤아웃 재시작: K8s ConfigMap 또는 Secret가 업데이트될 때 배포 다시 시작하기\n\n쿠버네티스 배포는 모든 쿠버네티스 클러스터에서 가장 일반적인 리소스 중 하나입니다. 우리는 모두 pod를 K8s 배포를 사용하여 실행하여 높은 가용성을 보장하고, pod가 삭제되면 자동으로 생성되도록합니다.\n\n애플리케이션이 항상 여러 환경에서 원활하게 실행되도록하기 위해 구성이 필요한 것은 매우 흔합니다. 데이터베이스 사용자 이름, 비밀번호 등과 같은 중요한 정보가 필요할 수도 있습니다. 쿠버네티스에서는 구성 맵과 시크릿을 사용하여 응용 프로그램별 데이터를 저장하고 pod로 주입하여 응용 프로그램에서 사용할 수 있도록 할 수 있습니다.\n\n그렇다면 구성 맵이나 시크릿의 값을 업데이트했을 때는 어떨까요? 최신 값을 반영하려면 pod를 다시 시작해야합니다, 맞죠? 또는 롤아웃을 다시 시작하여 새로운 pod를 생성하게 할 수도 있습니다. 이제 상상해보세요. 공통 configmap 또는 secret을 사용하는 수백 개의 배포가 있고 그 값을 업데이트하고 사용하는 것이 최신 값이라는 것을 확실하게 해야한다고 가정해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희는 AWS Secrets Manager에 비밀을 저장하고, Kubernetes Secrets Store CSI Driver를 위해 AWS Secrets 및 구성 제공자(ASCP)로부터 Kubernetes Secrets를 생성합니다.\n\n이 블로그 게시물에서는 Secret 또는 ConfigMap이 업데이트될 때 Kubernetes 배포를 자동으로 롤아웃 및 다시 시작하는 방법에 대해 설명하겠습니다.\n\n# 아키텍처 다이어그램:\n\n![Architecture Diagram](/assets/img/2024-06-19-KubernetesAutoRestartDeploymentswhenK8sConfigMaporSecretisUpdated_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 시작해 봅시다!\n\n### 준비물:\n\n- EKS 클러스터\n- EKS를 위한 OIDC 제공자 구성 필요\n- Kubectl\n- AWS CLI\n\n### 단계 1: ASCP를 위한 IAM 역할 및 정책 생성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nASCP(Amazon EKS Security Token Service)는 Amazon EKS 파드 ID를 검색하여 IAM 역할로 교환합니다. 해당 IAM 역할에 대한 IAM 정책에서 권한을 설정합니다. ASCP가 IAM 역할을 가정하면 권한을 부여받은 시크릿에 액세스할 수 있습니다. 다른 컨테이너는 IAM 역할과 연결되지 않는 한 시크릿에 액세스할 수 없습니다.\n\n- IAM 정책 문서 작성\n  \"secrets_policy\"라는 이름의 파일을 만들고 다음 내용을 추가하십시오.\n\n```js\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"secretsmanager:DescribeSecret\",\n                \"secretsmanager:GetSecretValue\"\n            ],\n            \"Effect\": \"Allow\",\n            \"Resource\": \"*\"\n        }\n}\n```\n\n2. 다음 명령을 실행하여 IAM 정책을 만듭니다.\n   IAM 정책을 IAM 역할에 연결할 때 policy ARN을 메모하십시오.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\naws iam create-policy \\\n    --policy-name my-secret-manager-policy \\\n    --policy-document file://secrets_policy\n```\n\n3. IAM 역할에 신뢰 정책 생성하기\n   \"trust_policy\"라는 이름의 파일을 생성하고 다음 내용을 추가하세요. 올바른 값으로 대체해야 합니다. `SERVICE_ACCOUNT_NAME`은 임의로 지정할 수 있지만 Kubernetes에서 실제 서비스 계정을 생성할 때 동일한 이름을 사용해야 합니다.\n\n```js\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": \"sts:AssumeRoleWithWebIdentity\",\n      \"Principal\": {\n        \"Federated\": \"arn:aws:iam::\u003cAWS_ACCOUNT_ID\u003e:oidc-provider/oidc.eks.\u003cAWS_REGION\u003e.amazonaws.com/id/\u003cOIDC_ID\u003e\"\n      },\n      \"Condition\": {\n        \"StringEquals\": {\n          \"oidc.eks.\u003cAWS_REGION\u003e.amazonaws.com/id/\u003cOIDC_ID\u003e:aud\": \"sts.amazonaws.com\",\n          \"oidc.eks.\u003cAWS_REGION\u003e.amazonaws.com/id/\u003cOIDC_ID\u003e:sub\": \"system:serviceaccount:\u003cK8S_NAMESPACE\u003e:\u003cSERVICE_ACCOUNT_NAME\u003e\"\n        }\n      }\n    }\n  ]\n}\n```\n\n4. 다음 명령어를 실행하여 IAM 역할을 만드세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\naws iam create-role --role-name my-secret-manager-role --assume-role-policy-document file://trust_policy\n```\n\n5. Attach IAM policy to IAM Role\n\n```js\naws iam attach-role-policy --policy-arn \u003cyour_policy_arn\u003e --role-name my-secret-manager-role\n```\n\n우리는 필요한 모든 IAM 역할과 정책을 생성했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계 2: ASCP 설치 및 구성\n\n이제 2개의 Helm 차트를 설치해야 합니다.\n\n- AWS Secrets and Configuration Provider (ASCP) 차트 설치\n\n```js\n# ASCP Helm 차트 리포지토리 추가\nhelm repo add aws-secrets-manager https://aws.github.io/secrets-store-csi-driver-provider-aws\n\n# ASCP Helm 차트 설치\nhelm install -n kube-system secrets-provider-aws aws-secrets-manager/secrets-store-csi-driver-provider-aws\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. Secrets Store CSI Driver 차트 설치\n\n- Secrets Store CSI Driver 차트를 위한 helm 레포지토리 추가\n\n```js\n# Secrets Store CSI Driver 차트 레포지토리 추가\nhelm repo add secrets-store-csi-driver https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts\n```\n\n- 기본값 확인\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 기본 값 가져오기\n\nhelm show values secrets-store-csi-driver/secrets-store-csi-driver \u003e secrets-store-csi-driver.yaml\n\n- secrets-store-csi-driver.yaml 파일에서 다음 값을 업데이트하세요.\n\n## K8S Secrets 동기화에 필요한 RBAC 역할 및 바인딩 설치 여부\n\nsyncSecret:\nenabled: true\n\n## 시크릿 로테이션 기능 활성화 [알파]\n\nenableSecretRotation: true\n\n위의 구성은 \"secrets-store-csi-driver\"가 AWS Secret Manager에서 최신 값을 가져와 해당 값을 Kubernetes Secrets 객체에 업데이트할 수 있게 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n회전-투표-간격은 기본적으로 2분으로 설정되어 있지만, 속성 rotationPollInterval을 설정함으로써 변경할 수 있습니다.\n\n- Helm 차트 설치\n\n```js\n# Helm 차트 설치\nhelm install -n kube-system csi-secrets-store secrets-store-csi-driver/secrets-store-csi-driver -f secrets-store-csi-driver.yaml\n```\n\n# 단계 3: AWS Secret Manager에 테스트 시크릿 생성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAWS Secret Manager에서 테스트 시크릿을 생성할 것입니다.\n\n```js\naws secretsmanager create-secret \\\n    --name my-test-secret \\\n    --description \"CLI로 생성한 내 테스트 시크릿.\" \\\n    --secret-string \"{\\\"user\\\":\\\"my-user\\\",\\\"password\\\":\\\"예시-비밀번호\\\"}\"\n```\n\n# 단계 4: Kubernetes ServiceAccount 생성\n\n이제 IAM 역할을 가정할 수 있도록 파드에 허용하는 ServiceAccount를 생성할 수 있습니다. 이 ServiceAccount는 K8s 배포에서 사용될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nserviceaccount.yaml이라는 이름의 파일을 생성해주세요.\n\n```yaml\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: \u003cyour_service_account_name\u003e # 이 이름은 IAM 신뢰 정책을 만들 때 지정한 이름과 일치해야 합니다.\n  annotations:\n    eks.amazonaws.com/role-arn: \u003cIAM_ROLE_ARN\u003e\n```\n\n다음 명령을 실행하여 K8s에서 서비스 계정을 생성합니다.\n\n```bash\nkubectl apply -f serviceaccount.yaml\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계 5: 테스트 객체 생성하기\n\n이제 필요한 모든 리소스를 배포했습니다. 이제 테스트 객체를 만들어 봅시다.\n\n- 이름이 “my-test-secret-manifest.yaml”인 파일 생성\n\n```js\n---\napiVersion: secrets-store.csi.x-k8s.io/v1\nkind: SecretProviderClass\nmetadata:\n  name: aws-secrets-providerclass\nspec:\n  provider: aws\n  secretObjects:\n    - secretName: my-test-k8s-secret\n      type: Opaque\n      data:\n        - objectName: user\n          key: user\n        - objectName: password\n          key: password\n  parameters:\n    objects: |\n      - objectName: arn:aws:secretsmanager:\u003cAWS_REGION\u003e:\u003cAWS_ACCOUNT_ID\u003e:secret:my-test-secret\n        jmesPath:\n          - path: user\n            objectAlias: user\n          - path: password\n            objectAlias: password\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: secret-rotation-test-ubuntu-deployment\n  labels:\n    app: ubuntu\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: ubuntu\n  template:\n    metadata:\n      labels:\n        app: ubuntu\n    spec:\n      serviceAccountName: \u003cyour_service_account_name\u003e # 이 이름은 단계 4에서 만든 서비스 계정 이름과 일치해야 합니다\n      volumes:\n      - name: mount-secrets-access\n        csi:\n          driver: secrets-store.csi.k8s.io\n          readOnly: true\n          volumeAttributes:\n            secretProviderClass: \"aws-secrets-providerclass\"\n      containers:\n      - name: ubuntu\n        image: ubuntu\n        command: [\"sleep\", \"123456\"]\n        env:\n        - name: USER\n          valueFrom:\n            secretKeyRef:\n              name: my-test-k8s-secret\n              key: user\n        - name: PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: my-test-k8s-secret\n              key: password\n        volumeMounts:\n        - name: mount-secrets-access\n          mountPath: \"/mnt/aws-secrets\"\n          readOnly: true\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. manifest를 적용하십시오\n\n```js\nkubectl apply -f my-test-secret-manifest.yaml\n```\n\n3. 다음 리소스가 생성됩니다.\n\n- SecretProviderClass 리소스 - AWS Secret Manager에서 데이터를 가져와 K8s Secret를 생성합니다\n- 볼륨 마운트가 있는 배포 - SecretProviderClass를 볼륨으로 마운트해야 합니다\n- Kubernetes Secret - 파드 내에서 환경 변수로 주입됩니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 다이어그램은 YAML을 적용할 때 뒷단에서 무슨 일이 벌어지는지 잘 시각화한 것입니다.\n\n![다이어그램](/assets/img/2024-06-19-KubernetesAutoRestartDeploymentswhenK8sConfigMaporSecretisUpdated_1.png)\n\n4. 모든 것이 배포되었는지 확인해보세요.\n\n```js\n# SecretProviderClass 확인\nkubectl get SecretProviderClass aws-secrets-providerclass -o yaml\n\n# 배포 확인\nkubectl get deploy secret-rotation-test-ubuntu-deployment -o yaml\n\n# Pod 확인\nkubectl get po \u003cpod_name\u003e -o yaml\n\n# Secret 가져오기\nkubectl get secret my-test-k8s-secret -o yaml\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계 6: Reloader 설치하기\n\nReloader는 ConfigMap과 Secret의 변경 사항을 감지하고 관련된 DeploymentConfig, Deployment, DaemonSet, StatefulSet 및 Rollout과 함께 Pod의 롤링 업그레이드를 수행할 수 있습니다.\n\n- Reloader Helm Repo 추가\n\n```js\n# Helm Repo 추가\nhelm repo add stakater https://stakater.github.io/stakater-charts\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. 기본값 가져오기\n\n```js\n# 기본값 가져오기\nhelm show values stakater/reloader \u003e reloader.yaml\n```\n\n3. reloader.yaml 파일 업데이트하기\n\n```js\nreloader:\n  # 리더십 선출을 활성화하려면 true로 설정하여 여러 레플리카를 실행할 수 있습니다.\n  enableHA: true\n  deployment:\n    # 여러 레플리카를 실행하려면 reloader.enableHA = true로 설정합니다.\n    replicas: 2\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n4. Helm 차트 설치\n\n```js\n# Helm 차트 설치\nhelm install reloader -f reloader.yaml stakater/reloader -n kube-system\n```\n\n# 단계 7: Secret 업데이트로 테스트하기\n\n- Reloader는 주석에 영향을 받습니다.\n  기본 주석 reloader.stakater.com/auto는 주요 메타데이터에 있어야 합니다. 아래 명령을 사용하여 배포에 주석을 추가하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 배포 주석 추가\nkubectl annotate deployment secret-rotation-test-ubuntu-deployment \"reloader.stakater.com/auto=true\"\n```\n\n또는 다음 블록으로 배포 파일을 편집하고 적용할 수도 있습니다.\n\n```js\nmetadata:\n  annotations:\n    reloader.stakater.com/auto: \"true\"\n```\n\n2. AWS Secret Manager에서 시크릿 업데이트하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\naws secretsmanager put-secret-value \\\n      --secret-id my-test-secret \\\n      --secret-string \"{\\\"user\\\":\\\"diegor\\\",\\\"password\\\":\\\"SAMPLE-PASSWORD\\\"}\"\n```\n\n3. 한 번 시크릿이 AWS 시크릿 스토어 csi 드라이버에 업데이트되면 K8s 시크릿이 즉시 업데이트됩니다. K8s 시크릿이 업데이트되면 Reloader가 롤아웃을 다시 시작하도록 트리거합니다.\n\n```js\n# K8s 시크릿을 확인하세요. 새로운 값이 있어야 합니다.\nkubectl get secret my-test-k8s-secret -o yaml\n\n# Pod를 확인하세요. 몇 초 전에 시작되었어야 합니다.\nkubectl get po\n\n# Reloader 팟의 로그를 확인하세요.\nkubectl logs \u003creloader-pod-name\u003e -n kube-system\n\n# Pod로 실행 후 새로운 값을 확인하세요.\nkubectl exec -it \u003cpod_name\u003e -- bash\n\n# Pod에 들어간 후 `env` 명령을 실행하세요. Pod에서 사용 가능한 모든 환경 변수가 출력됩니다.\n```\n\n# 단계 8: ConfigMap 업데이트를 테스트하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- \"my-test-cm-manifest.yaml\" 파일을 생성해주세요.\n\n```yaml\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: my-test-k8s-cm\ndata:\n  myvalue: \"Hello World\"\n  drink: coffee\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: reloader-poc-ubuntu-deployment\n  labels:\n    app: ubuntu\n  annotations:\n    reloader.stakater.com/auto: \"true\"\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: ubuntu\n  template:\n    metadata:\n      labels:\n        app: ubuntu\n    spec:\n      containers:\n        - name: ubuntu\n          image: ubuntu\n          command: [\"sleep\", \"123456\"]\n          env:\n            - name: DRINK\n              valueFrom:\n                configMapKeyRef:\n                  name: my-test-k8s-cm\n                  key: drink\n            - name: MYVALUE\n              valueFrom:\n                configMapKeyRef:\n                  name: my-test-k8s-cm\n                  key: myvalue\n```\n\n2. 매니페스트 적용\n\n```bash\nkubectl apply -f my-test-cm-manifest.yaml\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. my-test-cm-manifest.yaml 파일에서 configmap을 업데이트하세요.\n\n```yaml\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: my-test-k8s-cm\ndata:\n  myvalue: \"안녕하세요\"\n  drink: 차\n```\n\n4. 파일을 다시 적용하세요.\n\n```yaml\nkubectl apply -f my-test-cm-manifest.yaml\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n5. 확인\n\n```js\n# ConfigMap 확인\nkubectl get cm my-test-k8s-cm -o yaml\n\n# Pod 확인\nkubectl get po\n\n# Pod에 접속하여 새 값 확인\nkubectl exec -it \u003cpod_name\u003e -- bash\n\n# Pod에 들어간 후 `env` 명령어를 실행하면 Pod 내에서 사용 가능한 모든 환경 변수가 출력됩니다\n```\n\n축하합니다!!! secret-store-csi-driver와 reloader를 성공적으로 구성했습니다.\n\n감사합니다!!!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 참고 자료:\n\n- [AWS 공식 문서 - CSI 드라이버 통합](https://docs.aws.amazon.com/secretsmanager/latest/userguide/integrating_csi_driver.html)\n- [Bootlabs 기술 블로그 - AWS Secrets Manager in Kubernetes 시크릿 회전과 리로더](https://blog.bootlabstech.com/aws-secrets-manager-in-kubernetes-secret-rotation-and-reloader)\n- [Secrets Store CSI 드라이버 공식 홈페이지 - 시크릿 자동 회전](https://secrets-store-csi-driver.sigs.k8s.io/topics/secret-auto-rotation)\n- [Secrets Store CSI 드라이버 차트 값 설정 파일](https://github.com/kubernetes-sigs/secrets-store-csi-driver/blob/main/charts/secrets-store-csi-driver/values.yaml)\n- [Reloader GitHub 저장소](https://github.com/stakater/Reloader/tree/master)\n- [Reloader 작동 확인 문서](https://github.com/stakater/Reloader/blob/master/docs/Verify-Reloader-Working.md)\n- [Reloader 작동 방식 문서](https://github.com/stakater/Reloader/blob/master/docs/How-it-works.md)\n\n# 간단히 말하자면 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 계속 참여해 주세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 작가에게 박수를 보내고 팔로우를 눌러주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼에서 저희를 만나보세요: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다뤄야 하는 블로그 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요\n","ogImage":{"url":"/assets/img/2024-06-19-KubernetesAutoRestartDeploymentswhenK8sConfigMaporSecretisUpdated_0.png"},"coverImage":"/assets/img/2024-06-19-KubernetesAutoRestartDeploymentswhenK8sConfigMaporSecretisUpdated_0.png","tag":["Tech"],"readingTime":19},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e자동 롤아웃 재시작: K8s ConfigMap 또는 Secret가 업데이트될 때 배포 다시 시작하기\u003c/h2\u003e\n\u003cp\u003e쿠버네티스 배포는 모든 쿠버네티스 클러스터에서 가장 일반적인 리소스 중 하나입니다. 우리는 모두 pod를 K8s 배포를 사용하여 실행하여 높은 가용성을 보장하고, pod가 삭제되면 자동으로 생성되도록합니다.\u003c/p\u003e\n\u003cp\u003e애플리케이션이 항상 여러 환경에서 원활하게 실행되도록하기 위해 구성이 필요한 것은 매우 흔합니다. 데이터베이스 사용자 이름, 비밀번호 등과 같은 중요한 정보가 필요할 수도 있습니다. 쿠버네티스에서는 구성 맵과 시크릿을 사용하여 응용 프로그램별 데이터를 저장하고 pod로 주입하여 응용 프로그램에서 사용할 수 있도록 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그렇다면 구성 맵이나 시크릿의 값을 업데이트했을 때는 어떨까요? 최신 값을 반영하려면 pod를 다시 시작해야합니다, 맞죠? 또는 롤아웃을 다시 시작하여 새로운 pod를 생성하게 할 수도 있습니다. 이제 상상해보세요. 공통 configmap 또는 secret을 사용하는 수백 개의 배포가 있고 그 값을 업데이트하고 사용하는 것이 최신 값이라는 것을 확실하게 해야한다고 가정해보세요.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e저희는 AWS Secrets Manager에 비밀을 저장하고, Kubernetes Secrets Store CSI Driver를 위해 AWS Secrets 및 구성 제공자(ASCP)로부터 Kubernetes Secrets를 생성합니다.\u003c/p\u003e\n\u003cp\u003e이 블로그 게시물에서는 Secret 또는 ConfigMap이 업데이트될 때 Kubernetes 배포를 자동으로 롤아웃 및 다시 시작하는 방법에 대해 설명하겠습니다.\u003c/p\u003e\n\u003ch1\u003e아키텍처 다이어그램:\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-KubernetesAutoRestartDeploymentswhenK8sConfigMaporSecretisUpdated_0.png\" alt=\"Architecture Diagram\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e시작해 봅시다!\u003c/h2\u003e\n\u003ch3\u003e준비물:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eEKS 클러스터\u003c/li\u003e\n\u003cli\u003eEKS를 위한 OIDC 제공자 구성 필요\u003c/li\u003e\n\u003cli\u003eKubectl\u003c/li\u003e\n\u003cli\u003eAWS CLI\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e단계 1: ASCP를 위한 IAM 역할 및 정책 생성\u003c/h3\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eASCP(Amazon EKS Security Token Service)는 Amazon EKS 파드 ID를 검색하여 IAM 역할로 교환합니다. 해당 IAM 역할에 대한 IAM 정책에서 권한을 설정합니다. ASCP가 IAM 역할을 가정하면 권한을 부여받은 시크릿에 액세스할 수 있습니다. 다른 컨테이너는 IAM 역할과 연결되지 않는 한 시크릿에 액세스할 수 없습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIAM 정책 문서 작성\n\"secrets_policy\"라는 이름의 파일을 만들고 다음 내용을 추가하십시오.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{\n    \u003cspan class=\"hljs-string\"\u003e\"Version\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"2012-10-17\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"Statement\"\u003c/span\u003e: [\n        {\n            \u003cspan class=\"hljs-string\"\u003e\"Action\"\u003c/span\u003e: [\n                \u003cspan class=\"hljs-string\"\u003e\"secretsmanager:DescribeSecret\"\u003c/span\u003e,\n                \u003cspan class=\"hljs-string\"\u003e\"secretsmanager:GetSecretValue\"\u003c/span\u003e\n            ],\n            \u003cspan class=\"hljs-string\"\u003e\"Effect\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Allow\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"Resource\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"*\"\u003c/span\u003e\n        }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e다음 명령을 실행하여 IAM 정책을 만듭니다.\nIAM 정책을 IAM 역할에 연결할 때 policy ARN을 메모하십시오.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eaws iam create-policy \\\n    --policy-name my-secret-manager-policy \\\n    --policy-\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efile\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//secrets_policy\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eIAM 역할에 신뢰 정책 생성하기\n\"trust_policy\"라는 이름의 파일을 생성하고 다음 내용을 추가하세요. 올바른 값으로 대체해야 합니다. \u003ccode\u003eSERVICE_ACCOUNT_NAME\u003c/code\u003e은 임의로 지정할 수 있지만 Kubernetes에서 실제 서비스 계정을 생성할 때 동일한 이름을 사용해야 합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{\n  \u003cspan class=\"hljs-string\"\u003e\"Version\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"2012-10-17\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"Statement\"\u003c/span\u003e: [\n    {\n      \u003cspan class=\"hljs-string\"\u003e\"Effect\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Allow\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-string\"\u003e\"Action\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"sts:AssumeRoleWithWebIdentity\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-string\"\u003e\"Principal\"\u003c/span\u003e: {\n        \u003cspan class=\"hljs-string\"\u003e\"Federated\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"arn:aws:iam::\u0026#x3C;AWS_ACCOUNT_ID\u003e:oidc-provider/oidc.eks.\u0026#x3C;AWS_REGION\u003e.amazonaws.com/id/\u0026#x3C;OIDC_ID\u003e\"\u003c/span\u003e\n      },\n      \u003cspan class=\"hljs-string\"\u003e\"Condition\"\u003c/span\u003e: {\n        \u003cspan class=\"hljs-string\"\u003e\"StringEquals\"\u003c/span\u003e: {\n          \u003cspan class=\"hljs-string\"\u003e\"oidc.eks.\u0026#x3C;AWS_REGION\u003e.amazonaws.com/id/\u0026#x3C;OIDC_ID\u003e:aud\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"sts.amazonaws.com\"\u003c/span\u003e,\n          \u003cspan class=\"hljs-string\"\u003e\"oidc.eks.\u0026#x3C;AWS_REGION\u003e.amazonaws.com/id/\u0026#x3C;OIDC_ID\u003e:sub\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"system:serviceaccount:\u0026#x3C;K8S_NAMESPACE\u003e:\u0026#x3C;SERVICE_ACCOUNT_NAME\u003e\"\u003c/span\u003e\n        }\n      }\n    }\n  ]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e다음 명령어를 실행하여 IAM 역할을 만드세요.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eaws iam create-role --role-name my-secret-manager-role --assume-role-policy-\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efile\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//trust_policy\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003eAttach IAM policy to IAM Role\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eaws iam attach-role-policy --policy-arn \u0026#x3C;your_policy_arn\u003e --role-name my-secret-manager-role\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 필요한 모든 IAM 역할과 정책을 생성했습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003e단계 2: ASCP 설치 및 구성\u003c/h1\u003e\n\u003cp\u003e이제 2개의 Helm 차트를 설치해야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAWS Secrets and Configuration Provider (ASCP) 차트 설치\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-variable constant_\"\u003eASCP\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHelm\u003c/span\u003e 차트 리포지토리 추가\nhelm repo add aws-secrets-manager \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//aws.github.io/secrets-store-csi-driver-provider-aws\u003c/span\u003e\n\n# \u003cspan class=\"hljs-variable constant_\"\u003eASCP\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHelm\u003c/span\u003e 차트 설치\nhelm install -n kube-system secrets-provider-aws aws-secrets-manager/secrets-store-csi-driver-provider-aws\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eSecrets Store CSI Driver 차트 설치\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eSecrets Store CSI Driver 차트를 위한 helm 레포지토리 추가\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eSecrets\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStore\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCSI\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDriver\u003c/span\u003e 차트 레포지토리 추가\nhelm repo add secrets-store-csi-driver \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//kubernetes-sigs.github.io/secrets-store-csi-driver/charts\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e기본값 확인\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003e기본 값 가져오기\u003c/h1\u003e\n\u003cp\u003ehelm show values secrets-store-csi-driver/secrets-store-csi-driver \u003e secrets-store-csi-driver.yaml\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003esecrets-store-csi-driver.yaml 파일에서 다음 값을 업데이트하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eK8S Secrets 동기화에 필요한 RBAC 역할 및 바인딩 설치 여부\u003c/h2\u003e\n\u003cp\u003esyncSecret:\nenabled: true\u003c/p\u003e\n\u003ch2\u003e시크릿 로테이션 기능 활성화 [알파]\u003c/h2\u003e\n\u003cp\u003eenableSecretRotation: true\u003c/p\u003e\n\u003cp\u003e위의 구성은 \"secrets-store-csi-driver\"가 AWS Secret Manager에서 최신 값을 가져와 해당 값을 Kubernetes Secrets 객체에 업데이트할 수 있게 합니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e회전-투표-간격은 기본적으로 2분으로 설정되어 있지만, 속성 rotationPollInterval을 설정함으로써 변경할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHelm 차트 설치\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eHelm\u003c/span\u003e 차트 설치\nhelm install -n kube-system csi-secrets-store secrets-store-csi-driver/secrets-store-csi-driver -f secrets-store-csi-driver.\u003cspan class=\"hljs-property\"\u003eyaml\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e단계 3: AWS Secret Manager에 테스트 시크릿 생성\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eAWS Secret Manager에서 테스트 시크릿을 생성할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eaws secretsmanager create-secret \\\n    --name my-test-secret \\\n    --description \u003cspan class=\"hljs-string\"\u003e\"CLI로 생성한 내 테스트 시크릿.\"\u003c/span\u003e \\\n    --secret-string \u003cspan class=\"hljs-string\"\u003e\"{\\\"user\\\":\\\"my-user\\\",\\\"password\\\":\\\"예시-비밀번호\\\"}\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e단계 4: Kubernetes ServiceAccount 생성\u003c/h1\u003e\n\u003cp\u003e이제 IAM 역할을 가정할 수 있도록 파드에 허용하는 ServiceAccount를 생성할 수 있습니다. 이 ServiceAccount는 K8s 배포에서 사용될 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eserviceaccount.yaml이라는 이름의 파일을 생성해주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-attr\"\u003eapiVersion:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ev1\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003ekind:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eServiceAccount\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003emetadata:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;your_service_account_name\u003e\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e# 이 이름은 IAM 신뢰 정책을 만들 때 지정한 이름과 일치해야 합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eannotations:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eeks.amazonaws.com/role-arn:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;IAM_ROLE_ARN\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음 명령을 실행하여 K8s에서 서비스 계정을 생성합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003ekubectl apply -f serviceaccount.yaml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003e단계 5: 테스트 객체 생성하기\u003c/h1\u003e\n\u003cp\u003e이제 필요한 모든 리소스를 배포했습니다. 이제 테스트 객체를 만들어 봅시다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이름이 “my-test-secret-manifest.yaml”인 파일 생성\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e---\n\u003cspan class=\"hljs-attr\"\u003eapiVersion\u003c/span\u003e: secrets-store.\u003cspan class=\"hljs-property\"\u003ecsi\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ex\u003c/span\u003e-k8s.\u003cspan class=\"hljs-property\"\u003eio\u003c/span\u003e/v1\n\u003cspan class=\"hljs-attr\"\u003ekind\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSecretProviderClass\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003emetadata\u003c/span\u003e:\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: aws-secrets-provider\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003espec\u003c/span\u003e:\n  \u003cspan class=\"hljs-attr\"\u003eprovider\u003c/span\u003e: aws\n  \u003cspan class=\"hljs-attr\"\u003esecretObjects\u003c/span\u003e:\n    - \u003cspan class=\"hljs-attr\"\u003esecretName\u003c/span\u003e: my-test-k8s-secret\n      \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eOpaque\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e:\n        - \u003cspan class=\"hljs-attr\"\u003eobjectName\u003c/span\u003e: user\n          \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: user\n        - \u003cspan class=\"hljs-attr\"\u003eobjectName\u003c/span\u003e: password\n          \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: password\n  \u003cspan class=\"hljs-attr\"\u003eparameters\u003c/span\u003e:\n    \u003cspan class=\"hljs-attr\"\u003eobjects\u003c/span\u003e: |\n      - \u003cspan class=\"hljs-attr\"\u003eobjectName\u003c/span\u003e: \u003cspan class=\"hljs-attr\"\u003earn\u003c/span\u003e:\u003cspan class=\"hljs-attr\"\u003eaws\u003c/span\u003e:\u003cspan class=\"hljs-attr\"\u003esecretsmanager\u003c/span\u003e:\u0026#x3C;\u003cspan class=\"hljs-variable constant_\"\u003eAWS_REGION\u003c/span\u003e\u003e:\u0026#x3C;\u003cspan class=\"hljs-variable constant_\"\u003eAWS_ACCOUNT_ID\u003c/span\u003e\u003e:\u003cspan class=\"hljs-attr\"\u003esecret\u003c/span\u003e:my-test-secret\n        \u003cspan class=\"hljs-attr\"\u003ejmesPath\u003c/span\u003e:\n          - \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: user\n            \u003cspan class=\"hljs-attr\"\u003eobjectAlias\u003c/span\u003e: user\n          - \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: password\n            \u003cspan class=\"hljs-attr\"\u003eobjectAlias\u003c/span\u003e: password\n---\n\u003cspan class=\"hljs-attr\"\u003eapiVersion\u003c/span\u003e: apps/v1\n\u003cspan class=\"hljs-attr\"\u003ekind\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDeployment\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003emetadata\u003c/span\u003e:\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: secret-rotation-test-ubuntu-deployment\n  \u003cspan class=\"hljs-attr\"\u003elabels\u003c/span\u003e:\n    \u003cspan class=\"hljs-attr\"\u003eapp\u003c/span\u003e: ubuntu\n\u003cspan class=\"hljs-attr\"\u003espec\u003c/span\u003e:\n  \u003cspan class=\"hljs-attr\"\u003ereplicas\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e:\n    \u003cspan class=\"hljs-attr\"\u003ematchLabels\u003c/span\u003e:\n      \u003cspan class=\"hljs-attr\"\u003eapp\u003c/span\u003e: ubuntu\n  \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e:\n    \u003cspan class=\"hljs-attr\"\u003emetadata\u003c/span\u003e:\n      \u003cspan class=\"hljs-attr\"\u003elabels\u003c/span\u003e:\n        \u003cspan class=\"hljs-attr\"\u003eapp\u003c/span\u003e: ubuntu\n    \u003cspan class=\"hljs-attr\"\u003espec\u003c/span\u003e:\n      \u003cspan class=\"hljs-attr\"\u003eserviceAccountName\u003c/span\u003e: \u0026#x3C;your_service_account_name\u003e # 이 이름은 단계 \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e에서 만든 서비스 계정 이름과 일치해야 합니다\n      \u003cspan class=\"hljs-attr\"\u003evolumes\u003c/span\u003e:\n      - \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: mount-secrets-access\n        \u003cspan class=\"hljs-attr\"\u003ecsi\u003c/span\u003e:\n          \u003cspan class=\"hljs-attr\"\u003edriver\u003c/span\u003e: secrets-store.\u003cspan class=\"hljs-property\"\u003ecsi\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ek8s\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eio\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003ereadOnly\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003evolumeAttributes\u003c/span\u003e:\n            \u003cspan class=\"hljs-attr\"\u003esecretProviderClass\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"aws-secrets-providerclass\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003econtainers\u003c/span\u003e:\n      - \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: ubuntu\n        \u003cspan class=\"hljs-attr\"\u003eimage\u003c/span\u003e: ubuntu\n        \u003cspan class=\"hljs-attr\"\u003ecommand\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"sleep\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"123456\"\u003c/span\u003e]\n        \u003cspan class=\"hljs-attr\"\u003eenv\u003c/span\u003e:\n        - \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eUSER\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003evalueFrom\u003c/span\u003e:\n            \u003cspan class=\"hljs-attr\"\u003esecretKeyRef\u003c/span\u003e:\n              \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: my-test-k8s-secret\n              \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: user\n        - \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003ePASSWORD\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003evalueFrom\u003c/span\u003e:\n            \u003cspan class=\"hljs-attr\"\u003esecretKeyRef\u003c/span\u003e:\n              \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: my-test-k8s-secret\n              \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: password\n        \u003cspan class=\"hljs-attr\"\u003evolumeMounts\u003c/span\u003e:\n        - \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: mount-secrets-access\n          \u003cspan class=\"hljs-attr\"\u003emountPath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"/mnt/aws-secrets\"\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003ereadOnly\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003emanifest를 적용하십시오\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekubectl apply -f my-test-secret-manifest.\u003cspan class=\"hljs-property\"\u003eyaml\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e다음 리소스가 생성됩니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eSecretProviderClass 리소스 - AWS Secret Manager에서 데이터를 가져와 K8s Secret를 생성합니다\u003c/li\u003e\n\u003cli\u003e볼륨 마운트가 있는 배포 - SecretProviderClass를 볼륨으로 마운트해야 합니다\u003c/li\u003e\n\u003cli\u003eKubernetes Secret - 파드 내에서 환경 변수로 주입됩니다\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e아래 다이어그램은 YAML을 적용할 때 뒷단에서 무슨 일이 벌어지는지 잘 시각화한 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-KubernetesAutoRestartDeploymentswhenK8sConfigMaporSecretisUpdated_1.png\" alt=\"다이어그램\"\u003e\u003c/p\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e모든 것이 배포되었는지 확인해보세요.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eSecretProviderClass\u003c/span\u003e 확인\nkubectl get \u003cspan class=\"hljs-title class_\"\u003eSecretProviderClass\u003c/span\u003e aws-secrets-providerclass -o yaml\n\n# 배포 확인\nkubectl get deploy secret-rotation-test-ubuntu-deployment -o yaml\n\n# \u003cspan class=\"hljs-title class_\"\u003ePod\u003c/span\u003e 확인\nkubectl get po \u0026#x3C;pod_name\u003e -o yaml\n\n# \u003cspan class=\"hljs-title class_\"\u003eSecret\u003c/span\u003e 가져오기\nkubectl get secret my-test-k8s-secret -o yaml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003e단계 6: Reloader 설치하기\u003c/h1\u003e\n\u003cp\u003eReloader는 ConfigMap과 Secret의 변경 사항을 감지하고 관련된 DeploymentConfig, Deployment, DaemonSet, StatefulSet 및 Rollout과 함께 Pod의 롤링 업그레이드를 수행할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eReloader Helm Repo 추가\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eHelm\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRepo\u003c/span\u003e 추가\nhelm repo add stakater \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//stakater.github.io/stakater-charts\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e기본값 가져오기\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 기본값 가져오기\nhelm show values stakater/reloader \u003e reloader.\u003cspan class=\"hljs-property\"\u003eyaml\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003ereloader.yaml 파일 업데이트하기\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003ereloader\u003c/span\u003e:\n  # 리더십 선출을 활성화하려면 \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e로 설정하여 여러 레플리카를 실행할 수 있습니다.\n  \u003cspan class=\"hljs-attr\"\u003eenableHA\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003edeployment\u003c/span\u003e:\n    # 여러 레플리카를 실행하려면 reloader.\u003cspan class=\"hljs-property\"\u003eenableHA\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e로 설정합니다.\n    \u003cspan class=\"hljs-attr\"\u003ereplicas\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003eHelm 차트 설치\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eHelm\u003c/span\u003e 차트 설치\nhelm install reloader -f reloader.\u003cspan class=\"hljs-property\"\u003eyaml\u003c/span\u003e stakater/reloader -n kube-system\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e단계 7: Secret 업데이트로 테스트하기\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eReloader는 주석에 영향을 받습니다.\n기본 주석 reloader.stakater.com/auto는 주요 메타데이터에 있어야 합니다. 아래 명령을 사용하여 배포에 주석을 추가하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 배포 주석 추가\nkubectl annotate deployment secret-rotation-test-ubuntu-deployment \u003cspan class=\"hljs-string\"\u003e\"reloader.stakater.com/auto=true\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또는 다음 블록으로 배포 파일을 편집하고 적용할 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003emetadata\u003c/span\u003e:\n  \u003cspan class=\"hljs-attr\"\u003eannotations\u003c/span\u003e:\n    reloader.\u003cspan class=\"hljs-property\"\u003estakater\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecom\u003c/span\u003e/\u003cspan class=\"hljs-attr\"\u003eauto\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"true\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eAWS Secret Manager에서 시크릿 업데이트하기\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eaws secretsmanager put-secret-value \\\n      --secret-id my-test-secret \\\n      --secret-string \u003cspan class=\"hljs-string\"\u003e\"{\\\"user\\\":\\\"diegor\\\",\\\"password\\\":\\\"SAMPLE-PASSWORD\\\"}\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e한 번 시크릿이 AWS 시크릿 스토어 csi 드라이버에 업데이트되면 K8s 시크릿이 즉시 업데이트됩니다. K8s 시크릿이 업데이트되면 Reloader가 롤아웃을 다시 시작하도록 트리거합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# K8s 시크릿을 확인하세요. 새로운 값이 있어야 합니다.\nkubectl get secret my-test-k8s-secret -o yaml\n\n# \u003cspan class=\"hljs-title class_\"\u003ePod\u003c/span\u003e를 확인하세요. 몇 초 전에 시작되었어야 합니다.\nkubectl get po\n\n# \u003cspan class=\"hljs-title class_\"\u003eReloader\u003c/span\u003e 팟의 로그를 확인하세요.\nkubectl logs \u0026#x3C;reloader-pod-name\u003e -n kube-system\n\n# \u003cspan class=\"hljs-title class_\"\u003ePod\u003c/span\u003e로 실행 후 새로운 값을 확인하세요.\nkubectl exec -it \u0026#x3C;pod_name\u003e -- bash\n\n# \u003cspan class=\"hljs-title class_\"\u003ePod\u003c/span\u003e에 들어간 후 \u003cspan class=\"hljs-string\"\u003e`env`\u003c/span\u003e 명령을 실행하세요. \u003cspan class=\"hljs-title class_\"\u003ePod\u003c/span\u003e에서 사용 가능한 모든 환경 변수가 출력됩니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e단계 8: ConfigMap 업데이트를 테스트하세요.\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\"my-test-cm-manifest.yaml\" 파일을 생성해주세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-meta\"\u003e---\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eapiVersion:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ev1\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003ekind:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eConfigMap\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003emetadata:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003emy-test-k8s-cm\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003emyvalue:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Hello World\"\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003edrink:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecoffee\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e---\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eapiVersion:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eapps/v1\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003ekind:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eDeployment\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003emetadata:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ereloader-poc-ubuntu-deployment\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003elabels:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eapp:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eubuntu\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eannotations:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003ereloader.stakater.com/auto:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"true\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003espec:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ereplicas:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eselector:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003ematchLabels:\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eapp:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eubuntu\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003etemplate:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003emetadata:\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003elabels:\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eapp:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eubuntu\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003espec:\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003econtainers:\u003c/span\u003e\n        \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eubuntu\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eimage:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eubuntu\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003ecommand:\u003c/span\u003e [\u003cspan class=\"hljs-string\"\u003e\"sleep\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"123456\"\u003c/span\u003e]\n          \u003cspan class=\"hljs-attr\"\u003eenv:\u003c/span\u003e\n            \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eDRINK\u003c/span\u003e\n              \u003cspan class=\"hljs-attr\"\u003evalueFrom:\u003c/span\u003e\n                \u003cspan class=\"hljs-attr\"\u003econfigMapKeyRef:\u003c/span\u003e\n                  \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003emy-test-k8s-cm\u003c/span\u003e\n                  \u003cspan class=\"hljs-attr\"\u003ekey:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003edrink\u003c/span\u003e\n            \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eMYVALUE\u003c/span\u003e\n              \u003cspan class=\"hljs-attr\"\u003evalueFrom:\u003c/span\u003e\n                \u003cspan class=\"hljs-attr\"\u003econfigMapKeyRef:\u003c/span\u003e\n                  \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003emy-test-k8s-cm\u003c/span\u003e\n                  \u003cspan class=\"hljs-attr\"\u003ekey:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003emyvalue\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e매니페스트 적용\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003ekubectl apply -f my-test-cm-manifest.yaml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003emy-test-cm-manifest.yaml 파일에서 configmap을 업데이트하세요.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-meta\"\u003e---\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eapiVersion:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ev1\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003ekind:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eConfigMap\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003emetadata:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003emy-test-k8s-cm\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edata:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003emyvalue:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"안녕하세요\"\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003edrink:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e차\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e파일을 다시 적용하세요.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-string\"\u003ekubectl\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eapply\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e-f\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003emy-test-cm-manifest.yaml\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e확인\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eConfigMap\u003c/span\u003e 확인\nkubectl get cm my-test-k8s-cm -o yaml\n\n# \u003cspan class=\"hljs-title class_\"\u003ePod\u003c/span\u003e 확인\nkubectl get po\n\n# \u003cspan class=\"hljs-title class_\"\u003ePod\u003c/span\u003e에 접속하여 새 값 확인\nkubectl exec -it \u0026#x3C;pod_name\u003e -- bash\n\n# \u003cspan class=\"hljs-title class_\"\u003ePod\u003c/span\u003e에 들어간 후 \u003cspan class=\"hljs-string\"\u003e`env`\u003c/span\u003e 명령어를 실행하면 \u003cspan class=\"hljs-title class_\"\u003ePod\u003c/span\u003e 내에서 사용 가능한 모든 환경 변수가 출력됩니다\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e축하합니다!!! secret-store-csi-driver와 reloader를 성공적으로 구성했습니다.\u003c/p\u003e\n\u003cp\u003e감사합니다!!!\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e참고 자료:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docs.aws.amazon.com/secretsmanager/latest/userguide/integrating_csi_driver.html\" rel=\"nofollow\" target=\"_blank\"\u003eAWS 공식 문서 - CSI 드라이버 통합\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://blog.bootlabstech.com/aws-secrets-manager-in-kubernetes-secret-rotation-and-reloader\" rel=\"nofollow\" target=\"_blank\"\u003eBootlabs 기술 블로그 - AWS Secrets Manager in Kubernetes 시크릿 회전과 리로더\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://secrets-store-csi-driver.sigs.k8s.io/topics/secret-auto-rotation\" rel=\"nofollow\" target=\"_blank\"\u003eSecrets Store CSI 드라이버 공식 홈페이지 - 시크릿 자동 회전\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/kubernetes-sigs/secrets-store-csi-driver/blob/main/charts/secrets-store-csi-driver/values.yaml\" rel=\"nofollow\" target=\"_blank\"\u003eSecrets Store CSI 드라이버 차트 값 설정 파일\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/stakater/Reloader/tree/master\" rel=\"nofollow\" target=\"_blank\"\u003eReloader GitHub 저장소\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/stakater/Reloader/blob/master/docs/Verify-Reloader-Working.md\" rel=\"nofollow\" target=\"_blank\"\u003eReloader 작동 확인 문서\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/stakater/Reloader/blob/master/docs/How-it-works.md\" rel=\"nofollow\" target=\"_blank\"\u003eReloader 작동 방식 문서\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e간단히 말하자면 🚀\u003c/h1\u003e\n\u003cp\u003eIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 계속 참여해 주세요:\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e작가에게 박수를 보내고 팔로우를 눌러주세요 ️👏️️\u003c/li\u003e\n\u003cli\u003e팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\u003c/li\u003e\n\u003cli\u003e다른 플랫폼에서 저희를 만나보세요: Stackademic | CoFeed | Venture | Cubed\u003c/li\u003e\n\u003cli\u003e알고리즘 콘텐츠를 다뤄야 하는 블로그 플랫폼에 지쳤나요? Differ를 시도해보세요\u003c/li\u003e\n\u003cli\u003ePlainEnglish.io에서 더 많은 콘텐츠를 만나보세요\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-KubernetesAutoRestartDeploymentswhenK8sConfigMaporSecretisUpdated"},"buildId":"bb_yO9GbCvdfc_n71SfUf","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>