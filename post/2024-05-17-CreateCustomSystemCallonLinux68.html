<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>리눅스 68에서 사용자 정의 시스템 호출 만들기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-17-CreateCustomSystemCallonLinux68" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="리눅스 68에서 사용자 정의 시스템 호출 만들기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="리눅스 68에서 사용자 정의 시스템 호출 만들기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-17-CreateCustomSystemCallonLinux68" data-gatsby-head="true"/><meta name="twitter:title" content="리눅스 68에서 사용자 정의 시스템 호출 만들기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-17 18:49" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/RZIEBQ2aNAp_DXFVTV6eL/_buildManifest.js" defer=""></script><script src="/_next/static/RZIEBQ2aNAp_DXFVTV6eL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">리눅스 68에서 사용자 정의 시스템 호출 만들기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="리눅스 68에서 사용자 정의 시스템 호출 만들기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 17, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-17-CreateCustomSystemCallonLinux68&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>여태껏 사용자 정의 시스템 호출을 만들어보고 싶으셨나요? 과제를 위해서든, 즐거움을 위해서든, 또는 커널에 대해 더 많이 배우기 위해서든, 시스템 호출은 우리 시스템에 대해 더 많이 알아갈 수 있는 멋진 방법입니다.</p>
<h1>이 안내에 따를 이유는?</h1>
<p>이 주제에 대한 다양한 안내서가 있지만, 커널 개발 속도의 문제 때문에 문제가 발생합니다. 대부분의 안내서들은 오래되었고 다양한 오류를 발생시키기 때문에, 저는 이 포스트를 오류를 경험하고 그것들을 해결한 후에 작성하게 되었습니다 :)</p>
<h2>커널 컴파일을 위한 시스템 설정</h2>
<p>Red Hat / Fedora / Open Suse 기반 시스템에서는 아래와 같이 간편하게 실행할 수 있어요.</p>
<pre><code class="hljs language-bash">sudo dnf builddep kernel
sudo dnf install kernel-devel
</code></pre>
<p>Debian / Ubuntu 기반 시스템에서는</p>
<pre><code class="hljs language-bash">sudo apt-get install build-essential vim git cscope libncurses-dev libssl-dev bison flex
</code></pre>
<h2>커널 가져오기</h2>
<p>커널 소스 트리를 복제하세요. 특히 6.8 브랜치를 복제할 것이지만, 지침은 커널 개발자가 프로세스를 변경할 때까지 최신 브랜치에서도 작동해야 합니다.</p>
<pre><code class="hljs language-js">git clone --depth=<span class="hljs-number">1</span> --branch v6<span class="hljs-number">.8</span> <span class="hljs-attr">https</span>:<span class="hljs-comment">//git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git</span>
</code></pre>
<p>이상적으로, 복제된 버전은 현재 사용 중인 커널 버전과 같거나 더 높아야 합니다.</p>
<p>현재 커널 버전은 다음 명령어를 통해 확인할 수 있어요</p>
<pre><code class="hljs language-bash"><span class="hljs-built_in">uname</span> -r
</code></pre>
<h2>새로운 시스템 호출 생성</h2>
<p>다음을 수행해주세요</p>
<pre><code class="hljs language-js">cd linux
make mrproper
mkdir hello
cd hello
touch hello.<span class="hljs-property">c</span>
touch <span class="hljs-title class_">Makefile</span>
</code></pre>
<p>이 명령은 다운로드한 커널 소스 코드 내에 "hello"라는 폴더를 만들고, 그 안에 hello.c(시스템 호출 코드)와 Makefile(컴파일 규칙) 두 개의 파일을 생성합니다.</p>
<p>좋아하는 텍스트 편집기에서 hello.c를 열고 다음 코드를 넣어주세요.</p>
<pre><code class="hljs language-js">#include &#x3C;linux/kernel.<span class="hljs-property">h</span>>
#include &#x3C;linux/syscalls.<span class="hljs-property">h</span>>

<span class="hljs-title function_">SYSCALL_DEFINE0</span>(<span class="hljs-params">hello</span>) {
    <span class="hljs-title function_">pr_info</span>(<span class="hljs-string">"Hello World\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>커널 로그에 "Hello World"가 출력됩니다.</p>
<p>우리는 단순히 프린트만 할 것이기 때문에 n=0을 사용합니다.</p>
<p>이제 다음을 Makefile에 추가해주세요</p>
<p>obj-y := hello.o</p>
<p>이제</p>
<pre><code class="hljs language-js">cd ..
cd include/linux/
</code></pre>
<p>이 디렉토리 안에서 "syscalls.h" 파일을 열고 다음을 추가하세요.</p>
<pre><code class="hljs language-js">asmlinkage long <span class="hljs-title function_">sys_hello</span>(<span class="hljs-keyword">void</span>)
</code></pre>
<p>이것은 이전에 만든 syscall 함수에 대한 프로토타입입니다.</p>
<p>커널 루트 내의 "Kbuild" 파일을 열고 (cd ../..) 맨 아래에 다음을 추가하십시오.</p>
<pre><code class="hljs language-js">obj-y += hello/
</code></pre>
<p>아래는 우리가 포함한 새 폴더도 컴파일하도록 커널 빌드 시스템에 지시합니다.</p>
<p>이 작업이 완료되면, 아키텍처별 테이블에 시스콜 항목도 추가해 주어야 합니다.</p>
<p>각 CPU 아키텍처는 특정 시스콜을 가질 수 있으며, 우리의 시스콜이 어떤 아키텍처를 위해 만들어졌는지 알려주어야 합니다.</p>
<p>x86_64 아키텍처에서 파일은</p>
<pre><code class="hljs language-js">arch/x86/entry/syscalls/syscall_64.<span class="hljs-property">tbl</span>
</code></pre>
<p>빈번호를 사용하고 테이블 주석에서 금지된 번호를 사용하지 않도록 유의하여 시스콜 항목을 추가하세요.</p>
<p>제가 사용 가능한 번호 중 462번이 비어 있어서 새 항목을 다음과 같이 추가했습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-number">462</span> 공통 안녕 sys_hello
</code></pre>
<p>여기서 462은 우리의 시스템 호출에 매핑되며 두 아키텍처에 대해 공통인 sys_hello로 명명된 hello 시스템 호출의 진입 함수(entry function)입니다.</p>
<h2>새 커널을 컴파일하고 설치하기</h2>
<p>다음 명령을 실행하십시오.</p>
<p>주의: 이 안내를 따르더라도 시스템의 안전, 보안, 무결성과 안정성을 보장하지 않습니다. 여기 나열된 모든 지침은 제 경험이며 귀하의 시스템에서의 결과를 대표하지 않습니다. 조심히 주의하여 진행하십시오.</p>
<p>이제 법적인 부분은 끝냈으니, 계속해봅시다 ;)</p>
<pre><code class="hljs language-js">cp /boot/config-$(uname -r) .<span class="hljs-property">config</span>
make olddefconfig
make -j $(nproc)
sudo make -j $(nproc) modules_install
sudo make install
</code></pre>
<p>현재 부팅된 커널의 구성 파일을 복사하고, 빌드 시스템에 동일한 값을 사용하도록 요청하여 기본값을 설정합니다. 그런 다음 nproc에 의해 주어진 코어 수에 따라 병렬 처리를 사용하여 커널을 빌드합니다. 이후 사용자 정의 커널을 설치합니다 (자체 책임으로).</p>
<p>커널 컴파일에는 많은 시간이 소요되므로 커피 한 잔 또는 10잔을 마시며 터미널에서 스크롤되는 텍스트 줄을 즐기세요.</p>
<p>시스템 속도에 따라 몇 시간이 걸릴 수 있으므로 실제 소요 시간이 다를 수 있습니다. 이 단계에서 열이 치기도 할 수 있으니 온도를 확인하려면 팬이 소리를 지를 수도 있습니다 (내 경우에도 그렇었어요).</p>
<h2>재미있는 부분, 새로운 시스템 호출 사용</h2>
<p>이제 시스템 호출이 우리의 커널에 통합되었으니 시스템을 재부팅하고 부팅 중에 grub에서 새로운 커스텀 커널을 선택해주세요</p>
<p><img src="/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_3.png" alt="image"></p>
<p>부팅 후 시스템 호출을 사용하는 C 프로그램을 작성해봅시다.</p>
<p>다음 내용을 가진 파일 "test.c"를 생성하세요.</p>
<pre><code class="hljs language-js">#include &#x3C;stdio.<span class="hljs-property">h</span>>
#include &#x3C;sys/syscall.<span class="hljs-property">h</span>>
#include &#x3C;unistd.<span class="hljs-property">h</span>>
int <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>) {
  <span class="hljs-title function_">printf</span>(<span class="hljs-string">"%ld\n"</span>, <span class="hljs-title function_">syscall</span>(<span class="hljs-number">462</span>));
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>당신이 테이블에서 시스템 콜에 대해 선택한 번호로 462을 대체하세요.</p>
<p>프로그램을 컴파일하고 실행하세요.</p>
<pre><code class="hljs language-js">make test
chmod +x test
./test
</code></pre>
<p>모두 정상적으로 진행되면, 터미널에서 "0"을 출력하고 시스콜 출력이 커널 로그에 표시됩니다.</p>
<p>다음 명령어를 사용하여 로그에 액세스하세요.</p>
<pre><code class="hljs language-bash">sudo dmesg | <span class="hljs-built_in">tail</span>
</code></pre>
<p>그러면 원하는 시스템 콜 메시지가 출력된 것을 확인할 수 있습니다.</p>
<p>만약 성공적으로 수행했다면 축하드려요 🎉 좋아요와 댓글이 있다면 감사하겠습니다 :) 꼭 여러분의 이야기를 공유해 주세요 :D</p>
<p>다시 한 번 아래 사항을 기억해 주세요:</p>
<ul>
<li>커널을 컴파일하는 데 많은 시간이 걸립니다.</li>
<li>새로 컴파일한 커널은 상당한 용량을 차지하므로 저장 공간 확인이 필요합니다.</li>
<li>리눅스 커널은 코드 변경이 빠르게 이뤄집니다.</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"리눅스 68에서 사용자 정의 시스템 호출 만들기","description":"","date":"2024-05-17 18:49","slug":"2024-05-17-CreateCustomSystemCallonLinux68","content":"\n\n\n여태껏 사용자 정의 시스템 호출을 만들어보고 싶으셨나요? 과제를 위해서든, 즐거움을 위해서든, 또는 커널에 대해 더 많이 배우기 위해서든, 시스템 호출은 우리 시스템에 대해 더 많이 알아갈 수 있는 멋진 방법입니다.\n\n# 이 안내에 따를 이유는?\n\n이 주제에 대한 다양한 안내서가 있지만, 커널 개발 속도의 문제 때문에 문제가 발생합니다. 대부분의 안내서들은 오래되었고 다양한 오류를 발생시키기 때문에, 저는 이 포스트를 오류를 경험하고 그것들을 해결한 후에 작성하게 되었습니다 :)\n\n## 커널 컴파일을 위한 시스템 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRed Hat / Fedora / Open Suse 기반 시스템에서는 아래와 같이 간편하게 실행할 수 있어요.\n\n```bash\nsudo dnf builddep kernel\nsudo dnf install kernel-devel\n```\n\nDebian / Ubuntu 기반 시스템에서는\n\n```bash\nsudo apt-get install build-essential vim git cscope libncurses-dev libssl-dev bison flex\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 커널 가져오기\n\n커널 소스 트리를 복제하세요. 특히 6.8 브랜치를 복제할 것이지만, 지침은 커널 개발자가 프로세스를 변경할 때까지 최신 브랜치에서도 작동해야 합니다.\n\n```js\ngit clone --depth=1 --branch v6.8 https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git\n```\n\n이상적으로, 복제된 버전은 현재 사용 중인 커널 버전과 같거나 더 높아야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 커널 버전은 다음 명령어를 통해 확인할 수 있어요\n\n```bash\nuname -r\n```\n\n## 새로운 시스템 호출 생성\n\n다음을 수행해주세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\ncd linux\nmake mrproper\nmkdir hello\ncd hello\ntouch hello.c\ntouch Makefile\n```\n\n이 명령은 다운로드한 커널 소스 코드 내에 \"hello\"라는 폴더를 만들고, 그 안에 hello.c(시스템 호출 코드)와 Makefile(컴파일 규칙) 두 개의 파일을 생성합니다.\n\n좋아하는 텍스트 편집기에서 hello.c를 열고 다음 코드를 넣어주세요.\n\n```js\n#include \u003clinux/kernel.h\u003e\n#include \u003clinux/syscalls.h\u003e\n\nSYSCALL_DEFINE0(hello) {\n    pr_info(\"Hello World\\n\");\n    return 0;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n커널 로그에 \"Hello World\"가 출력됩니다.\n\n우리는 단순히 프린트만 할 것이기 때문에 n=0을 사용합니다.\n\n이제 다음을 Makefile에 추가해주세요\n\n\nobj-y := hello.o\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제\n\n```js\ncd ..\ncd include/linux/\n```\n\n이 디렉토리 안에서 \"syscalls.h\" 파일을 열고 다음을 추가하세요.\n\n```js\nasmlinkage long sys_hello(void)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_0.png\" /\u003e\n\n이것은 이전에 만든 syscall 함수에 대한 프로토타입입니다.\n\n커널 루트 내의 \"Kbuild\" 파일을 열고 (cd ../..) 맨 아래에 다음을 추가하십시오.\n\n```js\nobj-y += hello/\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 우리가 포함한 새 폴더도 컴파일하도록 커널 빌드 시스템에 지시합니다.\n\n이 작업이 완료되면, 아키텍처별 테이블에 시스콜 항목도 추가해 주어야 합니다.\n\n각 CPU 아키텍처는 특정 시스콜을 가질 수 있으며, 우리의 시스콜이 어떤 아키텍처를 위해 만들어졌는지 알려주어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nx86_64 아키텍처에서 파일은\n\n```js\narch/x86/entry/syscalls/syscall_64.tbl\n```\n\n빈번호를 사용하고 테이블 주석에서 금지된 번호를 사용하지 않도록 유의하여 시스콜 항목을 추가하세요.\n\n제가 사용 가능한 번호 중 462번이 비어 있어서 새 항목을 다음과 같이 추가했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n462 공통 안녕 sys_hello\n```\n\n\u003cimg src=\"/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_2.png\" /\u003e\n\n여기서 462은 우리의 시스템 호출에 매핑되며 두 아키텍처에 대해 공통인 sys_hello로 명명된 hello 시스템 호출의 진입 함수(entry function)입니다.\n\n## 새 커널을 컴파일하고 설치하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 명령을 실행하십시오.\n\n주의: 이 안내를 따르더라도 시스템의 안전, 보안, 무결성과 안정성을 보장하지 않습니다. 여기 나열된 모든 지침은 제 경험이며 귀하의 시스템에서의 결과를 대표하지 않습니다. 조심히 주의하여 진행하십시오.\n\n이제 법적인 부분은 끝냈으니, 계속해봅시다 ;)\n\n```js\ncp /boot/config-$(uname -r) .config\nmake olddefconfig\nmake -j $(nproc)\nsudo make -j $(nproc) modules_install\nsudo make install\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 부팅된 커널의 구성 파일을 복사하고, 빌드 시스템에 동일한 값을 사용하도록 요청하여 기본값을 설정합니다. 그런 다음 nproc에 의해 주어진 코어 수에 따라 병렬 처리를 사용하여 커널을 빌드합니다. 이후 사용자 정의 커널을 설치합니다 (자체 책임으로).\n\n커널 컴파일에는 많은 시간이 소요되므로 커피 한 잔 또는 10잔을 마시며 터미널에서 스크롤되는 텍스트 줄을 즐기세요.\n\n시스템 속도에 따라 몇 시간이 걸릴 수 있으므로 실제 소요 시간이 다를 수 있습니다. 이 단계에서 열이 치기도 할 수 있으니 온도를 확인하려면 팬이 소리를 지를 수도 있습니다 (내 경우에도 그렇었어요).\n\n## 재미있는 부분, 새로운 시스템 호출 사용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 시스템 호출이 우리의 커널에 통합되었으니 시스템을 재부팅하고 부팅 중에 grub에서 새로운 커스텀 커널을 선택해주세요\n\n![image](/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_3.png)\n\n부팅 후 시스템 호출을 사용하는 C 프로그램을 작성해봅시다.\n\n다음 내용을 가진 파일 \"test.c\"를 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n#include \u003cstdio.h\u003e\n#include \u003csys/syscall.h\u003e\n#include \u003cunistd.h\u003e\nint main(void) {\n  printf(\"%ld\\n\", syscall(462));\n  return 0;\n}\n```\n\n당신이 테이블에서 시스템 콜에 대해 선택한 번호로 462을 대체하세요.\n\n프로그램을 컴파일하고 실행하세요.\n\n```js\nmake test\nchmod +x test\n./test\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모두 정상적으로 진행되면, 터미널에서 \"0\"을 출력하고 시스콜 출력이 커널 로그에 표시됩니다.\n\n다음 명령어를 사용하여 로그에 액세스하세요.\n\n```bash\nsudo dmesg | tail\n```\n\n그러면 원하는 시스템 콜 메시지가 출력된 것을 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 성공적으로 수행했다면 축하드려요 🎉 좋아요와 댓글이 있다면 감사하겠습니다 :) 꼭 여러분의 이야기를 공유해 주세요 :D\n\n다시 한 번 아래 사항을 기억해 주세요:\n\n- 커널을 컴파일하는 데 많은 시간이 걸립니다.\n- 새로 컴파일한 커널은 상당한 용량을 차지하므로 저장 공간 확인이 필요합니다.\n- 리눅스 커널은 코드 변경이 빠르게 이뤄집니다.","ogImage":{"url":"/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_0.png"},"coverImage":"/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e여태껏 사용자 정의 시스템 호출을 만들어보고 싶으셨나요? 과제를 위해서든, 즐거움을 위해서든, 또는 커널에 대해 더 많이 배우기 위해서든, 시스템 호출은 우리 시스템에 대해 더 많이 알아갈 수 있는 멋진 방법입니다.\u003c/p\u003e\n\u003ch1\u003e이 안내에 따를 이유는?\u003c/h1\u003e\n\u003cp\u003e이 주제에 대한 다양한 안내서가 있지만, 커널 개발 속도의 문제 때문에 문제가 발생합니다. 대부분의 안내서들은 오래되었고 다양한 오류를 발생시키기 때문에, 저는 이 포스트를 오류를 경험하고 그것들을 해결한 후에 작성하게 되었습니다 :)\u003c/p\u003e\n\u003ch2\u003e커널 컴파일을 위한 시스템 설정\u003c/h2\u003e\n\u003cp\u003eRed Hat / Fedora / Open Suse 기반 시스템에서는 아래와 같이 간편하게 실행할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esudo dnf builddep kernel\nsudo dnf install kernel-devel\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDebian / Ubuntu 기반 시스템에서는\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esudo apt-get install build-essential vim git cscope libncurses-dev libssl-dev bison flex\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e커널 가져오기\u003c/h2\u003e\n\u003cp\u003e커널 소스 트리를 복제하세요. 특히 6.8 브랜치를 복제할 것이지만, 지침은 커널 개발자가 프로세스를 변경할 때까지 최신 브랜치에서도 작동해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003egit clone --depth=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e --branch v6\u003cspan class=\"hljs-number\"\u003e.8\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이상적으로, 복제된 버전은 현재 사용 중인 커널 버전과 같거나 더 높아야 합니다.\u003c/p\u003e\n\u003cp\u003e현재 커널 버전은 다음 명령어를 통해 확인할 수 있어요\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cspan class=\"hljs-built_in\"\u003euname\u003c/span\u003e -r\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e새로운 시스템 호출 생성\u003c/h2\u003e\n\u003cp\u003e다음을 수행해주세요\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecd linux\nmake mrproper\nmkdir hello\ncd hello\ntouch hello.\u003cspan class=\"hljs-property\"\u003ec\u003c/span\u003e\ntouch \u003cspan class=\"hljs-title class_\"\u003eMakefile\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 명령은 다운로드한 커널 소스 코드 내에 \"hello\"라는 폴더를 만들고, 그 안에 hello.c(시스템 호출 코드)와 Makefile(컴파일 규칙) 두 개의 파일을 생성합니다.\u003c/p\u003e\n\u003cp\u003e좋아하는 텍스트 편집기에서 hello.c를 열고 다음 코드를 넣어주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#include \u0026#x3C;linux/kernel.\u003cspan class=\"hljs-property\"\u003eh\u003c/span\u003e\u003e\n#include \u0026#x3C;linux/syscalls.\u003cspan class=\"hljs-property\"\u003eh\u003c/span\u003e\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003eSYSCALL_DEFINE0\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ehello\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003epr_info\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Hello World\\n\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e커널 로그에 \"Hello World\"가 출력됩니다.\u003c/p\u003e\n\u003cp\u003e우리는 단순히 프린트만 할 것이기 때문에 n=0을 사용합니다.\u003c/p\u003e\n\u003cp\u003e이제 다음을 Makefile에 추가해주세요\u003c/p\u003e\n\u003cp\u003eobj-y := hello.o\u003c/p\u003e\n\u003cp\u003e이제\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecd ..\ncd include/linux/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 디렉토리 안에서 \"syscalls.h\" 파일을 열고 다음을 추가하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003easmlinkage long \u003cspan class=\"hljs-title function_\"\u003esys_hello\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 이전에 만든 syscall 함수에 대한 프로토타입입니다.\u003c/p\u003e\n\u003cp\u003e커널 루트 내의 \"Kbuild\" 파일을 열고 (cd ../..) 맨 아래에 다음을 추가하십시오.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eobj-y += hello/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래는 우리가 포함한 새 폴더도 컴파일하도록 커널 빌드 시스템에 지시합니다.\u003c/p\u003e\n\u003cp\u003e이 작업이 완료되면, 아키텍처별 테이블에 시스콜 항목도 추가해 주어야 합니다.\u003c/p\u003e\n\u003cp\u003e각 CPU 아키텍처는 특정 시스콜을 가질 수 있으며, 우리의 시스콜이 어떤 아키텍처를 위해 만들어졌는지 알려주어야 합니다.\u003c/p\u003e\n\u003cp\u003ex86_64 아키텍처에서 파일은\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003earch/x86/entry/syscalls/syscall_64.\u003cspan class=\"hljs-property\"\u003etbl\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e빈번호를 사용하고 테이블 주석에서 금지된 번호를 사용하지 않도록 유의하여 시스콜 항목을 추가하세요.\u003c/p\u003e\n\u003cp\u003e제가 사용 가능한 번호 중 462번이 비어 있어서 새 항목을 다음과 같이 추가했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-number\"\u003e462\u003c/span\u003e 공통 안녕 sys_hello\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 462은 우리의 시스템 호출에 매핑되며 두 아키텍처에 대해 공통인 sys_hello로 명명된 hello 시스템 호출의 진입 함수(entry function)입니다.\u003c/p\u003e\n\u003ch2\u003e새 커널을 컴파일하고 설치하기\u003c/h2\u003e\n\u003cp\u003e다음 명령을 실행하십시오.\u003c/p\u003e\n\u003cp\u003e주의: 이 안내를 따르더라도 시스템의 안전, 보안, 무결성과 안정성을 보장하지 않습니다. 여기 나열된 모든 지침은 제 경험이며 귀하의 시스템에서의 결과를 대표하지 않습니다. 조심히 주의하여 진행하십시오.\u003c/p\u003e\n\u003cp\u003e이제 법적인 부분은 끝냈으니, 계속해봅시다 ;)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecp /boot/config-$(uname -r) .\u003cspan class=\"hljs-property\"\u003econfig\u003c/span\u003e\nmake olddefconfig\nmake -j $(nproc)\nsudo make -j $(nproc) modules_install\nsudo make install\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e현재 부팅된 커널의 구성 파일을 복사하고, 빌드 시스템에 동일한 값을 사용하도록 요청하여 기본값을 설정합니다. 그런 다음 nproc에 의해 주어진 코어 수에 따라 병렬 처리를 사용하여 커널을 빌드합니다. 이후 사용자 정의 커널을 설치합니다 (자체 책임으로).\u003c/p\u003e\n\u003cp\u003e커널 컴파일에는 많은 시간이 소요되므로 커피 한 잔 또는 10잔을 마시며 터미널에서 스크롤되는 텍스트 줄을 즐기세요.\u003c/p\u003e\n\u003cp\u003e시스템 속도에 따라 몇 시간이 걸릴 수 있으므로 실제 소요 시간이 다를 수 있습니다. 이 단계에서 열이 치기도 할 수 있으니 온도를 확인하려면 팬이 소리를 지를 수도 있습니다 (내 경우에도 그렇었어요).\u003c/p\u003e\n\u003ch2\u003e재미있는 부분, 새로운 시스템 호출 사용\u003c/h2\u003e\n\u003cp\u003e이제 시스템 호출이 우리의 커널에 통합되었으니 시스템을 재부팅하고 부팅 중에 grub에서 새로운 커스텀 커널을 선택해주세요\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_3.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e부팅 후 시스템 호출을 사용하는 C 프로그램을 작성해봅시다.\u003c/p\u003e\n\u003cp\u003e다음 내용을 가진 파일 \"test.c\"를 생성하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#include \u0026#x3C;stdio.\u003cspan class=\"hljs-property\"\u003eh\u003c/span\u003e\u003e\n#include \u0026#x3C;sys/syscall.\u003cspan class=\"hljs-property\"\u003eh\u003c/span\u003e\u003e\n#include \u0026#x3C;unistd.\u003cspan class=\"hljs-property\"\u003eh\u003c/span\u003e\u003e\nint \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title function_\"\u003eprintf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"%ld\\n\"\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003esyscall\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e462\u003c/span\u003e));\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e당신이 테이블에서 시스템 콜에 대해 선택한 번호로 462을 대체하세요.\u003c/p\u003e\n\u003cp\u003e프로그램을 컴파일하고 실행하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003emake test\nchmod +x test\n./test\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e모두 정상적으로 진행되면, 터미널에서 \"0\"을 출력하고 시스콜 출력이 커널 로그에 표시됩니다.\u003c/p\u003e\n\u003cp\u003e다음 명령어를 사용하여 로그에 액세스하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esudo dmesg | \u003cspan class=\"hljs-built_in\"\u003etail\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러면 원하는 시스템 콜 메시지가 출력된 것을 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e만약 성공적으로 수행했다면 축하드려요 🎉 좋아요와 댓글이 있다면 감사하겠습니다 :) 꼭 여러분의 이야기를 공유해 주세요 :D\u003c/p\u003e\n\u003cp\u003e다시 한 번 아래 사항을 기억해 주세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e커널을 컴파일하는 데 많은 시간이 걸립니다.\u003c/li\u003e\n\u003cli\u003e새로 컴파일한 커널은 상당한 용량을 차지하므로 저장 공간 확인이 필요합니다.\u003c/li\u003e\n\u003cli\u003e리눅스 커널은 코드 변경이 빠르게 이뤄집니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-17-CreateCustomSystemCallonLinux68"},"buildId":"RZIEBQ2aNAp_DXFVTV6eL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>