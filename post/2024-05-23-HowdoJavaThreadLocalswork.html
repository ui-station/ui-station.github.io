<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>자바 스레드 로컬Thread Locals은 어떻게 동작하나요 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-23-HowdoJavaThreadLocalswork" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="자바 스레드 로컬Thread Locals은 어떻게 동작하나요 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="자바 스레드 로컬Thread Locals은 어떻게 동작하나요 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-23-HowdoJavaThreadLocalswork_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-23-HowdoJavaThreadLocalswork" data-gatsby-head="true"/><meta name="twitter:title" content="자바 스레드 로컬Thread Locals은 어떻게 동작하나요 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-23-HowdoJavaThreadLocalswork_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-23 12:39" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/RZIEBQ2aNAp_DXFVTV6eL/_buildManifest.js" defer=""></script><script src="/_next/static/RZIEBQ2aNAp_DXFVTV6eL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">자바 스레드 로컬Thread Locals은 어떻게 동작하나요</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="자바 스레드 로컬Thread Locals은 어떻게 동작하나요" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 23, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-23-HowdoJavaThreadLocalswork&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>자바에서 쓰레드 로컬(Thread Locals)은 전체 쓰레드 범위를 가지는 변수입니다. 이 말은 쓰레드 어디서든지 이러한 변수를 설정하고, 동일한 쓰레드에서는 어디서든지 액세스할 수 있다는 것을 의미합니다. 한 쓰레드에서 설정된 값은 다른 쓰레드에서 접근할 수 없습니다.</p>
<p>자바 ThreadLocal 클래스에는 두 가지 유형이 있음을 알아야 합니다 — ThreadLocal 및 InheritableThreadLocal. 두 클래스 간의 차이를 살펴봅시다.</p>
<h1>ThreadLocal 클래스</h1>
<p>아래는 쓰레드 로컬 변수가 선언된 예시입니다. user 변수는 User 타입(Class 또는 Interface)의 변수를 보유하는 ThreadLocal 변수입니다. 여기서 user 변수가 public 및 static으로 선언되어 어디서든 코드 내에서 접근할 수 있도록 설정되었습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// Declare a Thread Local Variable user</span>
public <span class="hljs-keyword">static</span> final <span class="hljs-title class_">ThreadLocal</span>&#x3C;<span class="hljs-title class_">User</span>> user 
                     = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&#x3C;>();
</code></pre>
<p>아래는 쓰레드를 위해 user를 설정하고 가져오는 방법입니다. 예시에서는 'bob'으로 설정된 User 객체에 user 변수를 설정하고, 동일한 쓰레드 내에서 get() 메소드를 호출하면 User 'bob'이 검색됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// Sets the calling thread’s value for user</span>
user.<span class="hljs-title function_">set</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"bob"</span>));

<span class="hljs-comment">// Gets the calling thread’s value for user</span>
<span class="hljs-title class_">User</span> requestUser = user.<span class="hljs-title function_">get</span>();
</code></pre>
<p>사용자 변수가 코드베이스 전체에서 접근 가능하더라도 set(..) 메서드는 전달된 User 객체가 "호출" 스레드와 연관되도록 합니다. get() 메서드는 또한 "호출" 스레드와 연관된 User 객체를 검색하며, 다른 스레드에서 get() 메서드를 호출하더라도 bob이 아니라 다른 사용자(또는 null)를 검색하지 않습니다. 각 Java 스레드는 해당 스레드에 설정된 모든 스레드 로컬을 포함하는 ThreadLocal Map과 연결됩니다.</p>
<p>만약 아무것도 설정되지 않은 경우 get() 메서드를 호출하면 어떻게 될까요? 이 메서드는 단순히 null을 반환합니다.</p>
<p>그러나 람다 공급자로 초기 User 객체를 반환하는 Thread Local 객체를 생성할 수 있습니다. 아래 예제는 'anonymous'라는 User를 반환하는 공급자를 보여줍니다. 따라서 값이 설정되지 않은 ThreadLocal에 get() 메서드를 호출하면 이전에 값을 설정하지 않았을 때 공급자의 get() 메서드가 호출되며 사용자의 초기 값으로 설정됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 공급자와 함께 Thread Local 변수 user를 선언</span>
public <span class="hljs-keyword">static</span> <span class="hljs-title class_">ThreadLocal</span>&#x3C;<span class="hljs-title class_">User</span>> user 
          = <span class="hljs-title class_">ThreadLocal</span>.<span class="hljs-title function_">withInitial</span>(
                () -> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"anonymous"</span>))

<span class="hljs-comment">// 'Anonymous'를 반환</span>
<span class="hljs-title class_">User</span> requestUser = user.<span class="hljs-title function_">get</span>();
</code></pre>
<p>다음과 같이 remove() 메서드를 호출하여 이전에 설정된 값을 제거할 수도 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 호출 스레드의 사용자 값 제거</span>
user.<span class="hljs-title function_">remove</span>();
</code></pre>
<p>이 방법은 기본적으로 스레드와 관련된 User 객체를 제거합니다. 더 중요한 것은 이 작업으로 다른 스레드에는 영향을 미치지 않는다는 점입니다.</p>
<p>스레드 로컬을 다이어그램 형식으로 시각화한다면(저는 이것을 좋아합니다), 다음과 같이 보일 것입니다. 두 스레드의 사용자 변수가 서로 다른 User 객체를 가리키는 것을 알 수 있습니다.</p>
<h1>ThreadLocal 및 자식 스레드</h1>
<p>이전 섹션까지의 논의는 주로 한 개의 Java 스레드와 관련되어 있었습니다. 만약 Java 스레드가 새로운 자식 스레드를 시작한다면 어떻게 될까요? 자식 스레드가 부모에서 정의된 Thread Local 변수에 자동으로 액세스할 수 있을까요?</p>
<p>답은 "아니요"입니다! 자식 스레드는 부모의 Thread Local에 액세스할 수 없으며 이에 대한 매우 좋은 이유가 있습니다. 만약 액세스 가능하다면, Thread Local 변수에 저장된 객체는 스레드 안전하게 작성되어야 할 것이며 이렇게 되면 여러 스레드가 동일한 사용자 객체에 액세스할 수 있을 것입니다. 이는 Java 엔지니어들에 의한 좋은 기본 디자인 결정입니다.</p>
<p>하지만 때로는 그런 액세스가 유용할 때가 있습니다. 많은 사용자가 애플리케이션에 액세스하는 웹 애플리케이션과 같은 시나리오를 상상해보십시오. 요청 처리 중 사용자와 연결된 단일 Java 스레드가 있으며, 이 스레드의 Thread Local 객체에 사용자 객체가 저장되어 있다고 상상할 수 있습니다(이는 많은 응용 프로그램 서버 및 Spring Boot와 같은 프레임워크에서 수행됩니다). 그러나 생성된 자식 스레드도이 사용자 정보에 액세스하길 원할 수 있습니다.</p>
<p>이 시나리오에 대해 Java는 InheritableThreadLocal이라는 다른 클래스를 제공합니다.</p>
<h1>InheritableThreadLocal 클래스</h1>
<p>이 클래스를 사용하는 구문은 사실상 ThreadLocal 클래스와 거의 동일합니다. 아래 예제에서는 InheritableThreadLocal 클래스에 대한 해당 메서드를 보여줍니다.</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// 상속 가능한 쓰레드 로컬 변수 user를 선언합니다</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> InheritableThreadLocal&#x3C;User> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&#x3C;>();

<span class="hljs-comment">// 호출 중인 쓰레드의 user 값을 설정합니다</span>
user.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"bob"</span>));

<span class="hljs-comment">// 호출 중인 쓰레드의 user 값을 가져옵니다</span>
<span class="hljs-type">User</span> <span class="hljs-variable">requestUser</span> <span class="hljs-operator">=</span> user.get();

<span class="hljs-comment">// 호출 중인 쓰레드의 user 값을 제거합니다</span>
user.remove();
</code></pre>
<p>쓰레드 로컬 맵과 마찬가지로, 모든 쓰레드에는 상속 가능한 쓰레드 로컬 변수를 위한 맵이 있습니다. 여기서 큰 차이점은 자식 쓰레드가 생성될 때, 자식의 상속 가능한 쓰레드 로컬 맵이 부모로부터 복제된다는 것입니다. 따라서, 상속 가능한 쓰레드 로컬 변수는 자식 쓰레드에서도 접근할 수 있습니다.</p>
<p>만약 상속 가능한 쓰레드 로컬 변수를 다이어그램 형태로 시각화한다면, 다음과 같이 보일 것입니다. 상속 가능한 쓰레드 로컬 맵이 부모로부터 복제된 것을 볼 수 있습니다.</p>
<h1>함정에 유의하세요!</h1>
<p>위 다이어그램에서 명확히 볼 수 있듯이, 상속 가능한 쓰레드 로컬 변수의 장점은 단점이 될 수도 있습니다. 기본적으로, 자식 쓰레드가 생성될 때 상속 가능한 쓰레드 로컬 맵도 복제됩니다. 그러나 부모와 자식 쓰레드에서 동일한 "User" 객체를 가리킨다는 것을 알 수 있습니다.</p>
<p>이것은 User 객체가 여러 쓰레드에서 접근될 수 있고 스레드 안전하게 작성되어야 한다는 것을 의미합니다. 다시 말하면 - 단순한 ThreadLocal 클래스와 관련된 스레드 안전성이 InheritableThreadLocal 클래스를 사용할 때는 손실됩니다. 이것은 여러분의 디자인에 완벽히 적합할 수 있습니다 - 이에 문제는 없습니다.</p>
<p>그러나 더 안전한 접근 방식이 있을 수 있습니다. InheritableThreadLocal을 생성할 때 다음과 같이 childValue(..) 메서드를 지정할 수 있습니다. 사실, 아래 예시에서는 초기값과 child 값도 지정합니다.</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> InheritableThreadLocal&#x3C;User> user 
                   = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&#x3C;>() {

   <span class="hljs-meta">@Override</span>
   <span class="hljs-keyword">protected</span> User <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> { 
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"anonymous"</span>); 
   }

   <span class="hljs-meta">@Override</span>
   <span class="hljs-keyword">protected</span> User <span class="hljs-title function_">childValue</span><span class="hljs-params">(User parentValue)</span> { 
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(parentValue.getId()); 
   }
};
</code></pre>
<p>위 변경 사항을 통해 상속 가능한 스레드 로컬 맵이 복제될 때 자식에 연관된 값은 childValue(..) 메소드를 사용하여 부모 값이 전달되어 설정됩니다. 상속 가능한 스레드 로컬마다 새로운 객체가 생성되므로, User 객체가 부모 및 자식 스레드 간에 공유되지 않습니다. 이 변경으로 스레드 안전성으로 돌아가지만 User 객체에는 읽기 전용으로 액세스할 수 있게됩니다(사실상 복사본을 생성함).</p>
<p>다시 말하지만, 다이어그램 형식으로 상속 가능한 스레드 로컬을 시각화하면, 이와 같이 보일 것입니다. 이제 부모와 자식 스레드의 사용자가 서로 다른 User 객체를 가리키는 것을 명확히 알 수 있습니다.</p>
<p><img src="/assets/img/2024-05-23-HowdoJavaThreadLocalswork_3.png" alt="Java Thread Locals 동작 방식"></p>
<p>자바 스레드 지역 변수에 대한 좋은 이해를 얻을 수 있기를 바랍니다.</p>
<p>이 게시물이 도움이 되었다면 지원을 표시하기 위해 클로버 아이콘 👏을 몇 번 클릭해 주세요. 읽어 주셔서 감사합니다!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"자바 스레드 로컬Thread Locals은 어떻게 동작하나요","description":"","date":"2024-05-23 12:39","slug":"2024-05-23-HowdoJavaThreadLocalswork","content":"\n\n\u003cimg src=\"/assets/img/2024-05-23-HowdoJavaThreadLocalswork_0.png\" /\u003e\n\n자바에서 쓰레드 로컬(Thread Locals)은 전체 쓰레드 범위를 가지는 변수입니다. 이 말은 쓰레드 어디서든지 이러한 변수를 설정하고, 동일한 쓰레드에서는 어디서든지 액세스할 수 있다는 것을 의미합니다. 한 쓰레드에서 설정된 값은 다른 쓰레드에서 접근할 수 없습니다.\n\n자바 ThreadLocal 클래스에는 두 가지 유형이 있음을 알아야 합니다 — ThreadLocal 및 InheritableThreadLocal. 두 클래스 간의 차이를 살펴봅시다.\n\n# ThreadLocal 클래스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 쓰레드 로컬 변수가 선언된 예시입니다. user 변수는 User 타입(Class 또는 Interface)의 변수를 보유하는 ThreadLocal 변수입니다. 여기서 user 변수가 public 및 static으로 선언되어 어디서든 코드 내에서 접근할 수 있도록 설정되었습니다.\n\n```js\n// Declare a Thread Local Variable user\npublic static final ThreadLocal\u003cUser\u003e user \n                     = new ThreadLocal\u003c\u003e();\n```\n\n아래는 쓰레드를 위해 user를 설정하고 가져오는 방법입니다. 예시에서는 'bob'으로 설정된 User 객체에 user 변수를 설정하고, 동일한 쓰레드 내에서 get() 메소드를 호출하면 User 'bob'이 검색됩니다.\n\n```js\n// Sets the calling thread’s value for user\nuser.set(new User(\"bob\"));\n\n// Gets the calling thread’s value for user\nUser requestUser = user.get();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자 변수가 코드베이스 전체에서 접근 가능하더라도 set(..) 메서드는 전달된 User 객체가 \"호출\" 스레드와 연관되도록 합니다. get() 메서드는 또한 \"호출\" 스레드와 연관된 User 객체를 검색하며, 다른 스레드에서 get() 메서드를 호출하더라도 bob이 아니라 다른 사용자(또는 null)를 검색하지 않습니다. 각 Java 스레드는 해당 스레드에 설정된 모든 스레드 로컬을 포함하는 ThreadLocal Map과 연결됩니다.\n\n만약 아무것도 설정되지 않은 경우 get() 메서드를 호출하면 어떻게 될까요? 이 메서드는 단순히 null을 반환합니다.\n\n그러나 람다 공급자로 초기 User 객체를 반환하는 Thread Local 객체를 생성할 수 있습니다. 아래 예제는 'anonymous'라는 User를 반환하는 공급자를 보여줍니다. 따라서 값이 설정되지 않은 ThreadLocal에 get() 메서드를 호출하면 이전에 값을 설정하지 않았을 때 공급자의 get() 메서드가 호출되며 사용자의 초기 값으로 설정됩니다.\n\n```js\n// 공급자와 함께 Thread Local 변수 user를 선언\npublic static ThreadLocal\u003cUser\u003e user \n          = ThreadLocal.withInitial(\n                () -\u003e new User(\"anonymous\"))\n\n// 'Anonymous'를 반환\nUser requestUser = user.get();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음과 같이 remove() 메서드를 호출하여 이전에 설정된 값을 제거할 수도 있습니다.\n\n```js\n// 호출 스레드의 사용자 값 제거\nuser.remove();\n```\n\n이 방법은 기본적으로 스레드와 관련된 User 객체를 제거합니다. 더 중요한 것은 이 작업으로 다른 스레드에는 영향을 미치지 않는다는 점입니다.\n\n스레드 로컬을 다이어그램 형식으로 시각화한다면(저는 이것을 좋아합니다), 다음과 같이 보일 것입니다. 두 스레드의 사용자 변수가 서로 다른 User 객체를 가리키는 것을 알 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-23-HowdoJavaThreadLocalswork_1.png\" /\u003e\n\n# ThreadLocal 및 자식 스레드\n\n이전 섹션까지의 논의는 주로 한 개의 Java 스레드와 관련되어 있었습니다. 만약 Java 스레드가 새로운 자식 스레드를 시작한다면 어떻게 될까요? 자식 스레드가 부모에서 정의된 Thread Local 변수에 자동으로 액세스할 수 있을까요?\n\n답은 \"아니요\"입니다! 자식 스레드는 부모의 Thread Local에 액세스할 수 없으며 이에 대한 매우 좋은 이유가 있습니다. 만약 액세스 가능하다면, Thread Local 변수에 저장된 객체는 스레드 안전하게 작성되어야 할 것이며 이렇게 되면 여러 스레드가 동일한 사용자 객체에 액세스할 수 있을 것입니다. 이는 Java 엔지니어들에 의한 좋은 기본 디자인 결정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 때로는 그런 액세스가 유용할 때가 있습니다. 많은 사용자가 애플리케이션에 액세스하는 웹 애플리케이션과 같은 시나리오를 상상해보십시오. 요청 처리 중 사용자와 연결된 단일 Java 스레드가 있으며, 이 스레드의 Thread Local 객체에 사용자 객체가 저장되어 있다고 상상할 수 있습니다(이는 많은 응용 프로그램 서버 및 Spring Boot와 같은 프레임워크에서 수행됩니다). 그러나 생성된 자식 스레드도이 사용자 정보에 액세스하길 원할 수 있습니다.\n\n이 시나리오에 대해 Java는 InheritableThreadLocal이라는 다른 클래스를 제공합니다.\n\n# InheritableThreadLocal 클래스\n\n이 클래스를 사용하는 구문은 사실상 ThreadLocal 클래스와 거의 동일합니다. 아래 예제에서는 InheritableThreadLocal 클래스에 대한 해당 메서드를 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```java\n// 상속 가능한 쓰레드 로컬 변수 user를 선언합니다\npublic static final InheritableThreadLocal\u003cUser\u003e user = new InheritableThreadLocal\u003c\u003e();\n\n// 호출 중인 쓰레드의 user 값을 설정합니다\nuser.set(new User(\"bob\"));\n\n// 호출 중인 쓰레드의 user 값을 가져옵니다\nUser requestUser = user.get();\n\n// 호출 중인 쓰레드의 user 값을 제거합니다\nuser.remove();\n```\n\n쓰레드 로컬 맵과 마찬가지로, 모든 쓰레드에는 상속 가능한 쓰레드 로컬 변수를 위한 맵이 있습니다. 여기서 큰 차이점은 자식 쓰레드가 생성될 때, 자식의 상속 가능한 쓰레드 로컬 맵이 부모로부터 복제된다는 것입니다. 따라서, 상속 가능한 쓰레드 로컬 변수는 자식 쓰레드에서도 접근할 수 있습니다.\n\n만약 상속 가능한 쓰레드 로컬 변수를 다이어그램 형태로 시각화한다면, 다음과 같이 보일 것입니다. 상속 가능한 쓰레드 로컬 맵이 부모로부터 복제된 것을 볼 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-23-HowdoJavaThreadLocalswork_2.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 함정에 유의하세요!\n\n위 다이어그램에서 명확히 볼 수 있듯이, 상속 가능한 쓰레드 로컬 변수의 장점은 단점이 될 수도 있습니다. 기본적으로, 자식 쓰레드가 생성될 때 상속 가능한 쓰레드 로컬 맵도 복제됩니다. 그러나 부모와 자식 쓰레드에서 동일한 \"User\" 객체를 가리킨다는 것을 알 수 있습니다.\n\n이것은 User 객체가 여러 쓰레드에서 접근될 수 있고 스레드 안전하게 작성되어야 한다는 것을 의미합니다. 다시 말하면 - 단순한 ThreadLocal 클래스와 관련된 스레드 안전성이 InheritableThreadLocal 클래스를 사용할 때는 손실됩니다. 이것은 여러분의 디자인에 완벽히 적합할 수 있습니다 - 이에 문제는 없습니다.\n\n그러나 더 안전한 접근 방식이 있을 수 있습니다. InheritableThreadLocal을 생성할 때 다음과 같이 childValue(..) 메서드를 지정할 수 있습니다. 사실, 아래 예시에서는 초기값과 child 값도 지정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```java\npublic static final InheritableThreadLocal\u003cUser\u003e user \n                   = new InheritableThreadLocal\u003c\u003e() {\n\n   @Override\n   protected User initialValue() { \n      return new User(\"anonymous\"); \n   }\n\n   @Override\n   protected User childValue(User parentValue) { \n      return new User(parentValue.getId()); \n   }\n};\n```\n\n위 변경 사항을 통해 상속 가능한 스레드 로컬 맵이 복제될 때 자식에 연관된 값은 childValue(..) 메소드를 사용하여 부모 값이 전달되어 설정됩니다. 상속 가능한 스레드 로컬마다 새로운 객체가 생성되므로, User 객체가 부모 및 자식 스레드 간에 공유되지 않습니다. 이 변경으로 스레드 안전성으로 돌아가지만 User 객체에는 읽기 전용으로 액세스할 수 있게됩니다(사실상 복사본을 생성함).\n\n다시 말하지만, 다이어그램 형식으로 상속 가능한 스레드 로컬을 시각화하면, 이와 같이 보일 것입니다. 이제 부모와 자식 스레드의 사용자가 서로 다른 User 객체를 가리키는 것을 명확히 알 수 있습니다.\n\n![Java Thread Locals 동작 방식](/assets/img/2024-05-23-HowdoJavaThreadLocalswork_3.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바 스레드 지역 변수에 대한 좋은 이해를 얻을 수 있기를 바랍니다. \n\n이 게시물이 도움이 되었다면 지원을 표시하기 위해 클로버 아이콘 👏을 몇 번 클릭해 주세요. 읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-23-HowdoJavaThreadLocalswork_0.png"},"coverImage":"/assets/img/2024-05-23-HowdoJavaThreadLocalswork_0.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e자바에서 쓰레드 로컬(Thread Locals)은 전체 쓰레드 범위를 가지는 변수입니다. 이 말은 쓰레드 어디서든지 이러한 변수를 설정하고, 동일한 쓰레드에서는 어디서든지 액세스할 수 있다는 것을 의미합니다. 한 쓰레드에서 설정된 값은 다른 쓰레드에서 접근할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e자바 ThreadLocal 클래스에는 두 가지 유형이 있음을 알아야 합니다 — ThreadLocal 및 InheritableThreadLocal. 두 클래스 간의 차이를 살펴봅시다.\u003c/p\u003e\n\u003ch1\u003eThreadLocal 클래스\u003c/h1\u003e\n\u003cp\u003e아래는 쓰레드 로컬 변수가 선언된 예시입니다. user 변수는 User 타입(Class 또는 Interface)의 변수를 보유하는 ThreadLocal 변수입니다. 여기서 user 변수가 public 및 static으로 선언되어 어디서든 코드 내에서 접근할 수 있도록 설정되었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Declare a Thread Local Variable user\u003c/span\u003e\npublic \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e final \u003cspan class=\"hljs-title class_\"\u003eThreadLocal\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e\u003e user \n                     = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThreadLocal\u003c/span\u003e\u0026#x3C;\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래는 쓰레드를 위해 user를 설정하고 가져오는 방법입니다. 예시에서는 'bob'으로 설정된 User 객체에 user 변수를 설정하고, 동일한 쓰레드 내에서 get() 메소드를 호출하면 User 'bob'이 검색됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Sets the calling thread’s value for user\u003c/span\u003e\nuser.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"bob\"\u003c/span\u003e));\n\n\u003cspan class=\"hljs-comment\"\u003e// Gets the calling thread’s value for user\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e requestUser = user.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e사용자 변수가 코드베이스 전체에서 접근 가능하더라도 set(..) 메서드는 전달된 User 객체가 \"호출\" 스레드와 연관되도록 합니다. get() 메서드는 또한 \"호출\" 스레드와 연관된 User 객체를 검색하며, 다른 스레드에서 get() 메서드를 호출하더라도 bob이 아니라 다른 사용자(또는 null)를 검색하지 않습니다. 각 Java 스레드는 해당 스레드에 설정된 모든 스레드 로컬을 포함하는 ThreadLocal Map과 연결됩니다.\u003c/p\u003e\n\u003cp\u003e만약 아무것도 설정되지 않은 경우 get() 메서드를 호출하면 어떻게 될까요? 이 메서드는 단순히 null을 반환합니다.\u003c/p\u003e\n\u003cp\u003e그러나 람다 공급자로 초기 User 객체를 반환하는 Thread Local 객체를 생성할 수 있습니다. 아래 예제는 'anonymous'라는 User를 반환하는 공급자를 보여줍니다. 따라서 값이 설정되지 않은 ThreadLocal에 get() 메서드를 호출하면 이전에 값을 설정하지 않았을 때 공급자의 get() 메서드가 호출되며 사용자의 초기 값으로 설정됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 공급자와 함께 Thread Local 변수 user를 선언\u003c/span\u003e\npublic \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThreadLocal\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e\u003e user \n          = \u003cspan class=\"hljs-title class_\"\u003eThreadLocal\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ewithInitial\u003c/span\u003e(\n                () -\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"anonymous\"\u003c/span\u003e))\n\n\u003cspan class=\"hljs-comment\"\u003e// 'Anonymous'를 반환\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e requestUser = user.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음과 같이 remove() 메서드를 호출하여 이전에 설정된 값을 제거할 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 호출 스레드의 사용자 값 제거\u003c/span\u003e\nuser.\u003cspan class=\"hljs-title function_\"\u003eremove\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 방법은 기본적으로 스레드와 관련된 User 객체를 제거합니다. 더 중요한 것은 이 작업으로 다른 스레드에는 영향을 미치지 않는다는 점입니다.\u003c/p\u003e\n\u003cp\u003e스레드 로컬을 다이어그램 형식으로 시각화한다면(저는 이것을 좋아합니다), 다음과 같이 보일 것입니다. 두 스레드의 사용자 변수가 서로 다른 User 객체를 가리키는 것을 알 수 있습니다.\u003c/p\u003e\n\u003ch1\u003eThreadLocal 및 자식 스레드\u003c/h1\u003e\n\u003cp\u003e이전 섹션까지의 논의는 주로 한 개의 Java 스레드와 관련되어 있었습니다. 만약 Java 스레드가 새로운 자식 스레드를 시작한다면 어떻게 될까요? 자식 스레드가 부모에서 정의된 Thread Local 변수에 자동으로 액세스할 수 있을까요?\u003c/p\u003e\n\u003cp\u003e답은 \"아니요\"입니다! 자식 스레드는 부모의 Thread Local에 액세스할 수 없으며 이에 대한 매우 좋은 이유가 있습니다. 만약 액세스 가능하다면, Thread Local 변수에 저장된 객체는 스레드 안전하게 작성되어야 할 것이며 이렇게 되면 여러 스레드가 동일한 사용자 객체에 액세스할 수 있을 것입니다. 이는 Java 엔지니어들에 의한 좋은 기본 디자인 결정입니다.\u003c/p\u003e\n\u003cp\u003e하지만 때로는 그런 액세스가 유용할 때가 있습니다. 많은 사용자가 애플리케이션에 액세스하는 웹 애플리케이션과 같은 시나리오를 상상해보십시오. 요청 처리 중 사용자와 연결된 단일 Java 스레드가 있으며, 이 스레드의 Thread Local 객체에 사용자 객체가 저장되어 있다고 상상할 수 있습니다(이는 많은 응용 프로그램 서버 및 Spring Boot와 같은 프레임워크에서 수행됩니다). 그러나 생성된 자식 스레드도이 사용자 정보에 액세스하길 원할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 시나리오에 대해 Java는 InheritableThreadLocal이라는 다른 클래스를 제공합니다.\u003c/p\u003e\n\u003ch1\u003eInheritableThreadLocal 클래스\u003c/h1\u003e\n\u003cp\u003e이 클래스를 사용하는 구문은 사실상 ThreadLocal 클래스와 거의 동일합니다. 아래 예제에서는 InheritableThreadLocal 클래스에 대한 해당 메서드를 보여줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 상속 가능한 쓰레드 로컬 변수 user를 선언합니다\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e InheritableThreadLocal\u0026#x3C;User\u003e user = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInheritableThreadLocal\u003c/span\u003e\u0026#x3C;\u003e();\n\n\u003cspan class=\"hljs-comment\"\u003e// 호출 중인 쓰레드의 user 값을 설정합니다\u003c/span\u003e\nuser.set(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"bob\"\u003c/span\u003e));\n\n\u003cspan class=\"hljs-comment\"\u003e// 호출 중인 쓰레드의 user 값을 가져옵니다\u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003eUser\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003erequestUser\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e user.get();\n\n\u003cspan class=\"hljs-comment\"\u003e// 호출 중인 쓰레드의 user 값을 제거합니다\u003c/span\u003e\nuser.remove();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e쓰레드 로컬 맵과 마찬가지로, 모든 쓰레드에는 상속 가능한 쓰레드 로컬 변수를 위한 맵이 있습니다. 여기서 큰 차이점은 자식 쓰레드가 생성될 때, 자식의 상속 가능한 쓰레드 로컬 맵이 부모로부터 복제된다는 것입니다. 따라서, 상속 가능한 쓰레드 로컬 변수는 자식 쓰레드에서도 접근할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e만약 상속 가능한 쓰레드 로컬 변수를 다이어그램 형태로 시각화한다면, 다음과 같이 보일 것입니다. 상속 가능한 쓰레드 로컬 맵이 부모로부터 복제된 것을 볼 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e함정에 유의하세요!\u003c/h1\u003e\n\u003cp\u003e위 다이어그램에서 명확히 볼 수 있듯이, 상속 가능한 쓰레드 로컬 변수의 장점은 단점이 될 수도 있습니다. 기본적으로, 자식 쓰레드가 생성될 때 상속 가능한 쓰레드 로컬 맵도 복제됩니다. 그러나 부모와 자식 쓰레드에서 동일한 \"User\" 객체를 가리킨다는 것을 알 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이것은 User 객체가 여러 쓰레드에서 접근될 수 있고 스레드 안전하게 작성되어야 한다는 것을 의미합니다. 다시 말하면 - 단순한 ThreadLocal 클래스와 관련된 스레드 안전성이 InheritableThreadLocal 클래스를 사용할 때는 손실됩니다. 이것은 여러분의 디자인에 완벽히 적합할 수 있습니다 - 이에 문제는 없습니다.\u003c/p\u003e\n\u003cp\u003e그러나 더 안전한 접근 방식이 있을 수 있습니다. InheritableThreadLocal을 생성할 때 다음과 같이 childValue(..) 메서드를 지정할 수 있습니다. 사실, 아래 예시에서는 초기값과 child 값도 지정합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e InheritableThreadLocal\u0026#x3C;User\u003e user \n                   = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInheritableThreadLocal\u003c/span\u003e\u0026#x3C;\u003e() {\n\n   \u003cspan class=\"hljs-meta\"\u003e@Override\u003c/span\u003e\n   \u003cspan class=\"hljs-keyword\"\u003eprotected\u003c/span\u003e User \u003cspan class=\"hljs-title function_\"\u003einitialValue\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e { \n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"anonymous\"\u003c/span\u003e); \n   }\n\n   \u003cspan class=\"hljs-meta\"\u003e@Override\u003c/span\u003e\n   \u003cspan class=\"hljs-keyword\"\u003eprotected\u003c/span\u003e User \u003cspan class=\"hljs-title function_\"\u003echildValue\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(User parentValue)\u003c/span\u003e { \n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(parentValue.getId()); \n   }\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 변경 사항을 통해 상속 가능한 스레드 로컬 맵이 복제될 때 자식에 연관된 값은 childValue(..) 메소드를 사용하여 부모 값이 전달되어 설정됩니다. 상속 가능한 스레드 로컬마다 새로운 객체가 생성되므로, User 객체가 부모 및 자식 스레드 간에 공유되지 않습니다. 이 변경으로 스레드 안전성으로 돌아가지만 User 객체에는 읽기 전용으로 액세스할 수 있게됩니다(사실상 복사본을 생성함).\u003c/p\u003e\n\u003cp\u003e다시 말하지만, 다이어그램 형식으로 상속 가능한 스레드 로컬을 시각화하면, 이와 같이 보일 것입니다. 이제 부모와 자식 스레드의 사용자가 서로 다른 User 객체를 가리키는 것을 명확히 알 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-HowdoJavaThreadLocalswork_3.png\" alt=\"Java Thread Locals 동작 방식\"\u003e\u003c/p\u003e\n\u003cp\u003e자바 스레드 지역 변수에 대한 좋은 이해를 얻을 수 있기를 바랍니다.\u003c/p\u003e\n\u003cp\u003e이 게시물이 도움이 되었다면 지원을 표시하기 위해 클로버 아이콘 👏을 몇 번 클릭해 주세요. 읽어 주셔서 감사합니다!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-23-HowdoJavaThreadLocalswork"},"buildId":"RZIEBQ2aNAp_DXFVTV6eL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>