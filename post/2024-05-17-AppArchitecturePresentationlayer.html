<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>앱 아키텍처 프레젠테이션 레이어 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-17-AppArchitecturePresentationlayer" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="앱 아키텍처 프레젠테이션 레이어 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="앱 아키텍처 프레젠테이션 레이어 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-17-AppArchitecturePresentationlayer_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-17-AppArchitecturePresentationlayer" data-gatsby-head="true"/><meta name="twitter:title" content="앱 아키텍처 프레젠테이션 레이어 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-17-AppArchitecturePresentationlayer_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-17 18:36" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-561ae49ab5aab7f5.js" defer=""></script><script src="/_next/static/0asLlD6on3tm8cIfzBaxd/_buildManifest.js" defer=""></script><script src="/_next/static/0asLlD6on3tm8cIfzBaxd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">앱 아키텍처 프레젠테이션 레이어</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="앱 아키텍처 프레젠테이션 레이어" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 17, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-17-AppArchitecturePresentationlayer&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p><img src="/assets/img/2024-05-17-AppArchitecturePresentationlayer_0.png" alt="Presentation Layer"/></p>
<p>오늘은 우리 아키텍처의 프레젠테이션 레이어를 살펴보겠습니다. 이 레이어에는 UI 관련 로직과 사용자가 볼 수 있고 상호 작용할 수 있는 모든 것이 포함됩니다. 또한 이 레이어는 애플리케이션 데이터를 사용자가 읽을 수 있는 형태로 해석하고 반대로 사용자 상호 작용을 앱의 데이터 변경으로 변환하는 것을 담당합니다.</p>
<p><img src="/assets/img/2024-05-17-AppArchitecturePresentationlayer_1.png" alt="UI Layer"/></p>
<p>이 안내서에서는 UI 레이어를 구현하고 구성하는 방법을 보여줄 것입니다. UI 레이어를 구축하기 위해 사용할 수 있는 많은 라이브러리, 프레임워크 및 패턴이 있습니다. 오늘은 Android Fragment + Jatpack Compose + Orbit-MVI + Kotlin + Flow + Coroutines + Koin (DI) 기술 스택을 기반으로 모든 것을 구축할 것입니다. 이것은 최적의 조합 중 하나입니다. 저는 Router, Router Container, ViewModel, Screen, Navigator와 같은 UI 구성 요소에 초점을 맞출 것입니다.</p>
<div class="content-ad"></div>
<h1>라우터</h1>
<p><strong>라우터</strong>는 다음과 같은 기능을 수행하는 메인 UI 유닛입니다:</p>
<ul>
<li>ViewModel, Navigator 및 화면 구성 요소와 함께 UI 요소를 보유합니다.</li>
<li>UI 상태를 소비합니다.</li>
<li>Side Effects(일회성 액션)를 처리합니다.</li>
<li>사용자 상호 작용을 ViewModel로 전달합니다.</li>
</ul>
<p>라우터 뒤에 있는 주요 아이디어는 UI 상태를 생성하고 관리하는 방법을 알고 있으며 탐색할 수 있는, 자체 지속 가능한 UI 유닛을 캡슐화하는 것입니다.</p>
<div class="content-ad"></div>
<h2>네이밍 규칙</h2>
<p>Route 클래스는 해당하는 화면 이름에 따라 이름이 지정됩니다.</p>
<p>화면 이름 + Route</p>
<p>예를 들어: FareListRoute, ConformationRoute.</p>
<div class="content-ad"></div>
<p>위의 코드에서는 Router가 어떻게 보이는지 확인할 수 있습니다. 매개변수로 전달되는 ViewModel은 Koin(DI)에 의해 주입됩니다. 이와 함께, 이전 화면에서 전달된 Navigator와 ryderId를 데이터로 전달합니다. Koin의 멋진 기능 중 하나는 ryderId를 ViewModel 생성자에 주입할 수 있다는 것입니다.</p>
<p>ViewModel 섹션에서 다룰 것입니다. Router에서는 ViewModel이 보유한 상태를 수집하고, 해당 상태를 Screen에 매개변수로 전달합니다.</p>
<p>collectAsState는 ViewModel이 Orbit 라이브러리에서 구현하는 ContainerHost의 확장 기능입니다.</p>
<p>lifecycleState — 이 Flow 작업을 다시 시작하는 Lifecycle이 유지됩니다.</p>
<div class="content-ad"></div>
<p>Markdown으로 표 태그를 변경하세요.</p>
<p>| Header 1 | Header 2 |
| -------- | -------- |
| Data 1   | Data 2   |</p>
<div class="content-ad"></div>
<h2>명명 규칙</h2>
<p>이 클래스들은 그들이 책임지고 있는 UI 구성 요소에 따라 이름이 지어집니다.</p>
<p>UI 구성 요소 이름 + Fragment.</p>
<p>예를 들어 FareListFragment.</p>
<div class="content-ad"></div>
<p>UI 구성 요소 이름 + 컨트롤러.</p>
<p>예를 들어 FareListController.</p>
<p>프래그먼트 클래스의 코드가 작은 이유는 모든 UI 로직이 Route에 캡슐화되어 있기 때문입니다. 이는 컨테이너 구현을 쉽게 변경할 수 있습니다.</p>
<p>이것이 왜 네비게이터의 주입 로직이 Router가 아닌 Fragment 안에 있는 이유입니다. 네비게이터는 네비게이션 로직을 구현하기 위해 Fragment NavController를 필요로하기 때문입니다. 이렇게 함으로써 Router와 컨테이너 구현이 분리되고, 우리가 컨테이너 구현을 쉽게 변경할 수 있게 해줍니다. 예를 들면 — Compose 네비게이션이나 Conductor 라이브러리의 Controller를 사용하는 것과 같이요.</p>
<div class="content-ad"></div>
<h1>네비게이터</h1>
<p>네비게이터는 다음을 담당합니다:</p>
<ul>
<li>라우터에서의 탐색 로직을 캡슐화합니다.</li>
<li>특정 화면을 위한 탐색 API를 제한합니다.</li>
<li>각 화면을 위해 명확한 API를 정의합니다.</li>
</ul>
<p>화면이 다른 화면으로 탐색해야 하는 경우, 해당 화면에 자체 네비게이터 클래스가 있어야 합니다. 이는 기본 ScreenNavigator에서 기본적인 뒤로 가기 동작을 가진 확장되어 있을 수 있으며, 다른 네비게이터와 Fragment NavController와 같은 플랫폼 의존적인 구성 요소를 포함할 수 있습니다.</p>
<div class="content-ad"></div>
<h2>네이밍 규칙</h2>
<p>네비게이터 클래스는 해당하는 화면 이름 뒤에 붙여지는 이름입니다:</p>
<p>화면 이름 + 네비게이터.</p>
<p>예를 들어 FareListNavigator.</p>
<div class="content-ad"></div>
<p>앱 아키텍처 프레젠테이션 계층 다이어그램을 살펴보는 걸로 하죠.</p>
<p><img src="/assets/img/2024-05-17-AppArchitecturePresentationlayer_2.png" alt="다이어그램"/></p>
<p>여기서 Core, Shared와 같은 핵심 모듈, Fare 및 Profile과 같은 기능 모듈, 그리고 App 모듈을 볼 수 있어요.</p>
<p>예를 들어, Fare 모듈이 있는데 그중 하나는 사용자의 프로필 화면으로 이동하는 버튼이 있는 기능이 있어요. 사용자 프로필 페이지는 Profile 모듈에 있죠. 이 네비게이션을 어떻게 구현하면 좋을까요?</p>
<div class="content-ad"></div>
<p>그걸 위해, 사용자 프로필 페이지로 이동하는 방법을 아는 ProfileSharedNavigator 인터페이스를 만들어야 하고, Shared 모듈에 유지해야 합니다.</p>
<p>우리 아키텍처에 따르면 Fare 모듈은 Shared에 의존하므로 FareListNavigator에서 ProfileSharedNavigator를 사용할 수 있습니다.</p>
<p>우리는 FareListNavigator에 ProfileSharedNavigator를 인수로 전달하고, 그곳에 있는 내비게이션 호출을 위임합니다.</p>
<p>ScreenNavigator는 이동하는 방법만을 알고 있는 베이스 클래스입니다.</p>
<div class="content-ad"></div>
<p>앱 모듈은 앱 내 모두에 대해 모든 정보를 알고 있습니다. 이 모듈의 주요 목적은 프로젝트의 모든 피처 모듈 사이에 있는 모든 의존성 주입 로직을 조직화하는 것입니다.</p>
<p>AppNavigator가 ProfileSharedNavigator 인터페이스의 실제 구현을 보유하고 있음을 확인할 수 있습니다. 이 인터페이스에 다양한 모듈에서 의존할 수 있으며, 의존성 역전 원칙 (DIP)을 따라 App 모듈에서 이를 구현할 수 있습니다.</p>
<h1>상태</h1>
<p>상태 파일에는 UI 상태 데이터 클래스가 포함되어 있으며, 사이드 이펙트 시그니처가 가장 적합합니다. 상태 클래스는 구성 변경을 통해 상태가 보존되길 원할 경우 Parcelable(선택 사항)할 수 있습니다. 모든 속성은 가능하다면 기본값을 가져야 합니다. Effect 클래스에는 UI에서의 일회성 작업이 포함되어 있습니다. 이는 네비게이션, 토스트, 스낵 바, 바텀 시트 또는 대화 상자와 같은 것입니다. Effect에 대해 자세히 알아보려면 Orbit Side Effect 문서를 읽어볼 수 있습니다.</p>
<div class="content-ad"></div>
<h2>네이밍 규칙</h2>
<p>상태 클래스는 담당하는 UI 구성 요소 유형에 따라 명명됩니다. 규칙은 다음과 같습니다:</p>
<p>UI 구성 요소 이름 + State.</p>
<p>UI 구성 요소 이름 + Effect.</p>
<div class="content-ad"></div>
<p>예를 들어, FareListState 및 FareListEffect.</p>
<p>화면에 다른 로딩 상태가 있는 경우, 상태 클래스에서 명확하게 분리하는 것이 좋습니다. 화면에는 Idle, Loading, Refreshing, Success, Failure와 같은 몇 가지 콘텐츠 상태가 있을 수 있습니다. 초기 콘텐츠 로딩 후 서버에 요청을 보내어 사용자에게 로딩을 표시하고 싶을 때, status 필드를 사용하여 ScreenContentStatus.Loading을 설정하는 대신 별도의 showRequestLoading 속성을 사용하여 로딩 대화상자를 표시하는 것이 좋습니다. 하나의 필드를 재사용하여 다양한 로딩 케이스를 처리하려고 하지 말아야 합니다.</p>
<h1>모델</h1>
<p>프레젠테이션 레이어에는 도메인 레이어의 모델을 반영하지만 더 UI에 특화된 데이터 모델이 있습니다. 프레젠테이션 모델과 도메인 간의 매핑 로직은 ViewModel 클래스에 배치해야 합니다.</p>
<div class="content-ad"></div>
<ul>
<li>프레젠테이션 레이어는 다른 레이어에게 UI 모델을 노출해서는 안 돼요.</li>
<li>프레젠테이션 모델은 Parcelable 및 Serializable과 같은 플랫폼별 직렬화 방식을 구현할 수 있어요.</li>
<li>프레젠테이션 모델은 변경 불가능해야 해요.</li>
</ul>
<h2>네이밍 규칙</h2>
<p>모델 클래스는 그들이 책임지는 데이터 유형을 나타내는 이름으로 지어져요:</p>
<p>데이터 유형 + Model.</p>
<div class="content-ad"></div>
<p>예를 들어: Ryder, Fare.</p>
<h2>ViewModel</h2>
<p>ViewModel은 비즈니스 로직 상태 보유자입니다. Android 개발에서 ViewModel은 비즈니스 로직에 액세스를 제공하고 응용 프로그램 데이터를 화면에 표시하기 위해 적합합니다. 또한 사용자 이벤트를 처리하고 데이터나 도메인 계층에서 화면 UI 상태로 데이터를 변환합니다.</p>
<p>현재 구현에서 androidx.lifecycle.ViewModel과 Orbit-MVI lib을 사용하고 있습니다. ViewModel은 Orbit 컨테이너를 보유하고 ContainerHost를 구현합니다. 무엇이 진행 중인지 더 잘 이해하기 위해 Orbit API 문서를 확인해보세요.</p>
<div class="content-ad"></div>
<h2>네이밍 규칙</h2>
<p>뷰모델 클래스는 그들이 책임지는 UI 구성 요소 유형에 따라 명명됩니다:</p>
<p>UI 구성 요소 이름 + ViewModel.</p>
<p>예를 들어, FareListViewModel.</p>
<div class="content-ad"></div>
<p>위의 코드에서 ViewModel의 예제를 확인할 수 있습니다. 거기에서 무슨 일이 일어나고 있는지 알아보겠습니다.</p>
<p>먼저 생성자부터 시작해 보겠습니다. 알 수 있듯이, 도메인 레이어에서 유스 케이스를 주입하고, 이전 화면에서 전달한 ryderId 및 ExceptionHandler를 주입합니다. ViewModel은 여러 개의 유스 케이스를 가질 수 있습니다.</p>
<p>아래와 같이 래퍼 클래스에 사용 사례를 넣고</p>
<p>그리고 ViewModel에 넣으려고 하지 마세요</p>
<div class="content-ad"></div>
<p>fetchFares 메소드에서 흥미로운 일이 더 많이 진행됩니다.</p>
<p>Orbit 라이브러리 API에 대해 간략히 설명하겠습니다. Intent 메소드는 Dispatcher.Default에서 람다를 실행합니다. Reduce 메소드는 Dispatcher.Main에서 람다를 실행합니다. 이는 상태를 줄이고 UI 상태를 업데이트합니다.</p>
<p>executeUseCase는 ViewModel의 확장 메소드로, 유증 실행하고 해당 결과를 kotlin.Result<code>R</code>으로 랩핑하는 역할을 합니다. Result 클래스의 확장 메소드인 onSuccess, onFailure 등의 메소드를 사용할 수 있게 합니다. 또한, 예외를 ViewModel 핸들러에 전달합니다.</p>
<p>하나의 작업을 위해 2개 이상의 유증을 실행해야 하는 상황에 직면하면 다음 옵션을 고려해보시기 바랍니다:</p>
<div class="content-ad"></div>
<ul>
<li>새 사용 사례를 만들고 모든 로직을 그곳에 넣으세요. 필요한 사용 사례를 결합하세요.</li>
<li>여러 사용 사례에서 결과를 기다려야하고 그 결과를 결합해야한다면:</li>
</ul>
<p>asPresentation() 메소드는 도메인 계층의 데이터 모델을 프레젠테이션 계층의 모델로 매핑하는 역할을 합니다. 계층간 데이터를 전달하는 방법은 여기에서 읽을 수 있습니다.</p>
<h1>화면</h1>
<p>화면 파일에는 UI 구성 구현이 모두 포함되어 있으며, 각 화면 상태에 대한 Compose 미리 보기가 포함되어 있습니다. 상태에는 비어 있는 상태, 오류 상태, 로딩 상태, 콘텐츠 상태 등이 있습니다.</p>
<div class="content-ad"></div>
<h2>네이밍 규칙</h2>
<p>화면 클래스는 해당 UI 구성 요소 유형을 책임지고 있으므로 그에 따라 명명됩니다:</p>
<p>UI 구성 요소 이름 + Screen.</p>
<p>예를 들어 FareListScreen.</p>
<div class="content-ad"></div>
<p>UI를 Compose를 사용하여 빌드할 때 따르는 것이 좋은 몇 가지 규칙이 있습니다.</p>
<ul>
<li>상태를 가지지 않는 Composable을 상태를 가지는 Composable보다 선택하세요. 이에 대해 더 알아보려면 여기를 읽어보세요.</li>
<li>모든 콜백을 최상위 화면 Composable에 전달하고 모든 사용자 상호 작용을 라우터 수준의 ViewModel에 전달하세요.</li>
<li>UI 구성 요소의 다른 상태에 대한 Composable 미리보기를 만드세요.</li>
</ul>
<p>TopAppBar Composable 함수를 작성해야 한다고 상상해보세요. 타이틀을 매개변수로 전달하는 두 가지 방법이 있습니다. String으로 타이틀을 전달하거나 @Composable () -&gt; Unit 함수로 전달하는 방법이 있습니다.</p>
<p>옵션 1.</p>
<div class="content-ad"></div>
<p>옵션 2를 항상 선택하세요. 그렇게 하면 Composable 함수가 더 맞춤 설정 가능하고 강력해집니다.</p>
<h2>화면 미리보기</h2>
<p>화면 미리보기를 실제 시나리오와 최대한 비슷하게 보이도록 하려면 상태를 만들기 위해 무작위 데이터가 필요합니다. 이를 위해 FareModelFake 클래스를 만들어서 FareModel과 동일한 패키지에 넣을 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"> model/
├─<span class="hljs-title class_">FareModel</span>
├─<span class="hljs-title class_">FareModelFake</span>
</code></pre>
<p>FareModelFake 클래스에는 미리보기에 사용할 수 있는 가짜 데이터가 포함된 FareModel이 있습니다.</p>
<h1>패키징 규칙</h1>
<pre><code class="hljs language-js">presentation/
├─ fare/
│ ├─ component/
│ │ ├─ <span class="hljs-title class_">FareList</span>
│ │ ├─ <span class="hljs-title class_">FareItem</span>
│ ├─ model/
│ │ ├─ <span class="hljs-title class_">FareModel</span>
│ │ ├─ <span class="hljs-title class_">FareModelFake</span>
│ ├─ <span class="hljs-title class_">FareListFragment</span>
│ ├─ <span class="hljs-title class_">FareListNavigator</span>
│ ├─ <span class="hljs-title class_">FareListRoute</span>
│ ├─ <span class="hljs-title class_">FareListScreen</span>
│ ├─ <span class="hljs-title class_">FareListState</span>
│ ├─ <span class="hljs-title class_">FareListViewModel</span>
├─ confirmation/
│ ├─ component/
│ │ ├─ <span class="hljs-title class_">ConfirmationItem</span>
│ ├─ model/
│ │ ├─ <span class="hljs-title class_">ConfirmationModel</span>
│ │ ├─ <span class="hljs-title class_">ConfirmationModelFake</span>
│ ├─ <span class="hljs-title class_">ConfirmationFragment</span>
│ ├─ <span class="hljs-title class_">ConfirmationNavigator</span>
│ ├─ <span class="hljs-title class_">ConfirmationRoute</span>
│ ├─ <span class="hljs-title class_">ConfirmationScreen</span>
│ ├─ <span class="hljs-title class_">ConfirmationState</span>
│ ├─ <span class="hljs-title class_">ConfirmationViewModel</span>
</code></pre>
<div class="content-ad"></div>
<h1>마무리</h1>
<p>프레젠테이션 레이어를 구현하는 다양한 방법이 있습니다. 오늘은 프레젠테이션 레이어를 구현하는 방법에 대해 몇 가지 아이디어를 공유했습니다. 이 접근 방식을 따르거나 여러분의 구현에 몇 가지 아이디어를 활용할 수 있습니다.</p>
<p>GitHub에서 샘플 프로젝트를 확인할 수 있습니다.</p>
<p>다음 앱 아키텍처 주제에 대한 소식을 기다려주세요.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"앱 아키텍처 프레젠테이션 레이어","description":"","date":"2024-05-17 18:36","slug":"2024-05-17-AppArchitecturePresentationlayer","content":"\n\n![Presentation Layer](/assets/img/2024-05-17-AppArchitecturePresentationlayer_0.png)\n\n오늘은 우리 아키텍처의 프레젠테이션 레이어를 살펴보겠습니다. 이 레이어에는 UI 관련 로직과 사용자가 볼 수 있고 상호 작용할 수 있는 모든 것이 포함됩니다. 또한 이 레이어는 애플리케이션 데이터를 사용자가 읽을 수 있는 형태로 해석하고 반대로 사용자 상호 작용을 앱의 데이터 변경으로 변환하는 것을 담당합니다.\n\n![UI Layer](/assets/img/2024-05-17-AppArchitecturePresentationlayer_1.png)\n\n이 안내서에서는 UI 레이어를 구현하고 구성하는 방법을 보여줄 것입니다. UI 레이어를 구축하기 위해 사용할 수 있는 많은 라이브러리, 프레임워크 및 패턴이 있습니다. 오늘은 Android Fragment + Jatpack Compose + Orbit-MVI + Kotlin + Flow + Coroutines + Koin (DI) 기술 스택을 기반으로 모든 것을 구축할 것입니다. 이것은 최적의 조합 중 하나입니다. 저는 Router, Router Container, ViewModel, Screen, Navigator와 같은 UI 구성 요소에 초점을 맞출 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 라우터\n\n**라우터**는 다음과 같은 기능을 수행하는 메인 UI 유닛입니다:\n\n- ViewModel, Navigator 및 화면 구성 요소와 함께 UI 요소를 보유합니다.\n- UI 상태를 소비합니다.\n- Side Effects(일회성 액션)를 처리합니다.\n- 사용자 상호 작용을 ViewModel로 전달합니다.\n\n라우터 뒤에 있는 주요 아이디어는 UI 상태를 생성하고 관리하는 방법을 알고 있으며 탐색할 수 있는, 자체 지속 가능한 UI 유닛을 캡슐화하는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 네이밍 규칙\n\nRoute 클래스는 해당하는 화면 이름에 따라 이름이 지정됩니다.\n\n화면 이름 + Route\n\n예를 들어: FareListRoute, ConformationRoute.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드에서는 Router가 어떻게 보이는지 확인할 수 있습니다. 매개변수로 전달되는 ViewModel은 Koin(DI)에 의해 주입됩니다. 이와 함께, 이전 화면에서 전달된 Navigator와 ryderId를 데이터로 전달합니다. Koin의 멋진 기능 중 하나는 ryderId를 ViewModel 생성자에 주입할 수 있다는 것입니다.\n\nViewModel 섹션에서 다룰 것입니다. Router에서는 ViewModel이 보유한 상태를 수집하고, 해당 상태를 Screen에 매개변수로 전달합니다.\n\ncollectAsState는 ViewModel이 Orbit 라이브러리에서 구현하는 ContainerHost의 확장 기능입니다.\n\nlifecycleState — 이 Flow 작업을 다시 시작하는 Lifecycle이 유지됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMarkdown으로 표 태그를 변경하세요.\n\n\n| Header 1 | Header 2 |\n| -------- | -------- |\n| Data 1   | Data 2   |\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 명명 규칙\n\n이 클래스들은 그들이 책임지고 있는 UI 구성 요소에 따라 이름이 지어집니다.\n\nUI 구성 요소 이름 + Fragment.\n\n예를 들어 FareListFragment.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUI 구성 요소 이름 + 컨트롤러.\n\n예를 들어 FareListController.\n\n프래그먼트 클래스의 코드가 작은 이유는 모든 UI 로직이 Route에 캡슐화되어 있기 때문입니다. 이는 컨테이너 구현을 쉽게 변경할 수 있습니다.\n\n이것이 왜 네비게이터의 주입 로직이 Router가 아닌 Fragment 안에 있는 이유입니다. 네비게이터는 네비게이션 로직을 구현하기 위해 Fragment NavController를 필요로하기 때문입니다. 이렇게 함으로써 Router와 컨테이너 구현이 분리되고, 우리가 컨테이너 구현을 쉽게 변경할 수 있게 해줍니다. 예를 들면 — Compose 네비게이션이나 Conductor 라이브러리의 Controller를 사용하는 것과 같이요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 네비게이터\n\n네비게이터는 다음을 담당합니다:\n\n- 라우터에서의 탐색 로직을 캡슐화합니다.\n- 특정 화면을 위한 탐색 API를 제한합니다.\n- 각 화면을 위해 명확한 API를 정의합니다.\n\n화면이 다른 화면으로 탐색해야 하는 경우, 해당 화면에 자체 네비게이터 클래스가 있어야 합니다. 이는 기본 ScreenNavigator에서 기본적인 뒤로 가기 동작을 가진 확장되어 있을 수 있으며, 다른 네비게이터와 Fragment NavController와 같은 플랫폼 의존적인 구성 요소를 포함할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 네이밍 규칙\n\n네비게이터 클래스는 해당하는 화면 이름 뒤에 붙여지는 이름입니다:\n\n화면 이름 + 네비게이터.\n\n예를 들어 FareListNavigator.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱 아키텍처 프레젠테이션 계층 다이어그램을 살펴보는 걸로 하죠.\n\n![다이어그램](/assets/img/2024-05-17-AppArchitecturePresentationlayer_2.png)\n\n여기서 Core, Shared와 같은 핵심 모듈, Fare 및 Profile과 같은 기능 모듈, 그리고 App 모듈을 볼 수 있어요.\n\n예를 들어, Fare 모듈이 있는데 그중 하나는 사용자의 프로필 화면으로 이동하는 버튼이 있는 기능이 있어요. 사용자 프로필 페이지는 Profile 모듈에 있죠. 이 네비게이션을 어떻게 구현하면 좋을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그걸 위해, 사용자 프로필 페이지로 이동하는 방법을 아는 ProfileSharedNavigator 인터페이스를 만들어야 하고, Shared 모듈에 유지해야 합니다.\n\n우리 아키텍처에 따르면 Fare 모듈은 Shared에 의존하므로 FareListNavigator에서 ProfileSharedNavigator를 사용할 수 있습니다.\n\n우리는 FareListNavigator에 ProfileSharedNavigator를 인수로 전달하고, 그곳에 있는 내비게이션 호출을 위임합니다.\n\nScreenNavigator는 이동하는 방법만을 알고 있는 베이스 클래스입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱 모듈은 앱 내 모두에 대해 모든 정보를 알고 있습니다. 이 모듈의 주요 목적은 프로젝트의 모든 피처 모듈 사이에 있는 모든 의존성 주입 로직을 조직화하는 것입니다.\n\nAppNavigator가 ProfileSharedNavigator 인터페이스의 실제 구현을 보유하고 있음을 확인할 수 있습니다. 이 인터페이스에 다양한 모듈에서 의존할 수 있으며, 의존성 역전 원칙 (DIP)을 따라 App 모듈에서 이를 구현할 수 있습니다.\n\n# 상태\n\n상태 파일에는 UI 상태 데이터 클래스가 포함되어 있으며, 사이드 이펙트 시그니처가 가장 적합합니다. 상태 클래스는 구성 변경을 통해 상태가 보존되길 원할 경우 Parcelable(선택 사항)할 수 있습니다. 모든 속성은 가능하다면 기본값을 가져야 합니다. Effect 클래스에는 UI에서의 일회성 작업이 포함되어 있습니다. 이는 네비게이션, 토스트, 스낵 바, 바텀 시트 또는 대화 상자와 같은 것입니다. Effect에 대해 자세히 알아보려면 Orbit Side Effect 문서를 읽어볼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 네이밍 규칙\n\n상태 클래스는 담당하는 UI 구성 요소 유형에 따라 명명됩니다. 규칙은 다음과 같습니다:\n\nUI 구성 요소 이름 + State.\n\nUI 구성 요소 이름 + Effect.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, FareListState 및 FareListEffect.\n\n화면에 다른 로딩 상태가 있는 경우, 상태 클래스에서 명확하게 분리하는 것이 좋습니다. 화면에는 Idle, Loading, Refreshing, Success, Failure와 같은 몇 가지 콘텐츠 상태가 있을 수 있습니다. 초기 콘텐츠 로딩 후 서버에 요청을 보내어 사용자에게 로딩을 표시하고 싶을 때, status 필드를 사용하여 ScreenContentStatus.Loading을 설정하는 대신 별도의 showRequestLoading 속성을 사용하여 로딩 대화상자를 표시하는 것이 좋습니다. 하나의 필드를 재사용하여 다양한 로딩 케이스를 처리하려고 하지 말아야 합니다.\n\n# 모델\n\n프레젠테이션 레이어에는 도메인 레이어의 모델을 반영하지만 더 UI에 특화된 데이터 모델이 있습니다. 프레젠테이션 모델과 도메인 간의 매핑 로직은 ViewModel 클래스에 배치해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 프레젠테이션 레이어는 다른 레이어에게 UI 모델을 노출해서는 안 돼요.\n- 프레젠테이션 모델은 Parcelable 및 Serializable과 같은 플랫폼별 직렬화 방식을 구현할 수 있어요.\n- 프레젠테이션 모델은 변경 불가능해야 해요.\n\n## 네이밍 규칙\n\n모델 클래스는 그들이 책임지는 데이터 유형을 나타내는 이름으로 지어져요:\n\n데이터 유형 + Model.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어: Ryder, Fare.\n\n## ViewModel\n\nViewModel은 비즈니스 로직 상태 보유자입니다. Android 개발에서 ViewModel은 비즈니스 로직에 액세스를 제공하고 응용 프로그램 데이터를 화면에 표시하기 위해 적합합니다. 또한 사용자 이벤트를 처리하고 데이터나 도메인 계층에서 화면 UI 상태로 데이터를 변환합니다.\n\n현재 구현에서 androidx.lifecycle.ViewModel과 Orbit-MVI lib을 사용하고 있습니다. ViewModel은 Orbit 컨테이너를 보유하고 ContainerHost를 구현합니다. 무엇이 진행 중인지 더 잘 이해하기 위해 Orbit API 문서를 확인해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 네이밍 규칙\n\n뷰모델 클래스는 그들이 책임지는 UI 구성 요소 유형에 따라 명명됩니다:\n\nUI 구성 요소 이름 + ViewModel.\n\n예를 들어, FareListViewModel.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드에서 ViewModel의 예제를 확인할 수 있습니다. 거기에서 무슨 일이 일어나고 있는지 알아보겠습니다.\n\n먼저 생성자부터 시작해 보겠습니다. 알 수 있듯이, 도메인 레이어에서 유스 케이스를 주입하고, 이전 화면에서 전달한 ryderId 및 ExceptionHandler를 주입합니다. ViewModel은 여러 개의 유스 케이스를 가질 수 있습니다.\n\n아래와 같이 래퍼 클래스에 사용 사례를 넣고\n\n그리고 ViewModel에 넣으려고 하지 마세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nfetchFares 메소드에서 흥미로운 일이 더 많이 진행됩니다.\n\nOrbit 라이브러리 API에 대해 간략히 설명하겠습니다. Intent 메소드는 Dispatcher.Default에서 람다를 실행합니다. Reduce 메소드는 Dispatcher.Main에서 람다를 실행합니다. 이는 상태를 줄이고 UI 상태를 업데이트합니다.\n\nexecuteUseCase는 ViewModel의 확장 메소드로, 유증 실행하고 해당 결과를 kotlin.Result`R`으로 랩핑하는 역할을 합니다. Result 클래스의 확장 메소드인 onSuccess, onFailure 등의 메소드를 사용할 수 있게 합니다. 또한, 예외를 ViewModel 핸들러에 전달합니다.\n\n하나의 작업을 위해 2개 이상의 유증을 실행해야 하는 상황에 직면하면 다음 옵션을 고려해보시기 바랍니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 새 사용 사례를 만들고 모든 로직을 그곳에 넣으세요. 필요한 사용 사례를 결합하세요.\n- 여러 사용 사례에서 결과를 기다려야하고 그 결과를 결합해야한다면:\n\nasPresentation() 메소드는 도메인 계층의 데이터 모델을 프레젠테이션 계층의 모델로 매핑하는 역할을 합니다. 계층간 데이터를 전달하는 방법은 여기에서 읽을 수 있습니다.\n\n# 화면\n\n화면 파일에는 UI 구성 구현이 모두 포함되어 있으며, 각 화면 상태에 대한 Compose 미리 보기가 포함되어 있습니다. 상태에는 비어 있는 상태, 오류 상태, 로딩 상태, 콘텐츠 상태 등이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 네이밍 규칙\n\n화면 클래스는 해당 UI 구성 요소 유형을 책임지고 있으므로 그에 따라 명명됩니다:\n\nUI 구성 요소 이름 + Screen.\n\n예를 들어 FareListScreen.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUI를 Compose를 사용하여 빌드할 때 따르는 것이 좋은 몇 가지 규칙이 있습니다.\n\n- 상태를 가지지 않는 Composable을 상태를 가지는 Composable보다 선택하세요. 이에 대해 더 알아보려면 여기를 읽어보세요.\n- 모든 콜백을 최상위 화면 Composable에 전달하고 모든 사용자 상호 작용을 라우터 수준의 ViewModel에 전달하세요.\n- UI 구성 요소의 다른 상태에 대한 Composable 미리보기를 만드세요.\n\nTopAppBar Composable 함수를 작성해야 한다고 상상해보세요. 타이틀을 매개변수로 전달하는 두 가지 방법이 있습니다. String으로 타이틀을 전달하거나 @Composable () -\u003e Unit 함수로 전달하는 방법이 있습니다.\n\n옵션 1.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n옵션 2를 항상 선택하세요. 그렇게 하면 Composable 함수가 더 맞춤 설정 가능하고 강력해집니다.\n\n## 화면 미리보기\n\n화면 미리보기를 실제 시나리오와 최대한 비슷하게 보이도록 하려면 상태를 만들기 위해 무작위 데이터가 필요합니다. 이를 위해 FareModelFake 클래스를 만들어서 FareModel과 동일한 패키지에 넣을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n model/\n├─FareModel\n├─FareModelFake\n```\n\nFareModelFake 클래스에는 미리보기에 사용할 수 있는 가짜 데이터가 포함된 FareModel이 있습니다.\n\n# 패키징 규칙\n\n```js\npresentation/\n├─ fare/\n│ ├─ component/\n│ │ ├─ FareList\n│ │ ├─ FareItem\n│ ├─ model/\n│ │ ├─ FareModel\n│ │ ├─ FareModelFake\n│ ├─ FareListFragment\n│ ├─ FareListNavigator\n│ ├─ FareListRoute\n│ ├─ FareListScreen\n│ ├─ FareListState\n│ ├─ FareListViewModel\n├─ confirmation/\n│ ├─ component/\n│ │ ├─ ConfirmationItem\n│ ├─ model/\n│ │ ├─ ConfirmationModel\n│ │ ├─ ConfirmationModelFake\n│ ├─ ConfirmationFragment\n│ ├─ ConfirmationNavigator\n│ ├─ ConfirmationRoute\n│ ├─ ConfirmationScreen\n│ ├─ ConfirmationState\n│ ├─ ConfirmationViewModel\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 마무리\n\n프레젠테이션 레이어를 구현하는 다양한 방법이 있습니다. 오늘은 프레젠테이션 레이어를 구현하는 방법에 대해 몇 가지 아이디어를 공유했습니다. 이 접근 방식을 따르거나 여러분의 구현에 몇 가지 아이디어를 활용할 수 있습니다.\n\nGitHub에서 샘플 프로젝트를 확인할 수 있습니다.\n\n다음 앱 아키텍처 주제에 대한 소식을 기다려주세요.","ogImage":{"url":"/assets/img/2024-05-17-AppArchitecturePresentationlayer_0.png"},"coverImage":"/assets/img/2024-05-17-AppArchitecturePresentationlayer_0.png","tag":["Tech"],"readingTime":9},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    strong: \"strong\",\n    ul: \"ul\",\n    li: \"li\",\n    h2: \"h2\",\n    code: \"code\",\n    pre: \"pre\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-AppArchitecturePresentationlayer_0.png\",\n        alt: \"Presentation Layer\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"오늘은 우리 아키텍처의 프레젠테이션 레이어를 살펴보겠습니다. 이 레이어에는 UI 관련 로직과 사용자가 볼 수 있고 상호 작용할 수 있는 모든 것이 포함됩니다. 또한 이 레이어는 애플리케이션 데이터를 사용자가 읽을 수 있는 형태로 해석하고 반대로 사용자 상호 작용을 앱의 데이터 변경으로 변환하는 것을 담당합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-AppArchitecturePresentationlayer_1.png\",\n        alt: \"UI Layer\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 안내서에서는 UI 레이어를 구현하고 구성하는 방법을 보여줄 것입니다. UI 레이어를 구축하기 위해 사용할 수 있는 많은 라이브러리, 프레임워크 및 패턴이 있습니다. 오늘은 Android Fragment + Jatpack Compose + Orbit-MVI + Kotlin + Flow + Coroutines + Koin (DI) 기술 스택을 기반으로 모든 것을 구축할 것입니다. 이것은 최적의 조합 중 하나입니다. 저는 Router, Router Container, ViewModel, Screen, Navigator와 같은 UI 구성 요소에 초점을 맞출 것입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"라우터\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"라우터\"\n      }), \"는 다음과 같은 기능을 수행하는 메인 UI 유닛입니다:\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"ViewModel, Navigator 및 화면 구성 요소와 함께 UI 요소를 보유합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"UI 상태를 소비합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Side Effects(일회성 액션)를 처리합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"사용자 상호 작용을 ViewModel로 전달합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"라우터 뒤에 있는 주요 아이디어는 UI 상태를 생성하고 관리하는 방법을 알고 있으며 탐색할 수 있는, 자체 지속 가능한 UI 유닛을 캡슐화하는 것입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"네이밍 규칙\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Route 클래스는 해당하는 화면 이름에 따라 이름이 지정됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"화면 이름 + Route\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어: FareListRoute, ConformationRoute.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 코드에서는 Router가 어떻게 보이는지 확인할 수 있습니다. 매개변수로 전달되는 ViewModel은 Koin(DI)에 의해 주입됩니다. 이와 함께, 이전 화면에서 전달된 Navigator와 ryderId를 데이터로 전달합니다. Koin의 멋진 기능 중 하나는 ryderId를 ViewModel 생성자에 주입할 수 있다는 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ViewModel 섹션에서 다룰 것입니다. Router에서는 ViewModel이 보유한 상태를 수집하고, 해당 상태를 Screen에 매개변수로 전달합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"collectAsState는 ViewModel이 Orbit 라이브러리에서 구현하는 ContainerHost의 확장 기능입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"lifecycleState — 이 Flow 작업을 다시 시작하는 Lifecycle이 유지됩니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Markdown으로 표 태그를 변경하세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"| Header 1 | Header 2 |\\n| -------- | -------- |\\n| Data 1   | Data 2   |\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"명명 규칙\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 클래스들은 그들이 책임지고 있는 UI 구성 요소에 따라 이름이 지어집니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"UI 구성 요소 이름 + Fragment.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어 FareListFragment.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"UI 구성 요소 이름 + 컨트롤러.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어 FareListController.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프래그먼트 클래스의 코드가 작은 이유는 모든 UI 로직이 Route에 캡슐화되어 있기 때문입니다. 이는 컨테이너 구현을 쉽게 변경할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것이 왜 네비게이터의 주입 로직이 Router가 아닌 Fragment 안에 있는 이유입니다. 네비게이터는 네비게이션 로직을 구현하기 위해 Fragment NavController를 필요로하기 때문입니다. 이렇게 함으로써 Router와 컨테이너 구현이 분리되고, 우리가 컨테이너 구현을 쉽게 변경할 수 있게 해줍니다. 예를 들면 — Compose 네비게이션이나 Conductor 라이브러리의 Controller를 사용하는 것과 같이요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"네비게이터\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"네비게이터는 다음을 담당합니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"라우터에서의 탐색 로직을 캡슐화합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"특정 화면을 위한 탐색 API를 제한합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"각 화면을 위해 명확한 API를 정의합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"화면이 다른 화면으로 탐색해야 하는 경우, 해당 화면에 자체 네비게이터 클래스가 있어야 합니다. 이는 기본 ScreenNavigator에서 기본적인 뒤로 가기 동작을 가진 확장되어 있을 수 있으며, 다른 네비게이터와 Fragment NavController와 같은 플랫폼 의존적인 구성 요소를 포함할 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"네이밍 규칙\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"네비게이터 클래스는 해당하는 화면 이름 뒤에 붙여지는 이름입니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"화면 이름 + 네비게이터.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어 FareListNavigator.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"앱 아키텍처 프레젠테이션 계층 다이어그램을 살펴보는 걸로 하죠.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-AppArchitecturePresentationlayer_2.png\",\n        alt: \"다이어그램\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서 Core, Shared와 같은 핵심 모듈, Fare 및 Profile과 같은 기능 모듈, 그리고 App 모듈을 볼 수 있어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어, Fare 모듈이 있는데 그중 하나는 사용자의 프로필 화면으로 이동하는 버튼이 있는 기능이 있어요. 사용자 프로필 페이지는 Profile 모듈에 있죠. 이 네비게이션을 어떻게 구현하면 좋을까요?\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그걸 위해, 사용자 프로필 페이지로 이동하는 방법을 아는 ProfileSharedNavigator 인터페이스를 만들어야 하고, Shared 모듈에 유지해야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리 아키텍처에 따르면 Fare 모듈은 Shared에 의존하므로 FareListNavigator에서 ProfileSharedNavigator를 사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 FareListNavigator에 ProfileSharedNavigator를 인수로 전달하고, 그곳에 있는 내비게이션 호출을 위임합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ScreenNavigator는 이동하는 방법만을 알고 있는 베이스 클래스입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"앱 모듈은 앱 내 모두에 대해 모든 정보를 알고 있습니다. 이 모듈의 주요 목적은 프로젝트의 모든 피처 모듈 사이에 있는 모든 의존성 주입 로직을 조직화하는 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"AppNavigator가 ProfileSharedNavigator 인터페이스의 실제 구현을 보유하고 있음을 확인할 수 있습니다. 이 인터페이스에 다양한 모듈에서 의존할 수 있으며, 의존성 역전 원칙 (DIP)을 따라 App 모듈에서 이를 구현할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"상태\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"상태 파일에는 UI 상태 데이터 클래스가 포함되어 있으며, 사이드 이펙트 시그니처가 가장 적합합니다. 상태 클래스는 구성 변경을 통해 상태가 보존되길 원할 경우 Parcelable(선택 사항)할 수 있습니다. 모든 속성은 가능하다면 기본값을 가져야 합니다. Effect 클래스에는 UI에서의 일회성 작업이 포함되어 있습니다. 이는 네비게이션, 토스트, 스낵 바, 바텀 시트 또는 대화 상자와 같은 것입니다. Effect에 대해 자세히 알아보려면 Orbit Side Effect 문서를 읽어볼 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"네이밍 규칙\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"상태 클래스는 담당하는 UI 구성 요소 유형에 따라 명명됩니다. 규칙은 다음과 같습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"UI 구성 요소 이름 + State.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"UI 구성 요소 이름 + Effect.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어, FareListState 및 FareListEffect.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"화면에 다른 로딩 상태가 있는 경우, 상태 클래스에서 명확하게 분리하는 것이 좋습니다. 화면에는 Idle, Loading, Refreshing, Success, Failure와 같은 몇 가지 콘텐츠 상태가 있을 수 있습니다. 초기 콘텐츠 로딩 후 서버에 요청을 보내어 사용자에게 로딩을 표시하고 싶을 때, status 필드를 사용하여 ScreenContentStatus.Loading을 설정하는 대신 별도의 showRequestLoading 속성을 사용하여 로딩 대화상자를 표시하는 것이 좋습니다. 하나의 필드를 재사용하여 다양한 로딩 케이스를 처리하려고 하지 말아야 합니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"모델\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프레젠테이션 레이어에는 도메인 레이어의 모델을 반영하지만 더 UI에 특화된 데이터 모델이 있습니다. 프레젠테이션 모델과 도메인 간의 매핑 로직은 ViewModel 클래스에 배치해야 합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"프레젠테이션 레이어는 다른 레이어에게 UI 모델을 노출해서는 안 돼요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"프레젠테이션 모델은 Parcelable 및 Serializable과 같은 플랫폼별 직렬화 방식을 구현할 수 있어요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"프레젠테이션 모델은 변경 불가능해야 해요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"네이밍 규칙\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"모델 클래스는 그들이 책임지는 데이터 유형을 나타내는 이름으로 지어져요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"데이터 유형 + Model.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어: Ryder, Fare.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"ViewModel\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ViewModel은 비즈니스 로직 상태 보유자입니다. Android 개발에서 ViewModel은 비즈니스 로직에 액세스를 제공하고 응용 프로그램 데이터를 화면에 표시하기 위해 적합합니다. 또한 사용자 이벤트를 처리하고 데이터나 도메인 계층에서 화면 UI 상태로 데이터를 변환합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"현재 구현에서 androidx.lifecycle.ViewModel과 Orbit-MVI lib을 사용하고 있습니다. ViewModel은 Orbit 컨테이너를 보유하고 ContainerHost를 구현합니다. 무엇이 진행 중인지 더 잘 이해하기 위해 Orbit API 문서를 확인해보세요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"네이밍 규칙\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"뷰모델 클래스는 그들이 책임지는 UI 구성 요소 유형에 따라 명명됩니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"UI 구성 요소 이름 + ViewModel.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어, FareListViewModel.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 코드에서 ViewModel의 예제를 확인할 수 있습니다. 거기에서 무슨 일이 일어나고 있는지 알아보겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저 생성자부터 시작해 보겠습니다. 알 수 있듯이, 도메인 레이어에서 유스 케이스를 주입하고, 이전 화면에서 전달한 ryderId 및 ExceptionHandler를 주입합니다. ViewModel은 여러 개의 유스 케이스를 가질 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래와 같이 래퍼 클래스에 사용 사례를 넣고\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 ViewModel에 넣으려고 하지 마세요\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"fetchFares 메소드에서 흥미로운 일이 더 많이 진행됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Orbit 라이브러리 API에 대해 간략히 설명하겠습니다. Intent 메소드는 Dispatcher.Default에서 람다를 실행합니다. Reduce 메소드는 Dispatcher.Main에서 람다를 실행합니다. 이는 상태를 줄이고 UI 상태를 업데이트합니다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"executeUseCase는 ViewModel의 확장 메소드로, 유증 실행하고 해당 결과를 kotlin.Result\", _jsx(_components.code, {\n        children: \"R\"\n      }), \"으로 랩핑하는 역할을 합니다. Result 클래스의 확장 메소드인 onSuccess, onFailure 등의 메소드를 사용할 수 있게 합니다. 또한, 예외를 ViewModel 핸들러에 전달합니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하나의 작업을 위해 2개 이상의 유증을 실행해야 하는 상황에 직면하면 다음 옵션을 고려해보시기 바랍니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"새 사용 사례를 만들고 모든 로직을 그곳에 넣으세요. 필요한 사용 사례를 결합하세요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"여러 사용 사례에서 결과를 기다려야하고 그 결과를 결합해야한다면:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"asPresentation() 메소드는 도메인 계층의 데이터 모델을 프레젠테이션 계층의 모델로 매핑하는 역할을 합니다. 계층간 데이터를 전달하는 방법은 여기에서 읽을 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"화면\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"화면 파일에는 UI 구성 구현이 모두 포함되어 있으며, 각 화면 상태에 대한 Compose 미리 보기가 포함되어 있습니다. 상태에는 비어 있는 상태, 오류 상태, 로딩 상태, 콘텐츠 상태 등이 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"네이밍 규칙\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"화면 클래스는 해당 UI 구성 요소 유형을 책임지고 있으므로 그에 따라 명명됩니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"UI 구성 요소 이름 + Screen.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어 FareListScreen.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"UI를 Compose를 사용하여 빌드할 때 따르는 것이 좋은 몇 가지 규칙이 있습니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"상태를 가지지 않는 Composable을 상태를 가지는 Composable보다 선택하세요. 이에 대해 더 알아보려면 여기를 읽어보세요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"모든 콜백을 최상위 화면 Composable에 전달하고 모든 사용자 상호 작용을 라우터 수준의 ViewModel에 전달하세요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"UI 구성 요소의 다른 상태에 대한 Composable 미리보기를 만드세요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"TopAppBar Composable 함수를 작성해야 한다고 상상해보세요. 타이틀을 매개변수로 전달하는 두 가지 방법이 있습니다. String으로 타이틀을 전달하거나 @Composable () -\u003e Unit 함수로 전달하는 방법이 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"옵션 1.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"옵션 2를 항상 선택하세요. 그렇게 하면 Composable 함수가 더 맞춤 설정 가능하고 강력해집니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"화면 미리보기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"화면 미리보기를 실제 시나리오와 최대한 비슷하게 보이도록 하려면 상태를 만들기 위해 무작위 데이터가 필요합니다. 이를 위해 FareModelFake 클래스를 만들어서 FareModel과 동일한 패키지에 넣을 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\" model/\\n├─\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FareModel\"\n        }), \"\\n├─\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FareModelFake\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"FareModelFake 클래스에는 미리보기에 사용할 수 있는 가짜 데이터가 포함된 FareModel이 있습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"패키징 규칙\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"presentation/\\n├─ fare/\\n│ ├─ component/\\n│ │ ├─ \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FareList\"\n        }), \"\\n│ │ ├─ \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FareItem\"\n        }), \"\\n│ ├─ model/\\n│ │ ├─ \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FareModel\"\n        }), \"\\n│ │ ├─ \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FareModelFake\"\n        }), \"\\n│ ├─ \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FareListFragment\"\n        }), \"\\n│ ├─ \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FareListNavigator\"\n        }), \"\\n│ ├─ \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FareListRoute\"\n        }), \"\\n│ ├─ \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FareListScreen\"\n        }), \"\\n│ ├─ \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FareListState\"\n        }), \"\\n│ ├─ \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FareListViewModel\"\n        }), \"\\n├─ confirmation/\\n│ ├─ component/\\n│ │ ├─ \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ConfirmationItem\"\n        }), \"\\n│ ├─ model/\\n│ │ ├─ \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ConfirmationModel\"\n        }), \"\\n│ │ ├─ \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ConfirmationModelFake\"\n        }), \"\\n│ ├─ \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ConfirmationFragment\"\n        }), \"\\n│ ├─ \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ConfirmationNavigator\"\n        }), \"\\n│ ├─ \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ConfirmationRoute\"\n        }), \"\\n│ ├─ \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ConfirmationScreen\"\n        }), \"\\n│ ├─ \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ConfirmationState\"\n        }), \"\\n│ ├─ \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ConfirmationViewModel\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"마무리\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프레젠테이션 레이어를 구현하는 다양한 방법이 있습니다. 오늘은 프레젠테이션 레이어를 구현하는 방법에 대해 몇 가지 아이디어를 공유했습니다. 이 접근 방식을 따르거나 여러분의 구현에 몇 가지 아이디어를 활용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"GitHub에서 샘플 프로젝트를 확인할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 앱 아키텍처 주제에 대한 소식을 기다려주세요.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-17-AppArchitecturePresentationlayer"},"buildId":"0asLlD6on3tm8cIfzBaxd","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>