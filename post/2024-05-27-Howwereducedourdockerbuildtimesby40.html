<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>우리가 도커 빌드 시간을 40 줄인 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-27-Howwereducedourdockerbuildtimesby40" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="우리가 도커 빌드 시간을 40 줄인 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="우리가 도커 빌드 시간을 40 줄인 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-27-Howwereducedourdockerbuildtimesby40_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-27-Howwereducedourdockerbuildtimesby40" data-gatsby-head="true"/><meta name="twitter:title" content="우리가 도커 빌드 시간을 40 줄인 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-27-Howwereducedourdockerbuildtimesby40_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-27 17:22" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_buildManifest.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">우리가 도커 빌드 시간을 40 줄인 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="우리가 도커 빌드 시간을 40 줄인 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 27, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-27-Howwereducedourdockerbuildtimesby40&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>많은 기업들과 마찬가지로, 저희 회사도 제품에 사용되는 모든 구성 요소에 대한 도커 이미지를 빌드합니다. 시간이 지남에 따라 몇 가지 이미지가 점점 커지고, 또한 CI 빌드 시간이 점점 오래 걸리게 되었습니다. 제 목표는 CI 빌드가 5분을 넘지 않도록 하는 것입니다. 이 아이디어는 커피를 마시기에 이상적인 시간이기 때문에 나왔습니다. 그 시간을 넘어가면, 개발자의 생산성이 떨어지게 됩니다.</p>
<p>생산성이 감소하는 이유는 다음과 같습니다:</p>
<ul>
<li>개발자들은 빌드가 완료되기를 기다려야 하며, 따라서 시간을 낭비합니다.</li>
<li>개발자들은 새로운 작업을 시작하고 나중에 되돌아옵니다. 이는 더 많은 문맥 전환을 요구하며 종종 비효율성으로 이어집니다.</li>
</ul>
<p><a href="/assets/img/2024-05-27-Howwereducedourdockerbuildtimesby40_0.png">이미지</a></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 블로그 포스트에서는 적용한 2가지 작은 변경 사항을 설명하고, 빌드 시간이 drasctic하게 개선된 결과를 보여드리고 싶습니다. 이러한 개선 사항에 집중하기 전에 Dockerfile 작성에 대한 최상의 실천 방법을 이미 준수하고 있는지 확인하세요.</p>
<ul>
<li>레이어 수를 최소화합니다</li>
<li>멀티 스테이지 빌드를 사용합니다</li>
<li>최소한의 베이스 이미지를 사용합니다</li>
<li>…</li>
</ul>
<h1>Buildkit vs Buildx</h1>
<p>먼저 Buildkit과 Buildx에 대해 설명하겠습니다. 이 두 용어는 종종 서로 교차적으로 사용되지만 실제로 동일하지는 않습니다. 이 게시물을 작성하기 전에 나도 두 용어 사이의 차이를 완전히 이해하지 못했습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>빌킷</h2>
<p>빌킷은 기존의 도커 빌더를 대체하는 개선된 백엔드입니다. 2018년부터 도커와 함께 제공되어 기본 빌더로 설정되었습니다.</p>
<p>다음과 같은 많은 흥미로운 기능을 제공합니다:</p>
<ul>
<li>개선된 캐싱 기능</li>
<li>서로 다른 레이어를 병렬로 빌드</li>
<li>기본 이미지를 지연해서 로드합니다 (≥ 빌킷 0.9)</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Buildkit을 사용할 때 docker build 명령의 출력이 더 깔끔하고 구조화된 모습이 빠르게 눈에 띕니다.</p>
<p>23.0 버전보다 오래된 docker 버전을 사용할 때 Buildkit을 사용하는 일반적인 방법은 다음과 같이 Buildkit 인수를 설정하는 것입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">DOCKER_BUILDKIT</span>=<span class="hljs-number">1</span> docker build --platform linux/amd64 . -t <span class="hljs-attr">someImage</span>:someVersion
<span class="hljs-variable constant_">DOCKER_BUILDKIT</span>=<span class="hljs-number">1</span> docker push <span class="hljs-attr">someImage</span>:someVersion
</code></pre>
<h2>Buildx</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>빌드엑스(Buildx)는 도커의 플러그인으로, 도커에서 빌드킷(Buildkit)의 모든 잠재력을 활용할 수 있게 해줍니다. 이것은 빌드킷이 새로운 구성 옵션을 지원하는데, 이를 모두 도커 빌드 명령에 거슬러 호환되는 방식으로 통합하기 어려운 경우에 만들어졌습니다.</p>
<p>이미지를 빌드하는 데 추가로, 빌드엑스는 여러 빌더를 관리하는 것을 지원합니다. CI에서 유용하게 쓰일 수 있으며, 공유 도커 데몬을 수정하지 않고 다른 설정으로 환경을 정의하는 데 도움이 됩니다.</p>
<p>빌드엑스를 시작하는 방법은 다음과 같습니다:</p>
<pre><code class="hljs language-js">docker buildx create --bootstrap --name builder
docker buildx use builder
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>원격 캐시의 혜택</h1>
<p>빌드를 가속화하는 첫 번째 방법은 이미지를 원격 레지스트리에 캐시하는 것입니다. 이렇게 하면 일반적으로 CI에서 수행되는 빌드와 같이 다른 기계에서 빌드하는 경우에도 빌드 캐시를 활용할 수 있습니다. 이를 해결하기 위해 많은 사람들이 새 이미지 버전을 빌드하기 전에 이미지의 최신 버전을 다운로드했습니다. 이점은 변경되지 않은 레이어를 캐시할 수 있다는 것인데, 처음에 전체 이미지를 다운받는 데 시간이 걸릴 수 있지만 레이어를 재사용할 수 있는 것은 보장할 수 없습니다. 예를 들어, 다음 명령어를 사용했습니다:</p>
<pre><code class="hljs language-js">docker pull <span class="hljs-attr">someImage</span>:latest || <span class="hljs-literal">true</span>
docker build --platform linux/amd64 . \
-t <span class="hljs-attr">someImage</span>:someVersion \
--cache-<span class="hljs-keyword">from</span> <span class="hljs-attr">someImage</span>:latest
</code></pre>
<p>Buildx를 사용하면 캐시 정보를 원격 위치(예: 컨테이너 레지스트리, Blob 스토리지 등)에 저장할 수 있습니다. 빌더는 주어진 레이어가 이미 존재하는지 확인하고, 그렇다면 다시 만들지 않고 재사용합니다. 이를 로컬로 다운로드하지 않고도 수행할 수 있습니다. 이 메커니즘을 활용하기 위해 이전 명령어를 재작성한 것은 다음과 같습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>docker buildx build --platform linux/amd64 . <br>
-t someImage:someVersion --push <br>
--cache-to type=inline,mode=max <br>
--cache-from someImage:somePreviousVersion</p>
<p>"max" 모드는 결과 이미지에 사용되지 않는 레이어도 모든 빌드 정보를 저장한다는 것을 의미합니다 (예: 멀티 스테이지 빌드 사용 시). 기본적으로 "min" 모드가 사용되며 최종 이미지에 존재하는 레이어에 대한 빌드 정보만 저장합니다.</p>
<p>캐싱의 특수 사례는 캐시 데이터를 "inline"으로 저장하는 것이며, 이미지와 함께 캐싱된다는 것을 의미합니다. 이 옵션은 Buildx 없이 Buildkit을 사용할 때도 지원됩니다. 멀티 스테이지 빌드를 사용할 때 시작하기 가장 쉽지만 출력물과 캐시 사이에 명확한 구분을 제공하지 않으며 조심해야 합니다. 캐시 데이터를 "inline"으로 저장하는 명령어는 다음과 같습니다:</p>
<p>docker buildx build --platform linux/amd64 . <br>
-t someImage:someVersion --push <br>
--cache-to type=inline,mode=max <br>
--cache-from someImage:somePreviousVersion</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>Docker 이미지에 파일 추가하는 새로운 방법</h1>
<p>도커는 Dockerfile 작성을 위한 새로운 구문 버전, 즉 #syntax=docker/dockerfile:1.4를 소개했습니다. 이 버전은 COPY 및 ADD 명령에 대한 추가 링크 옵션을 지원합니다.</p>
<p>이전에 COPY 또는 ADD 명령을 사용할 때 빌더가 새로운 스냅샷을 만들어 새 파일을 기존 파일 시스템과 병합했습니다. 이 작업을 수행하려면 부모 레이어가 모두 존재해야 하는데, 그렇지 않으면 대상 디렉토리가 아직 존재하지 않을 수 있습니다. 최종적으로 이미지(빌드 명령의 결과물)는 각각의 스냅샷 간의 차이를 포함하는 레이어 당 tarball로 구성됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">FROM</span> <span class="hljs-attr">baseImage</span>:version
<span class="hljs-variable constant_">COPY</span> binary /opt/
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>링크 옵션을 사용하면 새 파일은 이전 레이어에 의존하지 않고 자체 스냅샷에 넣습니다. 링크된 파일은 자체 tarball에 저장되며 서로 다른 tarball들이 연결되어 파일 시스템에 의존하지 않고 연결됩니다. 다음 이미지에 설명이 나와 있습니다.</p>
<p><img src="/assets/img/2024-05-27-Howwereducedourdockerbuildtimesby40_1.png" alt="이미지"></p>
<pre><code class="hljs language-js"># syntax=docker/<span class="hljs-attr">dockerfile</span>:<span class="hljs-number">1.4</span>
<span class="hljs-variable constant_">FROM</span> <span class="hljs-attr">baseImage</span>:version
<span class="hljs-variable constant_">COPY</span> [--chown=&#x3C;user>:&#x3C;group>] [--chmod=&#x3C;perms>] --link binary /opt/
</code></pre>
<p>주요 장점은 파일이 이제 이전 레이어에 의존하지 않는다는 것입니다. 파일이 변경되지 않았다면 이전 레이어가 변경되더라도 레이어를 재사용할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>또한 여러 레이어의 데이터 복사가 이제 병렬로 실행될 수 있기 때문에 빌드 속도를 높일 수도 있습니다.</p>
<h1>결론</h1>
<p>이 블로그 포스트에서는 CI 파이프라인을 최적화한 후 얻은 몇 가지 새로운 통찰을 설명합니다. 전체 도커 빌드 시간을 40% 줄이게 된 두 가지 작은 변경 사항에 대해 논의하겠습니다.</p>
<ul>
<li>빌드 캐시 정보를 원격으로 저장</li>
<li>도커 이미지에 파일을 추가하거나 복사할 때 링크 옵션 사용</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"우리가 도커 빌드 시간을 40 줄인 방법","description":"","date":"2024-05-27 17:22","slug":"2024-05-27-Howwereducedourdockerbuildtimesby40","content":"\n많은 기업들과 마찬가지로, 저희 회사도 제품에 사용되는 모든 구성 요소에 대한 도커 이미지를 빌드합니다. 시간이 지남에 따라 몇 가지 이미지가 점점 커지고, 또한 CI 빌드 시간이 점점 오래 걸리게 되었습니다. 제 목표는 CI 빌드가 5분을 넘지 않도록 하는 것입니다. 이 아이디어는 커피를 마시기에 이상적인 시간이기 때문에 나왔습니다. 그 시간을 넘어가면, 개발자의 생산성이 떨어지게 됩니다.\n\n생산성이 감소하는 이유는 다음과 같습니다:\n\n- 개발자들은 빌드가 완료되기를 기다려야 하며, 따라서 시간을 낭비합니다.\n- 개발자들은 새로운 작업을 시작하고 나중에 되돌아옵니다. 이는 더 많은 문맥 전환을 요구하며 종종 비효율성으로 이어집니다.\n\n[이미지](/assets/img/2024-05-27-Howwereducedourdockerbuildtimesby40_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 블로그 포스트에서는 적용한 2가지 작은 변경 사항을 설명하고, 빌드 시간이 drasctic하게 개선된 결과를 보여드리고 싶습니다. 이러한 개선 사항에 집중하기 전에 Dockerfile 작성에 대한 최상의 실천 방법을 이미 준수하고 있는지 확인하세요.\n\n- 레이어 수를 최소화합니다\n- 멀티 스테이지 빌드를 사용합니다\n- 최소한의 베이스 이미지를 사용합니다\n- …\n\n# Buildkit vs Buildx\n\n먼저 Buildkit과 Buildx에 대해 설명하겠습니다. 이 두 용어는 종종 서로 교차적으로 사용되지만 실제로 동일하지는 않습니다. 이 게시물을 작성하기 전에 나도 두 용어 사이의 차이를 완전히 이해하지 못했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 빌킷\n\n빌킷은 기존의 도커 빌더를 대체하는 개선된 백엔드입니다. 2018년부터 도커와 함께 제공되어 기본 빌더로 설정되었습니다.\n\n다음과 같은 많은 흥미로운 기능을 제공합니다:\n\n- 개선된 캐싱 기능\n- 서로 다른 레이어를 병렬로 빌드\n- 기본 이미지를 지연해서 로드합니다 (≥ 빌킷 0.9)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nBuildkit을 사용할 때 docker build 명령의 출력이 더 깔끔하고 구조화된 모습이 빠르게 눈에 띕니다.\n\n23.0 버전보다 오래된 docker 버전을 사용할 때 Buildkit을 사용하는 일반적인 방법은 다음과 같이 Buildkit 인수를 설정하는 것입니다:\n\n```js\nDOCKER_BUILDKIT=1 docker build --platform linux/amd64 . -t someImage:someVersion\nDOCKER_BUILDKIT=1 docker push someImage:someVersion\n```\n\n## Buildx\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n빌드엑스(Buildx)는 도커의 플러그인으로, 도커에서 빌드킷(Buildkit)의 모든 잠재력을 활용할 수 있게 해줍니다. 이것은 빌드킷이 새로운 구성 옵션을 지원하는데, 이를 모두 도커 빌드 명령에 거슬러 호환되는 방식으로 통합하기 어려운 경우에 만들어졌습니다.\n\n이미지를 빌드하는 데 추가로, 빌드엑스는 여러 빌더를 관리하는 것을 지원합니다. CI에서 유용하게 쓰일 수 있으며, 공유 도커 데몬을 수정하지 않고 다른 설정으로 환경을 정의하는 데 도움이 됩니다.\n\n빌드엑스를 시작하는 방법은 다음과 같습니다:\n\n```js\ndocker buildx create --bootstrap --name builder\ndocker buildx use builder\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 원격 캐시의 혜택\n\n빌드를 가속화하는 첫 번째 방법은 이미지를 원격 레지스트리에 캐시하는 것입니다. 이렇게 하면 일반적으로 CI에서 수행되는 빌드와 같이 다른 기계에서 빌드하는 경우에도 빌드 캐시를 활용할 수 있습니다. 이를 해결하기 위해 많은 사람들이 새 이미지 버전을 빌드하기 전에 이미지의 최신 버전을 다운로드했습니다. 이점은 변경되지 않은 레이어를 캐시할 수 있다는 것인데, 처음에 전체 이미지를 다운받는 데 시간이 걸릴 수 있지만 레이어를 재사용할 수 있는 것은 보장할 수 없습니다. 예를 들어, 다음 명령어를 사용했습니다:\n\n```js\ndocker pull someImage:latest || true\ndocker build --platform linux/amd64 . \\\n-t someImage:someVersion \\\n--cache-from someImage:latest\n```\n\nBuildx를 사용하면 캐시 정보를 원격 위치(예: 컨테이너 레지스트리, Blob 스토리지 등)에 저장할 수 있습니다. 빌더는 주어진 레이어가 이미 존재하는지 확인하고, 그렇다면 다시 만들지 않고 재사용합니다. 이를 로컬로 다운로드하지 않고도 수행할 수 있습니다. 이 메커니즘을 활용하기 위해 이전 명령어를 재작성한 것은 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ndocker buildx build --platform linux/amd64 . \\\n-t someImage:someVersion --push \\\n--cache-to type=inline,mode=max \\\n--cache-from someImage:somePreviousVersion\n\n\"max\" 모드는 결과 이미지에 사용되지 않는 레이어도 모든 빌드 정보를 저장한다는 것을 의미합니다 (예: 멀티 스테이지 빌드 사용 시). 기본적으로 \"min\" 모드가 사용되며 최종 이미지에 존재하는 레이어에 대한 빌드 정보만 저장합니다.\n\n캐싱의 특수 사례는 캐시 데이터를 \"inline\"으로 저장하는 것이며, 이미지와 함께 캐싱된다는 것을 의미합니다. 이 옵션은 Buildx 없이 Buildkit을 사용할 때도 지원됩니다. 멀티 스테이지 빌드를 사용할 때 시작하기 가장 쉽지만 출력물과 캐시 사이에 명확한 구분을 제공하지 않으며 조심해야 합니다. 캐시 데이터를 \"inline\"으로 저장하는 명령어는 다음과 같습니다:\n\ndocker buildx build --platform linux/amd64 . \\\n-t someImage:someVersion --push \\\n--cache-to type=inline,mode=max \\\n--cache-from someImage:somePreviousVersion\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Docker 이미지에 파일 추가하는 새로운 방법\n\n도커는 Dockerfile 작성을 위한 새로운 구문 버전, 즉 #syntax=docker/dockerfile:1.4를 소개했습니다. 이 버전은 COPY 및 ADD 명령에 대한 추가 링크 옵션을 지원합니다.\n\n이전에 COPY 또는 ADD 명령을 사용할 때 빌더가 새로운 스냅샷을 만들어 새 파일을 기존 파일 시스템과 병합했습니다. 이 작업을 수행하려면 부모 레이어가 모두 존재해야 하는데, 그렇지 않으면 대상 디렉토리가 아직 존재하지 않을 수 있습니다. 최종적으로 이미지(빌드 명령의 결과물)는 각각의 스냅샷 간의 차이를 포함하는 레이어 당 tarball로 구성됩니다.\n\n```js\nFROM baseImage:version\nCOPY binary /opt/\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n링크 옵션을 사용하면 새 파일은 이전 레이어에 의존하지 않고 자체 스냅샷에 넣습니다. 링크된 파일은 자체 tarball에 저장되며 서로 다른 tarball들이 연결되어 파일 시스템에 의존하지 않고 연결됩니다. 다음 이미지에 설명이 나와 있습니다.\n\n![이미지](/assets/img/2024-05-27-Howwereducedourdockerbuildtimesby40_1.png)\n\n```js\n# syntax=docker/dockerfile:1.4\nFROM baseImage:version\nCOPY [--chown=\u003cuser\u003e:\u003cgroup\u003e] [--chmod=\u003cperms\u003e] --link binary /opt/\n```\n\n주요 장점은 파일이 이제 이전 레이어에 의존하지 않는다는 것입니다. 파일이 변경되지 않았다면 이전 레이어가 변경되더라도 레이어를 재사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n또한 여러 레이어의 데이터 복사가 이제 병렬로 실행될 수 있기 때문에 빌드 속도를 높일 수도 있습니다.\n\n# 결론\n\n이 블로그 포스트에서는 CI 파이프라인을 최적화한 후 얻은 몇 가지 새로운 통찰을 설명합니다. 전체 도커 빌드 시간을 40% 줄이게 된 두 가지 작은 변경 사항에 대해 논의하겠습니다.\n\n- 빌드 캐시 정보를 원격으로 저장\n- 도커 이미지에 파일을 추가하거나 복사할 때 링크 옵션 사용\n","ogImage":{"url":"/assets/img/2024-05-27-Howwereducedourdockerbuildtimesby40_0.png"},"coverImage":"/assets/img/2024-05-27-Howwereducedourdockerbuildtimesby40_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e많은 기업들과 마찬가지로, 저희 회사도 제품에 사용되는 모든 구성 요소에 대한 도커 이미지를 빌드합니다. 시간이 지남에 따라 몇 가지 이미지가 점점 커지고, 또한 CI 빌드 시간이 점점 오래 걸리게 되었습니다. 제 목표는 CI 빌드가 5분을 넘지 않도록 하는 것입니다. 이 아이디어는 커피를 마시기에 이상적인 시간이기 때문에 나왔습니다. 그 시간을 넘어가면, 개발자의 생산성이 떨어지게 됩니다.\u003c/p\u003e\n\u003cp\u003e생산성이 감소하는 이유는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e개발자들은 빌드가 완료되기를 기다려야 하며, 따라서 시간을 낭비합니다.\u003c/li\u003e\n\u003cli\u003e개발자들은 새로운 작업을 시작하고 나중에 되돌아옵니다. 이는 더 많은 문맥 전환을 요구하며 종종 비효율성으로 이어집니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca href=\"/assets/img/2024-05-27-Howwereducedourdockerbuildtimesby40_0.png\"\u003e이미지\u003c/a\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 블로그 포스트에서는 적용한 2가지 작은 변경 사항을 설명하고, 빌드 시간이 drasctic하게 개선된 결과를 보여드리고 싶습니다. 이러한 개선 사항에 집중하기 전에 Dockerfile 작성에 대한 최상의 실천 방법을 이미 준수하고 있는지 확인하세요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e레이어 수를 최소화합니다\u003c/li\u003e\n\u003cli\u003e멀티 스테이지 빌드를 사용합니다\u003c/li\u003e\n\u003cli\u003e최소한의 베이스 이미지를 사용합니다\u003c/li\u003e\n\u003cli\u003e…\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eBuildkit vs Buildx\u003c/h1\u003e\n\u003cp\u003e먼저 Buildkit과 Buildx에 대해 설명하겠습니다. 이 두 용어는 종종 서로 교차적으로 사용되지만 실제로 동일하지는 않습니다. 이 게시물을 작성하기 전에 나도 두 용어 사이의 차이를 완전히 이해하지 못했습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e빌킷\u003c/h2\u003e\n\u003cp\u003e빌킷은 기존의 도커 빌더를 대체하는 개선된 백엔드입니다. 2018년부터 도커와 함께 제공되어 기본 빌더로 설정되었습니다.\u003c/p\u003e\n\u003cp\u003e다음과 같은 많은 흥미로운 기능을 제공합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e개선된 캐싱 기능\u003c/li\u003e\n\u003cli\u003e서로 다른 레이어를 병렬로 빌드\u003c/li\u003e\n\u003cli\u003e기본 이미지를 지연해서 로드합니다 (≥ 빌킷 0.9)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eBuildkit을 사용할 때 docker build 명령의 출력이 더 깔끔하고 구조화된 모습이 빠르게 눈에 띕니다.\u003c/p\u003e\n\u003cp\u003e23.0 버전보다 오래된 docker 버전을 사용할 때 Buildkit을 사용하는 일반적인 방법은 다음과 같이 Buildkit 인수를 설정하는 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eDOCKER_BUILDKIT\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e docker build --platform linux/amd64 . -t \u003cspan class=\"hljs-attr\"\u003esomeImage\u003c/span\u003e:someVersion\n\u003cspan class=\"hljs-variable constant_\"\u003eDOCKER_BUILDKIT\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e docker push \u003cspan class=\"hljs-attr\"\u003esomeImage\u003c/span\u003e:someVersion\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eBuildx\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e빌드엑스(Buildx)는 도커의 플러그인으로, 도커에서 빌드킷(Buildkit)의 모든 잠재력을 활용할 수 있게 해줍니다. 이것은 빌드킷이 새로운 구성 옵션을 지원하는데, 이를 모두 도커 빌드 명령에 거슬러 호환되는 방식으로 통합하기 어려운 경우에 만들어졌습니다.\u003c/p\u003e\n\u003cp\u003e이미지를 빌드하는 데 추가로, 빌드엑스는 여러 빌더를 관리하는 것을 지원합니다. CI에서 유용하게 쓰일 수 있으며, 공유 도커 데몬을 수정하지 않고 다른 설정으로 환경을 정의하는 데 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e빌드엑스를 시작하는 방법은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker buildx create --bootstrap --name builder\ndocker buildx use builder\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e원격 캐시의 혜택\u003c/h1\u003e\n\u003cp\u003e빌드를 가속화하는 첫 번째 방법은 이미지를 원격 레지스트리에 캐시하는 것입니다. 이렇게 하면 일반적으로 CI에서 수행되는 빌드와 같이 다른 기계에서 빌드하는 경우에도 빌드 캐시를 활용할 수 있습니다. 이를 해결하기 위해 많은 사람들이 새 이미지 버전을 빌드하기 전에 이미지의 최신 버전을 다운로드했습니다. 이점은 변경되지 않은 레이어를 캐시할 수 있다는 것인데, 처음에 전체 이미지를 다운받는 데 시간이 걸릴 수 있지만 레이어를 재사용할 수 있는 것은 보장할 수 없습니다. 예를 들어, 다음 명령어를 사용했습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker pull \u003cspan class=\"hljs-attr\"\u003esomeImage\u003c/span\u003e:latest || \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\ndocker build --platform linux/amd64 . \\\n-t \u003cspan class=\"hljs-attr\"\u003esomeImage\u003c/span\u003e:someVersion \\\n--cache-\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esomeImage\u003c/span\u003e:latest\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBuildx를 사용하면 캐시 정보를 원격 위치(예: 컨테이너 레지스트리, Blob 스토리지 등)에 저장할 수 있습니다. 빌더는 주어진 레이어가 이미 존재하는지 확인하고, 그렇다면 다시 만들지 않고 재사용합니다. 이를 로컬로 다운로드하지 않고도 수행할 수 있습니다. 이 메커니즘을 활용하기 위해 이전 명령어를 재작성한 것은 다음과 같습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003edocker buildx build --platform linux/amd64 . \u003cbr\u003e\n-t someImage:someVersion --push \u003cbr\u003e\n--cache-to type=inline,mode=max \u003cbr\u003e\n--cache-from someImage:somePreviousVersion\u003c/p\u003e\n\u003cp\u003e\"max\" 모드는 결과 이미지에 사용되지 않는 레이어도 모든 빌드 정보를 저장한다는 것을 의미합니다 (예: 멀티 스테이지 빌드 사용 시). 기본적으로 \"min\" 모드가 사용되며 최종 이미지에 존재하는 레이어에 대한 빌드 정보만 저장합니다.\u003c/p\u003e\n\u003cp\u003e캐싱의 특수 사례는 캐시 데이터를 \"inline\"으로 저장하는 것이며, 이미지와 함께 캐싱된다는 것을 의미합니다. 이 옵션은 Buildx 없이 Buildkit을 사용할 때도 지원됩니다. 멀티 스테이지 빌드를 사용할 때 시작하기 가장 쉽지만 출력물과 캐시 사이에 명확한 구분을 제공하지 않으며 조심해야 합니다. 캐시 데이터를 \"inline\"으로 저장하는 명령어는 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003edocker buildx build --platform linux/amd64 . \u003cbr\u003e\n-t someImage:someVersion --push \u003cbr\u003e\n--cache-to type=inline,mode=max \u003cbr\u003e\n--cache-from someImage:somePreviousVersion\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eDocker 이미지에 파일 추가하는 새로운 방법\u003c/h1\u003e\n\u003cp\u003e도커는 Dockerfile 작성을 위한 새로운 구문 버전, 즉 #syntax=docker/dockerfile:1.4를 소개했습니다. 이 버전은 COPY 및 ADD 명령에 대한 추가 링크 옵션을 지원합니다.\u003c/p\u003e\n\u003cp\u003e이전에 COPY 또는 ADD 명령을 사용할 때 빌더가 새로운 스냅샷을 만들어 새 파일을 기존 파일 시스템과 병합했습니다. 이 작업을 수행하려면 부모 레이어가 모두 존재해야 하는데, 그렇지 않으면 대상 디렉토리가 아직 존재하지 않을 수 있습니다. 최종적으로 이미지(빌드 명령의 결과물)는 각각의 스냅샷 간의 차이를 포함하는 레이어 당 tarball로 구성됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebaseImage\u003c/span\u003e:version\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e binary /opt/\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e링크 옵션을 사용하면 새 파일은 이전 레이어에 의존하지 않고 자체 스냅샷에 넣습니다. 링크된 파일은 자체 tarball에 저장되며 서로 다른 tarball들이 연결되어 파일 시스템에 의존하지 않고 연결됩니다. 다음 이미지에 설명이 나와 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-Howwereducedourdockerbuildtimesby40_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# syntax=docker/\u003cspan class=\"hljs-attr\"\u003edockerfile\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1.4\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebaseImage\u003c/span\u003e:version\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e [--chown=\u0026#x3C;user\u003e:\u0026#x3C;group\u003e] [--chmod=\u0026#x3C;perms\u003e] --link binary /opt/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e주요 장점은 파일이 이제 이전 레이어에 의존하지 않는다는 것입니다. 파일이 변경되지 않았다면 이전 레이어가 변경되더라도 레이어를 재사용할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e또한 여러 레이어의 데이터 복사가 이제 병렬로 실행될 수 있기 때문에 빌드 속도를 높일 수도 있습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 블로그 포스트에서는 CI 파이프라인을 최적화한 후 얻은 몇 가지 새로운 통찰을 설명합니다. 전체 도커 빌드 시간을 40% 줄이게 된 두 가지 작은 변경 사항에 대해 논의하겠습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e빌드 캐시 정보를 원격으로 저장\u003c/li\u003e\n\u003cli\u003e도커 이미지에 파일을 추가하거나 복사할 때 링크 옵션 사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-27-Howwereducedourdockerbuildtimesby40"},"buildId":"GsgRekSb--BvxYwv9FPn6","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>