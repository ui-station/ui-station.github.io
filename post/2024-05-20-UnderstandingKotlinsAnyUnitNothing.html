<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>코틀린의 Any, Unit, Nothing 이해하기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-20-UnderstandingKotlinsAnyUnitNothing" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="코틀린의 Any, Unit, Nothing 이해하기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="코틀린의 Any, Unit, Nothing 이해하기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-20-UnderstandingKotlinsAnyUnitNothing_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-20-UnderstandingKotlinsAnyUnitNothing" data-gatsby-head="true"/><meta name="twitter:title" content="코틀린의 Any, Unit, Nothing 이해하기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-20-UnderstandingKotlinsAnyUnitNothing_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-20 17:40" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-561ae49ab5aab7f5.js" defer=""></script><script src="/_next/static/0asLlD6on3tm8cIfzBaxd/_buildManifest.js" defer=""></script><script src="/_next/static/0asLlD6on3tm8cIfzBaxd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">코틀린의 Any, Unit, Nothing 이해하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="코틀린의 Any, Unit, Nothing 이해하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 20, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-20-UnderstandingKotlinsAnyUnitNothing&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p><img src="/assets/img/2024-05-20-UnderstandingKotlinsAnyUnitNothing_0.png" alt="Understanding Kotlin&#x27;s Any, Unit, Nothing"/></p>
<p>Kotlin은 Java에서 사용하던 것과는 매우 다른 독특한 유형을 제공합니다. 이 블로그에서는 Any, Unit, 그리고 Nothing과 같은 세 가지 유형을 탐색해 볼 것입니다.</p>
<h2>Any</h2>
<pre><code class="hljs language-js"><span class="hljs-comment">// 소스 코드</span>
package kotlin
<span class="hljs-comment">/**
 * 코틀린 클래스 계층 구조의 루트. 모든 코틀린 클래스는 [Any]를 슈퍼 클래스로 갖습니다.
 */</span>
public open <span class="hljs-keyword">class</span> <span class="hljs-title class_">Any</span> {
    public open operator fun <span class="hljs-title function_">equals</span>(<span class="hljs-attr">other</span>: <span class="hljs-title class_">Any</span>?): <span class="hljs-title class_">Boolean</span>
    public open fun <span class="hljs-title function_">hashCode</span>(): <span class="hljs-title class_">Int</span>
    public open fun <span class="hljs-title function_">toString</span>(): <span class="hljs-title class_">String</span>
}
</code></pre>
<div class="content-ad"></div>
<ul>
<li>클래스 계층 구조의 루트입니다. 모든 Kotlin 클래스는 Any로부터 상속받습니다.</li>
<li>Java의 Object에 해당됩니다.</li>
<li>우리가 오버라이드할 수 있는 세 가지 메소드를 제공합니다: equals(), hashCode(), toString(). 이것이 어떤 클래스에서 메소드를 오버라이드할 때 IDE에서 이 세 가지 옵션이 자주 제시되는 이유입니다.</li>
<li>기본적으로 Nullable이 아닙니다. 변수가 null을 저장할 수 있도록 필요하다면 Any?를 사용할 수 있습니다.</li>
</ul>
<p>예제</p>
<pre><code class="hljs language-js">fun <span class="hljs-title function_">printAny</span>(<span class="hljs-params">value: Any?</span>) {
    <span class="hljs-title function_">println</span>(value.<span class="hljs-title function_">toString</span>())
}

fun <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">printAny</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>)  <span class="hljs-comment">// 출력: Hello, World!</span>
    <span class="hljs-title function_">printAny</span>(<span class="hljs-number">123</span>)  <span class="hljs-comment">// 출력: 123</span>
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// 디컴파일할 때 Any는 Java의 Object로 변환됩니다</span>
public <span class="hljs-keyword">static</span> final <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAny</span>(<span class="hljs-params">@Nullable <span class="hljs-built_in">Object</span> value</span>) {
   <span class="hljs-title class_">String</span> var1 = <span class="hljs-title class_">String</span>.<span class="hljs-title function_">valueOf</span>(value);
   <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(var1);
}
</code></pre>
<div class="content-ad"></div>
<h1>Unit</h1>
<pre><code class="hljs language-js"><span class="hljs-comment">//SOURCE CODE</span>
package kotlin
<span class="hljs-comment">/**
 * `Unit` 객체만 있는 유형입니다. 이 유형은 Java의 `void` 유형에 해당합니다.
 */</span>
public object <span class="hljs-title class_">Unit</span> {
    override fun <span class="hljs-title function_">toString</span>() = <span class="hljs-string">&quot;kotlin.Unit&quot;</span>
}
</code></pre>
<ul>
<li>Java의 void와 동등하지만 void와 달리 Unit은 하나의 인스턴스만 있는 실제 클래스입니다 (싱글톤).</li>
<li>의미 있는 값을 반환하지 않는 함수를 나타냅니다.</li>
<li>함수의 반환 유형을 명시하지 않으면 Kotlin은 기본 반환 유형으로 Unit을 사용합니다.</li>
</ul>
<p>예시</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">fun <span class="hljs-title function_">printMessage</span>(<span class="hljs-params">message: <span class="hljs-built_in">String</span></span>) { <span class="hljs-comment">// Unit을 명시적으로 작성할 필요가 없습니다.</span>
    <span class="hljs-title function_">println</span>(message)
}

fun <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">printMessage</span>(<span class="hljs-string">&quot;안녕, Unit!&quot;</span>)  <span class="hljs-comment">// 출력: 안녕, Unit!</span>
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// 변환된 결과, Unit은 Java에서 void로 변환됩니다.</span>
public <span class="hljs-keyword">static</span> final <span class="hljs-keyword">void</span> <span class="hljs-title function_">printMessage</span>(<span class="hljs-params">@NotNull <span class="hljs-built_in">String</span> message</span>) {
   <span class="hljs-title class_">Intrinsics</span>.<span class="hljs-title function_">checkNotNullParameter</span>(message, <span class="hljs-string">&quot;message&quot;</span>);
   <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(message);
}
</code></pre>
<p>예시: 함수형 타입</p>
<pre><code class="hljs language-js">fun <span class="hljs-title function_">runBlock</span>(<span class="hljs-params">block: ()-&gt;Unit</span>) {
    <span class="hljs-title function_">block</span>()
}

fun <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    runBlock { <span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;여기&quot;</span>) } <span class="hljs-comment">// 출력: 여기</span>
}
</code></pre>
<div class="content-ad"></div>
<p>여기서 () -` Unit은 함수 유형을 나타내며 Unit은 해당 함수 유형이 의미 있는 값을 반환하지 않음을 나타냅니다.</p>
<p>함수 유형을 지정할 때 Unit을 명시하는 것이 필수입니다.</p>
<h1>Nothing</h1>
<pre><code class="hljs language-js"><span class="hljs-comment">//SOURCE CODE</span>
package kotlin
<span class="hljs-comment">/**
 * Nothing에는 인스턴스가 없습니다. Nothing을 사용하여 &quot;존재하지 않는 값&quot;을 표현할 수 있습니다: 예를 들어,
 * 반환 유형이 Nothing인 함수의 경우, 이는 결코 반환하지 않음을 의미합니다 (항상 예외를 throw함).
 */</span>
public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Nothing</span> private <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)
</code></pre>
<div class="content-ad"></div>
<ul>
<li>아무 값이 없음을 나타내며 함수가 일반적인 방식으로 반환하지 않을 것을 나타냅니다.</li>
<li>사용자가 정의한 Kotlin 유형을 포함한 모든 형식의 하위 유형입니다.</li>
<li>예외를 throw하거나 무한 루프에 들어가기 때문에 결코 반환되지 않는 함수에서 사용됩니다.</li>
<li>Nothing의 인스턴스를 만들거나 어떤 클래스도 상속할 수 없습니다.</li>
<li>반환 유형이 Nothing인 함수는 기본 반환 유형인 Unit조차 반환하지 않습니다.</li>
<li>Kotlin의 Nothing 반환 유형은 반환하지 않는다는 것을 명확히 하여 잠재적인 버그로부터 우리를 보호합니다. 반환 유형이 Nothing인 아무 함수가 호출되면 컴파일러는 이 함수 호출을 넘어가지 않고 접근할 수 없는 코드 경고를 알려 줍니다.</li>
</ul>
<p>예시</p>
<pre><code class="hljs language-js">fun <span class="hljs-title function_">fail</span>(<span class="hljs-attr">message</span>: <span class="hljs-title class_">String</span>): <span class="hljs-title class_">Nothing</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-title class_">IllegalArgumentException</span>(message)
}

fun <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 이것은 예외를 throw하고 일반적으로 반환하지 않을 것입니다.</span>
    <span class="hljs-title function_">fail</span>(<span class="hljs-string">&quot;에러 발생!&quot;</span>)
    <span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;안녕&quot;</span>) <span class="hljs-comment">// 컴파일러가 &quot;접근할 수 없는 코드&quot; 경고를 줍니다.</span>
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// Decompile되었을 때, Nothing은 Java에서 Void가 됩니다</span>
<span class="hljs-comment">// Void는 java.lang 패키지의 일부이며, void Java 원시 유형을 래핑하는 객체에 대한 참조 역할을 합니다. 생성할 수 없습니다.</span>
@<span class="hljs-title class_">NotNull</span>
public <span class="hljs-keyword">static</span> final <span class="hljs-title class_">Void</span> <span class="hljs-title function_">fail</span>(<span class="hljs-params">@NotNull <span class="hljs-built_in">String</span> message</span>) {
   <span class="hljs-title class_">Intrinsics</span>.<span class="hljs-title function_">checkNotNullParameter</span>(message, <span class="hljs-string">&quot;message&quot;</span>);
   <span class="hljs-keyword">throw</span> (<span class="hljs-title class_">Throwable</span>)(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(message));
}
</code></pre>
<div class="content-ad"></div>
<p>소스 코드: 깃허브</p>
<h1>연락처:</h1>
<p>링크드인, 트위터</p>
<p>코딩 즐기세요! ✌️</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"코틀린의 Any, Unit, Nothing 이해하기","description":"","date":"2024-05-20 17:40","slug":"2024-05-20-UnderstandingKotlinsAnyUnitNothing","content":"\n\n\n![Understanding Kotlin's Any, Unit, Nothing](/assets/img/2024-05-20-UnderstandingKotlinsAnyUnitNothing_0.png)\n\nKotlin은 Java에서 사용하던 것과는 매우 다른 독특한 유형을 제공합니다. 이 블로그에서는 Any, Unit, 그리고 Nothing과 같은 세 가지 유형을 탐색해 볼 것입니다.\n\n## Any\n\n```js\n// 소스 코드\npackage kotlin\n/**\n * 코틀린 클래스 계층 구조의 루트. 모든 코틀린 클래스는 [Any]를 슈퍼 클래스로 갖습니다.\n */\npublic open class Any {\n    public open operator fun equals(other: Any?): Boolean\n    public open fun hashCode(): Int\n    public open fun toString(): String\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 클래스 계층 구조의 루트입니다. 모든 Kotlin 클래스는 Any로부터 상속받습니다.\n- Java의 Object에 해당됩니다.\n- 우리가 오버라이드할 수 있는 세 가지 메소드를 제공합니다: equals(), hashCode(), toString(). 이것이 어떤 클래스에서 메소드를 오버라이드할 때 IDE에서 이 세 가지 옵션이 자주 제시되는 이유입니다.\n- 기본적으로 Nullable이 아닙니다. 변수가 null을 저장할 수 있도록 필요하다면 Any?를 사용할 수 있습니다.\n\n예제\n\n```js\nfun printAny(value: Any?) {\n    println(value.toString())\n}\n\nfun main() {\n    printAny(\"Hello, World!\")  // 출력: Hello, World!\n    printAny(123)  // 출력: 123\n}\n```\n\n```js\n// 디컴파일할 때 Any는 Java의 Object로 변환됩니다\npublic static final void printAny(@Nullable Object value) {\n   String var1 = String.valueOf(value);\n   System.out.println(var1);\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Unit\n\n```js\n//SOURCE CODE\npackage kotlin\n/**\n * `Unit` 객체만 있는 유형입니다. 이 유형은 Java의 `void` 유형에 해당합니다.\n */\npublic object Unit {\n    override fun toString() = \"kotlin.Unit\"\n}\n```\n\n- Java의 void와 동등하지만 void와 달리 Unit은 하나의 인스턴스만 있는 실제 클래스입니다 (싱글톤).\n- 의미 있는 값을 반환하지 않는 함수를 나타냅니다.\n- 함수의 반환 유형을 명시하지 않으면 Kotlin은 기본 반환 유형으로 Unit을 사용합니다.\n\n예시\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfun printMessage(message: String) { // Unit을 명시적으로 작성할 필요가 없습니다.\n    println(message)\n}\n\nfun main() {\n    printMessage(\"안녕, Unit!\")  // 출력: 안녕, Unit!\n}\n```\n\n```js\n// 변환된 결과, Unit은 Java에서 void로 변환됩니다.\npublic static final void printMessage(@NotNull String message) {\n   Intrinsics.checkNotNullParameter(message, \"message\");\n   System.out.println(message);\n}\n```\n\n예시: 함수형 타입\n\n```js\nfun runBlock(block: ()-\u003eUnit) {\n    block()\n}\n\nfun main() {\n    runBlock { println(\"여기\") } // 출력: 여기\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 () -` Unit은 함수 유형을 나타내며 Unit은 해당 함수 유형이 의미 있는 값을 반환하지 않음을 나타냅니다.\n\n함수 유형을 지정할 때 Unit을 명시하는 것이 필수입니다.\n\n# Nothing\n\n```js\n//SOURCE CODE\npackage kotlin\n/**\n * Nothing에는 인스턴스가 없습니다. Nothing을 사용하여 \"존재하지 않는 값\"을 표현할 수 있습니다: 예를 들어,\n * 반환 유형이 Nothing인 함수의 경우, 이는 결코 반환하지 않음을 의미합니다 (항상 예외를 throw함).\n */\npublic class Nothing private constructor()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 아무 값이 없음을 나타내며 함수가 일반적인 방식으로 반환하지 않을 것을 나타냅니다.\n- 사용자가 정의한 Kotlin 유형을 포함한 모든 형식의 하위 유형입니다.\n- 예외를 throw하거나 무한 루프에 들어가기 때문에 결코 반환되지 않는 함수에서 사용됩니다.\n- Nothing의 인스턴스를 만들거나 어떤 클래스도 상속할 수 없습니다.\n- 반환 유형이 Nothing인 함수는 기본 반환 유형인 Unit조차 반환하지 않습니다.\n- Kotlin의 Nothing 반환 유형은 반환하지 않는다는 것을 명확히 하여 잠재적인 버그로부터 우리를 보호합니다. 반환 유형이 Nothing인 아무 함수가 호출되면 컴파일러는 이 함수 호출을 넘어가지 않고 접근할 수 없는 코드 경고를 알려 줍니다.\n\n예시\n\n```js\nfun fail(message: String): Nothing {\n    throw IllegalArgumentException(message)\n}\n\nfun main() {\n    // 이것은 예외를 throw하고 일반적으로 반환하지 않을 것입니다.\n    fail(\"에러 발생!\")\n    println(\"안녕\") // 컴파일러가 \"접근할 수 없는 코드\" 경고를 줍니다.\n}\n```\n\n```js\n// Decompile되었을 때, Nothing은 Java에서 Void가 됩니다\n// Void는 java.lang 패키지의 일부이며, void Java 원시 유형을 래핑하는 객체에 대한 참조 역할을 합니다. 생성할 수 없습니다.\n@NotNull\npublic static final Void fail(@NotNull String message) {\n   Intrinsics.checkNotNullParameter(message, \"message\");\n   throw (Throwable)(new IllegalArgumentException(message));\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n소스 코드: 깃허브\n\n# 연락처:\n\n링크드인, 트위터\n\n코딩 즐기세요! ✌️","ogImage":{"url":"/assets/img/2024-05-20-UnderstandingKotlinsAnyUnitNothing_0.png"},"coverImage":"/assets/img/2024-05-20-UnderstandingKotlinsAnyUnitNothing_0.png","tag":["Tech"],"readingTime":4},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    ul: \"ul\",\n    li: \"li\",\n    h1: \"h1\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-UnderstandingKotlinsAnyUnitNothing_0.png\",\n        alt: \"Understanding Kotlin's Any, Unit, Nothing\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Kotlin은 Java에서 사용하던 것과는 매우 다른 독특한 유형을 제공합니다. 이 블로그에서는 Any, Unit, 그리고 Nothing과 같은 세 가지 유형을 탐색해 볼 것입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Any\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 소스 코드\"\n        }), \"\\npackage kotlin\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"/**\\n * 코틀린 클래스 계층 구조의 루트. 모든 코틀린 클래스는 [Any]를 슈퍼 클래스로 갖습니다.\\n */\"\n        }), \"\\npublic open \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Any\"\n        }), \" {\\n    public open operator fun \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"equals\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"other\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Any\"\n        }), \"?): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Boolean\"\n        }), \"\\n    public open fun \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"hashCode\"\n        }), \"(): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Int\"\n        }), \"\\n    public open fun \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"toString\"\n        }), \"(): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"클래스 계층 구조의 루트입니다. 모든 Kotlin 클래스는 Any로부터 상속받습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Java의 Object에 해당됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"우리가 오버라이드할 수 있는 세 가지 메소드를 제공합니다: equals(), hashCode(), toString(). 이것이 어떤 클래스에서 메소드를 오버라이드할 때 IDE에서 이 세 가지 옵션이 자주 제시되는 이유입니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"기본적으로 Nullable이 아닙니다. 변수가 null을 저장할 수 있도록 필요하다면 Any?를 사용할 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예제\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"fun \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"printAny\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"value: Any?\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"println\"\n        }), \"(value.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"toString\"\n        }), \"())\\n}\\n\\nfun \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"printAny\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Hello, World!\\\"\"\n        }), \")  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 출력: Hello, World!\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"printAny\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"123\"\n        }), \")  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 출력: 123\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 디컴파일할 때 Any는 Java의 Object로 변환됩니다\"\n        }), \"\\npublic \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" final \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"printAny\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"@Nullable \", _jsx(_components.span, {\n            className: \"hljs-built_in\",\n            children: \"Object\"\n          }), \" value\"]\n        }), \") {\\n   \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \" var1 = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"valueOf\"\n        }), \"(value);\\n   \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"System\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"out\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"println\"\n        }), \"(var1);\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Unit\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//SOURCE CODE\"\n        }), \"\\npackage kotlin\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"/**\\n * `Unit` 객체만 있는 유형입니다. 이 유형은 Java의 `void` 유형에 해당합니다.\\n */\"\n        }), \"\\npublic object \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Unit\"\n        }), \" {\\n    override fun \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"toString\"\n        }), \"() = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"kotlin.Unit\\\"\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Java의 void와 동등하지만 void와 달리 Unit은 하나의 인스턴스만 있는 실제 클래스입니다 (싱글톤).\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"의미 있는 값을 반환하지 않는 함수를 나타냅니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"함수의 반환 유형을 명시하지 않으면 Kotlin은 기본 반환 유형으로 Unit을 사용합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예시\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"fun \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"printMessage\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"message: \", _jsx(_components.span, {\n            className: \"hljs-built_in\",\n            children: \"String\"\n          })]\n        }), \") { \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Unit을 명시적으로 작성할 필요가 없습니다.\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"println\"\n        }), \"(message)\\n}\\n\\nfun \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"printMessage\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"안녕, Unit!\\\"\"\n        }), \")  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 출력: 안녕, Unit!\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 변환된 결과, Unit은 Java에서 void로 변환됩니다.\"\n        }), \"\\npublic \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" final \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"printMessage\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"@NotNull \", _jsx(_components.span, {\n            className: \"hljs-built_in\",\n            children: \"String\"\n          }), \" message\"]\n        }), \") {\\n   \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Intrinsics\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"checkNotNullParameter\"\n        }), \"(message, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"message\\\"\"\n        }), \");\\n   \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"System\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"out\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"println\"\n        }), \"(message);\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예시: 함수형 타입\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"fun \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"runBlock\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"block: ()-\u003eUnit\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"block\"\n        }), \"()\\n}\\n\\nfun \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    runBlock { \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"println\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"여기\\\"\"\n        }), \") } \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 출력: 여기\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서 () -` Unit은 함수 유형을 나타내며 Unit은 해당 함수 유형이 의미 있는 값을 반환하지 않음을 나타냅니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"함수 유형을 지정할 때 Unit을 명시하는 것이 필수입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Nothing\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//SOURCE CODE\"\n        }), \"\\npackage kotlin\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"/**\\n * Nothing에는 인스턴스가 없습니다. Nothing을 사용하여 \\\"존재하지 않는 값\\\"을 표현할 수 있습니다: 예를 들어,\\n * 반환 유형이 Nothing인 함수의 경우, 이는 결코 반환하지 않음을 의미합니다 (항상 예외를 throw함).\\n */\"\n        }), \"\\npublic \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Nothing\"\n        }), \" private \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"constructor\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"아무 값이 없음을 나타내며 함수가 일반적인 방식으로 반환하지 않을 것을 나타냅니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"사용자가 정의한 Kotlin 유형을 포함한 모든 형식의 하위 유형입니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"예외를 throw하거나 무한 루프에 들어가기 때문에 결코 반환되지 않는 함수에서 사용됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Nothing의 인스턴스를 만들거나 어떤 클래스도 상속할 수 없습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"반환 유형이 Nothing인 함수는 기본 반환 유형인 Unit조차 반환하지 않습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Kotlin의 Nothing 반환 유형은 반환하지 않는다는 것을 명확히 하여 잠재적인 버그로부터 우리를 보호합니다. 반환 유형이 Nothing인 아무 함수가 호출되면 컴파일러는 이 함수 호출을 넘어가지 않고 접근할 수 없는 코드 경고를 알려 줍니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예시\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"fun \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fail\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"message\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Nothing\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"throw\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"IllegalArgumentException\"\n        }), \"(message)\\n}\\n\\nfun \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 이것은 예외를 throw하고 일반적으로 반환하지 않을 것입니다.\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fail\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"에러 발생!\\\"\"\n        }), \")\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"println\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"안녕\\\"\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 컴파일러가 \\\"접근할 수 없는 코드\\\" 경고를 줍니다.\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Decompile되었을 때, Nothing은 Java에서 Void가 됩니다\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Void는 java.lang 패키지의 일부이며, void Java 원시 유형을 래핑하는 객체에 대한 참조 역할을 합니다. 생성할 수 없습니다.\"\n        }), \"\\n@\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NotNull\"\n        }), \"\\npublic \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" final \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fail\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"@NotNull \", _jsx(_components.span, {\n            className: \"hljs-built_in\",\n            children: \"String\"\n          }), \" message\"]\n        }), \") {\\n   \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Intrinsics\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"checkNotNullParameter\"\n        }), \"(message, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"message\\\"\"\n        }), \");\\n   \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"throw\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Throwable\"\n        }), \")(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"IllegalArgumentException\"\n        }), \"(message));\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"소스 코드: 깃허브\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"연락처:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"링크드인, 트위터\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"코딩 즐기세요! ✌️\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-20-UnderstandingKotlinsAnyUnitNothing"},"buildId":"0asLlD6on3tm8cIfzBaxd","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>