<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>코틀린의 Any, Unit, Nothing 이해하기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-20-UnderstandingKotlinsAnyUnitNothing" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="코틀린의 Any, Unit, Nothing 이해하기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="코틀린의 Any, Unit, Nothing 이해하기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-20-UnderstandingKotlinsAnyUnitNothing_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-20-UnderstandingKotlinsAnyUnitNothing" data-gatsby-head="true"/><meta name="twitter:title" content="코틀린의 Any, Unit, Nothing 이해하기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-20-UnderstandingKotlinsAnyUnitNothing_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-20 17:40" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_buildManifest.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">코틀린의 Any, Unit, Nothing 이해하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="코틀린의 Any, Unit, Nothing 이해하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 20, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-20-UnderstandingKotlinsAnyUnitNothing&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-20-UnderstandingKotlinsAnyUnitNothing_0.png" alt="Understanding Kotlin&#x27;s Any, Unit, Nothing"></p>
<p>Kotlin은 Java에서 사용하던 것과는 매우 다른 독특한 유형을 제공합니다. 이 블로그에서는 Any, Unit, 그리고 Nothing과 같은 세 가지 유형을 탐색해 볼 것입니다.</p>
<h2>Any</h2>
<pre><code class="hljs language-js"><span class="hljs-comment">// 소스 코드</span>
package kotlin
<span class="hljs-comment">/**
 * 코틀린 클래스 계층 구조의 루트. 모든 코틀린 클래스는 [Any]를 슈퍼 클래스로 갖습니다.
 */</span>
public open <span class="hljs-keyword">class</span> <span class="hljs-title class_">Any</span> {
    public open operator fun <span class="hljs-title function_">equals</span>(<span class="hljs-attr">other</span>: <span class="hljs-title class_">Any</span>?): <span class="hljs-title class_">Boolean</span>
    public open fun <span class="hljs-title function_">hashCode</span>(): <span class="hljs-title class_">Int</span>
    public open fun <span class="hljs-title function_">toString</span>(): <span class="hljs-title class_">String</span>
}
</code></pre>
<ul>
<li>클래스 계층 구조의 루트입니다. 모든 Kotlin 클래스는 Any로부터 상속받습니다.</li>
<li>Java의 Object에 해당됩니다.</li>
<li>우리가 오버라이드할 수 있는 세 가지 메소드를 제공합니다: equals(), hashCode(), toString(). 이것이 어떤 클래스에서 메소드를 오버라이드할 때 IDE에서 이 세 가지 옵션이 자주 제시되는 이유입니다.</li>
<li>기본적으로 Nullable이 아닙니다. 변수가 null을 저장할 수 있도록 필요하다면 Any?를 사용할 수 있습니다.</li>
</ul>
<p>예제</p>
<pre><code class="hljs language-js">fun <span class="hljs-title function_">printAny</span>(<span class="hljs-params">value: Any?</span>) {
    <span class="hljs-title function_">println</span>(value.<span class="hljs-title function_">toString</span>())
}

fun <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">printAny</span>(<span class="hljs-string">"Hello, World!"</span>)  <span class="hljs-comment">// 출력: Hello, World!</span>
    <span class="hljs-title function_">printAny</span>(<span class="hljs-number">123</span>)  <span class="hljs-comment">// 출력: 123</span>
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// 디컴파일할 때 Any는 Java의 Object로 변환됩니다</span>
public <span class="hljs-keyword">static</span> final <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAny</span>(<span class="hljs-params">@Nullable <span class="hljs-built_in">Object</span> value</span>) {
   <span class="hljs-title class_">String</span> var1 = <span class="hljs-title class_">String</span>.<span class="hljs-title function_">valueOf</span>(value);
   <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(var1);
}
</code></pre>
<h1>Unit</h1>
<pre><code class="hljs language-js"><span class="hljs-comment">//SOURCE CODE</span>
package kotlin
<span class="hljs-comment">/**
 * `Unit` 객체만 있는 유형입니다. 이 유형은 Java의 `void` 유형에 해당합니다.
 */</span>
public object <span class="hljs-title class_">Unit</span> {
    override fun <span class="hljs-title function_">toString</span>() = <span class="hljs-string">"kotlin.Unit"</span>
}
</code></pre>
<ul>
<li>Java의 void와 동등하지만 void와 달리 Unit은 하나의 인스턴스만 있는 실제 클래스입니다 (싱글톤).</li>
<li>의미 있는 값을 반환하지 않는 함수를 나타냅니다.</li>
<li>함수의 반환 유형을 명시하지 않으면 Kotlin은 기본 반환 유형으로 Unit을 사용합니다.</li>
</ul>
<p>예시</p>
<pre><code class="hljs language-js">fun <span class="hljs-title function_">printMessage</span>(<span class="hljs-params">message: <span class="hljs-built_in">String</span></span>) { <span class="hljs-comment">// Unit을 명시적으로 작성할 필요가 없습니다.</span>
    <span class="hljs-title function_">println</span>(message)
}

fun <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">printMessage</span>(<span class="hljs-string">"안녕, Unit!"</span>)  <span class="hljs-comment">// 출력: 안녕, Unit!</span>
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// 변환된 결과, Unit은 Java에서 void로 변환됩니다.</span>
public <span class="hljs-keyword">static</span> final <span class="hljs-keyword">void</span> <span class="hljs-title function_">printMessage</span>(<span class="hljs-params">@NotNull <span class="hljs-built_in">String</span> message</span>) {
   <span class="hljs-title class_">Intrinsics</span>.<span class="hljs-title function_">checkNotNullParameter</span>(message, <span class="hljs-string">"message"</span>);
   <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(message);
}
</code></pre>
<p>예시: 함수형 타입</p>
<pre><code class="hljs language-js">fun <span class="hljs-title function_">runBlock</span>(<span class="hljs-params">block: ()->Unit</span>) {
    <span class="hljs-title function_">block</span>()
}

fun <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    runBlock { <span class="hljs-title function_">println</span>(<span class="hljs-string">"여기"</span>) } <span class="hljs-comment">// 출력: 여기</span>
}
</code></pre>
<p>여기서 () -` Unit은 함수 유형을 나타내며 Unit은 해당 함수 유형이 의미 있는 값을 반환하지 않음을 나타냅니다.</p>
<p>함수 유형을 지정할 때 Unit을 명시하는 것이 필수입니다.</p>
<h1>Nothing</h1>
<pre><code class="hljs language-js"><span class="hljs-comment">//SOURCE CODE</span>
package kotlin
<span class="hljs-comment">/**
 * Nothing에는 인스턴스가 없습니다. Nothing을 사용하여 "존재하지 않는 값"을 표현할 수 있습니다: 예를 들어,
 * 반환 유형이 Nothing인 함수의 경우, 이는 결코 반환하지 않음을 의미합니다 (항상 예외를 throw함).
 */</span>
public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Nothing</span> private <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)
</code></pre>
<ul>
<li>아무 값이 없음을 나타내며 함수가 일반적인 방식으로 반환하지 않을 것을 나타냅니다.</li>
<li>사용자가 정의한 Kotlin 유형을 포함한 모든 형식의 하위 유형입니다.</li>
<li>예외를 throw하거나 무한 루프에 들어가기 때문에 결코 반환되지 않는 함수에서 사용됩니다.</li>
<li>Nothing의 인스턴스를 만들거나 어떤 클래스도 상속할 수 없습니다.</li>
<li>반환 유형이 Nothing인 함수는 기본 반환 유형인 Unit조차 반환하지 않습니다.</li>
<li>Kotlin의 Nothing 반환 유형은 반환하지 않는다는 것을 명확히 하여 잠재적인 버그로부터 우리를 보호합니다. 반환 유형이 Nothing인 아무 함수가 호출되면 컴파일러는 이 함수 호출을 넘어가지 않고 접근할 수 없는 코드 경고를 알려 줍니다.</li>
</ul>
<p>예시</p>
<pre><code class="hljs language-js">fun <span class="hljs-title function_">fail</span>(<span class="hljs-attr">message</span>: <span class="hljs-title class_">String</span>): <span class="hljs-title class_">Nothing</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-title class_">IllegalArgumentException</span>(message)
}

fun <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 이것은 예외를 throw하고 일반적으로 반환하지 않을 것입니다.</span>
    <span class="hljs-title function_">fail</span>(<span class="hljs-string">"에러 발생!"</span>)
    <span class="hljs-title function_">println</span>(<span class="hljs-string">"안녕"</span>) <span class="hljs-comment">// 컴파일러가 "접근할 수 없는 코드" 경고를 줍니다.</span>
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// Decompile되었을 때, Nothing은 Java에서 Void가 됩니다</span>
<span class="hljs-comment">// Void는 java.lang 패키지의 일부이며, void Java 원시 유형을 래핑하는 객체에 대한 참조 역할을 합니다. 생성할 수 없습니다.</span>
@<span class="hljs-title class_">NotNull</span>
public <span class="hljs-keyword">static</span> final <span class="hljs-title class_">Void</span> <span class="hljs-title function_">fail</span>(<span class="hljs-params">@NotNull <span class="hljs-built_in">String</span> message</span>) {
   <span class="hljs-title class_">Intrinsics</span>.<span class="hljs-title function_">checkNotNullParameter</span>(message, <span class="hljs-string">"message"</span>);
   <span class="hljs-keyword">throw</span> (<span class="hljs-title class_">Throwable</span>)(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(message));
}
</code></pre>
<p>소스 코드: 깃허브</p>
<h1>연락처:</h1>
<p>링크드인, 트위터</p>
<p>코딩 즐기세요! ✌️</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"코틀린의 Any, Unit, Nothing 이해하기","description":"","date":"2024-05-20 17:40","slug":"2024-05-20-UnderstandingKotlinsAnyUnitNothing","content":"\n\n\n![Understanding Kotlin's Any, Unit, Nothing](/assets/img/2024-05-20-UnderstandingKotlinsAnyUnitNothing_0.png)\n\nKotlin은 Java에서 사용하던 것과는 매우 다른 독특한 유형을 제공합니다. 이 블로그에서는 Any, Unit, 그리고 Nothing과 같은 세 가지 유형을 탐색해 볼 것입니다.\n\n## Any\n\n```js\n// 소스 코드\npackage kotlin\n/**\n * 코틀린 클래스 계층 구조의 루트. 모든 코틀린 클래스는 [Any]를 슈퍼 클래스로 갖습니다.\n */\npublic open class Any {\n    public open operator fun equals(other: Any?): Boolean\n    public open fun hashCode(): Int\n    public open fun toString(): String\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 클래스 계층 구조의 루트입니다. 모든 Kotlin 클래스는 Any로부터 상속받습니다.\n- Java의 Object에 해당됩니다.\n- 우리가 오버라이드할 수 있는 세 가지 메소드를 제공합니다: equals(), hashCode(), toString(). 이것이 어떤 클래스에서 메소드를 오버라이드할 때 IDE에서 이 세 가지 옵션이 자주 제시되는 이유입니다.\n- 기본적으로 Nullable이 아닙니다. 변수가 null을 저장할 수 있도록 필요하다면 Any?를 사용할 수 있습니다.\n\n예제\n\n```js\nfun printAny(value: Any?) {\n    println(value.toString())\n}\n\nfun main() {\n    printAny(\"Hello, World!\")  // 출력: Hello, World!\n    printAny(123)  // 출력: 123\n}\n```\n\n```js\n// 디컴파일할 때 Any는 Java의 Object로 변환됩니다\npublic static final void printAny(@Nullable Object value) {\n   String var1 = String.valueOf(value);\n   System.out.println(var1);\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Unit\n\n```js\n//SOURCE CODE\npackage kotlin\n/**\n * `Unit` 객체만 있는 유형입니다. 이 유형은 Java의 `void` 유형에 해당합니다.\n */\npublic object Unit {\n    override fun toString() = \"kotlin.Unit\"\n}\n```\n\n- Java의 void와 동등하지만 void와 달리 Unit은 하나의 인스턴스만 있는 실제 클래스입니다 (싱글톤).\n- 의미 있는 값을 반환하지 않는 함수를 나타냅니다.\n- 함수의 반환 유형을 명시하지 않으면 Kotlin은 기본 반환 유형으로 Unit을 사용합니다.\n\n예시\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfun printMessage(message: String) { // Unit을 명시적으로 작성할 필요가 없습니다.\n    println(message)\n}\n\nfun main() {\n    printMessage(\"안녕, Unit!\")  // 출력: 안녕, Unit!\n}\n```\n\n```js\n// 변환된 결과, Unit은 Java에서 void로 변환됩니다.\npublic static final void printMessage(@NotNull String message) {\n   Intrinsics.checkNotNullParameter(message, \"message\");\n   System.out.println(message);\n}\n```\n\n예시: 함수형 타입\n\n```js\nfun runBlock(block: ()-\u003eUnit) {\n    block()\n}\n\nfun main() {\n    runBlock { println(\"여기\") } // 출력: 여기\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 () -` Unit은 함수 유형을 나타내며 Unit은 해당 함수 유형이 의미 있는 값을 반환하지 않음을 나타냅니다.\n\n함수 유형을 지정할 때 Unit을 명시하는 것이 필수입니다.\n\n# Nothing\n\n```js\n//SOURCE CODE\npackage kotlin\n/**\n * Nothing에는 인스턴스가 없습니다. Nothing을 사용하여 \"존재하지 않는 값\"을 표현할 수 있습니다: 예를 들어,\n * 반환 유형이 Nothing인 함수의 경우, 이는 결코 반환하지 않음을 의미합니다 (항상 예외를 throw함).\n */\npublic class Nothing private constructor()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 아무 값이 없음을 나타내며 함수가 일반적인 방식으로 반환하지 않을 것을 나타냅니다.\n- 사용자가 정의한 Kotlin 유형을 포함한 모든 형식의 하위 유형입니다.\n- 예외를 throw하거나 무한 루프에 들어가기 때문에 결코 반환되지 않는 함수에서 사용됩니다.\n- Nothing의 인스턴스를 만들거나 어떤 클래스도 상속할 수 없습니다.\n- 반환 유형이 Nothing인 함수는 기본 반환 유형인 Unit조차 반환하지 않습니다.\n- Kotlin의 Nothing 반환 유형은 반환하지 않는다는 것을 명확히 하여 잠재적인 버그로부터 우리를 보호합니다. 반환 유형이 Nothing인 아무 함수가 호출되면 컴파일러는 이 함수 호출을 넘어가지 않고 접근할 수 없는 코드 경고를 알려 줍니다.\n\n예시\n\n```js\nfun fail(message: String): Nothing {\n    throw IllegalArgumentException(message)\n}\n\nfun main() {\n    // 이것은 예외를 throw하고 일반적으로 반환하지 않을 것입니다.\n    fail(\"에러 발생!\")\n    println(\"안녕\") // 컴파일러가 \"접근할 수 없는 코드\" 경고를 줍니다.\n}\n```\n\n```js\n// Decompile되었을 때, Nothing은 Java에서 Void가 됩니다\n// Void는 java.lang 패키지의 일부이며, void Java 원시 유형을 래핑하는 객체에 대한 참조 역할을 합니다. 생성할 수 없습니다.\n@NotNull\npublic static final Void fail(@NotNull String message) {\n   Intrinsics.checkNotNullParameter(message, \"message\");\n   throw (Throwable)(new IllegalArgumentException(message));\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n소스 코드: 깃허브\n\n# 연락처:\n\n링크드인, 트위터\n\n코딩 즐기세요! ✌️","ogImage":{"url":"/assets/img/2024-05-20-UnderstandingKotlinsAnyUnitNothing_0.png"},"coverImage":"/assets/img/2024-05-20-UnderstandingKotlinsAnyUnitNothing_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-UnderstandingKotlinsAnyUnitNothing_0.png\" alt=\"Understanding Kotlin\u0026#x27;s Any, Unit, Nothing\"\u003e\u003c/p\u003e\n\u003cp\u003eKotlin은 Java에서 사용하던 것과는 매우 다른 독특한 유형을 제공합니다. 이 블로그에서는 Any, Unit, 그리고 Nothing과 같은 세 가지 유형을 탐색해 볼 것입니다.\u003c/p\u003e\n\u003ch2\u003eAny\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 소스 코드\u003c/span\u003e\npackage kotlin\n\u003cspan class=\"hljs-comment\"\u003e/**\n * 코틀린 클래스 계층 구조의 루트. 모든 코틀린 클래스는 [Any]를 슈퍼 클래스로 갖습니다.\n */\u003c/span\u003e\npublic open \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAny\u003c/span\u003e {\n    public open operator fun \u003cspan class=\"hljs-title function_\"\u003eequals\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eother\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAny\u003c/span\u003e?): \u003cspan class=\"hljs-title class_\"\u003eBoolean\u003c/span\u003e\n    public open fun \u003cspan class=\"hljs-title function_\"\u003ehashCode\u003c/span\u003e(): \u003cspan class=\"hljs-title class_\"\u003eInt\u003c/span\u003e\n    public open fun \u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e(): \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e클래스 계층 구조의 루트입니다. 모든 Kotlin 클래스는 Any로부터 상속받습니다.\u003c/li\u003e\n\u003cli\u003eJava의 Object에 해당됩니다.\u003c/li\u003e\n\u003cli\u003e우리가 오버라이드할 수 있는 세 가지 메소드를 제공합니다: equals(), hashCode(), toString(). 이것이 어떤 클래스에서 메소드를 오버라이드할 때 IDE에서 이 세 가지 옵션이 자주 제시되는 이유입니다.\u003c/li\u003e\n\u003cli\u003e기본적으로 Nullable이 아닙니다. 변수가 null을 저장할 수 있도록 필요하다면 Any?를 사용할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예제\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efun \u003cspan class=\"hljs-title function_\"\u003eprintAny\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003evalue: Any?\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(value.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e())\n}\n\nfun \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003eprintAny\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Hello, World!\"\u003c/span\u003e)  \u003cspan class=\"hljs-comment\"\u003e// 출력: Hello, World!\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003eprintAny\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e123\u003c/span\u003e)  \u003cspan class=\"hljs-comment\"\u003e// 출력: 123\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 디컴파일할 때 Any는 Java의 Object로 변환됩니다\u003c/span\u003e\npublic \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e final \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprintAny\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e@Nullable \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e value\u003c/span\u003e) {\n   \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e var1 = \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003evalueOf\u003c/span\u003e(value);\n   \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eout\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(var1);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eUnit\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//SOURCE CODE\u003c/span\u003e\npackage kotlin\n\u003cspan class=\"hljs-comment\"\u003e/**\n * `Unit` 객체만 있는 유형입니다. 이 유형은 Java의 `void` 유형에 해당합니다.\n */\u003c/span\u003e\npublic object \u003cspan class=\"hljs-title class_\"\u003eUnit\u003c/span\u003e {\n    override fun \u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e() = \u003cspan class=\"hljs-string\"\u003e\"kotlin.Unit\"\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eJava의 void와 동등하지만 void와 달리 Unit은 하나의 인스턴스만 있는 실제 클래스입니다 (싱글톤).\u003c/li\u003e\n\u003cli\u003e의미 있는 값을 반환하지 않는 함수를 나타냅니다.\u003c/li\u003e\n\u003cli\u003e함수의 반환 유형을 명시하지 않으면 Kotlin은 기본 반환 유형으로 Unit을 사용합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예시\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efun \u003cspan class=\"hljs-title function_\"\u003eprintMessage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003emessage: \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e\u003c/span\u003e) { \u003cspan class=\"hljs-comment\"\u003e// Unit을 명시적으로 작성할 필요가 없습니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(message)\n}\n\nfun \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003eprintMessage\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"안녕, Unit!\"\u003c/span\u003e)  \u003cspan class=\"hljs-comment\"\u003e// 출력: 안녕, Unit!\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 변환된 결과, Unit은 Java에서 void로 변환됩니다.\u003c/span\u003e\npublic \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e final \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprintMessage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e@NotNull \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e message\u003c/span\u003e) {\n   \u003cspan class=\"hljs-title class_\"\u003eIntrinsics\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003echeckNotNullParameter\u003c/span\u003e(message, \u003cspan class=\"hljs-string\"\u003e\"message\"\u003c/span\u003e);\n   \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eout\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(message);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예시: 함수형 타입\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efun \u003cspan class=\"hljs-title function_\"\u003erunBlock\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eblock: ()-\u003eUnit\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003eblock\u003c/span\u003e()\n}\n\nfun \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    runBlock { \u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"여기\"\u003c/span\u003e) } \u003cspan class=\"hljs-comment\"\u003e// 출력: 여기\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 () -` Unit은 함수 유형을 나타내며 Unit은 해당 함수 유형이 의미 있는 값을 반환하지 않음을 나타냅니다.\u003c/p\u003e\n\u003cp\u003e함수 유형을 지정할 때 Unit을 명시하는 것이 필수입니다.\u003c/p\u003e\n\u003ch1\u003eNothing\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//SOURCE CODE\u003c/span\u003e\npackage kotlin\n\u003cspan class=\"hljs-comment\"\u003e/**\n * Nothing에는 인스턴스가 없습니다. Nothing을 사용하여 \"존재하지 않는 값\"을 표현할 수 있습니다: 예를 들어,\n * 반환 유형이 Nothing인 함수의 경우, 이는 결코 반환하지 않음을 의미합니다 (항상 예외를 throw함).\n */\u003c/span\u003e\npublic \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNothing\u003c/span\u003e private \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e아무 값이 없음을 나타내며 함수가 일반적인 방식으로 반환하지 않을 것을 나타냅니다.\u003c/li\u003e\n\u003cli\u003e사용자가 정의한 Kotlin 유형을 포함한 모든 형식의 하위 유형입니다.\u003c/li\u003e\n\u003cli\u003e예외를 throw하거나 무한 루프에 들어가기 때문에 결코 반환되지 않는 함수에서 사용됩니다.\u003c/li\u003e\n\u003cli\u003eNothing의 인스턴스를 만들거나 어떤 클래스도 상속할 수 없습니다.\u003c/li\u003e\n\u003cli\u003e반환 유형이 Nothing인 함수는 기본 반환 유형인 Unit조차 반환하지 않습니다.\u003c/li\u003e\n\u003cli\u003eKotlin의 Nothing 반환 유형은 반환하지 않는다는 것을 명확히 하여 잠재적인 버그로부터 우리를 보호합니다. 반환 유형이 Nothing인 아무 함수가 호출되면 컴파일러는 이 함수 호출을 넘어가지 않고 접근할 수 없는 코드 경고를 알려 줍니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예시\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efun \u003cspan class=\"hljs-title function_\"\u003efail\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e): \u003cspan class=\"hljs-title class_\"\u003eNothing\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIllegalArgumentException\u003c/span\u003e(message)\n}\n\nfun \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 이것은 예외를 throw하고 일반적으로 반환하지 않을 것입니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003efail\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"에러 발생!\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"안녕\"\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// 컴파일러가 \"접근할 수 없는 코드\" 경고를 줍니다.\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Decompile되었을 때, Nothing은 Java에서 Void가 됩니다\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// Void는 java.lang 패키지의 일부이며, void Java 원시 유형을 래핑하는 객체에 대한 참조 역할을 합니다. 생성할 수 없습니다.\u003c/span\u003e\n@\u003cspan class=\"hljs-title class_\"\u003eNotNull\u003c/span\u003e\npublic \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e final \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efail\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e@NotNull \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e message\u003c/span\u003e) {\n   \u003cspan class=\"hljs-title class_\"\u003eIntrinsics\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003echeckNotNullParameter\u003c/span\u003e(message, \u003cspan class=\"hljs-string\"\u003e\"message\"\u003c/span\u003e);\n   \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e (\u003cspan class=\"hljs-title class_\"\u003eThrowable\u003c/span\u003e)(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIllegalArgumentException\u003c/span\u003e(message));\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e소스 코드: 깃허브\u003c/p\u003e\n\u003ch1\u003e연락처:\u003c/h1\u003e\n\u003cp\u003e링크드인, 트위터\u003c/p\u003e\n\u003cp\u003e코딩 즐기세요! ✌️\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-20-UnderstandingKotlinsAnyUnitNothing"},"buildId":"o1YmnmSuZvAX2O4TI9r41","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>