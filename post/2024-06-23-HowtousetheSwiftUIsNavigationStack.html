<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>SwiftUI의 NavigationStack 사용 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-23-HowtousetheSwiftUIsNavigationStack" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="SwiftUI의 NavigationStack 사용 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="SwiftUI의 NavigationStack 사용 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-HowtousetheSwiftUIsNavigationStack_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-23-HowtousetheSwiftUIsNavigationStack" data-gatsby-head="true"/><meta name="twitter:title" content="SwiftUI의 NavigationStack 사용 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-HowtousetheSwiftUIsNavigationStack_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 23:37" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_buildManifest.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">SwiftUI의 NavigationStack 사용 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="SwiftUI의 NavigationStack 사용 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-HowtousetheSwiftUIsNavigationStack&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-23-HowtousetheSwiftUIsNavigationStack_0.png" alt="Navigation in SwiftUI"></p>
<p>SwiftUI에서의 네비게이션은 복잡하고 동적인 사용자 인터페이스를 생성하는 강력한 도구입니다. 직관적인 구문과 강력한 기능 세트를 갖춘 SwiftUI의 네비게이션 기능을 사용하면 원활하고 매력적인 앱 경험을 구축하기 쉽습니다. 간단한 프로토 타입을 만들거나 완전한 애플리케이션을 구축하더라도 SwiftUI의 네비게이션 도구를 사용하면 완벽한 사용자 경험을 만들 수 있습니다.</p>
<p>네비게이션은 NavigationView를 사용하여 수행되었으나, iOS 16에서 사용 중단되었으며 새로운 두 개의 컨테이너인 NavigationStack와 NavigationSplitView로 분할되었으며, 각각의 컨테이너에는 새로운 기능이 추가되었습니다.</p>
<p>NavigationStack은 다음 네비게이션에 뷰를 설정하기 위해 사용되며, 새로운 뷰를 이전 뷰 위에 쌓아 올리고 항상 상위에 뷰를 하나 유지합니다.</p>
<p></p>
<p>NavigationSplitView은 컬럼 기반 네비게이션을 만들어야 할 때 사용됩니다. 화면이 컬럼으로 나누어지며, 각 컬럼은 NavigationSplitView의 하위 뷰 중 하나입니다.</p>
<p>이 기사에서는 NavigationStack의 기본에 중점을 둘 것입니다.</p>
<h2>NavigationView를 NavigationStack으로 이관하기</h2>
<p>이전에 언급한 대로, NavigationView는 두 개로 분리되었으므로 모든 구현이 이관될 수 있는 것은 아닙니다. NavigationView가 스택 네비게이션 스타일을 사용할 때에만 직접적인 이관이 가능합니다.</p>
<p></p>
<p>위의 코드에서 볼 수 있듯이 .stack 함수를 사용하여 NavigationView를 사용했습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// IOS 16 이전 (사용 중단).</span>
struct <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> {
 <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span> {

  <span class="hljs-title class_">NavigationView</span> {
   <span class="hljs-title class_">VStack</span> {
    <span class="hljs-title class_">NavigationLink</span>(<span class="hljs-string">"스크린 1입니다"</span>) {
     <span class="hljs-title class_">Text</span>(<span class="hljs-string">"스크린 1로 이동"</span>)
    }
    <span class="hljs-title class_">Spacer</span>().<span class="hljs-title function_">frame</span>(<span class="hljs-attr">height</span>: <span class="hljs-number">10</span>)
    <span class="hljs-title class_">NavigationLink</span>(<span class="hljs-string">"스크린 2입니다"</span>) {
     <span class="hljs-title class_">Text</span>(<span class="hljs-string">"스크린 2로 이동"</span>)
    }
   }
  }
  .<span class="hljs-title function_">navigationViewStyle</span>(.<span class="hljs-property">stack</span>)
 }
}
</code></pre>
<p>그래서 이 마이그레이션을 수행하려면 내비게이션 스타일 함수를 제거하고 NavigationView를 NavigationStack으로 변경하면 됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// IOS 16.</span>
struct <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> {
 <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span> {

  <span class="hljs-title class_">NavigationStack</span> {
   <span class="hljs-title class_">VStack</span> {
    <span class="hljs-title class_">NavigationLink</span>(<span class="hljs-string">"스크린 1입니다"</span>) {
     <span class="hljs-title class_">Text</span>(<span class="hljs-string">"스크린 1로 이동"</span>)
    }
    <span class="hljs-title class_">Spacer</span>().<span class="hljs-title function_">frame</span>(<span class="hljs-attr">height</span>: <span class="hljs-number">10</span>)
    <span class="hljs-title class_">NavigationLink</span>(<span class="hljs-string">"스크린 2입니다"</span>) {
     <span class="hljs-title class_">Text</span>(<span class="hljs-string">"스크린 2로 이동"</span>)
    }
   }
  }
 }
}
</code></pre>
<p></p>
<h1>NavigationStack 새로운 기능</h1>
<h2>값 타입을 위한 NavigationDestination</h2>
<p>새로운 네비게이션 시스템으로 코드가 더 깔끔해졌습니다. 이제는 NavigationLink 생성과 관계없이 목적지를 정의할 수 있습니다.</p>
<p>목적지를 정의하려면 NavigationLink의 상위 뷰에 navigationDestination() 함수를 추가해야 합니다. 이 함수에는 다음과 같은 매개변수가 있습니다:</p>
<p></p>
<p>파라미터:</p>
<ul>
<li>Data: 이 대상과 일치하는 데이터의 유형입니다.</li>
<li>Destination: 스택의 탐색 상태에 <code>data</code> 유형의 값이 포함된 경우 표시할 뷰를 정의하는 뷰 빌더입니다. 이 클로저는 하나의 인수를 사용하며, 그것은 표시할 데이터의 값입니다.</li>
</ul>
<p>이전에 보았듯이, 파라미터 중 하나는 대상 데이터입니다. 이 정보를 navigationDestination()에 보내기 위해 NavigationLink에 값을 추가해야 합니다. 이 매개변수는 Hashable 프로토콜을 구현한 값만 수용합니다.</p>
<p>아래 예제에서는 각 링크마다 스크린 번호가 포함된 문자열이 NavigationLink의 값 매개변수로 전송됩니다. 그런 다음 링크 컨테이너는 navigationDestination을 구현했습니다. 이것은 문자열 유형의 어떤 값이라도 전달될 때 호출될 것입니다.</p>
<p></p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> {

 <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {
  <span class="hljs-type">NavigationStack</span> {
   <span class="hljs-type">VStack</span> {
    <span class="hljs-type">NavigationLink</span>(<span class="hljs-string">"화면 1으로 이동"</span>, value: <span class="hljs-string">"1"</span>)
    <span class="hljs-type">Spacer</span>().frame(height: <span class="hljs-number">10</span>)
    <span class="hljs-type">NavigationLink</span>(<span class="hljs-string">"화면 2로 이동"</span>, value: <span class="hljs-string">"2"</span>)
   }.navigationDestination(for: <span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>) { value <span class="hljs-keyword">in</span>
    <span class="hljs-type">Text</span>(<span class="hljs-string">"이것은 화면 번호 <span class="hljs-subst">\(value)</span>입니다"</span>)
   }
  }
 }
}
</code></pre>
<h2>불리언 상태 변수에 대한 NavigationDestination</h2>
<p>또 다른 navigation 대상을 구현하는 방법은 불리언 상태 변수를 관찰하는 것입니다. 따라서 observable state가 변경될 때마다 대상이 트리거됩니다.</p>
<p></p>
<p>아래 예제에서는 showDetails 변수를 true로 변경하는 버튼이 있습니다. 이 변수는 navigationDestination에 의해 관찰되며, destination에는 변수를 false로 변경하는 버튼이 포함되어 있습니다. 변수가 true이면 대상 뷰가 나타나고, false이면 사라집니다.</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> {
 <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> showDetails <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>

 <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {
  <span class="hljs-type">NavigationStack</span> {
   <span class="hljs-type">VStack</span> {
    <span class="hljs-type">Button</span>(<span class="hljs-string">"세부 정보 업데이트"</span>) {
     showDetails <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>
    }
   }
   .navigationDestination(isPresented: <span class="hljs-variable">$showDetails</span>) {
    <span class="hljs-type">VStack</span> {
     <span class="hljs-type">Text</span>(<span class="hljs-string">"세부 정보가 업데이트되었습니다"</span>)
     <span class="hljs-type">Button</span>(<span class="hljs-string">"닫기"</span>) {
      showDetails <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>
     }
    }
   }
  }
 }
}
</code></pre>
<p></p>
<p><img src="https://miro.medium.com/v2/resize:fit:784/1*mN4EwmCDiECEE6Iw_rKxBg.gif" alt="image"></p>
<h2>NavigationStack 경로 매개변수</h2>
<p>이 새로운 매개변수는 iOS 16에 도입된 최고의 새로운 기능 중 하나로, 딥링크 및 다른 특정 네비게이션 경우의 쉬운 구현을 가능하게 합니다.</p>
<p>기본적으로 이 매개변수는 우리에게 새로운 대상으로의 미리 정의된 경로를 정의하고, 경로에 쌓인 모든 화면을 추적할 수 있도록 해줍니다.</p>
<p></p>
<p>아래 예시에서는 패스 변수를 가지고 있으며, 해당 변수는 네비게이션 스택의 경로 매개변수로 설정되어 있습니다. 이 목록의 각 항목은 프로그램 시작 시에 열리는 화면과 대응합니다.</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> {

 @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">path</span>: [<span class="hljs-title class_">String</span>] = [<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>]

 <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span> {
  <span class="hljs-title class_">NavigationStack</span>(<span class="hljs-attr">path</span>: $path) {
   <span class="hljs-title class_">VStack</span> {
    <span class="hljs-title class_">NavigationLink</span>(<span class="hljs-string">"Go to screen 4"</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">"4"</span>)
   }.<span class="hljs-title function_">navigationDestination</span>(<span class="hljs-params"><span class="hljs-keyword">for</span>: <span class="hljs-built_in">String</span>.self</span>) { value <span class="hljs-keyword">in</span>
    <span class="hljs-title class_">Text</span>(<span class="hljs-string">"This is screen number \(value)"</span>)
   }
  }
 }
}
</code></pre>
<p><img src="https://miro.medium.com/v2/resize:fit:784/1*UKAZP7Xn4iBP12FsyphWng.gif" alt="이미지"></p>
<h2>NavigationPath</h2>
<p></p>
<p>이전 주제에서 NavigationStack의 변수 경로로 사용하기 위해 String 목록이 생성되었습니다. 그런데 새로운 화면이 다른 유형을 매개변수로받아야하는 경우에는 어떻게 해야하며 여전히 모든 탐색을 추적하고 싶다면 어떻게 해야합니까?</p>
<p>Apple은이 문제를 해결하기 위해 데이터의 타입을 지워버리는 NavigationPath라는 목록을 만들었습니다.</p>
<p>NavigationPath를 사용하는 방법을 더 잘 이해하기 위해 인물 모델을 만들겠습니다. NavigationLink의 값 매개변수와 마찬가지로 경로 목록에 추가될 모든 유형은 Hashable 프로토콜을 구현해야 합니다.</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">PersonModel</span>: <span class="hljs-title class_">Hashable</span> {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>
  <span class="hljs-keyword">let</span> <span class="hljs-attr">age</span>: <span class="hljs-title class_">Int</span>
}
</code></pre>
<p></p>
<p>그런 다음, 우리는 두 가지 시작 경로와 함께 문자열 유형을 가진 NavigationPath를 만듭니다.</p>
<p>그 후에, 새 경로가 NavigationStack의 경로 매개변수로 설정되고, NavigationPath의 유형 유연성을 테스트하기 위해 두 가지 새로운 NavigationsLinks를 만들 것입니다.</p>
<p>첫 번째 링크는 정수를 값 매개변수로 사용하고, 두 번째 링크는 생성된 person 모델을 값으로 사용합니다. 서로 다른 유형의 값을 추가한 후, 이들에 대한 특정 대상을 정의해야 합니다.</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> {

 @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> path = <span class="hljs-title class_">NavigationPath</span>([<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>])

 <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span> {
  <span class="hljs-title class_">NavigationStack</span>(<span class="hljs-attr">path</span>: $path) {
   <span class="hljs-title class_">VStack</span> {
    <span class="hljs-title class_">NavigationLink</span>(<span class="hljs-string">"정수 화면으로 이동"</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>)
    <span class="hljs-title class_">Spacer</span>().<span class="hljs-title function_">frame</span>(<span class="hljs-attr">height</span>: <span class="hljs-number">10</span>)
    <span class="hljs-title class_">NavigationLink</span>(<span class="hljs-string">"사람 화면으로 이동"</span>, <span class="hljs-attr">value</span>: <span class="hljs-title class_">PersonModel</span>(<span class="hljs-attr">name</span>: <span class="hljs-string">"Mark"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">32</span>))

   }.<span class="hljs-title function_">navigationDestination</span>(<span class="hljs-params"><span class="hljs-keyword">for</span>: <span class="hljs-built_in">String</span>.self</span>) { value <span class="hljs-keyword">in</span>
    <span class="hljs-title class_">Text</span>(<span class="hljs-string">"이것은 값이 있는 문자열 화면입니다: \(value)"</span>)
   }.<span class="hljs-title function_">navigationDestination</span>(<span class="hljs-params"><span class="hljs-keyword">for</span>: Int.self</span>) { value <span class="hljs-keyword">in</span>
    <span class="hljs-title class_">Text</span>(<span class="hljs-string">"이것은 값이 있는 정수 화면입니다: \(value)"</span>)
   }.<span class="hljs-title function_">navigationDestination</span>(<span class="hljs-params"><span class="hljs-keyword">for</span>: PersonModel.self</span>) { value <span class="hljs-keyword">in</span>
    <span class="hljs-title class_">Text</span>(<span class="hljs-string">"이것은 값이 있는 사람 화면입니다.\n이름: \(value.name), 나이: \(value.age)"</span>)
   }
  }
 }
}
</code></pre>
<p></p>
<h1>결론</h1>
<p>여기까지 새로운 iOS 16 내비게이션 방식의 강력함을 확인했고, 이제 SwiftUI가 제공하는 네이티브 도구를 사용하여 앱의 자체 내비게이션 시스템을 쉽게 구축할 수 있게 되었습니다.</p>
<p>iOS 개발 관련 질문이 있거나 대화를 나누고 싶으시다면 언제든지 LinkedIn으로 메시지를 남겨주세요! 🙂</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"SwiftUI의 NavigationStack 사용 방법","description":"","date":"2024-06-23 23:37","slug":"2024-06-23-HowtousetheSwiftUIsNavigationStack","content":"\n![Navigation in SwiftUI](/assets/img/2024-06-23-HowtousetheSwiftUIsNavigationStack_0.png)\n\nSwiftUI에서의 네비게이션은 복잡하고 동적인 사용자 인터페이스를 생성하는 강력한 도구입니다. 직관적인 구문과 강력한 기능 세트를 갖춘 SwiftUI의 네비게이션 기능을 사용하면 원활하고 매력적인 앱 경험을 구축하기 쉽습니다. 간단한 프로토 타입을 만들거나 완전한 애플리케이션을 구축하더라도 SwiftUI의 네비게이션 도구를 사용하면 완벽한 사용자 경험을 만들 수 있습니다.\n\n네비게이션은 NavigationView를 사용하여 수행되었으나, iOS 16에서 사용 중단되었으며 새로운 두 개의 컨테이너인 NavigationStack와 NavigationSplitView로 분할되었으며, 각각의 컨테이너에는 새로운 기능이 추가되었습니다.\n\nNavigationStack은 다음 네비게이션에 뷰를 설정하기 위해 사용되며, 새로운 뷰를 이전 뷰 위에 쌓아 올리고 항상 상위에 뷰를 하나 유지합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNavigationSplitView은 컬럼 기반 네비게이션을 만들어야 할 때 사용됩니다. 화면이 컬럼으로 나누어지며, 각 컬럼은 NavigationSplitView의 하위 뷰 중 하나입니다.\n\n이 기사에서는 NavigationStack의 기본에 중점을 둘 것입니다.\n\n## NavigationView를 NavigationStack으로 이관하기\n\n이전에 언급한 대로, NavigationView는 두 개로 분리되었으므로 모든 구현이 이관될 수 있는 것은 아닙니다. NavigationView가 스택 네비게이션 스타일을 사용할 때에만 직접적인 이관이 가능합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 코드에서 볼 수 있듯이 .stack 함수를 사용하여 NavigationView를 사용했습니다.\n\n```js\n// IOS 16 이전 (사용 중단).\nstruct ContentView: View {\n var body: some View {\n\n  NavigationView {\n   VStack {\n    NavigationLink(\"스크린 1입니다\") {\n     Text(\"스크린 1로 이동\")\n    }\n    Spacer().frame(height: 10)\n    NavigationLink(\"스크린 2입니다\") {\n     Text(\"스크린 2로 이동\")\n    }\n   }\n  }\n  .navigationViewStyle(.stack)\n }\n}\n```\n\n그래서 이 마이그레이션을 수행하려면 내비게이션 스타일 함수를 제거하고 NavigationView를 NavigationStack으로 변경하면 됩니다.\n\n```js\n// IOS 16.\nstruct ContentView: View {\n var body: some View {\n\n  NavigationStack {\n   VStack {\n    NavigationLink(\"스크린 1입니다\") {\n     Text(\"스크린 1로 이동\")\n    }\n    Spacer().frame(height: 10)\n    NavigationLink(\"스크린 2입니다\") {\n     Text(\"스크린 2로 이동\")\n    }\n   }\n  }\n }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# NavigationStack 새로운 기능\n\n## 값 타입을 위한 NavigationDestination\n\n새로운 네비게이션 시스템으로 코드가 더 깔끔해졌습니다. 이제는 NavigationLink 생성과 관계없이 목적지를 정의할 수 있습니다.\n\n목적지를 정의하려면 NavigationLink의 상위 뷰에 navigationDestination() 함수를 추가해야 합니다. 이 함수에는 다음과 같은 매개변수가 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파라미터:\n\n- Data: 이 대상과 일치하는 데이터의 유형입니다.\n- Destination: 스택의 탐색 상태에 `data` 유형의 값이 포함된 경우 표시할 뷰를 정의하는 뷰 빌더입니다. 이 클로저는 하나의 인수를 사용하며, 그것은 표시할 데이터의 값입니다.\n\n이전에 보았듯이, 파라미터 중 하나는 대상 데이터입니다. 이 정보를 navigationDestination()에 보내기 위해 NavigationLink에 값을 추가해야 합니다. 이 매개변수는 Hashable 프로토콜을 구현한 값만 수용합니다.\n\n아래 예제에서는 각 링크마다 스크린 번호가 포함된 문자열이 NavigationLink의 값 매개변수로 전송됩니다. 그런 다음 링크 컨테이너는 navigationDestination을 구현했습니다. 이것은 문자열 유형의 어떤 값이라도 전달될 때 호출될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nstruct ContentView: View {\n\n var body: some View {\n  NavigationStack {\n   VStack {\n    NavigationLink(\"화면 1으로 이동\", value: \"1\")\n    Spacer().frame(height: 10)\n    NavigationLink(\"화면 2로 이동\", value: \"2\")\n   }.navigationDestination(for: String.self) { value in\n    Text(\"이것은 화면 번호 \\(value)입니다\")\n   }\n  }\n }\n}\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:784/1*GwLWWM6KAWYGQmaztzbqTw.gif\" /\u003e\n\n## 불리언 상태 변수에 대한 NavigationDestination\n\n또 다른 navigation 대상을 구현하는 방법은 불리언 상태 변수를 관찰하는 것입니다. 따라서 observable state가 변경될 때마다 대상이 트리거됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 예제에서는 showDetails 변수를 true로 변경하는 버튼이 있습니다. 이 변수는 navigationDestination에 의해 관찰되며, destination에는 변수를 false로 변경하는 버튼이 포함되어 있습니다. 변수가 true이면 대상 뷰가 나타나고, false이면 사라집니다.\n\n```swift\nstruct ContentView: View {\n @State private var showDetails = false\n\n var body: some View {\n  NavigationStack {\n   VStack {\n    Button(\"세부 정보 업데이트\") {\n     showDetails = true\n    }\n   }\n   .navigationDestination(isPresented: $showDetails) {\n    VStack {\n     Text(\"세부 정보가 업데이트되었습니다\")\n     Button(\"닫기\") {\n      showDetails = false\n     }\n    }\n   }\n  }\n }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:784/1*mN4EwmCDiECEE6Iw_rKxBg.gif)\n\n## NavigationStack 경로 매개변수\n\n이 새로운 매개변수는 iOS 16에 도입된 최고의 새로운 기능 중 하나로, 딥링크 및 다른 특정 네비게이션 경우의 쉬운 구현을 가능하게 합니다.\n\n기본적으로 이 매개변수는 우리에게 새로운 대상으로의 미리 정의된 경로를 정의하고, 경로에 쌓인 모든 화면을 추적할 수 있도록 해줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 예시에서는 패스 변수를 가지고 있으며, 해당 변수는 네비게이션 스택의 경로 매개변수로 설정되어 있습니다. 이 목록의 각 항목은 프로그램 시작 시에 열리는 화면과 대응합니다.\n\n```js\nstruct ContentView: View {\n\n @State var path: [String] = [\"1\", \"2\", \"3\"]\n\n var body: some View {\n  NavigationStack(path: $path) {\n   VStack {\n    NavigationLink(\"Go to screen 4\", value: \"4\")\n   }.navigationDestination(for: String.self) { value in\n    Text(\"This is screen number \\(value)\")\n   }\n  }\n }\n}\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:784/1*UKAZP7Xn4iBP12FsyphWng.gif)\n\n## NavigationPath\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전 주제에서 NavigationStack의 변수 경로로 사용하기 위해 String 목록이 생성되었습니다. 그런데 새로운 화면이 다른 유형을 매개변수로받아야하는 경우에는 어떻게 해야하며 여전히 모든 탐색을 추적하고 싶다면 어떻게 해야합니까?\n\nApple은이 문제를 해결하기 위해 데이터의 타입을 지워버리는 NavigationPath라는 목록을 만들었습니다.\n\nNavigationPath를 사용하는 방법을 더 잘 이해하기 위해 인물 모델을 만들겠습니다. NavigationLink의 값 매개변수와 마찬가지로 경로 목록에 추가될 모든 유형은 Hashable 프로토콜을 구현해야 합니다.\n\n```js\nstruct PersonModel: Hashable {\n  let name: String\n  let age: Int\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그런 다음, 우리는 두 가지 시작 경로와 함께 문자열 유형을 가진 NavigationPath를 만듭니다.\n\n그 후에, 새 경로가 NavigationStack의 경로 매개변수로 설정되고, NavigationPath의 유형 유연성을 테스트하기 위해 두 가지 새로운 NavigationsLinks를 만들 것입니다.\n\n첫 번째 링크는 정수를 값 매개변수로 사용하고, 두 번째 링크는 생성된 person 모델을 값으로 사용합니다. 서로 다른 유형의 값을 추가한 후, 이들에 대한 특정 대상을 정의해야 합니다.\n\n```js\nstruct ContentView: View {\n\n @State var path = NavigationPath([\"1\", \"2\"])\n\n var body: some View {\n  NavigationStack(path: $path) {\n   VStack {\n    NavigationLink(\"정수 화면으로 이동\", value: 1)\n    Spacer().frame(height: 10)\n    NavigationLink(\"사람 화면으로 이동\", value: PersonModel(name: \"Mark\", age: 32))\n\n   }.navigationDestination(for: String.self) { value in\n    Text(\"이것은 값이 있는 문자열 화면입니다: \\(value)\")\n   }.navigationDestination(for: Int.self) { value in\n    Text(\"이것은 값이 있는 정수 화면입니다: \\(value)\")\n   }.navigationDestination(for: PersonModel.self) { value in\n    Text(\"이것은 값이 있는 사람 화면입니다.\\n이름: \\(value.name), 나이: \\(value.age)\")\n   }\n  }\n }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:788/1*13DNutvSEBznr-r2hmWSlQ.gif\" /\u003e\n\n# 결론\n\n여기까지 새로운 iOS 16 내비게이션 방식의 강력함을 확인했고, 이제 SwiftUI가 제공하는 네이티브 도구를 사용하여 앱의 자체 내비게이션 시스템을 쉽게 구축할 수 있게 되었습니다.\n\niOS 개발 관련 질문이 있거나 대화를 나누고 싶으시다면 언제든지 LinkedIn으로 메시지를 남겨주세요! 🙂\n","ogImage":{"url":"/assets/img/2024-06-23-HowtousetheSwiftUIsNavigationStack_0.png"},"coverImage":"/assets/img/2024-06-23-HowtousetheSwiftUIsNavigationStack_0.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-HowtousetheSwiftUIsNavigationStack_0.png\" alt=\"Navigation in SwiftUI\"\u003e\u003c/p\u003e\n\u003cp\u003eSwiftUI에서의 네비게이션은 복잡하고 동적인 사용자 인터페이스를 생성하는 강력한 도구입니다. 직관적인 구문과 강력한 기능 세트를 갖춘 SwiftUI의 네비게이션 기능을 사용하면 원활하고 매력적인 앱 경험을 구축하기 쉽습니다. 간단한 프로토 타입을 만들거나 완전한 애플리케이션을 구축하더라도 SwiftUI의 네비게이션 도구를 사용하면 완벽한 사용자 경험을 만들 수 있습니다.\u003c/p\u003e\n\u003cp\u003e네비게이션은 NavigationView를 사용하여 수행되었으나, iOS 16에서 사용 중단되었으며 새로운 두 개의 컨테이너인 NavigationStack와 NavigationSplitView로 분할되었으며, 각각의 컨테이너에는 새로운 기능이 추가되었습니다.\u003c/p\u003e\n\u003cp\u003eNavigationStack은 다음 네비게이션에 뷰를 설정하기 위해 사용되며, 새로운 뷰를 이전 뷰 위에 쌓아 올리고 항상 상위에 뷰를 하나 유지합니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eNavigationSplitView은 컬럼 기반 네비게이션을 만들어야 할 때 사용됩니다. 화면이 컬럼으로 나누어지며, 각 컬럼은 NavigationSplitView의 하위 뷰 중 하나입니다.\u003c/p\u003e\n\u003cp\u003e이 기사에서는 NavigationStack의 기본에 중점을 둘 것입니다.\u003c/p\u003e\n\u003ch2\u003eNavigationView를 NavigationStack으로 이관하기\u003c/h2\u003e\n\u003cp\u003e이전에 언급한 대로, NavigationView는 두 개로 분리되었으므로 모든 구현이 이관될 수 있는 것은 아닙니다. NavigationView가 스택 네비게이션 스타일을 사용할 때에만 직접적인 이관이 가능합니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e위의 코드에서 볼 수 있듯이 .stack 함수를 사용하여 NavigationView를 사용했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// IOS 16 이전 (사용 중단).\u003c/span\u003e\nstruct \u003cspan class=\"hljs-title class_\"\u003eContentView\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n\n  \u003cspan class=\"hljs-title class_\"\u003eNavigationView\u003c/span\u003e {\n   \u003cspan class=\"hljs-title class_\"\u003eVStack\u003c/span\u003e {\n    \u003cspan class=\"hljs-title class_\"\u003eNavigationLink\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"스크린 1입니다\"\u003c/span\u003e) {\n     \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"스크린 1로 이동\"\u003c/span\u003e)\n    }\n    \u003cspan class=\"hljs-title class_\"\u003eSpacer\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003eframe\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)\n    \u003cspan class=\"hljs-title class_\"\u003eNavigationLink\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"스크린 2입니다\"\u003c/span\u003e) {\n     \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"스크린 2로 이동\"\u003c/span\u003e)\n    }\n   }\n  }\n  .\u003cspan class=\"hljs-title function_\"\u003enavigationViewStyle\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003estack\u003c/span\u003e)\n }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그래서 이 마이그레이션을 수행하려면 내비게이션 스타일 함수를 제거하고 NavigationView를 NavigationStack으로 변경하면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// IOS 16.\u003c/span\u003e\nstruct \u003cspan class=\"hljs-title class_\"\u003eContentView\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n\n  \u003cspan class=\"hljs-title class_\"\u003eNavigationStack\u003c/span\u003e {\n   \u003cspan class=\"hljs-title class_\"\u003eVStack\u003c/span\u003e {\n    \u003cspan class=\"hljs-title class_\"\u003eNavigationLink\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"스크린 1입니다\"\u003c/span\u003e) {\n     \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"스크린 1로 이동\"\u003c/span\u003e)\n    }\n    \u003cspan class=\"hljs-title class_\"\u003eSpacer\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003eframe\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)\n    \u003cspan class=\"hljs-title class_\"\u003eNavigationLink\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"스크린 2입니다\"\u003c/span\u003e) {\n     \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"스크린 2로 이동\"\u003c/span\u003e)\n    }\n   }\n  }\n }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003eNavigationStack 새로운 기능\u003c/h1\u003e\n\u003ch2\u003e값 타입을 위한 NavigationDestination\u003c/h2\u003e\n\u003cp\u003e새로운 네비게이션 시스템으로 코드가 더 깔끔해졌습니다. 이제는 NavigationLink 생성과 관계없이 목적지를 정의할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e목적지를 정의하려면 NavigationLink의 상위 뷰에 navigationDestination() 함수를 추가해야 합니다. 이 함수에는 다음과 같은 매개변수가 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e파라미터:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eData: 이 대상과 일치하는 데이터의 유형입니다.\u003c/li\u003e\n\u003cli\u003eDestination: 스택의 탐색 상태에 \u003ccode\u003edata\u003c/code\u003e 유형의 값이 포함된 경우 표시할 뷰를 정의하는 뷰 빌더입니다. 이 클로저는 하나의 인수를 사용하며, 그것은 표시할 데이터의 값입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이전에 보았듯이, 파라미터 중 하나는 대상 데이터입니다. 이 정보를 navigationDestination()에 보내기 위해 NavigationLink에 값을 추가해야 합니다. 이 매개변수는 Hashable 프로토콜을 구현한 값만 수용합니다.\u003c/p\u003e\n\u003cp\u003e아래 예제에서는 각 링크마다 스크린 번호가 포함된 문자열이 NavigationLink의 값 매개변수로 전송됩니다. 그런 다음 링크 컨테이너는 navigationDestination을 구현했습니다. 이것은 문자열 유형의 어떤 값이라도 전달될 때 호출될 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eContentView\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n\n \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e body: \u003cspan class=\"hljs-keyword\"\u003esome\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eView\u003c/span\u003e {\n  \u003cspan class=\"hljs-type\"\u003eNavigationStack\u003c/span\u003e {\n   \u003cspan class=\"hljs-type\"\u003eVStack\u003c/span\u003e {\n    \u003cspan class=\"hljs-type\"\u003eNavigationLink\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"화면 1으로 이동\"\u003c/span\u003e, value: \u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-type\"\u003eSpacer\u003c/span\u003e().frame(height: \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)\n    \u003cspan class=\"hljs-type\"\u003eNavigationLink\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"화면 2로 이동\"\u003c/span\u003e, value: \u003cspan class=\"hljs-string\"\u003e\"2\"\u003c/span\u003e)\n   }.navigationDestination(for: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e.\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e) { value \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이것은 화면 번호 \u003cspan class=\"hljs-subst\"\u003e\\(value)\u003c/span\u003e입니다\"\u003c/span\u003e)\n   }\n  }\n }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e불리언 상태 변수에 대한 NavigationDestination\u003c/h2\u003e\n\u003cp\u003e또 다른 navigation 대상을 구현하는 방법은 불리언 상태 변수를 관찰하는 것입니다. 따라서 observable state가 변경될 때마다 대상이 트리거됩니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e아래 예제에서는 showDetails 변수를 true로 변경하는 버튼이 있습니다. 이 변수는 navigationDestination에 의해 관찰되며, destination에는 변수를 false로 변경하는 버튼이 포함되어 있습니다. 변수가 true이면 대상 뷰가 나타나고, false이면 사라집니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eContentView\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n \u003cspan class=\"hljs-meta\"\u003e@State\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e showDetails \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n\n \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e body: \u003cspan class=\"hljs-keyword\"\u003esome\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eView\u003c/span\u003e {\n  \u003cspan class=\"hljs-type\"\u003eNavigationStack\u003c/span\u003e {\n   \u003cspan class=\"hljs-type\"\u003eVStack\u003c/span\u003e {\n    \u003cspan class=\"hljs-type\"\u003eButton\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"세부 정보 업데이트\"\u003c/span\u003e) {\n     showDetails \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n    }\n   }\n   .navigationDestination(isPresented: \u003cspan class=\"hljs-variable\"\u003e$showDetails\u003c/span\u003e) {\n    \u003cspan class=\"hljs-type\"\u003eVStack\u003c/span\u003e {\n     \u003cspan class=\"hljs-type\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"세부 정보가 업데이트되었습니다\"\u003c/span\u003e)\n     \u003cspan class=\"hljs-type\"\u003eButton\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"닫기\"\u003c/span\u003e) {\n      showDetails \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n     }\n    }\n   }\n  }\n }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:784/1*mN4EwmCDiECEE6Iw_rKxBg.gif\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch2\u003eNavigationStack 경로 매개변수\u003c/h2\u003e\n\u003cp\u003e이 새로운 매개변수는 iOS 16에 도입된 최고의 새로운 기능 중 하나로, 딥링크 및 다른 특정 네비게이션 경우의 쉬운 구현을 가능하게 합니다.\u003c/p\u003e\n\u003cp\u003e기본적으로 이 매개변수는 우리에게 새로운 대상으로의 미리 정의된 경로를 정의하고, 경로에 쌓인 모든 화면을 추적할 수 있도록 해줍니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e아래 예시에서는 패스 변수를 가지고 있으며, 해당 변수는 네비게이션 스택의 경로 매개변수로 설정되어 있습니다. 이 목록의 각 항목은 프로그램 시작 시에 열리는 화면과 대응합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eContentView\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n\n @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e] = [\u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"2\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"3\"\u003c/span\u003e]\n\n \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n  \u003cspan class=\"hljs-title class_\"\u003eNavigationStack\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: $path) {\n   \u003cspan class=\"hljs-title class_\"\u003eVStack\u003c/span\u003e {\n    \u003cspan class=\"hljs-title class_\"\u003eNavigationLink\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Go to screen 4\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"4\"\u003c/span\u003e)\n   }.\u003cspan class=\"hljs-title function_\"\u003enavigationDestination\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e.self\u003c/span\u003e) { value \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"This is screen number \\(value)\"\u003c/span\u003e)\n   }\n  }\n }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:784/1*UKAZP7Xn4iBP12FsyphWng.gif\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003eNavigationPath\u003c/h2\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e이전 주제에서 NavigationStack의 변수 경로로 사용하기 위해 String 목록이 생성되었습니다. 그런데 새로운 화면이 다른 유형을 매개변수로받아야하는 경우에는 어떻게 해야하며 여전히 모든 탐색을 추적하고 싶다면 어떻게 해야합니까?\u003c/p\u003e\n\u003cp\u003eApple은이 문제를 해결하기 위해 데이터의 타입을 지워버리는 NavigationPath라는 목록을 만들었습니다.\u003c/p\u003e\n\u003cp\u003eNavigationPath를 사용하는 방법을 더 잘 이해하기 위해 인물 모델을 만들겠습니다. NavigationLink의 값 매개변수와 마찬가지로 경로 목록에 추가될 모든 유형은 Hashable 프로토콜을 구현해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003ePersonModel\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eHashable\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eInt\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e그런 다음, 우리는 두 가지 시작 경로와 함께 문자열 유형을 가진 NavigationPath를 만듭니다.\u003c/p\u003e\n\u003cp\u003e그 후에, 새 경로가 NavigationStack의 경로 매개변수로 설정되고, NavigationPath의 유형 유연성을 테스트하기 위해 두 가지 새로운 NavigationsLinks를 만들 것입니다.\u003c/p\u003e\n\u003cp\u003e첫 번째 링크는 정수를 값 매개변수로 사용하고, 두 번째 링크는 생성된 person 모델을 값으로 사용합니다. 서로 다른 유형의 값을 추가한 후, 이들에 대한 특정 대상을 정의해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eContentView\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n\n @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e path = \u003cspan class=\"hljs-title class_\"\u003eNavigationPath\u003c/span\u003e([\u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"2\"\u003c/span\u003e])\n\n \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n  \u003cspan class=\"hljs-title class_\"\u003eNavigationStack\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: $path) {\n   \u003cspan class=\"hljs-title class_\"\u003eVStack\u003c/span\u003e {\n    \u003cspan class=\"hljs-title class_\"\u003eNavigationLink\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"정수 화면으로 이동\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n    \u003cspan class=\"hljs-title class_\"\u003eSpacer\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003eframe\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)\n    \u003cspan class=\"hljs-title class_\"\u003eNavigationLink\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"사람 화면으로 이동\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003ePersonModel\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Mark\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e32\u003c/span\u003e))\n\n   }.\u003cspan class=\"hljs-title function_\"\u003enavigationDestination\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e.self\u003c/span\u003e) { value \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이것은 값이 있는 문자열 화면입니다: \\(value)\"\u003c/span\u003e)\n   }.\u003cspan class=\"hljs-title function_\"\u003enavigationDestination\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e: Int.self\u003c/span\u003e) { value \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이것은 값이 있는 정수 화면입니다: \\(value)\"\u003c/span\u003e)\n   }.\u003cspan class=\"hljs-title function_\"\u003enavigationDestination\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e: PersonModel.self\u003c/span\u003e) { value \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이것은 값이 있는 사람 화면입니다.\\n이름: \\(value.name), 나이: \\(value.age)\"\u003c/span\u003e)\n   }\n  }\n }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e여기까지 새로운 iOS 16 내비게이션 방식의 강력함을 확인했고, 이제 SwiftUI가 제공하는 네이티브 도구를 사용하여 앱의 자체 내비게이션 시스템을 쉽게 구축할 수 있게 되었습니다.\u003c/p\u003e\n\u003cp\u003eiOS 개발 관련 질문이 있거나 대화를 나누고 싶으시다면 언제든지 LinkedIn으로 메시지를 남겨주세요! 🙂\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-HowtousetheSwiftUIsNavigationStack"},"buildId":"bb_yO9GbCvdfc_n71SfUf","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>