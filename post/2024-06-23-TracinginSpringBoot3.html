<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Spring Boot3에서 트레이싱 활용하는 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-23-TracinginSpringBoot3" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Spring Boot3에서 트레이싱 활용하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Spring Boot3에서 트레이싱 활용하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-TracinginSpringBoot3_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-23-TracinginSpringBoot3" data-gatsby-head="true"/><meta name="twitter:title" content="Spring Boot3에서 트레이싱 활용하는 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-TracinginSpringBoot3_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 20:31" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/-dPCbnM2yhdKNgXe92VJV/_buildManifest.js" defer=""></script><script src="/_next/static/-dPCbnM2yhdKNgXe92VJV/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Spring Boot3에서 트레이싱 활용하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Spring Boot3에서 트레이싱 활용하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-TracinginSpringBoot3&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-23-TracinginSpringBoot3_0.png" alt="2024-06-23-TracinginSpringBoot3_0"></p>
<p>제 초창기 전문가 시절을 돌이켜보면, 프로덕션 문제 해결 방식에서 조금 놀라운 점이 있었습니다. 모든 것을 다 다루는 프로젝트에서 일했는데, 고객과의 인터페이싱부터 코딩, 배포, 그리고 문제 해결까지 모든 것을 처리했죠. 문제가 발생하면 명쾌한 해결책이 없는 상황이었고, 그때의 나는 프로덕션 데이터베이스 덤프를 떠서 해당 데이터베이스를 이용해 내 컴퓨터에서 애플리케이션을 실행한 다음 고객과 통화하면서 그들이 하는 작업을 재현하고 문제점을 확인하기 위해 필요한 디버그 지점 및 출력문을 사용했어요. 그 방식은 그 당시에는 효과적이었습니다. 애플리케이션은 작고 사용자 베이스가 제한적이었으며, 단일 개발자로는 완전히 관리할 수 있었지만, 그때는 여전히 로깅의 중요성을 이해하지 못했죠.</p>
<p>몇 년 후, 이제는 여러 개발자, 제품 소유자, 스크럼 마스터, 운영팀, 인프라팀, 그리고 물론 수백만 명의 사용자가 참여하는 프로젝트에서 일하고 있습니다. 중요한 점은 개발자에게는 프로덕션 환경이 대부분 접근 불가능하며, 또한 고객이 개발자와 직접 커뮤니케이션할 수 없으므로 우리를 미치게 만든다는 사실입니다.</p>
<p>운영팀은 이 두 영역 사이의 다리 역할을 했습니다. 그들의 주요 업무는 시스템, 애플리케이션 로그, 필요시 데이터베이스를 조사하여 문제를 해결하는 것이었죠. 해결책을 찾지 못하거나 향상 시야를 가지고 있다면 해당 데이터로 개발자에게 접근하게 됐습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 환경에서 작업하면서 로그의 중요성을 점차 알게 되었습니다. 로그는 응용프로그램이나 거래의 이벤트를 추적하는 데 도움이 됩니다. 적절한 분석을 통해 패턴을 찾거나 이상 현상을 예측하는 데 도움이 됩니다.</p>
<p>하지만 분산 추적에 대해 아직 많이 알지 못했습니다. 다양한 식별자(전화번호, 사용자 ID 등)를 추가하여 운영팀이 고객 문제를 적절히 조사할 수 있도록 했습니다.</p>
<p>그러나 이 방법에도 문제가 있었습니다. 동일한 고객이 시스템과 다양한 상호 작용을 할 수 있어, 해당 식별자로 여러 로그 스트림이 생성되었습니다. 따라서 문제에 대한 정확한 로그를 찾는 것은 여전히 번거로웠습니다. 여러 애플리케이션이 관련될 때의 고통은 시작도 못 했죠. 서비스 호출 간 페이로드에 수동으로 UUID를 추가하고 로그를 남겼습니다.</p>
<p>결국에는 내 현재 접근 방식이 부족하다는 것이 명백해졌습니다. 내 일부 응용프로그램은 다른 팀이 유지보수하는 다른 애플리케이션 사이에서 미들웨어로 작용했습니다. 그들이 내 불편함을 용인해야 할 이유가 있을까요?</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그런 다음, Sleuth를 발견했어요. 정말 놀라웠죠; 단 하나의 의존성을 추가하고 로깅을 구성하기만 하면 어플리케이션 전체에 대한 추적을 활성화할 수 있었어요. 여러 개의 마이크로서비스를 사용하더라도 서비스 간 추적 ID를 전파하기 위한 추가적인 조치가 필요하지 않았어요.</p>
<p>Spring Boot 3 이전에는 프로젝트를 시작할 때마다 항상 Spring Cloud Sleuth를 포함해 분산 추적을 활성화했어요.</p>
<p>그런 다음 Spring Boot 3이 나오면서 Sleuth가 Micrometer로 이관되었어요. 이 기사에서는 Micrometer 추적을 활용해 Spring Boot 3에서 Sleuth와 유사한 기능을 어떻게 구현하는지 살펴볼 거예요.</p>
<p>지금은 컨트롤러와 서비스가 있는데, 일부 로그를 사용하고 있어요. 포스트맨으로 컨트롤러 엔드포인트에 요청을 보내면 다음과 같은 로그를 얻게 돼요:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-number">2024</span>-<span class="hljs-number">02</span>-23<span class="hljs-attr">T23</span>:<span class="hljs-number">28</span>:<span class="hljs-number">18.043</span>+<span class="hljs-number">06</span>:<span class="hljs-number">00</span>  <span class="hljs-variable constant_">INFO</span> <span class="hljs-number">14443</span> --- [rest-api] [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">2</span>] x.<span class="hljs-property">r</span>.<span class="hljs-property">t</span>.<span class="hljs-property">restapi</span>.<span class="hljs-property">web</span>.<span class="hljs-property">MessageController</span>   : <span class="hljs-title class_">Received</span> <span class="hljs-attr">message</span>: <span class="hljs-title class_">Message</span>(header=some header, content=some content)
<span class="hljs-number">2024</span>-<span class="hljs-number">02</span>-23<span class="hljs-attr">T23</span>:<span class="hljs-number">28</span>:<span class="hljs-number">18.046</span>+<span class="hljs-number">06</span>:<span class="hljs-number">00</span>  <span class="hljs-variable constant_">INFO</span> <span class="hljs-number">14443</span> --- [rest-api] [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">2</span>] x.<span class="hljs-property">r</span>.<span class="hljs-property">t</span>.<span class="hljs-property">r</span>.<span class="hljs-property">service</span>.<span class="hljs-property">MessageServiceImpl</span>    : <span class="hljs-title class_">Handling</span> message <span class="hljs-title class_">Message</span>(header=some header, content=some content)
</code></pre>
<p>추적이 없다는 것을 명확하게 알 수 있어요. 이제 다음 종속성을 추가할 거에요:</p>
<pre><code class="hljs language-js">&#x3C;dependency>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">groupId</span>></span>io.micrometer<span class="hljs-tag">&#x3C;/<span class="hljs-name">groupId</span>></span></span>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">artifactId</span>></span>micrometer-tracing-bridge-brave<span class="hljs-tag">&#x3C;/<span class="hljs-name">artifactId</span>></span></span>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">scope</span>></span>compile<span class="hljs-tag">&#x3C;/<span class="hljs-name">scope</span>></span></span>
&#x3C;/dependency>
</code></pre>
<p>동일한 엔드포인트를 한 번 더 호출해보세요. 그런데 여전히 운이 없거나 로그가 없어요!</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>인터넷 검색 결과를 통해 작업을 수행하기 위해 액추에터도 추가해야 한다는 것을 알아냈습니다.</p>
<pre><code class="hljs language-js">&#x3C;dependency>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">groupId</span>></span>org.springframework.boot<span class="hljs-tag">&#x3C;/<span class="hljs-name">groupId</span>></span></span>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">artifactId</span>></span>spring-boot-starter-actuator<span class="hljs-tag">&#x3C;/<span class="hljs-name">artifactId</span>></span></span>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">scope</span>></span>compile<span class="hljs-tag">&#x3C;/<span class="hljs-name">scope</span>></span></span>
&#x3C;/dependency>
</code></pre>
<p>동일한 엔드포인트를 다시 요청하면 다음과 같은 로그가 생성됩니다:</p>
<pre><code class="hljs language-js"><span class="hljs-number">2024</span>-<span class="hljs-number">02</span>-24<span class="hljs-attr">T00</span>:<span class="hljs-number">11</span>:<span class="hljs-number">06</span><span class="hljs-number">.050</span>+<span class="hljs-number">06</span>:<span class="hljs-number">00</span>  <span class="hljs-variable constant_">INFO</span> <span class="hljs-number">18463</span> --- [rest-api] [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">1</span>] [65d8dfb96a137925ba56091d26f33e80-ba56091d26f33e80] x.<span class="hljs-property">r</span>.<span class="hljs-property">t</span>.<span class="hljs-property">restapi</span>.<span class="hljs-property">web</span>.<span class="hljs-property">MessageController</span>   : <span class="hljs-title class_">Received</span> <span class="hljs-attr">message</span>: <span class="hljs-title class_">Message</span>(header=some header, content=some content)
<span class="hljs-number">2024</span>-<span class="hljs-number">02</span>-24<span class="hljs-attr">T00</span>:<span class="hljs-number">11</span>:<span class="hljs-number">06</span><span class="hljs-number">.053</span>+<span class="hljs-number">06</span>:<span class="hljs-number">00</span>  <span class="hljs-variable constant_">INFO</span> <span class="hljs-number">18463</span> --- [rest-api] [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">1</span>] [65d8dfb96a137925ba56091d26f33e80-ba56091d26f33e80] x.<span class="hljs-property">r</span>.<span class="hljs-property">t</span>.<span class="hljs-property">r</span>.<span class="hljs-property">service</span>.<span class="hljs-property">MessageServiceImpl</span>    : <span class="hljs-title class_">Handling</span> message <span class="hljs-title class_">Message</span>(header=some header, content=some content)
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>여기 보세요. [65d8dfb96a137925ba56091d26f33e80-ba56091d26f33e80] 이 부분에는 트레이스 ID와 스팬 ID가 포함되어 있습니다.</p>
<p>이제 다른 서비스를 호출할 수 있는지 확인해 봅시다. 그리고 트레이스 ID가 거기로 전달되는지도 확인해 봅니다.</p>
<p>저는 rest-api-2 라는 다른 서비스를 만들었습니다. 해당 서비스에는 필요한 컨트롤러, 서비스 및 필요한 종속성이 포함되어 있습니다.</p>
<p>이제 새롭고 화려한 rest-client를 사용하여 rest-api에서 rest-api-2로 HTTP 호출을 해보겠습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>rest-api에서 MessageServiceImpl을 수정한 내용은 다음과 같습니다:</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Service</span>
@<span class="hljs-title class_">Slf4</span>j
public <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageServiceImpl</span> implements <span class="hljs-title class_">MessageService</span> {

 private final <span class="hljs-title class_">RestClient</span> restClient;
 public <span class="hljs-title class_">MessageServiceImpl</span>(@<span class="hljs-title class_">Value</span>(<span class="hljs-string">"${rest-api-2.url}"</span>) <span class="hljs-title class_">String</span> restApi2Url) {
     <span class="hljs-variable language_">this</span>.<span class="hljs-property">restClient</span>  = <span class="hljs-title class_">RestClient</span>.<span class="hljs-title function_">builder</span>().<span class="hljs-title function_">baseUrl</span>(restApi2Url)
         .<span class="hljs-title function_">defaultHeader</span>(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-title class_">MediaType</span>.<span class="hljs-property">APPLICATION_JSON_VALUE</span>).<span class="hljs-title function_">build</span>();

 }

 @<span class="hljs-title class_">Override</span>
 public <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span>(<span class="hljs-params">Message message</span>) {
     log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"처리할 메시지: {}"</span>, message);
     <span class="hljs-variable language_">this</span>.<span class="hljs-property">restClient</span>.<span class="hljs-title function_">post</span>().<span class="hljs-title function_">uri</span>( <span class="hljs-string">"/process-message"</span>).<span class="hljs-title function_">body</span>(message).<span class="hljs-title function_">retrieve</span>();

 }

}
</code></pre>
<p>여기서 생성자에서 rest 클라이언트의 인스턴스를 선언했습니다. 그런 다음, 서비스에서 rest-api-2로 호출을 수행했습니다.</p>
<p>rest-api의 로그:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-number">2024</span>-<span class="hljs-number">02</span>-24<span class="hljs-attr">T14</span>:<span class="hljs-number">31</span>:<span class="hljs-number">13.060</span>+<span class="hljs-number">06</span>:<span class="hljs-number">00</span>  <span class="hljs-variable constant_">INFO</span> <span class="hljs-number">29880</span> --- [rest-api] [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">5</span>] [65d9a95114390c055da56f5c4e138be3-5da56f5c4e138be3] x.<span class="hljs-property">r</span>.<span class="hljs-property">t</span>.<span class="hljs-property">restapi</span>.<span class="hljs-property">web</span>.<span class="hljs-property">MessageController</span>   : <span class="hljs-title class_">Received</span> <span class="hljs-attr">message</span>: <span class="hljs-title class_">Message</span>(header=some header, content=some content)
<span class="hljs-number">2024</span>-<span class="hljs-number">02</span>-24<span class="hljs-attr">T14</span>:<span class="hljs-number">31</span>:<span class="hljs-number">13.061</span>+<span class="hljs-number">06</span>:<span class="hljs-number">00</span>  <span class="hljs-variable constant_">INFO</span> <span class="hljs-number">29880</span> --- [rest-api] [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">5</span>] [65d9a95114390c055da56f5c4e138be3-5da56f5c4e138be3] x.<span class="hljs-property">r</span>.<span class="hljs-property">t</span>.<span class="hljs-property">r</span>.<span class="hljs-property">service</span>.<span class="hljs-property">MessageServiceImpl</span>    : <span class="hljs-title class_">Handling</span> message <span class="hljs-title class_">Message</span>(header=some header, content=some content)
</code></pre>
<p>rest-api-2의 로그:</p>
<pre><code class="hljs language-js"><span class="hljs-number">2024</span>-<span class="hljs-number">02</span>-24<span class="hljs-attr">T14</span>:<span class="hljs-number">31</span>:<span class="hljs-number">13.072</span>+<span class="hljs-number">06</span>:<span class="hljs-number">00</span>  <span class="hljs-variable constant_">INFO</span> <span class="hljs-number">29563</span> --- [rest-api-<span class="hljs-number">2</span>] [nio-<span class="hljs-number">8081</span>-exec-<span class="hljs-number">7</span>] [65d9a9513ed86cb5ea2477e08166b9d2-ea2477e08166b9d2] x.<span class="hljs-property">r</span>.<span class="hljs-property">t</span>.<span class="hljs-property">r</span>.<span class="hljs-property">web</span>.<span class="hljs-property">MessageProcessorController</span>   : <span class="hljs-title class_">Received</span> message <span class="hljs-keyword">for</span> processing <span class="hljs-title class_">Message</span>(header=some header, content=some content)
<span class="hljs-number">2024</span>-<span class="hljs-number">02</span>-24<span class="hljs-attr">T14</span>:<span class="hljs-number">31</span>:<span class="hljs-number">13.072</span>+<span class="hljs-number">06</span>:<span class="hljs-number">00</span>  <span class="hljs-variable constant_">INFO</span> <span class="hljs-number">29563</span> --- [rest-api-<span class="hljs-number">2</span>] [nio-<span class="hljs-number">8081</span>-exec-<span class="hljs-number">7</span>] [65d9a9513ed86cb5ea2477e08166b9d2-ea2477e08166b9d2] x.<span class="hljs-property">r</span>.<span class="hljs-property">t</span>.<span class="hljs-property">r</span>.<span class="hljs-property">s</span>.<span class="hljs-property">MessageProcessorServiceImpl</span> : <span class="hljs-title class_">Processing</span> <span class="hljs-title class_">Message</span> <span class="hljs-title class_">Message</span>(header=some header, content=some content)
</code></pre>
<p>rest-api-2의 traceId와 spanId가 있는 것을 확인할 수 있어요. 하지만, 이들은 일치하지 않아요! 각 요청마다 새로운 추적 컨텍스트를 시작하고 있어요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이는 첫 번째 애플리케이션에서의 traceId가 두 번째 애플리케이션으로 전파되지 않는 것을 의미합니다.</p>
<p>이를 확인해 보겠습니다.</p>
<p>rest-api-2 애플리케이션을 중지하고, 해당 애플리케이션이 실행되던 포트를 듣기 시작한 것을 netcat이라는 도구로 확인했습니다:</p>
<p><img src="/assets/img/2024-06-23-TracinginSpringBoot3_1.png" alt="이미지"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 엔드포인트가 호출되면 다음과 같은 내용을 받습니다:</p>
<img src="/assets/img/2024-06-23-TracinginSpringBoot3_2.png">
<p>보시다시피, traceId를 포함한 일부 헤더가 있어야 하는데 없습니다. 요청에 추적 컨텍스트가 포함된 적절한 헤더가 있는지 확인해야 합니다.</p>
<p>이건 그렇게 어렵지 않아요. 우리는 스프링 부트가 자동으로 구성한 기본 restClient 빌더를 사용해야 합니다. 이것은 traceId를 전파하기 위한 필요한 지식을 갖고 있습니다. 다음과 같이 할 수 있어요:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">public <span class="hljs-title class_">MessageServiceImpl</span>(@<span class="hljs-title class_">Value</span>(<span class="hljs-string">"${rest-api-2.url}"</span>) <span class="hljs-title class_">String</span> restApi2Url, <span class="hljs-title class_">RestClient</span>.<span class="hljs-property">Builder</span> restClientBuilder) {
     <span class="hljs-variable language_">this</span>.<span class="hljs-property">restClient</span>  = restClientBuilder.<span class="hljs-title function_">baseUrl</span>(restApi2Url)
         .<span class="hljs-title function_">defaultHeader</span>(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-title class_">MediaType</span>.<span class="hljs-property">APPLICATION_JSON_VALUE</span>).<span class="hljs-title function_">build</span>();

 }
</code></pre>
<p>우리는 서비스의 생성자를 통해 기본 RestClient.Builder를 받았습니다. 코드의 나머지 부분은 간단합니다. 이제 요청을 초기화하면 다음과 같은 것을 볼 수 있습니다:</p>
<img src="/assets/img/2024-06-23-TracinginSpringBoot3_3.png">
<p>이제 우리에게 traceId를 포함한 traceparent라는 헤더가 있습니다. 이제 netcat을 중지하고 rest-api-2 애플리케이션을 시작하겠습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>첫 번째 애플리케이션 로그:</p>
<p><img src="/assets/img/2024-06-23-TracinginSpringBoot3_4.png" alt="2024-06-23-TracinginSpringBoot3_4.png"></p>
<p>두 번째 애플리케이션 로그:</p>
<p><img src="/assets/img/2024-06-23-TracinginSpringBoot3_5.png" alt="2024-06-23-TracinginSpringBoot3_5.png"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그리고 빙고!</p>
<p>두 애플리케이션 간에 트레이스 ID가 일치하는 것을 볼 수 있습니다. 단, spanId는 일치하지 않지만, 이는 예상한 바입니다.</p>
<p>서비스를 리팩토링할 수 있는 좋은 시기라고 생각합니다. 여기서 rest-client를 선언하는 대신, 구성 클래스에서 재사용 가능한 빈으로 선언할 것입니다.</p>
<p>Rest client 구성 클래스는 다음과 같습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RestClientConfig</span> {
 <span class="hljs-meta">@Bean("restApi2Client")</span>
 RestClient <span class="hljs-title function_">restApi2Client</span><span class="hljs-params">(<span class="hljs-meta">@Value("${rest-api-2.url}")</span> String restApi2Url, RestClient.Builder restClientBuilder)</span> {
     <span class="hljs-keyword">return</span> restClientBuilder.baseUrl(restApi2Url)
         .defaultHeader(<span class="hljs-string">"Content-Type"</span>, MediaType.APPLICATION_JSON_VALUE).build();
 }

}
</code></pre>
<p>And refactored MessageServiceImpl class:</p>
<pre><code class="hljs language-java"><span class="hljs-meta">@Service</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MessageService</span> {

 <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RestClient restClient;

 <span class="hljs-keyword">public</span> <span class="hljs-title function_">MessageServiceImpl</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier("restApi2Client")</span> RestClient restClient)</span> {
     <span class="hljs-built_in">this</span>.restClient = restClient;
 }


 <span class="hljs-meta">@Override</span>
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message message)</span> {
     log.info(<span class="hljs-string">"Handling message {}"</span>, message);
     <span class="hljs-built_in">this</span>.restClient.post().uri( <span class="hljs-string">"/process-message"</span>).body(message).retrieve();

 }

}
</code></pre>
<p>Cleaner right ?</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이것은 단순한 데모입니다. Micrometer를 활용하여 다른 관측 가능성 사용 사례에 대해 더 많이 쓸 예정이에요.</p>
<p>여기 모든 코드가 있는 레포입니다.</p>
<p>즐거운 코딩하세요!</p>
<p><img src="https://miro.medium.com/v2/resize:fit:960/1*5D9ZTssrYkDI-7hN0fAVkw.gif" alt="이미지"></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Spring Boot3에서 트레이싱 활용하는 방법","description":"","date":"2024-06-23 20:31","slug":"2024-06-23-TracinginSpringBoot3","content":"\n![2024-06-23-TracinginSpringBoot3_0](/assets/img/2024-06-23-TracinginSpringBoot3_0.png)\n\n제 초창기 전문가 시절을 돌이켜보면, 프로덕션 문제 해결 방식에서 조금 놀라운 점이 있었습니다. 모든 것을 다 다루는 프로젝트에서 일했는데, 고객과의 인터페이싱부터 코딩, 배포, 그리고 문제 해결까지 모든 것을 처리했죠. 문제가 발생하면 명쾌한 해결책이 없는 상황이었고, 그때의 나는 프로덕션 데이터베이스 덤프를 떠서 해당 데이터베이스를 이용해 내 컴퓨터에서 애플리케이션을 실행한 다음 고객과 통화하면서 그들이 하는 작업을 재현하고 문제점을 확인하기 위해 필요한 디버그 지점 및 출력문을 사용했어요. 그 방식은 그 당시에는 효과적이었습니다. 애플리케이션은 작고 사용자 베이스가 제한적이었으며, 단일 개발자로는 완전히 관리할 수 있었지만, 그때는 여전히 로깅의 중요성을 이해하지 못했죠.\n\n몇 년 후, 이제는 여러 개발자, 제품 소유자, 스크럼 마스터, 운영팀, 인프라팀, 그리고 물론 수백만 명의 사용자가 참여하는 프로젝트에서 일하고 있습니다. 중요한 점은 개발자에게는 프로덕션 환경이 대부분 접근 불가능하며, 또한 고객이 개발자와 직접 커뮤니케이션할 수 없으므로 우리를 미치게 만든다는 사실입니다.\n\n운영팀은 이 두 영역 사이의 다리 역할을 했습니다. 그들의 주요 업무는 시스템, 애플리케이션 로그, 필요시 데이터베이스를 조사하여 문제를 해결하는 것이었죠. 해결책을 찾지 못하거나 향상 시야를 가지고 있다면 해당 데이터로 개발자에게 접근하게 됐습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 환경에서 작업하면서 로그의 중요성을 점차 알게 되었습니다. 로그는 응용프로그램이나 거래의 이벤트를 추적하는 데 도움이 됩니다. 적절한 분석을 통해 패턴을 찾거나 이상 현상을 예측하는 데 도움이 됩니다.\n\n하지만 분산 추적에 대해 아직 많이 알지 못했습니다. 다양한 식별자(전화번호, 사용자 ID 등)를 추가하여 운영팀이 고객 문제를 적절히 조사할 수 있도록 했습니다.\n\n그러나 이 방법에도 문제가 있었습니다. 동일한 고객이 시스템과 다양한 상호 작용을 할 수 있어, 해당 식별자로 여러 로그 스트림이 생성되었습니다. 따라서 문제에 대한 정확한 로그를 찾는 것은 여전히 번거로웠습니다. 여러 애플리케이션이 관련될 때의 고통은 시작도 못 했죠. 서비스 호출 간 페이로드에 수동으로 UUID를 추가하고 로그를 남겼습니다.\n\n결국에는 내 현재 접근 방식이 부족하다는 것이 명백해졌습니다. 내 일부 응용프로그램은 다른 팀이 유지보수하는 다른 애플리케이션 사이에서 미들웨어로 작용했습니다. 그들이 내 불편함을 용인해야 할 이유가 있을까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그런 다음, Sleuth를 발견했어요. 정말 놀라웠죠; 단 하나의 의존성을 추가하고 로깅을 구성하기만 하면 어플리케이션 전체에 대한 추적을 활성화할 수 있었어요. 여러 개의 마이크로서비스를 사용하더라도 서비스 간 추적 ID를 전파하기 위한 추가적인 조치가 필요하지 않았어요.\n\nSpring Boot 3 이전에는 프로젝트를 시작할 때마다 항상 Spring Cloud Sleuth를 포함해 분산 추적을 활성화했어요.\n\n그런 다음 Spring Boot 3이 나오면서 Sleuth가 Micrometer로 이관되었어요. 이 기사에서는 Micrometer 추적을 활용해 Spring Boot 3에서 Sleuth와 유사한 기능을 어떻게 구현하는지 살펴볼 거예요.\n\n지금은 컨트롤러와 서비스가 있는데, 일부 로그를 사용하고 있어요. 포스트맨으로 컨트롤러 엔드포인트에 요청을 보내면 다음과 같은 로그를 얻게 돼요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n2024-02-23T23:28:18.043+06:00  INFO 14443 --- [rest-api] [nio-8080-exec-2] x.r.t.restapi.web.MessageController   : Received message: Message(header=some header, content=some content)\n2024-02-23T23:28:18.046+06:00  INFO 14443 --- [rest-api] [nio-8080-exec-2] x.r.t.r.service.MessageServiceImpl    : Handling message Message(header=some header, content=some content)\n```\n\n추적이 없다는 것을 명확하게 알 수 있어요. 이제 다음 종속성을 추가할 거에요:\n\n```js\n\u003cdependency\u003e\n  \u003cgroupId\u003eio.micrometer\u003c/groupId\u003e\n  \u003cartifactId\u003emicrometer-tracing-bridge-brave\u003c/artifactId\u003e\n  \u003cscope\u003ecompile\u003c/scope\u003e\n\u003c/dependency\u003e\n```\n\n동일한 엔드포인트를 한 번 더 호출해보세요. 그런데 여전히 운이 없거나 로그가 없어요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인터넷 검색 결과를 통해 작업을 수행하기 위해 액추에터도 추가해야 한다는 것을 알아냈습니다.\n\n```js\n\u003cdependency\u003e\n  \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\n  \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e\n  \u003cscope\u003ecompile\u003c/scope\u003e\n\u003c/dependency\u003e\n```\n\n동일한 엔드포인트를 다시 요청하면 다음과 같은 로그가 생성됩니다:\n\n```js\n2024-02-24T00:11:06.050+06:00  INFO 18463 --- [rest-api] [nio-8080-exec-1] [65d8dfb96a137925ba56091d26f33e80-ba56091d26f33e80] x.r.t.restapi.web.MessageController   : Received message: Message(header=some header, content=some content)\n2024-02-24T00:11:06.053+06:00  INFO 18463 --- [rest-api] [nio-8080-exec-1] [65d8dfb96a137925ba56091d26f33e80-ba56091d26f33e80] x.r.t.r.service.MessageServiceImpl    : Handling message Message(header=some header, content=some content)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 보세요. [65d8dfb96a137925ba56091d26f33e80-ba56091d26f33e80] 이 부분에는 트레이스 ID와 스팬 ID가 포함되어 있습니다.\n\n이제 다른 서비스를 호출할 수 있는지 확인해 봅시다. 그리고 트레이스 ID가 거기로 전달되는지도 확인해 봅니다.\n\n저는 rest-api-2 라는 다른 서비스를 만들었습니다. 해당 서비스에는 필요한 컨트롤러, 서비스 및 필요한 종속성이 포함되어 있습니다.\n\n이제 새롭고 화려한 rest-client를 사용하여 rest-api에서 rest-api-2로 HTTP 호출을 해보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nrest-api에서 MessageServiceImpl을 수정한 내용은 다음과 같습니다:\n\n```js\n@Service\n@Slf4j\npublic class MessageServiceImpl implements MessageService {\n\n private final RestClient restClient;\n public MessageServiceImpl(@Value(\"${rest-api-2.url}\") String restApi2Url) {\n     this.restClient  = RestClient.builder().baseUrl(restApi2Url)\n         .defaultHeader(\"Content-Type\", MediaType.APPLICATION_JSON_VALUE).build();\n\n }\n\n @Override\n public void handleMessage(Message message) {\n     log.info(\"처리할 메시지: {}\", message);\n     this.restClient.post().uri( \"/process-message\").body(message).retrieve();\n\n }\n\n}\n```\n\n여기서 생성자에서 rest 클라이언트의 인스턴스를 선언했습니다. 그런 다음, 서비스에서 rest-api-2로 호출을 수행했습니다.\n\nrest-api의 로그:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n2024-02-24T14:31:13.060+06:00  INFO 29880 --- [rest-api] [nio-8080-exec-5] [65d9a95114390c055da56f5c4e138be3-5da56f5c4e138be3] x.r.t.restapi.web.MessageController   : Received message: Message(header=some header, content=some content)\n2024-02-24T14:31:13.061+06:00  INFO 29880 --- [rest-api] [nio-8080-exec-5] [65d9a95114390c055da56f5c4e138be3-5da56f5c4e138be3] x.r.t.r.service.MessageServiceImpl    : Handling message Message(header=some header, content=some content)\n```\n\nrest-api-2의 로그:\n\n```js\n2024-02-24T14:31:13.072+06:00  INFO 29563 --- [rest-api-2] [nio-8081-exec-7] [65d9a9513ed86cb5ea2477e08166b9d2-ea2477e08166b9d2] x.r.t.r.web.MessageProcessorController   : Received message for processing Message(header=some header, content=some content)\n2024-02-24T14:31:13.072+06:00  INFO 29563 --- [rest-api-2] [nio-8081-exec-7] [65d9a9513ed86cb5ea2477e08166b9d2-ea2477e08166b9d2] x.r.t.r.s.MessageProcessorServiceImpl : Processing Message Message(header=some header, content=some content)\n```\n\nrest-api-2의 traceId와 spanId가 있는 것을 확인할 수 있어요. 하지만, 이들은 일치하지 않아요! 각 요청마다 새로운 추적 컨텍스트를 시작하고 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이는 첫 번째 애플리케이션에서의 traceId가 두 번째 애플리케이션으로 전파되지 않는 것을 의미합니다.\n\n이를 확인해 보겠습니다.\n\nrest-api-2 애플리케이션을 중지하고, 해당 애플리케이션이 실행되던 포트를 듣기 시작한 것을 netcat이라는 도구로 확인했습니다:\n\n![이미지](/assets/img/2024-06-23-TracinginSpringBoot3_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 엔드포인트가 호출되면 다음과 같은 내용을 받습니다:\n\n\u003cimg src=\"/assets/img/2024-06-23-TracinginSpringBoot3_2.png\" /\u003e\n\n보시다시피, traceId를 포함한 일부 헤더가 있어야 하는데 없습니다. 요청에 추적 컨텍스트가 포함된 적절한 헤더가 있는지 확인해야 합니다.\n\n이건 그렇게 어렵지 않아요. 우리는 스프링 부트가 자동으로 구성한 기본 restClient 빌더를 사용해야 합니다. 이것은 traceId를 전파하기 위한 필요한 지식을 갖고 있습니다. 다음과 같이 할 수 있어요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npublic MessageServiceImpl(@Value(\"${rest-api-2.url}\") String restApi2Url, RestClient.Builder restClientBuilder) {\n     this.restClient  = restClientBuilder.baseUrl(restApi2Url)\n         .defaultHeader(\"Content-Type\", MediaType.APPLICATION_JSON_VALUE).build();\n\n }\n```\n\n우리는 서비스의 생성자를 통해 기본 RestClient.Builder를 받았습니다. 코드의 나머지 부분은 간단합니다. 이제 요청을 초기화하면 다음과 같은 것을 볼 수 있습니다:\n\n\u003cimg src=\"/assets/img/2024-06-23-TracinginSpringBoot3_3.png\" /\u003e\n\n이제 우리에게 traceId를 포함한 traceparent라는 헤더가 있습니다. 이제 netcat을 중지하고 rest-api-2 애플리케이션을 시작하겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 애플리케이션 로그:\n\n![2024-06-23-TracinginSpringBoot3_4.png](/assets/img/2024-06-23-TracinginSpringBoot3_4.png)\n\n두 번째 애플리케이션 로그:\n\n![2024-06-23-TracinginSpringBoot3_5.png](/assets/img/2024-06-23-TracinginSpringBoot3_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그리고 빙고!\n\n두 애플리케이션 간에 트레이스 ID가 일치하는 것을 볼 수 있습니다. 단, spanId는 일치하지 않지만, 이는 예상한 바입니다.\n\n서비스를 리팩토링할 수 있는 좋은 시기라고 생각합니다. 여기서 rest-client를 선언하는 대신, 구성 클래스에서 재사용 가능한 빈으로 선언할 것입니다.\n\nRest client 구성 클래스는 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\n@Configuration\npublic class RestClientConfig {\n @Bean(\"restApi2Client\")\n RestClient restApi2Client(@Value(\"${rest-api-2.url}\") String restApi2Url, RestClient.Builder restClientBuilder) {\n     return restClientBuilder.baseUrl(restApi2Url)\n         .defaultHeader(\"Content-Type\", MediaType.APPLICATION_JSON_VALUE).build();\n }\n\n}\n```\n\nAnd refactored MessageServiceImpl class:\n\n```java\n@Service\n@Slf4j\npublic class MessageServiceImpl implements MessageService {\n\n private final RestClient restClient;\n\n public MessageServiceImpl(@Qualifier(\"restApi2Client\") RestClient restClient) {\n     this.restClient = restClient;\n }\n\n\n @Override\n public void handleMessage(Message message) {\n     log.info(\"Handling message {}\", message);\n     this.restClient.post().uri( \"/process-message\").body(message).retrieve();\n\n }\n\n}\n```\n\nCleaner right ?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 단순한 데모입니다. Micrometer를 활용하여 다른 관측 가능성 사용 사례에 대해 더 많이 쓸 예정이에요.\n\n여기 모든 코드가 있는 레포입니다.\n\n즐거운 코딩하세요!\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*5D9ZTssrYkDI-7hN0fAVkw.gif)\n","ogImage":{"url":"/assets/img/2024-06-23-TracinginSpringBoot3_0.png"},"coverImage":"/assets/img/2024-06-23-TracinginSpringBoot3_0.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-TracinginSpringBoot3_0.png\" alt=\"2024-06-23-TracinginSpringBoot3_0\"\u003e\u003c/p\u003e\n\u003cp\u003e제 초창기 전문가 시절을 돌이켜보면, 프로덕션 문제 해결 방식에서 조금 놀라운 점이 있었습니다. 모든 것을 다 다루는 프로젝트에서 일했는데, 고객과의 인터페이싱부터 코딩, 배포, 그리고 문제 해결까지 모든 것을 처리했죠. 문제가 발생하면 명쾌한 해결책이 없는 상황이었고, 그때의 나는 프로덕션 데이터베이스 덤프를 떠서 해당 데이터베이스를 이용해 내 컴퓨터에서 애플리케이션을 실행한 다음 고객과 통화하면서 그들이 하는 작업을 재현하고 문제점을 확인하기 위해 필요한 디버그 지점 및 출력문을 사용했어요. 그 방식은 그 당시에는 효과적이었습니다. 애플리케이션은 작고 사용자 베이스가 제한적이었으며, 단일 개발자로는 완전히 관리할 수 있었지만, 그때는 여전히 로깅의 중요성을 이해하지 못했죠.\u003c/p\u003e\n\u003cp\u003e몇 년 후, 이제는 여러 개발자, 제품 소유자, 스크럼 마스터, 운영팀, 인프라팀, 그리고 물론 수백만 명의 사용자가 참여하는 프로젝트에서 일하고 있습니다. 중요한 점은 개발자에게는 프로덕션 환경이 대부분 접근 불가능하며, 또한 고객이 개발자와 직접 커뮤니케이션할 수 없으므로 우리를 미치게 만든다는 사실입니다.\u003c/p\u003e\n\u003cp\u003e운영팀은 이 두 영역 사이의 다리 역할을 했습니다. 그들의 주요 업무는 시스템, 애플리케이션 로그, 필요시 데이터베이스를 조사하여 문제를 해결하는 것이었죠. 해결책을 찾지 못하거나 향상 시야를 가지고 있다면 해당 데이터로 개발자에게 접근하게 됐습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 환경에서 작업하면서 로그의 중요성을 점차 알게 되었습니다. 로그는 응용프로그램이나 거래의 이벤트를 추적하는 데 도움이 됩니다. 적절한 분석을 통해 패턴을 찾거나 이상 현상을 예측하는 데 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e하지만 분산 추적에 대해 아직 많이 알지 못했습니다. 다양한 식별자(전화번호, 사용자 ID 등)를 추가하여 운영팀이 고객 문제를 적절히 조사할 수 있도록 했습니다.\u003c/p\u003e\n\u003cp\u003e그러나 이 방법에도 문제가 있었습니다. 동일한 고객이 시스템과 다양한 상호 작용을 할 수 있어, 해당 식별자로 여러 로그 스트림이 생성되었습니다. 따라서 문제에 대한 정확한 로그를 찾는 것은 여전히 번거로웠습니다. 여러 애플리케이션이 관련될 때의 고통은 시작도 못 했죠. 서비스 호출 간 페이로드에 수동으로 UUID를 추가하고 로그를 남겼습니다.\u003c/p\u003e\n\u003cp\u003e결국에는 내 현재 접근 방식이 부족하다는 것이 명백해졌습니다. 내 일부 응용프로그램은 다른 팀이 유지보수하는 다른 애플리케이션 사이에서 미들웨어로 작용했습니다. 그들이 내 불편함을 용인해야 할 이유가 있을까요?\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그런 다음, Sleuth를 발견했어요. 정말 놀라웠죠; 단 하나의 의존성을 추가하고 로깅을 구성하기만 하면 어플리케이션 전체에 대한 추적을 활성화할 수 있었어요. 여러 개의 마이크로서비스를 사용하더라도 서비스 간 추적 ID를 전파하기 위한 추가적인 조치가 필요하지 않았어요.\u003c/p\u003e\n\u003cp\u003eSpring Boot 3 이전에는 프로젝트를 시작할 때마다 항상 Spring Cloud Sleuth를 포함해 분산 추적을 활성화했어요.\u003c/p\u003e\n\u003cp\u003e그런 다음 Spring Boot 3이 나오면서 Sleuth가 Micrometer로 이관되었어요. 이 기사에서는 Micrometer 추적을 활용해 Spring Boot 3에서 Sleuth와 유사한 기능을 어떻게 구현하는지 살펴볼 거예요.\u003c/p\u003e\n\u003cp\u003e지금은 컨트롤러와 서비스가 있는데, 일부 로그를 사용하고 있어요. 포스트맨으로 컨트롤러 엔드포인트에 요청을 보내면 다음과 같은 로그를 얻게 돼요:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e02\u003c/span\u003e-23\u003cspan class=\"hljs-attr\"\u003eT23\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e28\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e18.043\u003c/span\u003e+\u003cspan class=\"hljs-number\"\u003e06\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e  \u003cspan class=\"hljs-variable constant_\"\u003eINFO\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e14443\u003c/span\u003e --- [rest-api] [nio-\u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e-exec-\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e] x.\u003cspan class=\"hljs-property\"\u003er\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003erestapi\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eweb\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eMessageController\u003c/span\u003e   : \u003cspan class=\"hljs-title class_\"\u003eReceived\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMessage\u003c/span\u003e(header=some header, content=some content)\n\u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e02\u003c/span\u003e-23\u003cspan class=\"hljs-attr\"\u003eT23\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e28\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e18.046\u003c/span\u003e+\u003cspan class=\"hljs-number\"\u003e06\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e  \u003cspan class=\"hljs-variable constant_\"\u003eINFO\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e14443\u003c/span\u003e --- [rest-api] [nio-\u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e-exec-\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e] x.\u003cspan class=\"hljs-property\"\u003er\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003er\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eservice\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eMessageServiceImpl\u003c/span\u003e    : \u003cspan class=\"hljs-title class_\"\u003eHandling\u003c/span\u003e message \u003cspan class=\"hljs-title class_\"\u003eMessage\u003c/span\u003e(header=some header, content=some content)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e추적이 없다는 것을 명확하게 알 수 있어요. 이제 다음 종속성을 추가할 거에요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;dependency\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u003e\u003c/span\u003eio.micrometer\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u003e\u003c/span\u003emicrometer-tracing-bridge-brave\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escope\u003c/span\u003e\u003e\u003c/span\u003ecompile\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escope\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/dependency\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e동일한 엔드포인트를 한 번 더 호출해보세요. 그런데 여전히 운이 없거나 로그가 없어요!\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e인터넷 검색 결과를 통해 작업을 수행하기 위해 액추에터도 추가해야 한다는 것을 알아냈습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;dependency\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u003e\u003c/span\u003eorg.springframework.boot\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003egroupId\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u003e\u003c/span\u003espring-boot-starter-actuator\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eartifactId\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escope\u003c/span\u003e\u003e\u003c/span\u003ecompile\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escope\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/dependency\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e동일한 엔드포인트를 다시 요청하면 다음과 같은 로그가 생성됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e02\u003c/span\u003e-24\u003cspan class=\"hljs-attr\"\u003eT00\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e06\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.050\u003c/span\u003e+\u003cspan class=\"hljs-number\"\u003e06\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e  \u003cspan class=\"hljs-variable constant_\"\u003eINFO\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e18463\u003c/span\u003e --- [rest-api] [nio-\u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e-exec-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] [65d8dfb96a137925ba56091d26f33e80-ba56091d26f33e80] x.\u003cspan class=\"hljs-property\"\u003er\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003erestapi\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eweb\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eMessageController\u003c/span\u003e   : \u003cspan class=\"hljs-title class_\"\u003eReceived\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMessage\u003c/span\u003e(header=some header, content=some content)\n\u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e02\u003c/span\u003e-24\u003cspan class=\"hljs-attr\"\u003eT00\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e06\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.053\u003c/span\u003e+\u003cspan class=\"hljs-number\"\u003e06\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e  \u003cspan class=\"hljs-variable constant_\"\u003eINFO\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e18463\u003c/span\u003e --- [rest-api] [nio-\u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e-exec-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] [65d8dfb96a137925ba56091d26f33e80-ba56091d26f33e80] x.\u003cspan class=\"hljs-property\"\u003er\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003er\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eservice\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eMessageServiceImpl\u003c/span\u003e    : \u003cspan class=\"hljs-title class_\"\u003eHandling\u003c/span\u003e message \u003cspan class=\"hljs-title class_\"\u003eMessage\u003c/span\u003e(header=some header, content=some content)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e여기 보세요. [65d8dfb96a137925ba56091d26f33e80-ba56091d26f33e80] 이 부분에는 트레이스 ID와 스팬 ID가 포함되어 있습니다.\u003c/p\u003e\n\u003cp\u003e이제 다른 서비스를 호출할 수 있는지 확인해 봅시다. 그리고 트레이스 ID가 거기로 전달되는지도 확인해 봅니다.\u003c/p\u003e\n\u003cp\u003e저는 rest-api-2 라는 다른 서비스를 만들었습니다. 해당 서비스에는 필요한 컨트롤러, 서비스 및 필요한 종속성이 포함되어 있습니다.\u003c/p\u003e\n\u003cp\u003e이제 새롭고 화려한 rest-client를 사용하여 rest-api에서 rest-api-2로 HTTP 호출을 해보겠습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003erest-api에서 MessageServiceImpl을 수정한 내용은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eService\u003c/span\u003e\n@\u003cspan class=\"hljs-title class_\"\u003eSlf4\u003c/span\u003ej\npublic \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMessageServiceImpl\u003c/span\u003e implements \u003cspan class=\"hljs-title class_\"\u003eMessageService\u003c/span\u003e {\n\n private final \u003cspan class=\"hljs-title class_\"\u003eRestClient\u003c/span\u003e restClient;\n public \u003cspan class=\"hljs-title class_\"\u003eMessageServiceImpl\u003c/span\u003e(@\u003cspan class=\"hljs-title class_\"\u003eValue\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"${rest-api-2.url}\"\u003c/span\u003e) \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e restApi2Url) {\n     \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003erestClient\u003c/span\u003e  = \u003cspan class=\"hljs-title class_\"\u003eRestClient\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ebuilder\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ebaseUrl\u003c/span\u003e(restApi2Url)\n         .\u003cspan class=\"hljs-title function_\"\u003edefaultHeader\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Content-Type\"\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eMediaType\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eAPPLICATION_JSON_VALUE\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e();\n\n }\n\n @\u003cspan class=\"hljs-title class_\"\u003eOverride\u003c/span\u003e\n public \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleMessage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eMessage message\u003c/span\u003e) {\n     log.\u003cspan class=\"hljs-title function_\"\u003einfo\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"처리할 메시지: {}\"\u003c/span\u003e, message);\n     \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003erestClient\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003euri\u003c/span\u003e( \u003cspan class=\"hljs-string\"\u003e\"/process-message\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ebody\u003c/span\u003e(message).\u003cspan class=\"hljs-title function_\"\u003eretrieve\u003c/span\u003e();\n\n }\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 생성자에서 rest 클라이언트의 인스턴스를 선언했습니다. 그런 다음, 서비스에서 rest-api-2로 호출을 수행했습니다.\u003c/p\u003e\n\u003cp\u003erest-api의 로그:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e02\u003c/span\u003e-24\u003cspan class=\"hljs-attr\"\u003eT14\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e31\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e13.060\u003c/span\u003e+\u003cspan class=\"hljs-number\"\u003e06\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e  \u003cspan class=\"hljs-variable constant_\"\u003eINFO\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e29880\u003c/span\u003e --- [rest-api] [nio-\u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e-exec-\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e] [65d9a95114390c055da56f5c4e138be3-5da56f5c4e138be3] x.\u003cspan class=\"hljs-property\"\u003er\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003erestapi\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eweb\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eMessageController\u003c/span\u003e   : \u003cspan class=\"hljs-title class_\"\u003eReceived\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMessage\u003c/span\u003e(header=some header, content=some content)\n\u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e02\u003c/span\u003e-24\u003cspan class=\"hljs-attr\"\u003eT14\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e31\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e13.061\u003c/span\u003e+\u003cspan class=\"hljs-number\"\u003e06\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e  \u003cspan class=\"hljs-variable constant_\"\u003eINFO\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e29880\u003c/span\u003e --- [rest-api] [nio-\u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e-exec-\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e] [65d9a95114390c055da56f5c4e138be3-5da56f5c4e138be3] x.\u003cspan class=\"hljs-property\"\u003er\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003er\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eservice\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eMessageServiceImpl\u003c/span\u003e    : \u003cspan class=\"hljs-title class_\"\u003eHandling\u003c/span\u003e message \u003cspan class=\"hljs-title class_\"\u003eMessage\u003c/span\u003e(header=some header, content=some content)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003erest-api-2의 로그:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e02\u003c/span\u003e-24\u003cspan class=\"hljs-attr\"\u003eT14\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e31\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e13.072\u003c/span\u003e+\u003cspan class=\"hljs-number\"\u003e06\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e  \u003cspan class=\"hljs-variable constant_\"\u003eINFO\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e29563\u003c/span\u003e --- [rest-api-\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e] [nio-\u003cspan class=\"hljs-number\"\u003e8081\u003c/span\u003e-exec-\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e] [65d9a9513ed86cb5ea2477e08166b9d2-ea2477e08166b9d2] x.\u003cspan class=\"hljs-property\"\u003er\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003er\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eweb\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eMessageProcessorController\u003c/span\u003e   : \u003cspan class=\"hljs-title class_\"\u003eReceived\u003c/span\u003e message \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e processing \u003cspan class=\"hljs-title class_\"\u003eMessage\u003c/span\u003e(header=some header, content=some content)\n\u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e02\u003c/span\u003e-24\u003cspan class=\"hljs-attr\"\u003eT14\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e31\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e13.072\u003c/span\u003e+\u003cspan class=\"hljs-number\"\u003e06\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e  \u003cspan class=\"hljs-variable constant_\"\u003eINFO\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e29563\u003c/span\u003e --- [rest-api-\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e] [nio-\u003cspan class=\"hljs-number\"\u003e8081\u003c/span\u003e-exec-\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e] [65d9a9513ed86cb5ea2477e08166b9d2-ea2477e08166b9d2] x.\u003cspan class=\"hljs-property\"\u003er\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003et\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003er\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003es\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eMessageProcessorServiceImpl\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eProcessing\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMessage\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMessage\u003c/span\u003e(header=some header, content=some content)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003erest-api-2의 traceId와 spanId가 있는 것을 확인할 수 있어요. 하지만, 이들은 일치하지 않아요! 각 요청마다 새로운 추적 컨텍스트를 시작하고 있어요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이는 첫 번째 애플리케이션에서의 traceId가 두 번째 애플리케이션으로 전파되지 않는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e이를 확인해 보겠습니다.\u003c/p\u003e\n\u003cp\u003erest-api-2 애플리케이션을 중지하고, 해당 애플리케이션이 실행되던 포트를 듣기 시작한 것을 netcat이라는 도구로 확인했습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-TracinginSpringBoot3_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 엔드포인트가 호출되면 다음과 같은 내용을 받습니다:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-23-TracinginSpringBoot3_2.png\"\u003e\n\u003cp\u003e보시다시피, traceId를 포함한 일부 헤더가 있어야 하는데 없습니다. 요청에 추적 컨텍스트가 포함된 적절한 헤더가 있는지 확인해야 합니다.\u003c/p\u003e\n\u003cp\u003e이건 그렇게 어렵지 않아요. 우리는 스프링 부트가 자동으로 구성한 기본 restClient 빌더를 사용해야 합니다. 이것은 traceId를 전파하기 위한 필요한 지식을 갖고 있습니다. 다음과 같이 할 수 있어요:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epublic \u003cspan class=\"hljs-title class_\"\u003eMessageServiceImpl\u003c/span\u003e(@\u003cspan class=\"hljs-title class_\"\u003eValue\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"${rest-api-2.url}\"\u003c/span\u003e) \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e restApi2Url, \u003cspan class=\"hljs-title class_\"\u003eRestClient\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eBuilder\u003c/span\u003e restClientBuilder) {\n     \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003erestClient\u003c/span\u003e  = restClientBuilder.\u003cspan class=\"hljs-title function_\"\u003ebaseUrl\u003c/span\u003e(restApi2Url)\n         .\u003cspan class=\"hljs-title function_\"\u003edefaultHeader\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Content-Type\"\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eMediaType\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eAPPLICATION_JSON_VALUE\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e();\n\n }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 서비스의 생성자를 통해 기본 RestClient.Builder를 받았습니다. 코드의 나머지 부분은 간단합니다. 이제 요청을 초기화하면 다음과 같은 것을 볼 수 있습니다:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-23-TracinginSpringBoot3_3.png\"\u003e\n\u003cp\u003e이제 우리에게 traceId를 포함한 traceparent라는 헤더가 있습니다. 이제 netcat을 중지하고 rest-api-2 애플리케이션을 시작하겠습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e첫 번째 애플리케이션 로그:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-TracinginSpringBoot3_4.png\" alt=\"2024-06-23-TracinginSpringBoot3_4.png\"\u003e\u003c/p\u003e\n\u003cp\u003e두 번째 애플리케이션 로그:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-TracinginSpringBoot3_5.png\" alt=\"2024-06-23-TracinginSpringBoot3_5.png\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그리고 빙고!\u003c/p\u003e\n\u003cp\u003e두 애플리케이션 간에 트레이스 ID가 일치하는 것을 볼 수 있습니다. 단, spanId는 일치하지 않지만, 이는 예상한 바입니다.\u003c/p\u003e\n\u003cp\u003e서비스를 리팩토링할 수 있는 좋은 시기라고 생각합니다. 여기서 rest-client를 선언하는 대신, 구성 클래스에서 재사용 가능한 빈으로 선언할 것입니다.\u003c/p\u003e\n\u003cp\u003eRest client 구성 클래스는 다음과 같습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Configuration\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRestClientConfig\u003c/span\u003e {\n \u003cspan class=\"hljs-meta\"\u003e@Bean(\"restApi2Client\")\u003c/span\u003e\n RestClient \u003cspan class=\"hljs-title function_\"\u003erestApi2Client\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-meta\"\u003e@Value(\"${rest-api-2.url}\")\u003c/span\u003e String restApi2Url, RestClient.Builder restClientBuilder)\u003c/span\u003e {\n     \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e restClientBuilder.baseUrl(restApi2Url)\n         .defaultHeader(\u003cspan class=\"hljs-string\"\u003e\"Content-Type\"\u003c/span\u003e, MediaType.APPLICATION_JSON_VALUE).build();\n }\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd refactored MessageServiceImpl class:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Service\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@Slf4j\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMessageServiceImpl\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimplements\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMessageService\u003c/span\u003e {\n\n \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e RestClient restClient;\n\n \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMessageServiceImpl\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-meta\"\u003e@Qualifier(\"restApi2Client\")\u003c/span\u003e RestClient restClient)\u003c/span\u003e {\n     \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.restClient = restClient;\n }\n\n\n \u003cspan class=\"hljs-meta\"\u003e@Override\u003c/span\u003e\n \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleMessage\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(Message message)\u003c/span\u003e {\n     log.info(\u003cspan class=\"hljs-string\"\u003e\"Handling message {}\"\u003c/span\u003e, message);\n     \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.restClient.post().uri( \u003cspan class=\"hljs-string\"\u003e\"/process-message\"\u003c/span\u003e).body(message).retrieve();\n\n }\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCleaner right ?\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이것은 단순한 데모입니다. Micrometer를 활용하여 다른 관측 가능성 사용 사례에 대해 더 많이 쓸 예정이에요.\u003c/p\u003e\n\u003cp\u003e여기 모든 코드가 있는 레포입니다.\u003c/p\u003e\n\u003cp\u003e즐거운 코딩하세요!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:960/1*5D9ZTssrYkDI-7hN0fAVkw.gif\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-TracinginSpringBoot3"},"buildId":"-dPCbnM2yhdKNgXe92VJV","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>