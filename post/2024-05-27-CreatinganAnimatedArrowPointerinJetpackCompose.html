<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Jetpack Compose에서 애니메이션 화살표 포인터 만들기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Jetpack Compose에서 애니메이션 화살표 포인터 만들기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Jetpack Compose에서 애니메이션 화살표 포인터 만들기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose" data-gatsby-head="true"/><meta name="twitter:title" content="Jetpack Compose에서 애니메이션 화살표 포인터 만들기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-27 16:10" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_buildManifest.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Jetpack Compose에서 애니메이션 화살표 포인터 만들기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Jetpack Compose에서 애니메이션 화살표 포인터 만들기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 27, 2024</span><span class="posts_reading_time__f7YPP">11<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>환영합니다 👋</p>
<p>이 기사에서는 Jetpack Compose를 사용하여 멋진 애니메이션 화살표 포인터를 만드는 방법을 탐색하고 앱의 외관을 5분 안에 향상시키는 방법에 대해 알아보겠습니다.</p>
<p>계속 주목하고, 함께 알아보시죠! 🚀</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*jP0QAL3blRz6ynJ8IkjCuQ.gif" alt="Animated Arrow Pointer"></p>
<p></p>
<h1>함수 정의하기</h1>
<p>AnimatedArrowPointer 함수를 선언하고 그 파라미터들을 살펴봅시다.</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Composable</span>
fun <span class="hljs-title class_">AnimatedArrowPointer</span>(
    <span class="hljs-attr">modifier</span>: <span class="hljs-title class_">Modifier</span>,
    <span class="hljs-attr">color</span>: <span class="hljs-title class_">Color</span>,
    <span class="hljs-attr">isVisible</span>: <span class="hljs-title class_">Boolean</span> = <span class="hljs-literal">true</span>,
    <span class="hljs-attr">strokeWidth</span>: <span class="hljs-title class_">Dp</span> = <span class="hljs-number">2.</span>dp,
    <span class="hljs-attr">pointerSize</span>: <span class="hljs-title class_">Dp</span> = <span class="hljs-number">12.</span>dp,
    <span class="hljs-attr">dashLength</span>: <span class="hljs-title class_">Dp</span>? = <span class="hljs-number">4.</span>dp,
    <span class="hljs-attr">strokeCap</span>: <span class="hljs-title class_">StrokeCap</span> = <span class="hljs-title class_">StrokeCap</span>.<span class="hljs-property">Round</span>,
    <span class="hljs-attr">pointerShape</span>: <span class="hljs-title class_">Shape</span> = <span class="hljs-title class_">SimpleArrow</span>,
    <span class="hljs-attr">animationSpec</span>: <span class="hljs-title class_">AnimationSpec</span>&#x3C;<span class="hljs-title class_">Float</span>> = <span class="hljs-title function_">tween</span>(<span class="hljs-number">3000</span>)
)
</code></pre>
<h2>⚒️ 파라미터 설명</h2>
<p></p>
<p>⚡ modifier ➜ 포인터 레이아웃에 적용할 수정자입니다.</p>
<p>⚡ color ➜ 화살표 포인터의 색상입니다.</p>
<p>⚡ isVisible ➜ 화살표 포인터가 표시되는지 여부를 결정합니다.</p>
<p>⚡ strokeWidth ➜ 화살표 포인터의 선 두께입니다.</p>
<p></p>
<p>⚡ pointerSize ➜ 화살표 포인터의 크기입니다.</p>
<p>⚡ dashLength ➜ 테두리 대시의 길이입니다. null은 실선을 의미합니다.</p>
<p>⚡ strokeCap ➜ 화살표 포인터의 선 끝 스타일입니다.</p>
<p>⚡ pointerShape ➜ 화살표 포인터의 모양입니다.</p>
<p></p>
<p>⚡ animationSpec ➜ 화살표 애니메이션 동작을 지정합니다.</p>
<h1>경로</h1>
<p>좋아요, 오늘 기사의 주요 내용으로 넘어갑시다.</p>
<h2>ArrowPath</h2>
<p></p>
<p>테이블 태그를 마크다운 형식으로 변경해보세요.</p>
<p></p>
<h2>SimplePointer</h2>
<p>다음으로 포인터를 제작해야 합니다. Shape 인터페이스를 구현하는 객체를 정의합시다:</p>
<pre><code class="hljs language-js">object <span class="hljs-title class_">SimpleArrow</span> : <span class="hljs-title class_">Shape</span> {
    override fun <span class="hljs-title function_">createOutline</span>(
        <span class="hljs-attr">size</span>: <span class="hljs-title class_">Size</span>,
        <span class="hljs-attr">layoutDirection</span>: <span class="hljs-title class_">LayoutDirection</span>,
        <span class="hljs-attr">density</span>: <span class="hljs-title class_">Density</span>
    ): <span class="hljs-title class_">Outline</span> {
        val width = size.<span class="hljs-property">width</span>
        val height = size.<span class="hljs-property">height</span>

        val path = <span class="hljs-title class_">Path</span>().<span class="hljs-property">apply</span> {
            <span class="hljs-title function_">moveTo</span>(0f, 0f) <span class="hljs-comment">// 1</span>
            <span class="hljs-title function_">lineTo</span>(width, height * <span class="hljs-number">0.</span>5f) <span class="hljs-comment">// 2</span>
            <span class="hljs-title function_">lineTo</span>(0f, height) <span class="hljs-comment">// 3</span>
            <span class="hljs-title function_">lineTo</span>(width * <span class="hljs-number">0.</span>5f, height * <span class="hljs-number">0.</span>5f) <span class="hljs-comment">// 4</span>
            <span class="hljs-title function_">close</span>() <span class="hljs-comment">// line to 1</span>
        }
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Outline</span>.<span class="hljs-title class_">Generic</span>(path)
    }
}
</code></pre>
<p>이해를 돕기 위해 다음 이미지를 확인해보세요 👇</p>
<p></p>
<p><img src="/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_1.png" alt="이미지"></p>
<h1>그리기</h1>
<p>이제 함수 구현에 가까워졌어요. 하지만 그 전에, 경로와 포인터 머리를 그리기 위한 두 개의 지원 함수를 정의해야 해요.</p>
<h2>화살 경로 그리기</h2>
<p></p>
<p>경로를 그리는 것은 간단합니다. 지정된 속성을 가진 캔버스에 일반적인 경로를 그리기만 하면 됩니다:</p>
<pre><code class="hljs language-js">fun <span class="hljs-title class_">DrawScope</span>.<span class="hljs-title function_">drawPathSegment</span>(<span class="hljs-params">
    path: Path,
    color: Color,
    strokeWidth: Dp,
    strokeCap: StrokeCap,
    dashLength: Dp? = <span class="hljs-literal">null</span>
</span>) {
    <span class="hljs-title function_">drawPath</span>(
        path = path,
        color = color,
        style = <span class="hljs-title class_">Stroke</span>(
            width = strokeWidth.<span class="hljs-title function_">toPx</span>(),
            cap = strokeCap,
            <span class="hljs-comment">// dashLength가 지정되어 있다면 대시 스트로크를 그리고,</span>
            <span class="hljs-comment">// 그렇지 않으면 실선을 사용합니다.</span>
            pathEffect = dashLength?.<span class="hljs-property">let</span> { dash ->
                <span class="hljs-title class_">PathEffect</span>.<span class="hljs-title function_">dashPathEffect</span>(
                    <span class="hljs-title function_">floatArrayOf</span>(dash.<span class="hljs-title function_">toPx</span>(), dash.<span class="hljs-title function_">toPx</span>())
                )
            }
        )
    )
}
</code></pre>
<h2>포인터 헤드 그리기</h2>
<p>현재 경로 세그먼트의 끝에 동적으로 헤드를 그리려면 PathMeasure의 getPosition 및 getTangent를 활용하여 포인터의 위치와 올바른 방향을 가리키는 각도를 얻을 것입니다.</p>
<p></p>
<pre><code class="hljs language-js">fun <span class="hljs-title class_">DrawScope</span>.<span class="hljs-title function_">drawPointerHead</span>(<span class="hljs-params">
    pathMeasure: PathMeasure,
    stopDistance: Float,
    pointerSize: Dp,
    color: Color,
    pointerShape: Shape
</span>) {
    <span class="hljs-comment">// 지정된 거리에서의 점과 접선을 계산합니다.</span>
    val headPoint = pathMeasure.<span class="hljs-title function_">getPosition</span>(stopDistance)
    val tangent = pathMeasure.<span class="hljs-title function_">getTangent</span>(stopDistance)

    <span class="hljs-comment">// 접선을 기반으로 화살표 머리의 회전 각도를 계산합니다.</span>
    val angle = <span class="hljs-title function_">atan2</span>(tangent.<span class="hljs-property">y</span>.<span class="hljs-title function_">toDouble</span>(), tangent.<span class="hljs-property">x</span>.<span class="hljs-title function_">toDouble</span>()).<span class="hljs-title function_">toFloat</span>() * <span class="hljs-number">180</span> / <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>.<span class="hljs-title function_">toFloat</span>()

    <span class="hljs-comment">// 화살표 머리의 크기와 윤곽을 정의합니다.</span>
    val headSize = <span class="hljs-title class_">Size</span>(pointerSize.<span class="hljs-title function_">toPx</span>(), pointerSize.<span class="hljs-title function_">toPx</span>())
    val headOutline = pointerShape.<span class="hljs-title function_">createOutline</span>(headSize, layoutDirection, <span class="hljs-variable language_">this</span>)

    <span class="hljs-comment">// 캔버스를 이동하고 회전시켜 화살표 머리의 위치와 방향을 조정합니다.</span>
    <span class="hljs-title function_">translate</span>(<span class="hljs-params">headPoint.x - (headSize.width / <span class="hljs-number">2</span>), headPoint.y - (headSize.height / <span class="hljs-number">2</span>)</span>) {
        <span class="hljs-title function_">rotate</span>(<span class="hljs-params">angle, pivot = headSize.center</span>) {
            <span class="hljs-comment">// 화살표 머리 윤곽을 그립니다.</span>
            <span class="hljs-title function_">drawOutline</span>(headOutline, color = color)
        }
    }
}
</code></pre>
<h1>구현</h1>
<p>마지막으로 모든 것을 합쳐서 애니메이션을 적용합시다.</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Composable</span>
fun <span class="hljs-title class_">AnimatedArrowPointer</span>(
    <span class="hljs-comment">/* 매개변수... */</span>
) {
    <span class="hljs-comment">// 애니메이션 진행 값을 위한 Animatable 정의</span>
    val pathCompletion = remember { <span class="hljs-title class_">Animatable</span>(0f) }

    <span class="hljs-comment">// 가시성 상태 변경에 기반하여 애니메이션 시작</span>
    <span class="hljs-title class_">LaunchedEffect</span>(isVisible) {
        <span class="hljs-keyword">if</span> (isVisible) {
            <span class="hljs-comment">// 경로 애니메이션</span>
            pathCompletion.<span class="hljs-title function_">animateTo</span>(1f, animationSpec)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 경로 즉시 숨기기</span>
            pathCompletion.<span class="hljs-title function_">snapTo</span>(0f)
        }
    }

    <span class="hljs-comment">// Canvas에서 애니메이션된 화살표 그리기</span>
    <span class="hljs-title class_">Canvas</span>(
        <span class="hljs-comment">// 경로 왜곡을 방지하기 위한 적절한 비율 보장</span>
        modifier.<span class="hljs-title function_">aspectRatio</span>(<span class="hljs-number">0.</span>6f)
    ) {
        <span class="hljs-comment">// 캔버스 크기에 따라 화살표 경로 생성</span>
        val arrowPath = <span class="hljs-title function_">createArrowPath</span>(size.<span class="hljs-property">width</span>, size.<span class="hljs-property">height</span>)

        <span class="hljs-comment">// 길이와 세그먼트 정보를 얻기 위해 경로 측정</span>
        val pathMeasure = <span class="hljs-title class_">PathMeasure</span>().<span class="hljs-property">apply</span> {
            <span class="hljs-title function_">setPath</span>(arrowPath, <span class="hljs-literal">false</span>)
        }

        <span class="hljs-comment">// 현재 애니메이션 진행에 기반한 경로 세그먼트 생성</span>
        val pathSegment = <span class="hljs-title class_">Path</span>()
        val stopDistance = pathCompletion.<span class="hljs-property">value</span> * pathMeasure.<span class="hljs-property">length</span>
        pathMeasure.<span class="hljs-title function_">getSegment</span>(0f, stopDistance, pathSegment, <span class="hljs-literal">true</span>)

        <span class="hljs-comment">// 지정된 속성으로 현재 화살표 경로 세그먼트 그리기</span>
        <span class="hljs-title function_">drawPathSegment</span>(pathSegment, color, strokeWidth, strokeCap, dashLength)

        <span class="hljs-comment">// 경로가 일부 그려진 경우, 화살표 머리 그리기</span>
        <span class="hljs-keyword">if</span> (pathCompletion.<span class="hljs-property">value</span> > <span class="hljs-number">0</span>) {
            <span class="hljs-title function_">drawPointerHead</span>(pathMeasure, stopDistance, pointerSize, color, pointerShape)
        }
    }
}
</code></pre>
<p></p>
<p>축하해요 🥳! 우리 성공적으로 만들었어요 👏. 전체 코드 구현을 확인하려면 GitHub Gist에 액세스할 수 있어요 🧑‍💻. 이제 사용 방법을 알아보아요.</p>
<h2>광고</h2>
<p>외국어를 배우고 새로운 어휘로 고민하고 계신가요? 그렇다면, 여러분의 학습을 쉽고 편리하게 해줄 이 어플을 확인하는 걸 강력히 추천해요!</p>
<p></p>
<h1>사용법</h1>
<p>배치에 간단한 변형 수정자를 적용하여 화살표 포인터의 위치를 쉽게 사용자 정의할 수 있습니다. 여기에는 일반적인 시나리오가 있습니다:</p>
<h2>하단-우측 (기본)</h2>
<p>하단-우측 위치는 기본 포인팅 방향입니다:</p>
<p></p>
<pre><code class="hljs language-kotlin">AnimatedArrowPointer(
    modifier = Modifier.size(<span class="hljs-number">140.</span>dp),
    color = Color.Red
)
</code></pre>
<p><img src="https://miro.medium.com/v2/resize:fit:576/1*FM6yzByscqrfK0bihhE_6g.gif" alt="Arrow Pointer"></p>
<h2>Top-Right</h2>
<p>To point to the top-right, rotate the layout by -90 degrees:</p>
<p></p>
<pre><code class="hljs language-kotlin">AnimatedArrowPointer(
    modifier = Modifier
        .size(<span class="hljs-number">140.</span>dp)
        .rotate(-<span class="hljs-number">90f</span>),
    color = Color.Red
)
</code></pre>
<p><img src="https://miro.medium.com/v2/resize:fit:900/1*TDE55uvzhAy-XZNn-d8bGg.gif" alt="Animated Arrow Pointer"></p>
<h2>Bottom-Left</h2>
<p>Bottom-Left를 가리키려면 레이아웃을 x축에서 -1f로 확장하여 수평으로 반사합니다:</p>
<p></p>
<pre><code class="hljs language-kotlin">AnimatedArrowPointer(
    modifier = Modifier
        .size(<span class="hljs-number">140.</span>dp)
        .scale(-<span class="hljs-number">1f</span>, <span class="hljs-number">1f</span>),
    color = Color.Red
)
</code></pre>
<p><img src="https://miro.medium.com/v2/resize:fit:570/1*NZ608yVkzKu7IVAwAPa8HQ.gif" alt="Animated arrow pointer"></p>
<h2>왼쪽 위</h2>
<p>왼쪽 위 방향을 위해, 먼저 레이아웃을 수평으로 반사한 다음, -90도로 회전시킵니다:</p>
<p></p>
<pre><code class="hljs language-kotlin">AnimatedArrowPointer(
    modifier = Modifier
        .size(<span class="hljs-number">140.</span>dp)
        .scale(-<span class="hljs-number">1f</span>, <span class="hljs-number">1f</span>)
        .rotate(-<span class="hljs-number">90f</span>),
    color = Color.Red
)
</code></pre>
<p><img src="https://miro.medium.com/v2/resize:fit:900/1*UaIjzfaG0aaaqpSNmN4Qpw.gif" alt="Animated Arrow Pointer"></p>
<p>좋아할 만한 내용이 있을 것 같아요 👇</p>
<p>이 기사를 읽어 주셔서 감사합니다! ❤️ 즐거우시고 가치 있게 보내셨으면 좋겣습니다. 만약 좋았다면 만세 👏를 눌러서 감사를 표현해 주시고 Kappdev를 팔로우하여 더욱 흥미로운 기사를 읽어보세요 😊</p>
<p></p>
<p>행복한 코딩!</p>
<p><img src="/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_3.png" alt="이미지"></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Jetpack Compose에서 애니메이션 화살표 포인터 만들기","description":"","date":"2024-05-27 16:10","slug":"2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose","content":"\n환영합니다 👋\n\n이 기사에서는 Jetpack Compose를 사용하여 멋진 애니메이션 화살표 포인터를 만드는 방법을 탐색하고 앱의 외관을 5분 안에 향상시키는 방법에 대해 알아보겠습니다.\n\n계속 주목하고, 함께 알아보시죠! 🚀\n\n![Animated Arrow Pointer](https://miro.medium.com/v2/resize:fit:1400/1*jP0QAL3blRz6ynJ8IkjCuQ.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 함수 정의하기\n\nAnimatedArrowPointer 함수를 선언하고 그 파라미터들을 살펴봅시다.\n\n```js\n@Composable\nfun AnimatedArrowPointer(\n    modifier: Modifier,\n    color: Color,\n    isVisible: Boolean = true,\n    strokeWidth: Dp = 2.dp,\n    pointerSize: Dp = 12.dp,\n    dashLength: Dp? = 4.dp,\n    strokeCap: StrokeCap = StrokeCap.Round,\n    pointerShape: Shape = SimpleArrow,\n    animationSpec: AnimationSpec\u003cFloat\u003e = tween(3000)\n)\n```\n\n## ⚒️ 파라미터 설명\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n⚡ modifier ➜ 포인터 레이아웃에 적용할 수정자입니다.\n\n⚡ color ➜ 화살표 포인터의 색상입니다.\n\n⚡ isVisible ➜ 화살표 포인터가 표시되는지 여부를 결정합니다.\n\n⚡ strokeWidth ➜ 화살표 포인터의 선 두께입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n⚡ pointerSize ➜ 화살표 포인터의 크기입니다.\n\n⚡ dashLength ➜ 테두리 대시의 길이입니다. null은 실선을 의미합니다.\n\n⚡ strokeCap ➜ 화살표 포인터의 선 끝 스타일입니다.\n\n⚡ pointerShape ➜ 화살표 포인터의 모양입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n⚡ animationSpec ➜ 화살표 애니메이션 동작을 지정합니다.\n\n# 경로\n\n좋아요, 오늘 기사의 주요 내용으로 넘어갑시다.\n\n## ArrowPath\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## SimplePointer\n\n다음으로 포인터를 제작해야 합니다. Shape 인터페이스를 구현하는 객체를 정의합시다:\n\n```js\nobject SimpleArrow : Shape {\n    override fun createOutline(\n        size: Size,\n        layoutDirection: LayoutDirection,\n        density: Density\n    ): Outline {\n        val width = size.width\n        val height = size.height\n\n        val path = Path().apply {\n            moveTo(0f, 0f) // 1\n            lineTo(width, height * 0.5f) // 2\n            lineTo(0f, height) // 3\n            lineTo(width * 0.5f, height * 0.5f) // 4\n            close() // line to 1\n        }\n        return Outline.Generic(path)\n    }\n}\n```\n\n이해를 돕기 위해 다음 이미지를 확인해보세요 👇\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_1.png)\n\n# 그리기\n\n이제 함수 구현에 가까워졌어요. 하지만 그 전에, 경로와 포인터 머리를 그리기 위한 두 개의 지원 함수를 정의해야 해요.\n\n## 화살 경로 그리기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n경로를 그리는 것은 간단합니다. 지정된 속성을 가진 캔버스에 일반적인 경로를 그리기만 하면 됩니다:\n\n```js\nfun DrawScope.drawPathSegment(\n    path: Path,\n    color: Color,\n    strokeWidth: Dp,\n    strokeCap: StrokeCap,\n    dashLength: Dp? = null\n) {\n    drawPath(\n        path = path,\n        color = color,\n        style = Stroke(\n            width = strokeWidth.toPx(),\n            cap = strokeCap,\n            // dashLength가 지정되어 있다면 대시 스트로크를 그리고,\n            // 그렇지 않으면 실선을 사용합니다.\n            pathEffect = dashLength?.let { dash -\u003e\n                PathEffect.dashPathEffect(\n                    floatArrayOf(dash.toPx(), dash.toPx())\n                )\n            }\n        )\n    )\n}\n```\n\n## 포인터 헤드 그리기\n\n현재 경로 세그먼트의 끝에 동적으로 헤드를 그리려면 PathMeasure의 getPosition 및 getTangent를 활용하여 포인터의 위치와 올바른 방향을 가리키는 각도를 얻을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfun DrawScope.drawPointerHead(\n    pathMeasure: PathMeasure,\n    stopDistance: Float,\n    pointerSize: Dp,\n    color: Color,\n    pointerShape: Shape\n) {\n    // 지정된 거리에서의 점과 접선을 계산합니다.\n    val headPoint = pathMeasure.getPosition(stopDistance)\n    val tangent = pathMeasure.getTangent(stopDistance)\n\n    // 접선을 기반으로 화살표 머리의 회전 각도를 계산합니다.\n    val angle = atan2(tangent.y.toDouble(), tangent.x.toDouble()).toFloat() * 180 / Math.PI.toFloat()\n\n    // 화살표 머리의 크기와 윤곽을 정의합니다.\n    val headSize = Size(pointerSize.toPx(), pointerSize.toPx())\n    val headOutline = pointerShape.createOutline(headSize, layoutDirection, this)\n\n    // 캔버스를 이동하고 회전시켜 화살표 머리의 위치와 방향을 조정합니다.\n    translate(headPoint.x - (headSize.width / 2), headPoint.y - (headSize.height / 2)) {\n        rotate(angle, pivot = headSize.center) {\n            // 화살표 머리 윤곽을 그립니다.\n            drawOutline(headOutline, color = color)\n        }\n    }\n}\n```\n\n# 구현\n\n마지막으로 모든 것을 합쳐서 애니메이션을 적용합시다.\n\n```js\n@Composable\nfun AnimatedArrowPointer(\n    /* 매개변수... */\n) {\n    // 애니메이션 진행 값을 위한 Animatable 정의\n    val pathCompletion = remember { Animatable(0f) }\n\n    // 가시성 상태 변경에 기반하여 애니메이션 시작\n    LaunchedEffect(isVisible) {\n        if (isVisible) {\n            // 경로 애니메이션\n            pathCompletion.animateTo(1f, animationSpec)\n        } else {\n            // 경로 즉시 숨기기\n            pathCompletion.snapTo(0f)\n        }\n    }\n\n    // Canvas에서 애니메이션된 화살표 그리기\n    Canvas(\n        // 경로 왜곡을 방지하기 위한 적절한 비율 보장\n        modifier.aspectRatio(0.6f)\n    ) {\n        // 캔버스 크기에 따라 화살표 경로 생성\n        val arrowPath = createArrowPath(size.width, size.height)\n\n        // 길이와 세그먼트 정보를 얻기 위해 경로 측정\n        val pathMeasure = PathMeasure().apply {\n            setPath(arrowPath, false)\n        }\n\n        // 현재 애니메이션 진행에 기반한 경로 세그먼트 생성\n        val pathSegment = Path()\n        val stopDistance = pathCompletion.value * pathMeasure.length\n        pathMeasure.getSegment(0f, stopDistance, pathSegment, true)\n\n        // 지정된 속성으로 현재 화살표 경로 세그먼트 그리기\n        drawPathSegment(pathSegment, color, strokeWidth, strokeCap, dashLength)\n\n        // 경로가 일부 그려진 경우, 화살표 머리 그리기\n        if (pathCompletion.value \u003e 0) {\n            drawPointerHead(pathMeasure, stopDistance, pointerSize, color, pointerShape)\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n축하해요 🥳! 우리 성공적으로 만들었어요 👏. 전체 코드 구현을 확인하려면 GitHub Gist에 액세스할 수 있어요 🧑‍💻. 이제 사용 방법을 알아보아요.\n\n## 광고\n\n외국어를 배우고 새로운 어휘로 고민하고 계신가요? 그렇다면, 여러분의 학습을 쉽고 편리하게 해줄 이 어플을 확인하는 걸 강력히 추천해요!\n\n\u003cimg src=\"/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_2.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 사용법\n\n배치에 간단한 변형 수정자를 적용하여 화살표 포인터의 위치를 쉽게 사용자 정의할 수 있습니다. 여기에는 일반적인 시나리오가 있습니다:\n\n## 하단-우측 (기본)\n\n하단-우측 위치는 기본 포인팅 방향입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nAnimatedArrowPointer(\n    modifier = Modifier.size(140.dp),\n    color = Color.Red\n)\n```\n\n![Arrow Pointer](https://miro.medium.com/v2/resize:fit:576/1*FM6yzByscqrfK0bihhE_6g.gif)\n\n## Top-Right\n\nTo point to the top-right, rotate the layout by -90 degrees:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nAnimatedArrowPointer(\n    modifier = Modifier\n        .size(140.dp)\n        .rotate(-90f),\n    color = Color.Red\n)\n```\n\n![Animated Arrow Pointer](https://miro.medium.com/v2/resize:fit:900/1*TDE55uvzhAy-XZNn-d8bGg.gif)\n\n## Bottom-Left\n\nBottom-Left를 가리키려면 레이아웃을 x축에서 -1f로 확장하여 수평으로 반사합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nAnimatedArrowPointer(\n    modifier = Modifier\n        .size(140.dp)\n        .scale(-1f, 1f),\n    color = Color.Red\n)\n```\n\n![Animated arrow pointer](https://miro.medium.com/v2/resize:fit:570/1*NZ608yVkzKu7IVAwAPa8HQ.gif)\n\n## 왼쪽 위\n\n왼쪽 위 방향을 위해, 먼저 레이아웃을 수평으로 반사한 다음, -90도로 회전시킵니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nAnimatedArrowPointer(\n    modifier = Modifier\n        .size(140.dp)\n        .scale(-1f, 1f)\n        .rotate(-90f),\n    color = Color.Red\n)\n```\n\n![Animated Arrow Pointer](https://miro.medium.com/v2/resize:fit:900/1*UaIjzfaG0aaaqpSNmN4Qpw.gif)\n\n좋아할 만한 내용이 있을 것 같아요 👇\n\n이 기사를 읽어 주셔서 감사합니다! ❤️ 즐거우시고 가치 있게 보내셨으면 좋겣습니다. 만약 좋았다면 만세 👏를 눌러서 감사를 표현해 주시고 Kappdev를 팔로우하여 더욱 흥미로운 기사를 읽어보세요 😊\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n행복한 코딩!\n\n![이미지](/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_3.png)\n","ogImage":{"url":"/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_0.png"},"coverImage":"/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_0.png","tag":["Tech"],"readingTime":11},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e환영합니다 👋\u003c/p\u003e\n\u003cp\u003e이 기사에서는 Jetpack Compose를 사용하여 멋진 애니메이션 화살표 포인터를 만드는 방법을 탐색하고 앱의 외관을 5분 안에 향상시키는 방법에 대해 알아보겠습니다.\u003c/p\u003e\n\u003cp\u003e계속 주목하고, 함께 알아보시죠! 🚀\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*jP0QAL3blRz6ynJ8IkjCuQ.gif\" alt=\"Animated Arrow Pointer\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003e함수 정의하기\u003c/h1\u003e\n\u003cp\u003eAnimatedArrowPointer 함수를 선언하고 그 파라미터들을 살펴봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eComposable\u003c/span\u003e\nfun \u003cspan class=\"hljs-title class_\"\u003eAnimatedArrowPointer\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003emodifier\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eModifier\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eColor\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eisVisible\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBoolean\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003estrokeWidth\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDp\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e2.\u003c/span\u003edp,\n    \u003cspan class=\"hljs-attr\"\u003epointerSize\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDp\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e12.\u003c/span\u003edp,\n    \u003cspan class=\"hljs-attr\"\u003edashLength\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDp\u003c/span\u003e? = \u003cspan class=\"hljs-number\"\u003e4.\u003c/span\u003edp,\n    \u003cspan class=\"hljs-attr\"\u003estrokeCap\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eStrokeCap\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eStrokeCap\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eRound\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003epointerShape\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eShape\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eSimpleArrow\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eanimationSpec\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAnimationSpec\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eFloat\u003c/span\u003e\u003e = \u003cspan class=\"hljs-title function_\"\u003etween\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e)\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e⚒️ 파라미터 설명\u003c/h2\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e⚡ modifier ➜ 포인터 레이아웃에 적용할 수정자입니다.\u003c/p\u003e\n\u003cp\u003e⚡ color ➜ 화살표 포인터의 색상입니다.\u003c/p\u003e\n\u003cp\u003e⚡ isVisible ➜ 화살표 포인터가 표시되는지 여부를 결정합니다.\u003c/p\u003e\n\u003cp\u003e⚡ strokeWidth ➜ 화살표 포인터의 선 두께입니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e⚡ pointerSize ➜ 화살표 포인터의 크기입니다.\u003c/p\u003e\n\u003cp\u003e⚡ dashLength ➜ 테두리 대시의 길이입니다. null은 실선을 의미합니다.\u003c/p\u003e\n\u003cp\u003e⚡ strokeCap ➜ 화살표 포인터의 선 끝 스타일입니다.\u003c/p\u003e\n\u003cp\u003e⚡ pointerShape ➜ 화살표 포인터의 모양입니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e⚡ animationSpec ➜ 화살표 애니메이션 동작을 지정합니다.\u003c/p\u003e\n\u003ch1\u003e경로\u003c/h1\u003e\n\u003cp\u003e좋아요, 오늘 기사의 주요 내용으로 넘어갑시다.\u003c/p\u003e\n\u003ch2\u003eArrowPath\u003c/h2\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e테이블 태그를 마크다운 형식으로 변경해보세요.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003eSimplePointer\u003c/h2\u003e\n\u003cp\u003e다음으로 포인터를 제작해야 합니다. Shape 인터페이스를 구현하는 객체를 정의합시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eobject \u003cspan class=\"hljs-title class_\"\u003eSimpleArrow\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eShape\u003c/span\u003e {\n    override fun \u003cspan class=\"hljs-title function_\"\u003ecreateOutline\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003esize\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSize\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003elayoutDirection\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eLayoutDirection\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003edensity\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDensity\u003c/span\u003e\n    ): \u003cspan class=\"hljs-title class_\"\u003eOutline\u003c/span\u003e {\n        val width = size.\u003cspan class=\"hljs-property\"\u003ewidth\u003c/span\u003e\n        val height = size.\u003cspan class=\"hljs-property\"\u003eheight\u003c/span\u003e\n\n        val path = \u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003eapply\u003c/span\u003e {\n            \u003cspan class=\"hljs-title function_\"\u003emoveTo\u003c/span\u003e(0f, 0f) \u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n            \u003cspan class=\"hljs-title function_\"\u003elineTo\u003c/span\u003e(width, height * \u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e5f) \u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n            \u003cspan class=\"hljs-title function_\"\u003elineTo\u003c/span\u003e(0f, height) \u003cspan class=\"hljs-comment\"\u003e// 3\u003c/span\u003e\n            \u003cspan class=\"hljs-title function_\"\u003elineTo\u003c/span\u003e(width * \u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e5f, height * \u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e5f) \u003cspan class=\"hljs-comment\"\u003e// 4\u003c/span\u003e\n            \u003cspan class=\"hljs-title function_\"\u003eclose\u003c/span\u003e() \u003cspan class=\"hljs-comment\"\u003e// line to 1\u003c/span\u003e\n        }\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOutline\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eGeneric\u003c/span\u003e(path)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이해를 돕기 위해 다음 이미지를 확인해보세요 👇\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e그리기\u003c/h1\u003e\n\u003cp\u003e이제 함수 구현에 가까워졌어요. 하지만 그 전에, 경로와 포인터 머리를 그리기 위한 두 개의 지원 함수를 정의해야 해요.\u003c/p\u003e\n\u003ch2\u003e화살 경로 그리기\u003c/h2\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e경로를 그리는 것은 간단합니다. 지정된 속성을 가진 캔버스에 일반적인 경로를 그리기만 하면 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efun \u003cspan class=\"hljs-title class_\"\u003eDrawScope\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edrawPathSegment\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n    path: Path,\n    color: Color,\n    strokeWidth: Dp,\n    strokeCap: StrokeCap,\n    dashLength: Dp? = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003edrawPath\u003c/span\u003e(\n        path = path,\n        color = color,\n        style = \u003cspan class=\"hljs-title class_\"\u003eStroke\u003c/span\u003e(\n            width = strokeWidth.\u003cspan class=\"hljs-title function_\"\u003etoPx\u003c/span\u003e(),\n            cap = strokeCap,\n            \u003cspan class=\"hljs-comment\"\u003e// dashLength가 지정되어 있다면 대시 스트로크를 그리고,\u003c/span\u003e\n            \u003cspan class=\"hljs-comment\"\u003e// 그렇지 않으면 실선을 사용합니다.\u003c/span\u003e\n            pathEffect = dashLength?.\u003cspan class=\"hljs-property\"\u003elet\u003c/span\u003e { dash -\u003e\n                \u003cspan class=\"hljs-title class_\"\u003ePathEffect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edashPathEffect\u003c/span\u003e(\n                    \u003cspan class=\"hljs-title function_\"\u003efloatArrayOf\u003c/span\u003e(dash.\u003cspan class=\"hljs-title function_\"\u003etoPx\u003c/span\u003e(), dash.\u003cspan class=\"hljs-title function_\"\u003etoPx\u003c/span\u003e())\n                )\n            }\n        )\n    )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e포인터 헤드 그리기\u003c/h2\u003e\n\u003cp\u003e현재 경로 세그먼트의 끝에 동적으로 헤드를 그리려면 PathMeasure의 getPosition 및 getTangent를 활용하여 포인터의 위치와 올바른 방향을 가리키는 각도를 얻을 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efun \u003cspan class=\"hljs-title class_\"\u003eDrawScope\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edrawPointerHead\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n    pathMeasure: PathMeasure,\n    stopDistance: Float,\n    pointerSize: Dp,\n    color: Color,\n    pointerShape: Shape\n\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 지정된 거리에서의 점과 접선을 계산합니다.\u003c/span\u003e\n    val headPoint = pathMeasure.\u003cspan class=\"hljs-title function_\"\u003egetPosition\u003c/span\u003e(stopDistance)\n    val tangent = pathMeasure.\u003cspan class=\"hljs-title function_\"\u003egetTangent\u003c/span\u003e(stopDistance)\n\n    \u003cspan class=\"hljs-comment\"\u003e// 접선을 기반으로 화살표 머리의 회전 각도를 계산합니다.\u003c/span\u003e\n    val angle = \u003cspan class=\"hljs-title function_\"\u003eatan2\u003c/span\u003e(tangent.\u003cspan class=\"hljs-property\"\u003ey\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etoDouble\u003c/span\u003e(), tangent.\u003cspan class=\"hljs-property\"\u003ex\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etoDouble\u003c/span\u003e()).\u003cspan class=\"hljs-title function_\"\u003etoFloat\u003c/span\u003e() * \u003cspan class=\"hljs-number\"\u003e180\u003c/span\u003e / \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePI\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etoFloat\u003c/span\u003e()\n\n    \u003cspan class=\"hljs-comment\"\u003e// 화살표 머리의 크기와 윤곽을 정의합니다.\u003c/span\u003e\n    val headSize = \u003cspan class=\"hljs-title class_\"\u003eSize\u003c/span\u003e(pointerSize.\u003cspan class=\"hljs-title function_\"\u003etoPx\u003c/span\u003e(), pointerSize.\u003cspan class=\"hljs-title function_\"\u003etoPx\u003c/span\u003e())\n    val headOutline = pointerShape.\u003cspan class=\"hljs-title function_\"\u003ecreateOutline\u003c/span\u003e(headSize, layoutDirection, \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-comment\"\u003e// 캔버스를 이동하고 회전시켜 화살표 머리의 위치와 방향을 조정합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003etranslate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eheadPoint.x - (headSize.width / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e), headPoint.y - (headSize.height / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title function_\"\u003erotate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eangle, pivot = headSize.center\u003c/span\u003e) {\n            \u003cspan class=\"hljs-comment\"\u003e// 화살표 머리 윤곽을 그립니다.\u003c/span\u003e\n            \u003cspan class=\"hljs-title function_\"\u003edrawOutline\u003c/span\u003e(headOutline, color = color)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e구현\u003c/h1\u003e\n\u003cp\u003e마지막으로 모든 것을 합쳐서 애니메이션을 적용합시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eComposable\u003c/span\u003e\nfun \u003cspan class=\"hljs-title class_\"\u003eAnimatedArrowPointer\u003c/span\u003e(\n    \u003cspan class=\"hljs-comment\"\u003e/* 매개변수... */\u003c/span\u003e\n) {\n    \u003cspan class=\"hljs-comment\"\u003e// 애니메이션 진행 값을 위한 Animatable 정의\u003c/span\u003e\n    val pathCompletion = remember { \u003cspan class=\"hljs-title class_\"\u003eAnimatable\u003c/span\u003e(0f) }\n\n    \u003cspan class=\"hljs-comment\"\u003e// 가시성 상태 변경에 기반하여 애니메이션 시작\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eLaunchedEffect\u003c/span\u003e(isVisible) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isVisible) {\n            \u003cspan class=\"hljs-comment\"\u003e// 경로 애니메이션\u003c/span\u003e\n            pathCompletion.\u003cspan class=\"hljs-title function_\"\u003eanimateTo\u003c/span\u003e(1f, animationSpec)\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-comment\"\u003e// 경로 즉시 숨기기\u003c/span\u003e\n            pathCompletion.\u003cspan class=\"hljs-title function_\"\u003esnapTo\u003c/span\u003e(0f)\n        }\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// Canvas에서 애니메이션된 화살표 그리기\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eCanvas\u003c/span\u003e(\n        \u003cspan class=\"hljs-comment\"\u003e// 경로 왜곡을 방지하기 위한 적절한 비율 보장\u003c/span\u003e\n        modifier.\u003cspan class=\"hljs-title function_\"\u003easpectRatio\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e6f)\n    ) {\n        \u003cspan class=\"hljs-comment\"\u003e// 캔버스 크기에 따라 화살표 경로 생성\u003c/span\u003e\n        val arrowPath = \u003cspan class=\"hljs-title function_\"\u003ecreateArrowPath\u003c/span\u003e(size.\u003cspan class=\"hljs-property\"\u003ewidth\u003c/span\u003e, size.\u003cspan class=\"hljs-property\"\u003eheight\u003c/span\u003e)\n\n        \u003cspan class=\"hljs-comment\"\u003e// 길이와 세그먼트 정보를 얻기 위해 경로 측정\u003c/span\u003e\n        val pathMeasure = \u003cspan class=\"hljs-title class_\"\u003ePathMeasure\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003eapply\u003c/span\u003e {\n            \u003cspan class=\"hljs-title function_\"\u003esetPath\u003c/span\u003e(arrowPath, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e)\n        }\n\n        \u003cspan class=\"hljs-comment\"\u003e// 현재 애니메이션 진행에 기반한 경로 세그먼트 생성\u003c/span\u003e\n        val pathSegment = \u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e()\n        val stopDistance = pathCompletion.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e * pathMeasure.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e\n        pathMeasure.\u003cspan class=\"hljs-title function_\"\u003egetSegment\u003c/span\u003e(0f, stopDistance, pathSegment, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e)\n\n        \u003cspan class=\"hljs-comment\"\u003e// 지정된 속성으로 현재 화살표 경로 세그먼트 그리기\u003c/span\u003e\n        \u003cspan class=\"hljs-title function_\"\u003edrawPathSegment\u003c/span\u003e(pathSegment, color, strokeWidth, strokeCap, dashLength)\n\n        \u003cspan class=\"hljs-comment\"\u003e// 경로가 일부 그려진 경우, 화살표 머리 그리기\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (pathCompletion.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e \u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n            \u003cspan class=\"hljs-title function_\"\u003edrawPointerHead\u003c/span\u003e(pathMeasure, stopDistance, pointerSize, color, pointerShape)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e축하해요 🥳! 우리 성공적으로 만들었어요 👏. 전체 코드 구현을 확인하려면 GitHub Gist에 액세스할 수 있어요 🧑‍💻. 이제 사용 방법을 알아보아요.\u003c/p\u003e\n\u003ch2\u003e광고\u003c/h2\u003e\n\u003cp\u003e외국어를 배우고 새로운 어휘로 고민하고 계신가요? 그렇다면, 여러분의 학습을 쉽고 편리하게 해줄 이 어플을 확인하는 걸 강력히 추천해요!\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003e사용법\u003c/h1\u003e\n\u003cp\u003e배치에 간단한 변형 수정자를 적용하여 화살표 포인터의 위치를 쉽게 사용자 정의할 수 있습니다. 여기에는 일반적인 시나리오가 있습니다:\u003c/p\u003e\n\u003ch2\u003e하단-우측 (기본)\u003c/h2\u003e\n\u003cp\u003e하단-우측 위치는 기본 포인팅 방향입니다:\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003eAnimatedArrowPointer(\n    modifier = Modifier.size(\u003cspan class=\"hljs-number\"\u003e140.\u003c/span\u003edp),\n    color = Color.Red\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:576/1*FM6yzByscqrfK0bihhE_6g.gif\" alt=\"Arrow Pointer\"\u003e\u003c/p\u003e\n\u003ch2\u003eTop-Right\u003c/h2\u003e\n\u003cp\u003eTo point to the top-right, rotate the layout by -90 degrees:\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003eAnimatedArrowPointer(\n    modifier = Modifier\n        .size(\u003cspan class=\"hljs-number\"\u003e140.\u003c/span\u003edp)\n        .rotate(-\u003cspan class=\"hljs-number\"\u003e90f\u003c/span\u003e),\n    color = Color.Red\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:900/1*TDE55uvzhAy-XZNn-d8bGg.gif\" alt=\"Animated Arrow Pointer\"\u003e\u003c/p\u003e\n\u003ch2\u003eBottom-Left\u003c/h2\u003e\n\u003cp\u003eBottom-Left를 가리키려면 레이아웃을 x축에서 -1f로 확장하여 수평으로 반사합니다:\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003eAnimatedArrowPointer(\n    modifier = Modifier\n        .size(\u003cspan class=\"hljs-number\"\u003e140.\u003c/span\u003edp)\n        .scale(-\u003cspan class=\"hljs-number\"\u003e1f\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1f\u003c/span\u003e),\n    color = Color.Red\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:570/1*NZ608yVkzKu7IVAwAPa8HQ.gif\" alt=\"Animated arrow pointer\"\u003e\u003c/p\u003e\n\u003ch2\u003e왼쪽 위\u003c/h2\u003e\n\u003cp\u003e왼쪽 위 방향을 위해, 먼저 레이아웃을 수평으로 반사한 다음, -90도로 회전시킵니다:\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003eAnimatedArrowPointer(\n    modifier = Modifier\n        .size(\u003cspan class=\"hljs-number\"\u003e140.\u003c/span\u003edp)\n        .scale(-\u003cspan class=\"hljs-number\"\u003e1f\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1f\u003c/span\u003e)\n        .rotate(-\u003cspan class=\"hljs-number\"\u003e90f\u003c/span\u003e),\n    color = Color.Red\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:900/1*UaIjzfaG0aaaqpSNmN4Qpw.gif\" alt=\"Animated Arrow Pointer\"\u003e\u003c/p\u003e\n\u003cp\u003e좋아할 만한 내용이 있을 것 같아요 👇\u003c/p\u003e\n\u003cp\u003e이 기사를 읽어 주셔서 감사합니다! ❤️ 즐거우시고 가치 있게 보내셨으면 좋겣습니다. 만약 좋았다면 만세 👏를 눌러서 감사를 표현해 주시고 Kappdev를 팔로우하여 더욱 흥미로운 기사를 읽어보세요 😊\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e행복한 코딩!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose"},"buildId":"bb_yO9GbCvdfc_n71SfUf","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>