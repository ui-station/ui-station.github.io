<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>국영세대 ZGC로 일시 중지 시간을 제어하세요 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="국영세대 ZGC로 일시 중지 시간을 제어하세요 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="국영세대 ZGC로 일시 중지 시간을 제어하세요 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC" data-gatsby-head="true"/><meta name="twitter:title" content="국영세대 ZGC로 일시 중지 시간을 제어하세요 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-17 17:41" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-561ae49ab5aab7f5.js" defer=""></script><script src="/_next/static/R1x9p1CQYDDJESXyLXKOK/_buildManifest.js" defer=""></script><script src="/_next/static/R1x9p1CQYDDJESXyLXKOK/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">국영세대 ZGC로 일시 중지 시간을 제어하세요</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="국영세대 ZGC로 일시 중지 시간을 제어하세요" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 17, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p>Z Garbage Collector 세대의 놀라운 혜택과 그리 놀라운 혜택.</p>
<p>Danny Thomas가 쓴 JVM 에코시스템 팀의 기사</p>
<p><img src="/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_0.png" alt="GenerationalZGC"/></p>
<p>최신 장기 지원 릴리스인 JDK는 Z Garbage Collector를 위한 세대 지원을 제공합니다. Netflix는 주요 이유로 동시 가비지 수집의 중요한 혜택을 인한 것으로, JDK 21 및 그 이후부터 G1에서 Generational ZGC로 기본 전환했습니다.</p>
<div class="content-ad"></div>
<p>저희 핵심 스트리밍 비디오 서비스 중 절반 이상이 Generational ZGC와 JDK 21에서 실행 중이에요. 이제 제 경험과 얻은 혜택에 대해 이야기할 때가 좋아졌네요. Netflix에서 Java를 어떻게 사용하는지 궁금하시다면, Paul Bakker의 강연인 &#x27;Netflix가 정말로 Java를 사용하는 방법&#x27;이 좋은 시작점이 될 거예요.</p>
<h1>Tail Latency 감소</h1>
<p>저희 GRPC와 DGS 프레임워크 서비스에서 GC 일시 중단은 Tail Latency의 중요한 원인 중 하나에요. 특히 GRPC 클라이언트와 서버에서는 시간 초과로 인한 요청 취소가 재시도, 헤징 및 폴백과 같은 신뢰성 기능과 상호작용하죠. 이러한 에러마다 요청이 취소되어 재시도되는 것인데, 이런 감소로 인해 전체 서비스 트래픽이 더욱 줄어들었어요:</p>
<p><img src="/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_1.png" alt="이미지"/></p>
<div class="content-ad"></div>
<p>잦은 일시 정지의 소음을 제거하면 실제 지연 원천을 식별할 수 있어서 그렇지 않으면 소음에 감춰져 있을 수 있습니다. 최대 일시 중지 시간 이상치는 상당히 중요할 수 있습니다:</p>
<p><img src="/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_2.png" alt="image"/></p>
<h1>효율</h1>
<p>평가 결과가 매우 유망하게 나타난 후에도 ZGC의 채택을 교환할 것으로 예상했습니다: 스토어 및 로드 버리어, 스레드 로컬 핸드셰이크에서 수행되는 작업 및 응용프로그램 자원 경합으로 인한 GC로 인해 약간의 응용프로그램 처리량이 줄어드는 경우. 우리는 그것을 수용 가능한 교환이라고 생각했는데, 일시 정지를 피함으로써 그 부가적인 오버헤드보다 더 큰 이점을 제공했습니다.</p>
<div class="content-ad"></div>
<p>사실 우리의 서비스와 아키텍처에 대해 조사한 결과, 그러한 교환이 없다는 것을 발견했습니다. 특정 CPU 활용 목표에 대해 ZGC는 G1과 비교했을 때 평균 및 P99 대기 시간을 개선하면서 CPU 활용률도 동등하거나 더 나아진다는 것을 알 수 있었습니다.</p>
<p>우리가 관찰한 많은 서비스에서 요청률, 요청 패턴, 응답 시간 및 할당률의 일관성이 ZGC를 도와주지만, ZGC가 덜 일관된 워크로드를 처리하는 능력도 뛰어나다는 것을 확인했습니다 (물론 예외는 있습니다; 자세한 내용은 아래에서 다루겠습니다).</p>
<h1>운영의 간편함</h1>
<p>서비스 소유자들은 종종 너무 긴 일시 중지 시간에 대한 질문이나 튜닝 도움을 요청합니다. 우리는 주기적으로 많은 양의 힙 데이터를 새로 고치는 여러 프레임워크를 보유하고 있어서 외부 서비스 호출을 효율적으로 피하기 위해 이를 사용합니다. 힙 데이터의 주기적 갱신으로 G1을 깜짝놀라게 하는 이러한 작업은 기본 일시 중지 시간 목표를 크게 넘는 이상값에 이르게 합니다.</p>
<div class="content-ad"></div>
<p>아래는 Markdown 형식으로 테이블을 변환한 것입니다.</p>
<p>| Feature        | Description                                                                                                                                                                                  |
|----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Generational ZGC | Improved CPU utilization by nearly 10% compared to G1 for the same workload.                                                                                                                 |
| Hollow library | Used by half of the streaming video services for on-heap metadata, which led to the removal of array pooling mitigations and saved hundreds of megabytes of memory for allocations.       |
| Operational simplicity | ZGC&#x27;s heuristics and defaults require no explicit tuning to achieve optimal results. Allocation stalls are rare and shorter than with G1.                                                        |
| Memory overhead | The long-lived on-heap data was the main reason we previously avoided non-generational ZGC, but generational ZGC helped improve the situation significantly.                                   |</p>
<div class="content-ad"></div>
<p>힙의 압축된 참조를 잃어버리기 때문에 64비트 객체 포인터가 필요한 색상 포인터 때문에 32G의 힙에서 압축된 참조를 잃어버리는 것이 가비지 콜렉터 선택의 주요 요소가 될 것으로 예상했습니다.</p>
<p>우리는 그것이 스탑-더-월드 GC들에 대해 중요한 고려 사항이긴 하지만, 작은 힙에서라도 할당 속도의 증가가 효율성과 운영 개선에 의해 상쇄된다는 점을 발견했습니다. 오라클의 Erik Österlund씨에게 감사드립니다. 동시 가비지 콜렉터에 있어서 색상 포인터의 직관적이지 않은 이점을 설명해 준 덕분에 우리는 초기 계획보다 ZGC를 더 폭넓게 평가하게 되었습니다.</p>
<p>대부분의 경우 ZGC는 응용 프로그램에 더 많은 메모리를 일관되게 제공할 수도 있습니다.</p>
<div class="content-ad"></div>
<p>ZGC는 힙 크기의 3%에 대한 고정 오버헤드가 있어 G1보다 더 많은 원시 메모리를 필요로 합니다. 몇 가지 예외를 제외하고는 더 많은 여유 공간을 위해 최대 힙 크기를 낮출 필요가 없었으며, 그것들은 평균 이상의 원시 메모리 요구가 있는 서비스들이었습니다.</p>
<p>참조 처리는 또한 ZGC에서 주요 콜렉션 시에만 수행됩니다. 직접 바이트 버퍼의 할당 해제에 특히 주의를 기울였지만, 지금까지는 영향을 볼 수 없었습니다. 이 참조 처리의 차이로 JSON 쓰레드 덤프 지원에서 성능 문제가 발생했지만, 이것은 프레임워크가 실수로 각 요청마다 사용되지 않는 ExecutorService 인스턴스를 생성하여 발생한 특이한 상황입니다.</p>
<h1>Transparent huge pages</h1>
<p>ZGC를 사용하지 않더라도 거대 페이지를 사용해야 할 것입니다. 투명 거대 페이지가 그들을 사용하는 가장 편리한 방법입니다.</p>
<div class="content-ad"></div>
<p>ZGC는 힙에 대해 공유 메모리를 사용하며, 많은 Linux 배포판에서는 shmem_enabled를 &#x27;never&#x27;로 설정하여 -XX:+UseTransparentHugePages를 사용하는 경우 ZGC가 거대 페이지를 사용하지 못하게 만듭니다.</p>
<p>이렇게 변경된 부분을 제외하고 아무런 변경 없이 배포된 서비스가 있습니다. shmem_enabled가 &#x27;never&#x27;에서 &#x27;advise&#x27;로 변경되면 CPU 사용률이 저하되었습니다.</p>
<p>아래는 기본 구성입니다:</p>
<p><img src="/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_4.png" alt="이미지"/></p>
<p>저희의 기본 구성:</p>
<div class="content-ad"></div>
<ul>
<li>힙의 최소 및 최대를 같은 크기로 설정합니다.</li>
<li>-XX:+UseTransparentHugePages -XX:+AlwaysPreTouch을 구성합니다.</li>
<li>다음과 같은 transparent_hugepage 구성을 사용합니다:</li>
</ul>
<pre><code class="hljs language-js">echo madvise | sudo tee /sys/kernel/mm/transparent_hugepage/enabled
echo advise | sudo tee /sys/kernel/mm/transparent_hugepage/shmem_enabled
echo defer | sudo tee /sys/kernel/mm/transparent_hugepage/defrag
echo <span class="hljs-number">1</span> | sudo tee /sys/kernel/mm/transparent_hugepage/khugepaged/defrag
</code></pre>
<h1>어떤 워크로드가 적합하지 않았나요?</h1>
<p>가장 좋은 가비지 컬렉터는 없습니다. 각각은 가비지 컬렉터의 목표에 따라 콜렉션 처리량, 응용프로그램 대기 시간 및 자원 이용을 교환합니다.</p>
<div class="content-ad"></div>
<p>G1 대비 ZGC에서 더 나은 성능을 보인 작업 부하들은 대부분 처리량을 중심으로 한 경향이 있습니다. 매우 변덕스러운 할당 속도와 예측할 수 없는 기간 동안 객체를 보유하는 장기 실행 작업들이 포함되어 있습니다.</p>
<p>한 가지 주목할만한 예시는 매우 변덕스러운 할당 속도와 많은 수의 고수명 객체를 가진 서비스였는데, 이는 G1의 일시 중지 시간 목표와 오래된 영역 수집 휴리스틱에 특히 적합했습니다. G1이 ZGC가 처리하지 못한 GC 사이클의 비생산적인 작업을 피할 수 있게 해주었습니다.</p>
<p>기본적으로 ZGC로 전환함으로써 응용프로그램 소유자들이 가비지 수집기의 선택에 대해 고민할 수 있는 좋은 기회가 제공되었습니다. G1을 기본으로 사용하던 여러 배치/준비 계산 사례들이 병렬 수집기로부터 더 나은 처리량을 얻었을 것입니다. 대규모 준비 계산 작업에서는 G1 대비 응용프로그램 처리량이 6~8% 향상되어 배치 시간이 한 시간 단축되는 것을 확인할 수 있었습니다.</p>
<h1>직접 해보세요!</h1>
<div class="content-ad"></div>
<p>가정과 기대를 의심하지 않으면, 우리는 10년 동안 우리의 운영 기본 설정 중 가장 영향력 있는 변화 중 하나를 놓치게 될 수 있습니다. 우리는 여러분께 직접 제너레이셔널 ZGC를 시도해 보라고 권장합니다. 여러분에게 우리가 놀란 만큼 놀라운 경험을 줄 수도 있습니다.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"국영세대 ZGC로 일시 중지 시간을 제어하세요","description":"","date":"2024-05-17 17:41","slug":"2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC","content":"\n\nZ Garbage Collector 세대의 놀라운 혜택과 그리 놀라운 혜택.\n\nDanny Thomas가 쓴 JVM 에코시스템 팀의 기사\n\n![GenerationalZGC](/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_0.png)\n\n최신 장기 지원 릴리스인 JDK는 Z Garbage Collector를 위한 세대 지원을 제공합니다. Netflix는 주요 이유로 동시 가비지 수집의 중요한 혜택을 인한 것으로, JDK 21 및 그 이후부터 G1에서 Generational ZGC로 기본 전환했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 핵심 스트리밍 비디오 서비스 중 절반 이상이 Generational ZGC와 JDK 21에서 실행 중이에요. 이제 제 경험과 얻은 혜택에 대해 이야기할 때가 좋아졌네요. Netflix에서 Java를 어떻게 사용하는지 궁금하시다면, Paul Bakker의 강연인 'Netflix가 정말로 Java를 사용하는 방법'이 좋은 시작점이 될 거예요.\n\n# Tail Latency 감소\n\n저희 GRPC와 DGS 프레임워크 서비스에서 GC 일시 중단은 Tail Latency의 중요한 원인 중 하나에요. 특히 GRPC 클라이언트와 서버에서는 시간 초과로 인한 요청 취소가 재시도, 헤징 및 폴백과 같은 신뢰성 기능과 상호작용하죠. 이러한 에러마다 요청이 취소되어 재시도되는 것인데, 이런 감소로 인해 전체 서비스 트래픽이 더욱 줄어들었어요: \n\n![이미지](/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잦은 일시 정지의 소음을 제거하면 실제 지연 원천을 식별할 수 있어서 그렇지 않으면 소음에 감춰져 있을 수 있습니다. 최대 일시 중지 시간 이상치는 상당히 중요할 수 있습니다:\n\n![image](/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_2.png)\n\n# 효율\n\n평가 결과가 매우 유망하게 나타난 후에도 ZGC의 채택을 교환할 것으로 예상했습니다: 스토어 및 로드 버리어, 스레드 로컬 핸드셰이크에서 수행되는 작업 및 응용프로그램 자원 경합으로 인한 GC로 인해 약간의 응용프로그램 처리량이 줄어드는 경우. 우리는 그것을 수용 가능한 교환이라고 생각했는데, 일시 정지를 피함으로써 그 부가적인 오버헤드보다 더 큰 이점을 제공했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사실 우리의 서비스와 아키텍처에 대해 조사한 결과, 그러한 교환이 없다는 것을 발견했습니다. 특정 CPU 활용 목표에 대해 ZGC는 G1과 비교했을 때 평균 및 P99 대기 시간을 개선하면서 CPU 활용률도 동등하거나 더 나아진다는 것을 알 수 있었습니다.\n\n우리가 관찰한 많은 서비스에서 요청률, 요청 패턴, 응답 시간 및 할당률의 일관성이 ZGC를 도와주지만, ZGC가 덜 일관된 워크로드를 처리하는 능력도 뛰어나다는 것을 확인했습니다 (물론 예외는 있습니다; 자세한 내용은 아래에서 다루겠습니다).\n\n# 운영의 간편함\n\n서비스 소유자들은 종종 너무 긴 일시 중지 시간에 대한 질문이나 튜닝 도움을 요청합니다. 우리는 주기적으로 많은 양의 힙 데이터를 새로 고치는 여러 프레임워크를 보유하고 있어서 외부 서비스 호출을 효율적으로 피하기 위해 이를 사용합니다. 힙 데이터의 주기적 갱신으로 G1을 깜짝놀라게 하는 이러한 작업은 기본 일시 중지 시간 목표를 크게 넘는 이상값에 이르게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 테이블을 변환한 것입니다.\n\n\n| Feature        | Description                                                                                                                                                                                  |\n|----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| Generational ZGC | Improved CPU utilization by nearly 10% compared to G1 for the same workload.                                                                                                                 |\n| Hollow library | Used by half of the streaming video services for on-heap metadata, which led to the removal of array pooling mitigations and saved hundreds of megabytes of memory for allocations.       |\n| Operational simplicity | ZGC's heuristics and defaults require no explicit tuning to achieve optimal results. Allocation stalls are rare and shorter than with G1.                                                        |\n| Memory overhead | The long-lived on-heap data was the main reason we previously avoided non-generational ZGC, but generational ZGC helped improve the situation significantly.                                   |\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n힙의 압축된 참조를 잃어버리기 때문에 64비트 객체 포인터가 필요한 색상 포인터 때문에 32G의 힙에서 압축된 참조를 잃어버리는 것이 가비지 콜렉터 선택의 주요 요소가 될 것으로 예상했습니다.\n\n우리는 그것이 스탑-더-월드 GC들에 대해 중요한 고려 사항이긴 하지만, 작은 힙에서라도 할당 속도의 증가가 효율성과 운영 개선에 의해 상쇄된다는 점을 발견했습니다. 오라클의 Erik Österlund씨에게 감사드립니다. 동시 가비지 콜렉터에 있어서 색상 포인터의 직관적이지 않은 이점을 설명해 준 덕분에 우리는 초기 계획보다 ZGC를 더 폭넓게 평가하게 되었습니다.\n\n대부분의 경우 ZGC는 응용 프로그램에 더 많은 메모리를 일관되게 제공할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nZGC는 힙 크기의 3%에 대한 고정 오버헤드가 있어 G1보다 더 많은 원시 메모리를 필요로 합니다. 몇 가지 예외를 제외하고는 더 많은 여유 공간을 위해 최대 힙 크기를 낮출 필요가 없었으며, 그것들은 평균 이상의 원시 메모리 요구가 있는 서비스들이었습니다.\n\n참조 처리는 또한 ZGC에서 주요 콜렉션 시에만 수행됩니다. 직접 바이트 버퍼의 할당 해제에 특히 주의를 기울였지만, 지금까지는 영향을 볼 수 없었습니다. 이 참조 처리의 차이로 JSON 쓰레드 덤프 지원에서 성능 문제가 발생했지만, 이것은 프레임워크가 실수로 각 요청마다 사용되지 않는 ExecutorService 인스턴스를 생성하여 발생한 특이한 상황입니다.\n\n# Transparent huge pages\n\nZGC를 사용하지 않더라도 거대 페이지를 사용해야 할 것입니다. 투명 거대 페이지가 그들을 사용하는 가장 편리한 방법입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nZGC는 힙에 대해 공유 메모리를 사용하며, 많은 Linux 배포판에서는 shmem_enabled를 'never'로 설정하여 -XX:+UseTransparentHugePages를 사용하는 경우 ZGC가 거대 페이지를 사용하지 못하게 만듭니다.\n\n이렇게 변경된 부분을 제외하고 아무런 변경 없이 배포된 서비스가 있습니다. shmem_enabled가 'never'에서 'advise'로 변경되면 CPU 사용률이 저하되었습니다.\n\n아래는 기본 구성입니다:\n\n![이미지](/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_4.png)\n\n저희의 기본 구성:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 힙의 최소 및 최대를 같은 크기로 설정합니다.\n- -XX:+UseTransparentHugePages -XX:+AlwaysPreTouch을 구성합니다.\n- 다음과 같은 transparent_hugepage 구성을 사용합니다:\n\n```js\necho madvise | sudo tee /sys/kernel/mm/transparent_hugepage/enabled\necho advise | sudo tee /sys/kernel/mm/transparent_hugepage/shmem_enabled\necho defer | sudo tee /sys/kernel/mm/transparent_hugepage/defrag\necho 1 | sudo tee /sys/kernel/mm/transparent_hugepage/khugepaged/defrag\n```\n\n# 어떤 워크로드가 적합하지 않았나요?\n\n가장 좋은 가비지 컬렉터는 없습니다. 각각은 가비지 컬렉터의 목표에 따라 콜렉션 처리량, 응용프로그램 대기 시간 및 자원 이용을 교환합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nG1 대비 ZGC에서 더 나은 성능을 보인 작업 부하들은 대부분 처리량을 중심으로 한 경향이 있습니다. 매우 변덕스러운 할당 속도와 예측할 수 없는 기간 동안 객체를 보유하는 장기 실행 작업들이 포함되어 있습니다.\n\n한 가지 주목할만한 예시는 매우 변덕스러운 할당 속도와 많은 수의 고수명 객체를 가진 서비스였는데, 이는 G1의 일시 중지 시간 목표와 오래된 영역 수집 휴리스틱에 특히 적합했습니다. G1이 ZGC가 처리하지 못한 GC 사이클의 비생산적인 작업을 피할 수 있게 해주었습니다.\n\n기본적으로 ZGC로 전환함으로써 응용프로그램 소유자들이 가비지 수집기의 선택에 대해 고민할 수 있는 좋은 기회가 제공되었습니다. G1을 기본으로 사용하던 여러 배치/준비 계산 사례들이 병렬 수집기로부터 더 나은 처리량을 얻었을 것입니다. 대규모 준비 계산 작업에서는 G1 대비 응용프로그램 처리량이 6~8% 향상되어 배치 시간이 한 시간 단축되는 것을 확인할 수 있었습니다.\n\n# 직접 해보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가정과 기대를 의심하지 않으면, 우리는 10년 동안 우리의 운영 기본 설정 중 가장 영향력 있는 변화 중 하나를 놓치게 될 수 있습니다. 우리는 여러분께 직접 제너레이셔널 ZGC를 시도해 보라고 권장합니다. 여러분에게 우리가 놀란 만큼 놀라운 경험을 줄 수도 있습니다.","ogImage":{"url":"/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_0.png"},"coverImage":"/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_0.png","tag":["Tech"],"readingTime":6},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Z Garbage Collector 세대의 놀라운 혜택과 그리 놀라운 혜택.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Danny Thomas가 쓴 JVM 에코시스템 팀의 기사\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_0.png\",\n        alt: \"GenerationalZGC\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"최신 장기 지원 릴리스인 JDK는 Z Garbage Collector를 위한 세대 지원을 제공합니다. Netflix는 주요 이유로 동시 가비지 수집의 중요한 혜택을 인한 것으로, JDK 21 및 그 이후부터 G1에서 Generational ZGC로 기본 전환했습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저희 핵심 스트리밍 비디오 서비스 중 절반 이상이 Generational ZGC와 JDK 21에서 실행 중이에요. 이제 제 경험과 얻은 혜택에 대해 이야기할 때가 좋아졌네요. Netflix에서 Java를 어떻게 사용하는지 궁금하시다면, Paul Bakker의 강연인 'Netflix가 정말로 Java를 사용하는 방법'이 좋은 시작점이 될 거예요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Tail Latency 감소\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저희 GRPC와 DGS 프레임워크 서비스에서 GC 일시 중단은 Tail Latency의 중요한 원인 중 하나에요. 특히 GRPC 클라이언트와 서버에서는 시간 초과로 인한 요청 취소가 재시도, 헤징 및 폴백과 같은 신뢰성 기능과 상호작용하죠. 이러한 에러마다 요청이 취소되어 재시도되는 것인데, 이런 감소로 인해 전체 서비스 트래픽이 더욱 줄어들었어요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_1.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"잦은 일시 정지의 소음을 제거하면 실제 지연 원천을 식별할 수 있어서 그렇지 않으면 소음에 감춰져 있을 수 있습니다. 최대 일시 중지 시간 이상치는 상당히 중요할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_2.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"효율\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"평가 결과가 매우 유망하게 나타난 후에도 ZGC의 채택을 교환할 것으로 예상했습니다: 스토어 및 로드 버리어, 스레드 로컬 핸드셰이크에서 수행되는 작업 및 응용프로그램 자원 경합으로 인한 GC로 인해 약간의 응용프로그램 처리량이 줄어드는 경우. 우리는 그것을 수용 가능한 교환이라고 생각했는데, 일시 정지를 피함으로써 그 부가적인 오버헤드보다 더 큰 이점을 제공했습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사실 우리의 서비스와 아키텍처에 대해 조사한 결과, 그러한 교환이 없다는 것을 발견했습니다. 특정 CPU 활용 목표에 대해 ZGC는 G1과 비교했을 때 평균 및 P99 대기 시간을 개선하면서 CPU 활용률도 동등하거나 더 나아진다는 것을 알 수 있었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리가 관찰한 많은 서비스에서 요청률, 요청 패턴, 응답 시간 및 할당률의 일관성이 ZGC를 도와주지만, ZGC가 덜 일관된 워크로드를 처리하는 능력도 뛰어나다는 것을 확인했습니다 (물론 예외는 있습니다; 자세한 내용은 아래에서 다루겠습니다).\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"운영의 간편함\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"서비스 소유자들은 종종 너무 긴 일시 중지 시간에 대한 질문이나 튜닝 도움을 요청합니다. 우리는 주기적으로 많은 양의 힙 데이터를 새로 고치는 여러 프레임워크를 보유하고 있어서 외부 서비스 호출을 효율적으로 피하기 위해 이를 사용합니다. 힙 데이터의 주기적 갱신으로 G1을 깜짝놀라게 하는 이러한 작업은 기본 일시 중지 시간 목표를 크게 넘는 이상값에 이르게 합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래는 Markdown 형식으로 테이블을 변환한 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"| Feature        | Description                                                                                                                                                                                  |\\n|----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\\n| Generational ZGC | Improved CPU utilization by nearly 10% compared to G1 for the same workload.                                                                                                                 |\\n| Hollow library | Used by half of the streaming video services for on-heap metadata, which led to the removal of array pooling mitigations and saved hundreds of megabytes of memory for allocations.       |\\n| Operational simplicity | ZGC's heuristics and defaults require no explicit tuning to achieve optimal results. Allocation stalls are rare and shorter than with G1.                                                        |\\n| Memory overhead | The long-lived on-heap data was the main reason we previously avoided non-generational ZGC, but generational ZGC helped improve the situation significantly.                                   |\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"힙의 압축된 참조를 잃어버리기 때문에 64비트 객체 포인터가 필요한 색상 포인터 때문에 32G의 힙에서 압축된 참조를 잃어버리는 것이 가비지 콜렉터 선택의 주요 요소가 될 것으로 예상했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 그것이 스탑-더-월드 GC들에 대해 중요한 고려 사항이긴 하지만, 작은 힙에서라도 할당 속도의 증가가 효율성과 운영 개선에 의해 상쇄된다는 점을 발견했습니다. 오라클의 Erik Österlund씨에게 감사드립니다. 동시 가비지 콜렉터에 있어서 색상 포인터의 직관적이지 않은 이점을 설명해 준 덕분에 우리는 초기 계획보다 ZGC를 더 폭넓게 평가하게 되었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"대부분의 경우 ZGC는 응용 프로그램에 더 많은 메모리를 일관되게 제공할 수도 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ZGC는 힙 크기의 3%에 대한 고정 오버헤드가 있어 G1보다 더 많은 원시 메모리를 필요로 합니다. 몇 가지 예외를 제외하고는 더 많은 여유 공간을 위해 최대 힙 크기를 낮출 필요가 없었으며, 그것들은 평균 이상의 원시 메모리 요구가 있는 서비스들이었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"참조 처리는 또한 ZGC에서 주요 콜렉션 시에만 수행됩니다. 직접 바이트 버퍼의 할당 해제에 특히 주의를 기울였지만, 지금까지는 영향을 볼 수 없었습니다. 이 참조 처리의 차이로 JSON 쓰레드 덤프 지원에서 성능 문제가 발생했지만, 이것은 프레임워크가 실수로 각 요청마다 사용되지 않는 ExecutorService 인스턴스를 생성하여 발생한 특이한 상황입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Transparent huge pages\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ZGC를 사용하지 않더라도 거대 페이지를 사용해야 할 것입니다. 투명 거대 페이지가 그들을 사용하는 가장 편리한 방법입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ZGC는 힙에 대해 공유 메모리를 사용하며, 많은 Linux 배포판에서는 shmem_enabled를 'never'로 설정하여 -XX:+UseTransparentHugePages를 사용하는 경우 ZGC가 거대 페이지를 사용하지 못하게 만듭니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이렇게 변경된 부분을 제외하고 아무런 변경 없이 배포된 서비스가 있습니다. shmem_enabled가 'never'에서 'advise'로 변경되면 CPU 사용률이 저하되었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래는 기본 구성입니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_4.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저희의 기본 구성:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"힙의 최소 및 최대를 같은 크기로 설정합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"-XX:+UseTransparentHugePages -XX:+AlwaysPreTouch을 구성합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"다음과 같은 transparent_hugepage 구성을 사용합니다:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"echo madvise | sudo tee /sys/kernel/mm/transparent_hugepage/enabled\\necho advise | sudo tee /sys/kernel/mm/transparent_hugepage/shmem_enabled\\necho defer | sudo tee /sys/kernel/mm/transparent_hugepage/defrag\\necho \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" | sudo tee /sys/kernel/mm/transparent_hugepage/khugepaged/defrag\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"어떤 워크로드가 적합하지 않았나요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"가장 좋은 가비지 컬렉터는 없습니다. 각각은 가비지 컬렉터의 목표에 따라 콜렉션 처리량, 응용프로그램 대기 시간 및 자원 이용을 교환합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"G1 대비 ZGC에서 더 나은 성능을 보인 작업 부하들은 대부분 처리량을 중심으로 한 경향이 있습니다. 매우 변덕스러운 할당 속도와 예측할 수 없는 기간 동안 객체를 보유하는 장기 실행 작업들이 포함되어 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"한 가지 주목할만한 예시는 매우 변덕스러운 할당 속도와 많은 수의 고수명 객체를 가진 서비스였는데, 이는 G1의 일시 중지 시간 목표와 오래된 영역 수집 휴리스틱에 특히 적합했습니다. G1이 ZGC가 처리하지 못한 GC 사이클의 비생산적인 작업을 피할 수 있게 해주었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"기본적으로 ZGC로 전환함으로써 응용프로그램 소유자들이 가비지 수집기의 선택에 대해 고민할 수 있는 좋은 기회가 제공되었습니다. G1을 기본으로 사용하던 여러 배치/준비 계산 사례들이 병렬 수집기로부터 더 나은 처리량을 얻었을 것입니다. 대규모 준비 계산 작업에서는 G1 대비 응용프로그램 처리량이 6~8% 향상되어 배치 시간이 한 시간 단축되는 것을 확인할 수 있었습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"직접 해보세요!\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"가정과 기대를 의심하지 않으면, 우리는 10년 동안 우리의 운영 기본 설정 중 가장 영향력 있는 변화 중 하나를 놓치게 될 수 있습니다. 우리는 여러분께 직접 제너레이셔널 ZGC를 시도해 보라고 권장합니다. 여러분에게 우리가 놀란 만큼 놀라운 경험을 줄 수도 있습니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC"},"buildId":"R1x9p1CQYDDJESXyLXKOK","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>