<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>다중 환경에서 Terraform을 사용하여 AWS Lambda 함수를 배포하는 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="다중 환경에서 Terraform을 사용하여 AWS Lambda 함수를 배포하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="다중 환경에서 Terraform을 사용하여 AWS Lambda 함수를 배포하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform" data-gatsby-head="true"/><meta name="twitter:title" content="다중 환경에서 Terraform을 사용하여 AWS Lambda 함수를 배포하는 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 13:38" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_buildManifest.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">다중 환경에서 Terraform을 사용하여 AWS Lambda 함수를 배포하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="다중 환경에서 Terraform을 사용하여 AWS Lambda 함수를 배포하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>여러 환경에 걸쳐 AWS Lambda 함수를 배포하는 방법 배우기 — Hashicorp Terraform을 통해 가능하게 하기</h2>
<p><img src="/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_0.png" alt="이미지"></p>
<p>AWS Lambda는 서버를 프로비저닝하거나 관리하지 않고 코드를 실행할 수 있는 서버리스 컴퓨팅 서비스로, 배포 프로세스를 간소화하고 비즈니스가 자동으로 확장할 수 있게 합니다. 그러나 특히 여러 환경에 걸쳐 Lambda 함수를 배포하는 것은 개발 라이프사이클을 복잡하게 만들 수 있는 특정한 도전을 야기합니다.</p>
<h1>Lambda 배포 도전</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>AWS 람다 함수를 배포하는 가장 기본적인 방법은 주로 AWS 관리 콘솔을 통해 zip 파일을 수동으로 업로드하거나 AWS CLI 명령을 사용하는 것입니다. 그러나 이 방법은 몇 가지 어려움을 야기할 수 있습니다:</p>
<ul>
<li>일관성 문제: 수동 프로세스는 실수하기 쉽습니다. 개발, 테스트 및 프로덕션 환경을 거치는 반복 배포가 신중하게 관리되지 않으면 일관성 문제를 야기할 수 있습니다.</li>
<li>확장성 제한: 애플리케이션이 성장함에 따라 여러 함수를 수동으로 관리하는 것은 다루기 어렵고 실수를 유발할 수 있습니다.</li>
<li>구성 관리: 다른 환경(예: 개발, 스테이징, 프로덕션)에 대한 다른 구성을 수동으로 처리하는 것은 복잡하며 구성 드리프트를 야기할 수 있습니다.</li>
<li>버전 관리: 수동 배포는 기본적으로 버전 관리를 지원하지 않으며, 변경 사항을 추적하거나 이전 버전의 함수로 롤백하는 것이 어려울 수 있습니다.</li>
</ul>
<h1>Terraform을 활용하여 다중 환경 도전을 해결하기</h1>
<p>개발, 스테이징, 프로덕션과 같은 여러 환경에 걸쳐 람다 함수를 배포하려면 구성 및 인프라를 일관되게 처리하는 전략이 필요합니다. 이것이 Terraform이 이러한 문제들에 대처하는 방법입니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>인프라스트럭처를 코드로 정의함으로써 Terraform은 배포가 다양한 환경에서 반복 가능하고 일관성 있게 이루어지도록 합니다. 이는 "내 컴퓨터에서는 작동한다" 문제를 제거합니다.</li>
<li>환경 분리: Terraform은 워크스페이스나 변수 파일을 활용하여 동일한 코드로 여러 환경을 관리할 수 있습니다. 각 환경은 Terraform의 상태 파일을 통해 구성을 관리함으로써 격리를 보장하고 교차 환경 오염의 위험을 최소화합니다.</li>
<li>자동화된 배포: Terraform은 자원 생성, 수정 및 삭제 과정을 자동화하여 인간 에러 가능성을 줄이고 효율성을 높입니다.</li>
<li>변경 관리와 버전 관리: Terraform을 사용하면 모든 변경 사항이 버전 관리되고 적용되기 전에 검토되어 수정 사항에 대한 감사 트레일을 제공하고 쉬운 롤백 매커니즘을 제공합니다.</li>
</ul>
<h1>Terraform을 활용한 실용적인 구현</h1>
<p>제공된 Terraform 코드는 Lambda 함수용 필요한 인프라를 설정하는 방법을 보여줍니다. IAM 역할, 정책, 그리고 Lambda 함수 자체를 구성하고 Terraform 변수를 사용하여 환경별 구성을 설정합니다.
AWS Terraform 프로바이더에 익숙하지 않은 경우, Terraform을 AWS에 연결하는 방법을 이해하기 위해 해당 문서를 읽어보세요.</p>
<ol>
<li>IAM 역할 및 정책 설정</li>
</ol>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>람다 함수는 다른 AWS 리소스와 상호작용할 것입니다. 이를 위해 IAM 역할을 가정해야 합니다. 먼저 해당 역할을 만들어 봅시다.</p>
<pre><code class="hljs language-js"># 람다 함수가 가정할 <span class="hljs-variable constant_">IAM</span> 역할을 정의합니다.
resource <span class="hljs-string">"aws_iam_role"</span> <span class="hljs-string">"lambda_role"</span> {
  name               = <span class="hljs-string">"lambda_function_role"</span>
  assume_role_policy = &#x3C;&#x3C;<span class="hljs-variable constant_">EOF</span>
{
  <span class="hljs-string">"Version"</span>: <span class="hljs-string">"2012-10-17"</span>,
  <span class="hljs-string">"Statement"</span>: [
    {
      <span class="hljs-string">"Action"</span>: <span class="hljs-string">"sts:AssumeRole"</span>,
      <span class="hljs-string">"Principal"</span>: {
        <span class="hljs-string">"Service"</span>: <span class="hljs-string">"lambda.amazonaws.com"</span>
      },
      <span class="hljs-string">"Effect"</span>: <span class="hljs-string">"Allow"</span>,
      <span class="hljs-string">"Sid"</span>: <span class="hljs-string">""</span>
    }
  ]
}
<span class="hljs-variable constant_">EOF</span>
}
</code></pre>
<h2>설명</h2>
<p>이 IAM 역할을 생성하고 해당 가정 역할 정책을 첨부함으로써, 람다 함수가 이 역할을 가정할 수 있게 합니다. 즉, 람다 함수는 이 역할과 관련된 권한을 사용하여 다른 AWS 리소스와 상호작용할 수 있습니다. 예를 들어, 이 역할에 S3 버킷에 액세스를 허용하는 정책을 첨부하면, 람다 함수는 이 역할을 사용하여 해당 버킷에서 읽거나 쓰는 작업을 수행할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_1.png">
<p>참고: 본 튜토리얼에서는 환경 변수가 어떻게 사용되는지 간단하게 알 수 있도록 실제 버킷과 AWS 정책은 사용하지 않습니다. 하지만 다음 기사에서 사용할 예정입니다.</p>
<h1>람다 함수 배포</h1>
<p>환경에 따라 다른 변수를 출력하는 기본 "Hello World!" 파이썬 함수를 배포할 것입니다. 람다 패키지는 두 개의 파일로 구성됩니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"># index.<span class="hljs-property">py</span>, 핸들러가 있는 곳입니다
<span class="hljs-keyword">from</span> config <span class="hljs-keyword">import</span> <span class="hljs-variable constant_">BUCKET_NAME</span>

def <span class="hljs-title function_">lambda_handler</span>(event, context):
   message = f<span class="hljs-string">"버킷 사용 중: {BUCKET_NAME}"</span>
   <span class="hljs-keyword">return</span> {
       <span class="hljs-string">'message'</span> : message
   }
</code></pre>
<pre><code class="hljs language-js"># config.<span class="hljs-property">py</span>, 환경 변수를 가져와 다른 구성을 할 수 있습니다
<span class="hljs-keyword">import</span> os

# 지정되지 않은 경우 <span class="hljs-string">'mybucket'</span>으로 기본 설정
<span class="hljs-variable constant_">BUCKET_NAME</span> = os.<span class="hljs-title function_">getenv</span>(<span class="hljs-string">'BUCKET_NAME'</span>, <span class="hljs-string">'mybucket'</span>)
</code></pre>
<p>먼저, Lambda 함수 코드가 있는 "code" 폴더를 압축하여 배포에 사용할 ZIP 파일로 만들기 위해 Terraform 아카이브 파일 데이터 원본을 정의할 것입니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Lambda</span> 배포를 위해 <span class="hljs-title class_">Python</span> 코드를 zip 파일로 묶습니다.
data <span class="hljs-string">"archive_file"</span> <span class="hljs-string">"zip_the_code"</span> {
  type        = <span class="hljs-string">"zip"</span>
  source_dir  = <span class="hljs-string">"./code/"</span>
  output_path = <span class="hljs-string">"./code/test-terraform.zip"</span>
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 화면 구조를 명확하게하기 위해 스크린샷을 여기에 넣었습니다.</p>
<p><img src="/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_2.png" alt="폴더 구조 이미지"></p>
<p>이제 우리는 람다 자원을 생성하기 위해 출력을 사용할 수 있습니다. 여기서 source_code_hash 속성이 매우 중요합니다. 소스 코드 해시 덕분에 Terraform이 코드의 변경을 감지할 수 있습니다.</p>
<pre><code class="hljs language-js"># 환경별 변수로 <span class="hljs-title class_">Lambda</span> 함수를 배포합니다.
resource <span class="hljs-string">"aws_lambda_function"</span> <span class="hljs-string">"terraform_lambda_func"</span> {
  filename         = data.<span class="hljs-property">archive_file</span>.<span class="hljs-property">zip_the_code</span>.<span class="hljs-property">output_path</span>
  function_name    = <span class="hljs-string">"MyLambdaFunction"</span>
  role             = aws_iam_role.<span class="hljs-property">lambda_role</span>.<span class="hljs-property">arn</span>
  handler          = <span class="hljs-string">"index.lambda_handler"</span>
  source_code_hash = data.<span class="hljs-property">archive_file</span>.<span class="hljs-property">zip_the_code</span>.<span class="hljs-property">output_base64sha256</span>
  runtime          = <span class="hljs-string">"python3.8"</span>
  environment {
    variables = {
      <span class="hljs-variable constant_">BUCKET_NAME</span> = <span class="hljs-keyword">var</span>.<span class="hljs-property">BUCKET_NAME</span>
    }
  }
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>여기서 주요 요소는 환경 블록입니다. 이 블록을 정의함으로써 AWS Lambda가 실행 중에 읽을 수 있는 환경 변수인 BUCKET_NAME의 값을 지정할 수 있습니다.</p>
<h1>여러 환경 관리</h1>
<p>여러 환경을 관리하는 방법으로는 Terraform 워크스페이스를 사용하거나 서로 다른 변수 파일로 Terraform을 실행하여 각 환경별로 리소스를 분리하고 상태를 별도로 관리하는 데 도움이 됩니다:</p>
<pre><code class="hljs language-js"># 새 워크스페이스를 생성하고 개발 환경을 위한 리소스를 배포합니다.
terraform workspace <span class="hljs-keyword">new</span> development
terraform apply -<span class="hljs-keyword">var</span>=<span class="hljs-string">"BUCKET_NAME=dev-bucket"</span>

# 프로덕션 워크스페이스로 전환하고 리소스를 배포합니다.
terraform workspace <span class="hljs-keyword">new</span> production
terraform apply -<span class="hljs-keyword">var</span>=<span class="hljs-string">"BUCKET_NAME=prod-bucket"</span>
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>가끔은 많은 환경 변수를 정의해야 할 때가 있습니다. 그럴 땐 환경에 따라 다른 테라폼 변수 파일을 가리킬 수 있습니다.</p>
<h2>예시</h2>
<pre><code class="hljs language-js">terraform apply -<span class="hljs-keyword">var</span>-file=<span class="hljs-string">"dev-variables.tfvars"</span>
terraform apply -<span class="hljs-keyword">var</span>-file=<span class="hljs-string">"prod-variables.tfvars"</span>
</code></pre>
<h2>결론</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>AWS Lambda 함수를 여러 환경에 배포하기 위해 Terraform을 사용하면 배포를 표준화하고 서버리스 애플리케이션을 간단하게 관리할 수 있어요.</p>
<p>다음에는 GitHub 액션, CSV 파일 및 적절한 폴더 구조를 사용하여 오늘 본 개념과 기술을 어떻게 제품화하는지 보여 드릴게요.</p>
<p>읽어 주셔서 감사합니다. 저는 Infostrux의 데이터 아키텍트인 Mehdi Sidi Boumedine입니다. LinkedIn에서 저와 연락하거나 팔로우하고 Infostrux 블로그의 최신 기고를 확인해 주세요. 다음 글도 기대해 주세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"다중 환경에서 Terraform을 사용하여 AWS Lambda 함수를 배포하는 방법","description":"","date":"2024-06-19 13:38","slug":"2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform","content":"\n## 여러 환경에 걸쳐 AWS Lambda 함수를 배포하는 방법 배우기 — Hashicorp Terraform을 통해 가능하게 하기\n\n![이미지](/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_0.png)\n\nAWS Lambda는 서버를 프로비저닝하거나 관리하지 않고 코드를 실행할 수 있는 서버리스 컴퓨팅 서비스로, 배포 프로세스를 간소화하고 비즈니스가 자동으로 확장할 수 있게 합니다. 그러나 특히 여러 환경에 걸쳐 Lambda 함수를 배포하는 것은 개발 라이프사이클을 복잡하게 만들 수 있는 특정한 도전을 야기합니다.\n\n# Lambda 배포 도전\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAWS 람다 함수를 배포하는 가장 기본적인 방법은 주로 AWS 관리 콘솔을 통해 zip 파일을 수동으로 업로드하거나 AWS CLI 명령을 사용하는 것입니다. 그러나 이 방법은 몇 가지 어려움을 야기할 수 있습니다:\n\n- 일관성 문제: 수동 프로세스는 실수하기 쉽습니다. 개발, 테스트 및 프로덕션 환경을 거치는 반복 배포가 신중하게 관리되지 않으면 일관성 문제를 야기할 수 있습니다.\n- 확장성 제한: 애플리케이션이 성장함에 따라 여러 함수를 수동으로 관리하는 것은 다루기 어렵고 실수를 유발할 수 있습니다.\n- 구성 관리: 다른 환경(예: 개발, 스테이징, 프로덕션)에 대한 다른 구성을 수동으로 처리하는 것은 복잡하며 구성 드리프트를 야기할 수 있습니다.\n- 버전 관리: 수동 배포는 기본적으로 버전 관리를 지원하지 않으며, 변경 사항을 추적하거나 이전 버전의 함수로 롤백하는 것이 어려울 수 있습니다.\n\n# Terraform을 활용하여 다중 환경 도전을 해결하기\n\n개발, 스테이징, 프로덕션과 같은 여러 환경에 걸쳐 람다 함수를 배포하려면 구성 및 인프라를 일관되게 처리하는 전략이 필요합니다. 이것이 Terraform이 이러한 문제들에 대처하는 방법입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 인프라스트럭처를 코드로 정의함으로써 Terraform은 배포가 다양한 환경에서 반복 가능하고 일관성 있게 이루어지도록 합니다. 이는 \"내 컴퓨터에서는 작동한다\" 문제를 제거합니다.\n- 환경 분리: Terraform은 워크스페이스나 변수 파일을 활용하여 동일한 코드로 여러 환경을 관리할 수 있습니다. 각 환경은 Terraform의 상태 파일을 통해 구성을 관리함으로써 격리를 보장하고 교차 환경 오염의 위험을 최소화합니다.\n- 자동화된 배포: Terraform은 자원 생성, 수정 및 삭제 과정을 자동화하여 인간 에러 가능성을 줄이고 효율성을 높입니다.\n- 변경 관리와 버전 관리: Terraform을 사용하면 모든 변경 사항이 버전 관리되고 적용되기 전에 검토되어 수정 사항에 대한 감사 트레일을 제공하고 쉬운 롤백 매커니즘을 제공합니다.\n\n# Terraform을 활용한 실용적인 구현\n\n제공된 Terraform 코드는 Lambda 함수용 필요한 인프라를 설정하는 방법을 보여줍니다. IAM 역할, 정책, 그리고 Lambda 함수 자체를 구성하고 Terraform 변수를 사용하여 환경별 구성을 설정합니다.\nAWS Terraform 프로바이더에 익숙하지 않은 경우, Terraform을 AWS에 연결하는 방법을 이해하기 위해 해당 문서를 읽어보세요.\n\n1. IAM 역할 및 정책 설정\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n람다 함수는 다른 AWS 리소스와 상호작용할 것입니다. 이를 위해 IAM 역할을 가정해야 합니다. 먼저 해당 역할을 만들어 봅시다.\n\n```js\n# 람다 함수가 가정할 IAM 역할을 정의합니다.\nresource \"aws_iam_role\" \"lambda_role\" {\n  name               = \"lambda_function_role\"\n  assume_role_policy = \u003c\u003cEOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": \"sts:AssumeRole\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Effect\": \"Allow\",\n      \"Sid\": \"\"\n    }\n  ]\n}\nEOF\n}\n```\n\n## 설명\n\n이 IAM 역할을 생성하고 해당 가정 역할 정책을 첨부함으로써, 람다 함수가 이 역할을 가정할 수 있게 합니다. 즉, 람다 함수는 이 역할과 관련된 권한을 사용하여 다른 AWS 리소스와 상호작용할 수 있습니다. 예를 들어, 이 역할에 S3 버킷에 액세스를 허용하는 정책을 첨부하면, 람다 함수는 이 역할을 사용하여 해당 버킷에서 읽거나 쓰는 작업을 수행할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_1.png\" /\u003e\n\n참고: 본 튜토리얼에서는 환경 변수가 어떻게 사용되는지 간단하게 알 수 있도록 실제 버킷과 AWS 정책은 사용하지 않습니다. 하지만 다음 기사에서 사용할 예정입니다.\n\n# 람다 함수 배포\n\n환경에 따라 다른 변수를 출력하는 기본 \"Hello World!\" 파이썬 함수를 배포할 것입니다. 람다 패키지는 두 개의 파일로 구성됩니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# index.py, 핸들러가 있는 곳입니다\nfrom config import BUCKET_NAME\n\ndef lambda_handler(event, context):\n   message = f\"버킷 사용 중: {BUCKET_NAME}\"\n   return {\n       'message' : message\n   }\n```\n\n```js\n# config.py, 환경 변수를 가져와 다른 구성을 할 수 있습니다\nimport os\n\n# 지정되지 않은 경우 'mybucket'으로 기본 설정\nBUCKET_NAME = os.getenv('BUCKET_NAME', 'mybucket')\n```\n\n먼저, Lambda 함수 코드가 있는 \"code\" 폴더를 압축하여 배포에 사용할 ZIP 파일로 만들기 위해 Terraform 아카이브 파일 데이터 원본을 정의할 것입니다.\n\n```js\n# Lambda 배포를 위해 Python 코드를 zip 파일로 묶습니다.\ndata \"archive_file\" \"zip_the_code\" {\n  type        = \"zip\"\n  source_dir  = \"./code/\"\n  output_path = \"./code/test-terraform.zip\"\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 화면 구조를 명확하게하기 위해 스크린샷을 여기에 넣었습니다.\n\n![폴더 구조 이미지](/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_2.png)\n\n이제 우리는 람다 자원을 생성하기 위해 출력을 사용할 수 있습니다. 여기서 source_code_hash 속성이 매우 중요합니다. 소스 코드 해시 덕분에 Terraform이 코드의 변경을 감지할 수 있습니다.\n\n```js\n# 환경별 변수로 Lambda 함수를 배포합니다.\nresource \"aws_lambda_function\" \"terraform_lambda_func\" {\n  filename         = data.archive_file.zip_the_code.output_path\n  function_name    = \"MyLambdaFunction\"\n  role             = aws_iam_role.lambda_role.arn\n  handler          = \"index.lambda_handler\"\n  source_code_hash = data.archive_file.zip_the_code.output_base64sha256\n  runtime          = \"python3.8\"\n  environment {\n    variables = {\n      BUCKET_NAME = var.BUCKET_NAME\n    }\n  }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 주요 요소는 환경 블록입니다. 이 블록을 정의함으로써 AWS Lambda가 실행 중에 읽을 수 있는 환경 변수인 BUCKET_NAME의 값을 지정할 수 있습니다.\n\n# 여러 환경 관리\n\n여러 환경을 관리하는 방법으로는 Terraform 워크스페이스를 사용하거나 서로 다른 변수 파일로 Terraform을 실행하여 각 환경별로 리소스를 분리하고 상태를 별도로 관리하는 데 도움이 됩니다:\n\n```js\n# 새 워크스페이스를 생성하고 개발 환경을 위한 리소스를 배포합니다.\nterraform workspace new development\nterraform apply -var=\"BUCKET_NAME=dev-bucket\"\n\n# 프로덕션 워크스페이스로 전환하고 리소스를 배포합니다.\nterraform workspace new production\nterraform apply -var=\"BUCKET_NAME=prod-bucket\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가끔은 많은 환경 변수를 정의해야 할 때가 있습니다. 그럴 땐 환경에 따라 다른 테라폼 변수 파일을 가리킬 수 있습니다.\n\n## 예시\n\n```js\nterraform apply -var-file=\"dev-variables.tfvars\"\nterraform apply -var-file=\"prod-variables.tfvars\"\n```\n\n## 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAWS Lambda 함수를 여러 환경에 배포하기 위해 Terraform을 사용하면 배포를 표준화하고 서버리스 애플리케이션을 간단하게 관리할 수 있어요.\n\n다음에는 GitHub 액션, CSV 파일 및 적절한 폴더 구조를 사용하여 오늘 본 개념과 기술을 어떻게 제품화하는지 보여 드릴게요.\n\n읽어 주셔서 감사합니다. 저는 Infostrux의 데이터 아키텍트인 Mehdi Sidi Boumedine입니다. LinkedIn에서 저와 연락하거나 팔로우하고 Infostrux 블로그의 최신 기고를 확인해 주세요. 다음 글도 기대해 주세요.\n","ogImage":{"url":"/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_0.png"},"coverImage":"/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e여러 환경에 걸쳐 AWS Lambda 함수를 배포하는 방법 배우기 — Hashicorp Terraform을 통해 가능하게 하기\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eAWS Lambda는 서버를 프로비저닝하거나 관리하지 않고 코드를 실행할 수 있는 서버리스 컴퓨팅 서비스로, 배포 프로세스를 간소화하고 비즈니스가 자동으로 확장할 수 있게 합니다. 그러나 특히 여러 환경에 걸쳐 Lambda 함수를 배포하는 것은 개발 라이프사이클을 복잡하게 만들 수 있는 특정한 도전을 야기합니다.\u003c/p\u003e\n\u003ch1\u003eLambda 배포 도전\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eAWS 람다 함수를 배포하는 가장 기본적인 방법은 주로 AWS 관리 콘솔을 통해 zip 파일을 수동으로 업로드하거나 AWS CLI 명령을 사용하는 것입니다. 그러나 이 방법은 몇 가지 어려움을 야기할 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e일관성 문제: 수동 프로세스는 실수하기 쉽습니다. 개발, 테스트 및 프로덕션 환경을 거치는 반복 배포가 신중하게 관리되지 않으면 일관성 문제를 야기할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e확장성 제한: 애플리케이션이 성장함에 따라 여러 함수를 수동으로 관리하는 것은 다루기 어렵고 실수를 유발할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e구성 관리: 다른 환경(예: 개발, 스테이징, 프로덕션)에 대한 다른 구성을 수동으로 처리하는 것은 복잡하며 구성 드리프트를 야기할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e버전 관리: 수동 배포는 기본적으로 버전 관리를 지원하지 않으며, 변경 사항을 추적하거나 이전 버전의 함수로 롤백하는 것이 어려울 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eTerraform을 활용하여 다중 환경 도전을 해결하기\u003c/h1\u003e\n\u003cp\u003e개발, 스테이징, 프로덕션과 같은 여러 환경에 걸쳐 람다 함수를 배포하려면 구성 및 인프라를 일관되게 처리하는 전략이 필요합니다. 이것이 Terraform이 이러한 문제들에 대처하는 방법입니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e인프라스트럭처를 코드로 정의함으로써 Terraform은 배포가 다양한 환경에서 반복 가능하고 일관성 있게 이루어지도록 합니다. 이는 \"내 컴퓨터에서는 작동한다\" 문제를 제거합니다.\u003c/li\u003e\n\u003cli\u003e환경 분리: Terraform은 워크스페이스나 변수 파일을 활용하여 동일한 코드로 여러 환경을 관리할 수 있습니다. 각 환경은 Terraform의 상태 파일을 통해 구성을 관리함으로써 격리를 보장하고 교차 환경 오염의 위험을 최소화합니다.\u003c/li\u003e\n\u003cli\u003e자동화된 배포: Terraform은 자원 생성, 수정 및 삭제 과정을 자동화하여 인간 에러 가능성을 줄이고 효율성을 높입니다.\u003c/li\u003e\n\u003cli\u003e변경 관리와 버전 관리: Terraform을 사용하면 모든 변경 사항이 버전 관리되고 적용되기 전에 검토되어 수정 사항에 대한 감사 트레일을 제공하고 쉬운 롤백 매커니즘을 제공합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eTerraform을 활용한 실용적인 구현\u003c/h1\u003e\n\u003cp\u003e제공된 Terraform 코드는 Lambda 함수용 필요한 인프라를 설정하는 방법을 보여줍니다. IAM 역할, 정책, 그리고 Lambda 함수 자체를 구성하고 Terraform 변수를 사용하여 환경별 구성을 설정합니다.\nAWS Terraform 프로바이더에 익숙하지 않은 경우, Terraform을 AWS에 연결하는 방법을 이해하기 위해 해당 문서를 읽어보세요.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eIAM 역할 및 정책 설정\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e람다 함수는 다른 AWS 리소스와 상호작용할 것입니다. 이를 위해 IAM 역할을 가정해야 합니다. 먼저 해당 역할을 만들어 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 람다 함수가 가정할 \u003cspan class=\"hljs-variable constant_\"\u003eIAM\u003c/span\u003e 역할을 정의합니다.\nresource \u003cspan class=\"hljs-string\"\u003e\"aws_iam_role\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"lambda_role\"\u003c/span\u003e {\n  name               = \u003cspan class=\"hljs-string\"\u003e\"lambda_function_role\"\u003c/span\u003e\n  assume_role_policy = \u0026#x3C;\u0026#x3C;\u003cspan class=\"hljs-variable constant_\"\u003eEOF\u003c/span\u003e\n{\n  \u003cspan class=\"hljs-string\"\u003e\"Version\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"2012-10-17\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"Statement\"\u003c/span\u003e: [\n    {\n      \u003cspan class=\"hljs-string\"\u003e\"Action\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"sts:AssumeRole\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-string\"\u003e\"Principal\"\u003c/span\u003e: {\n        \u003cspan class=\"hljs-string\"\u003e\"Service\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"lambda.amazonaws.com\"\u003c/span\u003e\n      },\n      \u003cspan class=\"hljs-string\"\u003e\"Effect\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Allow\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-string\"\u003e\"Sid\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    }\n  ]\n}\n\u003cspan class=\"hljs-variable constant_\"\u003eEOF\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e설명\u003c/h2\u003e\n\u003cp\u003e이 IAM 역할을 생성하고 해당 가정 역할 정책을 첨부함으로써, 람다 함수가 이 역할을 가정할 수 있게 합니다. 즉, 람다 함수는 이 역할과 관련된 권한을 사용하여 다른 AWS 리소스와 상호작용할 수 있습니다. 예를 들어, 이 역할에 S3 버킷에 액세스를 허용하는 정책을 첨부하면, 람다 함수는 이 역할을 사용하여 해당 버킷에서 읽거나 쓰는 작업을 수행할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_1.png\"\u003e\n\u003cp\u003e참고: 본 튜토리얼에서는 환경 변수가 어떻게 사용되는지 간단하게 알 수 있도록 실제 버킷과 AWS 정책은 사용하지 않습니다. 하지만 다음 기사에서 사용할 예정입니다.\u003c/p\u003e\n\u003ch1\u003e람다 함수 배포\u003c/h1\u003e\n\u003cp\u003e환경에 따라 다른 변수를 출력하는 기본 \"Hello World!\" 파이썬 함수를 배포할 것입니다. 람다 패키지는 두 개의 파일로 구성됩니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# index.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e, 핸들러가 있는 곳입니다\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e config \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBUCKET_NAME\u003c/span\u003e\n\ndef \u003cspan class=\"hljs-title function_\"\u003elambda_handler\u003c/span\u003e(event, context):\n   message = f\u003cspan class=\"hljs-string\"\u003e\"버킷 사용 중: {BUCKET_NAME}\"\u003c/span\u003e\n   \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n       \u003cspan class=\"hljs-string\"\u003e'message'\u003c/span\u003e : message\n   }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# config.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e, 환경 변수를 가져와 다른 구성을 할 수 있습니다\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e os\n\n# 지정되지 않은 경우 \u003cspan class=\"hljs-string\"\u003e'mybucket'\u003c/span\u003e으로 기본 설정\n\u003cspan class=\"hljs-variable constant_\"\u003eBUCKET_NAME\u003c/span\u003e = os.\u003cspan class=\"hljs-title function_\"\u003egetenv\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'BUCKET_NAME'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'mybucket'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e먼저, Lambda 함수 코드가 있는 \"code\" 폴더를 압축하여 배포에 사용할 ZIP 파일로 만들기 위해 Terraform 아카이브 파일 데이터 원본을 정의할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eLambda\u003c/span\u003e 배포를 위해 \u003cspan class=\"hljs-title class_\"\u003ePython\u003c/span\u003e 코드를 zip 파일로 묶습니다.\ndata \u003cspan class=\"hljs-string\"\u003e\"archive_file\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"zip_the_code\"\u003c/span\u003e {\n  type        = \u003cspan class=\"hljs-string\"\u003e\"zip\"\u003c/span\u003e\n  source_dir  = \u003cspan class=\"hljs-string\"\u003e\"./code/\"\u003c/span\u003e\n  output_path = \u003cspan class=\"hljs-string\"\u003e\"./code/test-terraform.zip\"\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 화면 구조를 명확하게하기 위해 스크린샷을 여기에 넣었습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_2.png\" alt=\"폴더 구조 이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 우리는 람다 자원을 생성하기 위해 출력을 사용할 수 있습니다. 여기서 source_code_hash 속성이 매우 중요합니다. 소스 코드 해시 덕분에 Terraform이 코드의 변경을 감지할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 환경별 변수로 \u003cspan class=\"hljs-title class_\"\u003eLambda\u003c/span\u003e 함수를 배포합니다.\nresource \u003cspan class=\"hljs-string\"\u003e\"aws_lambda_function\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"terraform_lambda_func\"\u003c/span\u003e {\n  filename         = data.\u003cspan class=\"hljs-property\"\u003earchive_file\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ezip_the_code\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eoutput_path\u003c/span\u003e\n  function_name    = \u003cspan class=\"hljs-string\"\u003e\"MyLambdaFunction\"\u003c/span\u003e\n  role             = aws_iam_role.\u003cspan class=\"hljs-property\"\u003elambda_role\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003earn\u003c/span\u003e\n  handler          = \u003cspan class=\"hljs-string\"\u003e\"index.lambda_handler\"\u003c/span\u003e\n  source_code_hash = data.\u003cspan class=\"hljs-property\"\u003earchive_file\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ezip_the_code\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eoutput_base64sha256\u003c/span\u003e\n  runtime          = \u003cspan class=\"hljs-string\"\u003e\"python3.8\"\u003c/span\u003e\n  environment {\n    variables = {\n      \u003cspan class=\"hljs-variable constant_\"\u003eBUCKET_NAME\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eBUCKET_NAME\u003c/span\u003e\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e여기서 주요 요소는 환경 블록입니다. 이 블록을 정의함으로써 AWS Lambda가 실행 중에 읽을 수 있는 환경 변수인 BUCKET_NAME의 값을 지정할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e여러 환경 관리\u003c/h1\u003e\n\u003cp\u003e여러 환경을 관리하는 방법으로는 Terraform 워크스페이스를 사용하거나 서로 다른 변수 파일로 Terraform을 실행하여 각 환경별로 리소스를 분리하고 상태를 별도로 관리하는 데 도움이 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 새 워크스페이스를 생성하고 개발 환경을 위한 리소스를 배포합니다.\nterraform workspace \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e development\nterraform apply -\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"BUCKET_NAME=dev-bucket\"\u003c/span\u003e\n\n# 프로덕션 워크스페이스로 전환하고 리소스를 배포합니다.\nterraform workspace \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e production\nterraform apply -\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"BUCKET_NAME=prod-bucket\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e가끔은 많은 환경 변수를 정의해야 할 때가 있습니다. 그럴 땐 환경에 따라 다른 테라폼 변수 파일을 가리킬 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e예시\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eterraform apply -\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e-file=\u003cspan class=\"hljs-string\"\u003e\"dev-variables.tfvars\"\u003c/span\u003e\nterraform apply -\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e-file=\u003cspan class=\"hljs-string\"\u003e\"prod-variables.tfvars\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e결론\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eAWS Lambda 함수를 여러 환경에 배포하기 위해 Terraform을 사용하면 배포를 표준화하고 서버리스 애플리케이션을 간단하게 관리할 수 있어요.\u003c/p\u003e\n\u003cp\u003e다음에는 GitHub 액션, CSV 파일 및 적절한 폴더 구조를 사용하여 오늘 본 개념과 기술을 어떻게 제품화하는지 보여 드릴게요.\u003c/p\u003e\n\u003cp\u003e읽어 주셔서 감사합니다. 저는 Infostrux의 데이터 아키텍트인 Mehdi Sidi Boumedine입니다. LinkedIn에서 저와 연락하거나 팔로우하고 Infostrux 블로그의 최신 기고를 확인해 주세요. 다음 글도 기대해 주세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform"},"buildId":"wfHLuDA3kTGBYfaM5IGXk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>