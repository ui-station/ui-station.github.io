<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Python weakref 모듈을 사용한 약한 참조 가이드 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-07-01-AGuidetoPythonsWeakReferencesUsingtheweakrefModule" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Python weakref 모듈을 사용한 약한 참조 가이드 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Python weakref 모듈을 사용한 약한 참조 가이드 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-07-01-AGuidetoPythonsWeakReferencesUsingtheweakrefModule_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-07-01-AGuidetoPythonsWeakReferencesUsingtheweakrefModule" data-gatsby-head="true"/><meta name="twitter:title" content="Python weakref 모듈을 사용한 약한 참조 가이드 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-07-01-AGuidetoPythonsWeakReferencesUsingtheweakrefModule_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-01 16:06" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_buildManifest.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Python weakref 모듈을 사용한 약한 참조 가이드</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Python weakref 모듈을 사용한 약한 참조 가이드" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 1, 2024</span><span class="posts_reading_time__f7YPP">11<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-01-AGuidetoPythonsWeakReferencesUsingtheweakrefModule&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-07-01-AGuidetoPythonsWeakReferencesUsingtheweakrefModule_0.png">
<p>아마 당신은 파이썬의 weakref 모듈에 대해 들어본 적이 없을 것입니다. 여러분의 코드에서 자주 사용되지는 않지만, 많은 라이브러리, 프레임워크 및 심지어 파이썬 자체의 내부 작업에 기본적입니다. 그래서, 이 글에서는 weakref 모듈이 무엇인지, 어떻게 유용한지, 그리고 여러분의 코드에 어떻게 통합할 수 있는지 살펴보겠습니다.</p>
<h1>기본 사항</h1>
<p>weakref 모듈과 약한 참조를 이해하기 위해 먼저 파이썬에서 가비지 컬렉션에 대해 간단히 소개해야 합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>파이썬은 쓰레기 수집을 위한 메커니즘으로 참조 카운팅을 사용합니다. 간단히 말해, 파이썬은 우리가 생성한 각 객체에 대한 참조 카운트를 유지하며, 코드에서 객체가 참조될 때마다 참조 카운트가 증가하고, 객체가 해제될 때(e.g. 변수가 None으로 설정될 때) 감소합니다. 참조 카운트가 0이 되면, 해당 객체의 메모리가 할당 해제(가비지 수집)됩니다.</p>
<p>조금 더 이해하기 쉽도록 코드를 살펴봅시다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> sys

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeObject</span>:
    def <span class="hljs-title function_">__del__</span>(self):
        <span class="hljs-title function_">print</span>(f<span class="hljs-string">"(Deleting {self=})"</span>)

obj = <span class="hljs-title class_">SomeObject</span>()

<span class="hljs-title function_">print</span>(sys.<span class="hljs-title function_">getrefcount</span>(obj))  # <span class="hljs-number">2</span>

obj2 = obj
<span class="hljs-title function_">print</span>(sys.<span class="hljs-title function_">getrefcount</span>(obj))  # <span class="hljs-number">3</span>

obj = <span class="hljs-title class_">None</span>
obj2 = <span class="hljs-title class_">None</span>

# (<span class="hljs-title class_">Deleting</span> self=<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">__main__.SomeObject</span> <span class="hljs-attr">object</span> <span class="hljs-attr">at</span> <span class="hljs-attr">0x7d303fee7e80</span>></span>)
</span></code></pre>
<p>여기서는 <strong>del</strong> 메서드만 구현한 클래스를 정의하는데, 이 메서드는 객체가 가비지 수집될 때 호출되며, 가비지 수집이 발생했을 때를 확인할 수 있도록 합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 클래스의 인스턴스를 만든 후에는 sys.getrefcount를 사용하여이 객체에 대한 현재 참조 수를 가져옵니다. 여기에서는 1을 기대하지만 getrefcount가 반환하는 카운트는 일반적으로 예상보다 한 단계 높습니다. getrefcount를 호출하면 참조가 함수의 인수로 값에 의해 복사되어 객체의 참조 수가 일시적으로 증가하기 때문입니다.</p>
<p>다음으로, obj2 = obj를 선언하고 다시 getrefcount를 호출하면 이제 obj와 obj2 둘 다에 의해 참조되기 때문에 3을 얻습니다. 반대로, 이러한 변수에 None을 할당하면 참조 수가 0으로 감소하고, 마침내 객체가 가비지 수집되었다는 <strong>del</strong> 메서드에서 메시지를 받게 됩니다.</p>
<p>자, 그럼 약한 참조는 어떻게 여기에 맞는 것인가요? 객체에 대한 유일한 남은 참조가 약한 참조인 경우, Python 인터프리터는 이 객체를 가비지 수집할 수 있습니다. 다른 말로하면 — 객체에 대한 약한 참조만으로는 객체를 살리는 데 충분하지 않습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> weakref

obj = <span class="hljs-title class_">SomeObject</span>()

reference = weakref.<span class="hljs-title function_">ref</span>(obj)

<span class="hljs-title function_">print</span>(reference)  # &#x3C;weakref at <span class="hljs-number">0x734b0a514590</span>; to <span class="hljs-string">'SomeObject'</span> at <span class="hljs-number">0x734b0a4e7700</span>>
<span class="hljs-title function_">print</span>(<span class="hljs-title function_">reference</span>())  # &#x3C;__main__.<span class="hljs-property">SomeObject</span> object at <span class="hljs-number">0x707038c0b700</span>>
<span class="hljs-title function_">print</span>(obj.<span class="hljs-property">__weakref__</span>)  # &#x3C;weakref at <span class="hljs-number">0x734b0a514590</span>; to <span class="hljs-string">'SomeObject'</span> at <span class="hljs-number">0x734b0a4e7700</span>>

<span class="hljs-title function_">print</span>(sys.<span class="hljs-title function_">getrefcount</span>(obj))  # <span class="hljs-number">2</span>

obj = <span class="hljs-title class_">None</span>

# (<span class="hljs-title class_">Deleting</span> self=&#x3C;__main__.SomeObject object at 0x70744d42b700>)

print(reference)  # &#x3C;weakref at 0x7988e2d70590; dead>
print(reference())  # None
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우리는 다시 클래스의 obj 변수를 선언합니다. 이번에는 이 객체에 대한 두 번째 강력한 참조 대신에 참조 변수에 약한 참조를 만듭니다.</p>
<p>그런 다음 참조 카운트를 확인하면 증가하지 않음을 알 수 있고, obj 변수를 None으로 설정하면 약한 참조가 여전히 남아 있음에도 즉시 쓰레기 수집됨을 확인할 수 있습니다.</p>
<p>마지막으로 이미 쓰레기로 처리된 객체에 대한 약한 참조에 액세스하려고 하면 “무효한” 참조 및 None이 반환됩니다.</p>
<p>또한 객체에 액세스하기 위해 약한 참조를 사용할 때 함수로 호출해야 했음을 주목하십시오(reference()). 따라서 객체 속성에 액세스해야 하는 경우 특히 프록시를 사용하는 것이 훨씬 편리합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">obj = <span class="hljs-title class_">SomeObject</span>()

reference = weakref.<span class="hljs-title function_">proxy</span>(obj)

<span class="hljs-title function_">print</span>(reference)  # &#x3C;__main__.<span class="hljs-property">SomeObject</span> object at <span class="hljs-number">0x78a420e6b700</span>>

obj.<span class="hljs-property">attr</span> = <span class="hljs-number">1</span>
<span class="hljs-title function_">print</span>(reference.<span class="hljs-property">attr</span>)  # <span class="hljs-number">1</span>
</code></pre>
<h1>사용 시기</h1>
<p>이제 약한 참조가 어떻게 작동하는지 알았으니, 어떻게 유용할 수 있는지 몇 가지 예시를 살펴보겠습니다.</p>
<p>약한 참조의 일반적인 사용 사례 중 하나는 트리와 같은 데이터 구조입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>class Node:
def <strong>init</strong>(self, value):
self.value = value
self._parent = None
self.children = []</p>
<pre><code>def __repr__(self):
    return "Node({!r:})".format(self.value)

@property
def parent(self):
    return self._parent if self._parent is None else self._parent()

@parent.setter
def parent(self, node):
    self._parent = weakref.ref(node)

def add_child(self, child):
    self.children.append(child)
    child.parent = self
</code></pre>
<p>root = Node("parent")
n = Node("child")
root.add_child(n)
print(n.parent)  # Node('parent')</p>
<p>del root
print(n.parent)  # None</p>
<p>여기서는 약한 참조를 사용하여 자식 노드들이 부모 노드를 가리키는 Node 클래스를 통해 트리를 구현했습니다. 이 관계에서 자식 Node는 부모 Node 없이 살 수 있어 부모가 소리 없이 제거되거나 가비지 수집될 수 있게 합니다.</p>
<p>또 다른 방법으로 이를 구현해보겠습니다:</p>
<p>class Node:
def <strong>init</strong>(self, value):
self.value = value
self._children = weakref.WeakValueDictionary()</p>
<pre><code>@property
def children(self):
    return list(self._children.items())

def add_child(self, key, child):
    self._children[key] = child
</code></pre>
<p>root = Node("parent")
n1 = Node("child one")
n2 = Node("child two")
root.add_child("n1", n1)
root.add_child("n2", n2)
print(root.children)  # [('n1', Node('child one')), ('n2', Node('child two'))]</p>
<p>del n1
print(root.children)  # [('n2', Node('child two'))]</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>여기서 부모는 자식들을 약한 참조를 갖고 있습니다. 이는 WeakValueDictionary를 사용합니다. 사전에서 참조된 요소(약한 참조)가 프로그램의 다른 곳에서 참조를 제거하면, 자동으로 사전에서도 제거됩니다. 따라서 사전 항목의 수명주기를 관리할 필요가 없습니다.</p>
<p>weakref의 또 다른 사용 예는 Observer 디자인 패턴에 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observable</span>:
    def <span class="hljs-title function_">__init__</span>(self):
        self.<span class="hljs-property">_observers</span> = weakref.<span class="hljs-title class_">WeakSet</span>()

    def <span class="hljs-title function_">register_observer</span>(self, obs):
        self.<span class="hljs-property">_observers</span>.<span class="hljs-title function_">add</span>(obs)

    def <span class="hljs-title function_">notify_observers</span>(self, *args, **kwargs):
        <span class="hljs-keyword">for</span> obs <span class="hljs-keyword">in</span> self.<span class="hljs-property">_observers</span>:
            obs.<span class="hljs-title function_">notify</span>(self, *args, **kwargs)


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span>:
    def <span class="hljs-title function_">__init__</span>(self, observable):
        observable.<span class="hljs-title function_">register_observer</span>(self)

    def <span class="hljs-title function_">notify</span>(self, observable, *args, **kwargs):
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"Got"</span>, args, kwargs, <span class="hljs-string">"From"</span>, observable)

subject = <span class="hljs-title class_">Observable</span>()
observer = <span class="hljs-title class_">Observer</span>(subject)
subject.<span class="hljs-title function_">notify_observers</span>(<span class="hljs-string">"test"</span>, kw=<span class="hljs-string">"python"</span>)
# <span class="hljs-title class_">Got</span> (<span class="hljs-string">'test'</span>,) {<span class="hljs-string">'kw'</span>: <span class="hljs-string">'python'</span>} <span class="hljs-title class_">From</span> &#x3C;__main__.<span class="hljs-property">Observable</span> object at <span class="hljs-number">0x757957b892d0</span>>
</code></pre>
<p>Observable 클래스는 옵저버에 대한 약한 참조를 유지합니다. 이는 그들이 제거되었는지 여부를 신경쓰지 않기 때문입니다. 이전 예제와 마찬가지로, 이를 통해 종속 객체의 수명주기를 관리할 필요가 없습니다. 아마도 주목했을 것이지만, 이 예제에서는 WeakSet을 사용했습니다. 이는 WeakValueDictionary와 비슷하지만 Set을 사용하여 구현되었습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 섹션의 최종 예제는 weakref 문서에서 빌려왔습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> tempfile, shutil
<span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> <span class="hljs-title class_">Path</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">TempDir</span>:
    def <span class="hljs-title function_">__init__</span>(self):
        self.<span class="hljs-property">name</span> = tempfile.<span class="hljs-title function_">mkdtemp</span>()
        self.<span class="hljs-property">_finalizer</span> = weakref.<span class="hljs-title function_">finalize</span>(self, shutil.<span class="hljs-property">rmtree</span>, self.<span class="hljs-property">name</span>)

    def <span class="hljs-title function_">__repr__</span>(self):
        <span class="hljs-keyword">return</span> <span class="hljs-string">"TempDir({!r:})"</span>.<span class="hljs-title function_">format</span>(self.<span class="hljs-property">name</span>)

    def <span class="hljs-title function_">remove</span>(self):
        self.<span class="hljs-title function_">_finalizer</span>()

    @property
    def <span class="hljs-title function_">removed</span>(self):
        <span class="hljs-keyword">return</span> not self.<span class="hljs-property">_finalizer</span>.<span class="hljs-property">alive</span>

tmp = <span class="hljs-title class_">TempDir</span>()
<span class="hljs-title function_">print</span>(tmp)  # <span class="hljs-title class_">TempDir</span>(<span class="hljs-string">'/tmp/tmp8o0aecl3'</span>)
<span class="hljs-title function_">print</span>(tmp.<span class="hljs-property">removed</span>)  # <span class="hljs-title class_">False</span>
<span class="hljs-title function_">print</span>(<span class="hljs-title class_">Path</span>(tmp.<span class="hljs-property">name</span>).<span class="hljs-title function_">is_dir</span>()) # <span class="hljs-title class_">True</span>
</code></pre>
<p>이를 통해 weakref 모듈의 또 다른 기능을 확인할 수 있습니다. 바로 weakref.finalize입니다. 이름에서 암시하는 바대로 종속 객체가 가비지 수집될 때 최종화 함수/콜백을 실행할 수 있습니다. 이 예제에서는 가비지 수집될 때 TempDir 객체에 대해 rmtree를 자동으로 실행할 최종화가 실행됩니다. 프로그램이 완전히 종료될 때를 포함하여 TempDir이 가비지 수집될 때 실행되는 finalizer를 통해 TempDir를 정리하기를 항상 기억해야하지만 잊어버릴 경우에 대비할 수 있습니다.</p>
<h1>실제 예제</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>앞서 섹션에서 weakref의 실용적인 사용 예를 보여드렸지만, 실세계 예제도 함께 살펴보겠습니다. 그 중 하나는 캐시된 인스턴스를 생성하는 것입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> logging
a = logging.<span class="hljs-title function_">getLogger</span>(<span class="hljs-string">"first"</span>)
b = logging.<span class="hljs-title function_">getLogger</span>(<span class="hljs-string">"second"</span>)
<span class="hljs-title function_">print</span>(a is b)  # <span class="hljs-title class_">False</span>

c = logging.<span class="hljs-title function_">getLogger</span>(<span class="hljs-string">"first"</span>)
<span class="hljs-title function_">print</span>(a is c)  # <span class="hljs-title class_">True</span>
</code></pre>
<p>위의 코드는 Python의 내장 logging 모듈의 기본적인 사용법입니다. 우리는 특정 이름에 하나의 로거 인스턴스만 관련시킬 수 있음을 알 수 있습니다. 즉, 동일한 로거를 여러 번 검색해도 항상 동일한 캐시된 로거 인스턴스가 반환됩니다.</p>
<p>만약 이를 구현하고 싶다면, 다음과 같이 할 수 있습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):
        self.name = name

_logger_cache = weakref.WeakValueDictionary()

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_logger</span>(<span class="hljs-params">name</span>):
    <span class="hljs-keyword">if</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> _logger_cache:
        l = Logger(name)
        _logger_cache[name] = l
    <span class="hljs-keyword">else</span>:
        l = _logger_cache[name]
    <span class="hljs-keyword">return</span> l

a = get_logger(<span class="hljs-string">"first"</span>)
b = get_logger(<span class="hljs-string">"second"</span>)
<span class="hljs-built_in">print</span>(a <span class="hljs-keyword">is</span> b)  <span class="hljs-comment"># False</span>

c = get_logger(<span class="hljs-string">"first"</span>)
<span class="hljs-built_in">print</span>(a <span class="hljs-keyword">is</span> c)  <span class="hljs-comment"># True</span>
</code></pre>
<p>마지막으로, Python 자체도 약한 참조를 사용합니다. OrderedDict의 구현 예시를 보겠습니다:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> _weakref <span class="hljs-keyword">import</span> proxy <span class="hljs-keyword">as</span> _proxy

<span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderedDict</span>(<span class="hljs-title class_ inherited__">dict</span>):

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, /, *args, **kwds</span>):
        self = <span class="hljs-built_in">dict</span>.__new__(cls)
        self.__hardroot = _Link()
        self.__root = root = _proxy(self.__hardroot)
        root.prev = root.<span class="hljs-built_in">next</span> = root
        self.__<span class="hljs-built_in">map</span> = {}
        <span class="hljs-keyword">return</span> self
</code></pre>
<p>위는 CPython의 collections 모듈에서의 일부 코드입니다. 여기서 weakref.proxy가 순환 참조를 막는 데 사용된다는 점을 유의하십시오 (더 많은 세부 정보는 doc-strings를 참조하세요).</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>결론</h1>
<p>weakref는 꽤 낯설지만 때때로 매우 유용한 도구로 여러분의 도구상자에 넣어두어야 할 가치가 있습니다. 이는 캐시를 구현하거나 이중 연결 리스트와 같이 서로 참조하는 데이터 구조를 다룰 때 매우 도움이 될 수 있습니다.</p>
<p>그렇지만 여기서 말한 모든 것과 문서에서 언급된 사항은 CPython에 특화되어 있으며 다른 Python 구현체에서는 weakref 동작이 다를 수 있음을 인식해야 합니다. 또한 리스트, 튜플 또는 정수와 같은 많은 내장 타입이 약한 참조를 지원하지 않는다는 사실을 알아두어야 합니다.</p>
<p>본 문서는 원문이 <a href="https://martinheinz.dev" rel="nofollow" target="_blank">martinheinz.dev</a>에 게시되었습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다음 항목을 추천해 드려요...</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Python weakref 모듈을 사용한 약한 참조 가이드","description":"","date":"2024-07-01 16:06","slug":"2024-07-01-AGuidetoPythonsWeakReferencesUsingtheweakrefModule","content":"\n\n\n\u003cimg src=\"/assets/img/2024-07-01-AGuidetoPythonsWeakReferencesUsingtheweakrefModule_0.png\" /\u003e\n\n아마 당신은 파이썬의 weakref 모듈에 대해 들어본 적이 없을 것입니다. 여러분의 코드에서 자주 사용되지는 않지만, 많은 라이브러리, 프레임워크 및 심지어 파이썬 자체의 내부 작업에 기본적입니다. 그래서, 이 글에서는 weakref 모듈이 무엇인지, 어떻게 유용한지, 그리고 여러분의 코드에 어떻게 통합할 수 있는지 살펴보겠습니다.\n\n# 기본 사항\n\nweakref 모듈과 약한 참조를 이해하기 위해 먼저 파이썬에서 가비지 컬렉션에 대해 간단히 소개해야 합니다.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬은 쓰레기 수집을 위한 메커니즘으로 참조 카운팅을 사용합니다. 간단히 말해, 파이썬은 우리가 생성한 각 객체에 대한 참조 카운트를 유지하며, 코드에서 객체가 참조될 때마다 참조 카운트가 증가하고, 객체가 해제될 때(e.g. 변수가 None으로 설정될 때) 감소합니다. 참조 카운트가 0이 되면, 해당 객체의 메모리가 할당 해제(가비지 수집)됩니다.\n\n조금 더 이해하기 쉽도록 코드를 살펴봅시다:\n\n```js\nimport sys\n\nclass SomeObject:\n    def __del__(self):\n        print(f\"(Deleting {self=})\")\n\nobj = SomeObject()\n\nprint(sys.getrefcount(obj))  # 2\n\nobj2 = obj\nprint(sys.getrefcount(obj))  # 3\n\nobj = None\nobj2 = None\n\n# (Deleting self=\u003c__main__.SomeObject object at 0x7d303fee7e80\u003e)\n```\n\n여기서는 __del__ 메서드만 구현한 클래스를 정의하는데, 이 메서드는 객체가 가비지 수집될 때 호출되며, 가비지 수집이 발생했을 때를 확인할 수 있도록 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 클래스의 인스턴스를 만든 후에는 sys.getrefcount를 사용하여이 객체에 대한 현재 참조 수를 가져옵니다. 여기에서는 1을 기대하지만 getrefcount가 반환하는 카운트는 일반적으로 예상보다 한 단계 높습니다. getrefcount를 호출하면 참조가 함수의 인수로 값에 의해 복사되어 객체의 참조 수가 일시적으로 증가하기 때문입니다.\n\n다음으로, obj2 = obj를 선언하고 다시 getrefcount를 호출하면 이제 obj와 obj2 둘 다에 의해 참조되기 때문에 3을 얻습니다. 반대로, 이러한 변수에 None을 할당하면 참조 수가 0으로 감소하고, 마침내 객체가 가비지 수집되었다는 __del__ 메서드에서 메시지를 받게 됩니다.\n\n자, 그럼 약한 참조는 어떻게 여기에 맞는 것인가요? 객체에 대한 유일한 남은 참조가 약한 참조인 경우, Python 인터프리터는 이 객체를 가비지 수집할 수 있습니다. 다른 말로하면 — 객체에 대한 약한 참조만으로는 객체를 살리는 데 충분하지 않습니다:\n\n```js\nimport weakref\n\nobj = SomeObject()\n\nreference = weakref.ref(obj)\n\nprint(reference)  # \u003cweakref at 0x734b0a514590; to 'SomeObject' at 0x734b0a4e7700\u003e\nprint(reference())  # \u003c__main__.SomeObject object at 0x707038c0b700\u003e\nprint(obj.__weakref__)  # \u003cweakref at 0x734b0a514590; to 'SomeObject' at 0x734b0a4e7700\u003e\n\nprint(sys.getrefcount(obj))  # 2\n\nobj = None\n\n# (Deleting self=\u003c__main__.SomeObject object at 0x70744d42b700\u003e)\n\nprint(reference)  # \u003cweakref at 0x7988e2d70590; dead\u003e\nprint(reference())  # None\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 다시 클래스의 obj 변수를 선언합니다. 이번에는 이 객체에 대한 두 번째 강력한 참조 대신에 참조 변수에 약한 참조를 만듭니다.\n\n그런 다음 참조 카운트를 확인하면 증가하지 않음을 알 수 있고, obj 변수를 None으로 설정하면 약한 참조가 여전히 남아 있음에도 즉시 쓰레기 수집됨을 확인할 수 있습니다.\n\n마지막으로 이미 쓰레기로 처리된 객체에 대한 약한 참조에 액세스하려고 하면 “무효한” 참조 및 None이 반환됩니다.\n\n또한 객체에 액세스하기 위해 약한 참조를 사용할 때 함수로 호출해야 했음을 주목하십시오(reference()). 따라서 객체 속성에 액세스해야 하는 경우 특히 프록시를 사용하는 것이 훨씬 편리합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nobj = SomeObject()\n\nreference = weakref.proxy(obj)\n\nprint(reference)  # \u003c__main__.SomeObject object at 0x78a420e6b700\u003e\n\nobj.attr = 1\nprint(reference.attr)  # 1\n```\n\n# 사용 시기\n\n이제 약한 참조가 어떻게 작동하는지 알았으니, 어떻게 유용할 수 있는지 몇 가지 예시를 살펴보겠습니다.\n\n약한 참조의 일반적인 사용 사례 중 하나는 트리와 같은 데이터 구조입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\nclass Node:\r\n    def __init__(self, value):\r\n        self.value = value\r\n        self._parent = None\r\n        self.children = []\r\n\r\n    def __repr__(self):\r\n        return \"Node({!r:})\".format(self.value)\r\n\r\n    @property\r\n    def parent(self):\r\n        return self._parent if self._parent is None else self._parent()\r\n\r\n    @parent.setter\r\n    def parent(self, node):\r\n        self._parent = weakref.ref(node)\r\n\r\n    def add_child(self, child):\r\n        self.children.append(child)\r\n        child.parent = self\r\n\r\nroot = Node(\"parent\")\r\nn = Node(\"child\")\r\nroot.add_child(n)\r\nprint(n.parent)  # Node('parent')\r\n\r\ndel root\r\nprint(n.parent)  # None\r\n\n\r\n여기서는 약한 참조를 사용하여 자식 노드들이 부모 노드를 가리키는 Node 클래스를 통해 트리를 구현했습니다. 이 관계에서 자식 Node는 부모 Node 없이 살 수 있어 부모가 소리 없이 제거되거나 가비지 수집될 수 있게 합니다.\r\n\r\n또 다른 방법으로 이를 구현해보겠습니다:\r\n\r\n\nclass Node:\r\n    def __init__(self, value):\r\n        self.value = value\r\n        self._children = weakref.WeakValueDictionary()\r\n\r\n    @property\r\n    def children(self):\r\n        return list(self._children.items())\r\n\r\n    def add_child(self, key, child):\r\n        self._children[key] = child\r\n\r\nroot = Node(\"parent\")\r\nn1 = Node(\"child one\")\r\nn2 = Node(\"child two\")\r\nroot.add_child(\"n1\", n1)\r\nroot.add_child(\"n2\", n2)\r\nprint(root.children)  # [('n1', Node('child one')), ('n2', Node('child two'))]\r\n\r\ndel n1\r\nprint(root.children)  # [('n2', Node('child two'))]\r\n\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 부모는 자식들을 약한 참조를 갖고 있습니다. 이는 WeakValueDictionary를 사용합니다. 사전에서 참조된 요소(약한 참조)가 프로그램의 다른 곳에서 참조를 제거하면, 자동으로 사전에서도 제거됩니다. 따라서 사전 항목의 수명주기를 관리할 필요가 없습니다.\n\nweakref의 또 다른 사용 예는 Observer 디자인 패턴에 있습니다:\n\n```js\nclass Observable:\n    def __init__(self):\n        self._observers = weakref.WeakSet()\n\n    def register_observer(self, obs):\n        self._observers.add(obs)\n\n    def notify_observers(self, *args, **kwargs):\n        for obs in self._observers:\n            obs.notify(self, *args, **kwargs)\n\n\nclass Observer:\n    def __init__(self, observable):\n        observable.register_observer(self)\n\n    def notify(self, observable, *args, **kwargs):\n        print(\"Got\", args, kwargs, \"From\", observable)\n\nsubject = Observable()\nobserver = Observer(subject)\nsubject.notify_observers(\"test\", kw=\"python\")\n# Got ('test',) {'kw': 'python'} From \u003c__main__.Observable object at 0x757957b892d0\u003e\n```\n\nObservable 클래스는 옵저버에 대한 약한 참조를 유지합니다. 이는 그들이 제거되었는지 여부를 신경쓰지 않기 때문입니다. 이전 예제와 마찬가지로, 이를 통해 종속 객체의 수명주기를 관리할 필요가 없습니다. 아마도 주목했을 것이지만, 이 예제에서는 WeakSet을 사용했습니다. 이는 WeakValueDictionary와 비슷하지만 Set을 사용하여 구현되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 섹션의 최종 예제는 weakref 문서에서 빌려왔습니다:\n\n```js\nimport tempfile, shutil\nfrom pathlib import Path\n\nclass TempDir:\n    def __init__(self):\n        self.name = tempfile.mkdtemp()\n        self._finalizer = weakref.finalize(self, shutil.rmtree, self.name)\n\n    def __repr__(self):\n        return \"TempDir({!r:})\".format(self.name)\n\n    def remove(self):\n        self._finalizer()\n\n    @property\n    def removed(self):\n        return not self._finalizer.alive\n\ntmp = TempDir()\nprint(tmp)  # TempDir('/tmp/tmp8o0aecl3')\nprint(tmp.removed)  # False\nprint(Path(tmp.name).is_dir()) # True\n```\n\n이를 통해 weakref 모듈의 또 다른 기능을 확인할 수 있습니다. 바로 weakref.finalize입니다. 이름에서 암시하는 바대로 종속 객체가 가비지 수집될 때 최종화 함수/콜백을 실행할 수 있습니다. 이 예제에서는 가비지 수집될 때 TempDir 객체에 대해 rmtree를 자동으로 실행할 최종화가 실행됩니다. 프로그램이 완전히 종료될 때를 포함하여 TempDir이 가비지 수집될 때 실행되는 finalizer를 통해 TempDir를 정리하기를 항상 기억해야하지만 잊어버릴 경우에 대비할 수 있습니다.\n\n# 실제 예제\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앞서 섹션에서 weakref의 실용적인 사용 예를 보여드렸지만, 실세계 예제도 함께 살펴보겠습니다. 그 중 하나는 캐시된 인스턴스를 생성하는 것입니다:\n\n```js\nimport logging\na = logging.getLogger(\"first\")\nb = logging.getLogger(\"second\")\nprint(a is b)  # False\n\nc = logging.getLogger(\"first\")\nprint(a is c)  # True\n```\n\n위의 코드는 Python의 내장 logging 모듈의 기본적인 사용법입니다. 우리는 특정 이름에 하나의 로거 인스턴스만 관련시킬 수 있음을 알 수 있습니다. 즉, 동일한 로거를 여러 번 검색해도 항상 동일한 캐시된 로거 인스턴스가 반환됩니다.\n\n만약 이를 구현하고 싶다면, 다음과 같이 할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nclass Logger:\n    def __init__(self, name):\n        self.name = name\n\n_logger_cache = weakref.WeakValueDictionary()\n\ndef get_logger(name):\n    if name not in _logger_cache:\n        l = Logger(name)\n        _logger_cache[name] = l\n    else:\n        l = _logger_cache[name]\n    return l\n\na = get_logger(\"first\")\nb = get_logger(\"second\")\nprint(a is b)  # False\n\nc = get_logger(\"first\")\nprint(a is c)  # True\n```\n\n마지막으로, Python 자체도 약한 참조를 사용합니다. OrderedDict의 구현 예시를 보겠습니다:\n\n```python\nfrom _weakref import proxy as _proxy\n\nclass OrderedDict(dict):\n\n    def __new__(cls, /, *args, **kwds):\n        self = dict.__new__(cls)\n        self.__hardroot = _Link()\n        self.__root = root = _proxy(self.__hardroot)\n        root.prev = root.next = root\n        self.__map = {}\n        return self\n```\n\n위는 CPython의 collections 모듈에서의 일부 코드입니다. 여기서 weakref.proxy가 순환 참조를 막는 데 사용된다는 점을 유의하십시오 (더 많은 세부 정보는 doc-strings를 참조하세요).\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\nweakref는 꽤 낯설지만 때때로 매우 유용한 도구로 여러분의 도구상자에 넣어두어야 할 가치가 있습니다. 이는 캐시를 구현하거나 이중 연결 리스트와 같이 서로 참조하는 데이터 구조를 다룰 때 매우 도움이 될 수 있습니다.\n\n그렇지만 여기서 말한 모든 것과 문서에서 언급된 사항은 CPython에 특화되어 있으며 다른 Python 구현체에서는 weakref 동작이 다를 수 있음을 인식해야 합니다. 또한 리스트, 튜플 또는 정수와 같은 많은 내장 타입이 약한 참조를 지원하지 않는다는 사실을 알아두어야 합니다.\n\n본 문서는 원문이 [martinheinz.dev](https://martinheinz.dev)에 게시되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 항목을 추천해 드려요...","ogImage":{"url":"/assets/img/2024-07-01-AGuidetoPythonsWeakReferencesUsingtheweakrefModule_0.png"},"coverImage":"/assets/img/2024-07-01-AGuidetoPythonsWeakReferencesUsingtheweakrefModule_0.png","tag":["Tech"],"readingTime":11},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-07-01-AGuidetoPythonsWeakReferencesUsingtheweakrefModule_0.png\"\u003e\n\u003cp\u003e아마 당신은 파이썬의 weakref 모듈에 대해 들어본 적이 없을 것입니다. 여러분의 코드에서 자주 사용되지는 않지만, 많은 라이브러리, 프레임워크 및 심지어 파이썬 자체의 내부 작업에 기본적입니다. 그래서, 이 글에서는 weakref 모듈이 무엇인지, 어떻게 유용한지, 그리고 여러분의 코드에 어떻게 통합할 수 있는지 살펴보겠습니다.\u003c/p\u003e\n\u003ch1\u003e기본 사항\u003c/h1\u003e\n\u003cp\u003eweakref 모듈과 약한 참조를 이해하기 위해 먼저 파이썬에서 가비지 컬렉션에 대해 간단히 소개해야 합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e파이썬은 쓰레기 수집을 위한 메커니즘으로 참조 카운팅을 사용합니다. 간단히 말해, 파이썬은 우리가 생성한 각 객체에 대한 참조 카운트를 유지하며, 코드에서 객체가 참조될 때마다 참조 카운트가 증가하고, 객체가 해제될 때(e.g. 변수가 None으로 설정될 때) 감소합니다. 참조 카운트가 0이 되면, 해당 객체의 메모리가 할당 해제(가비지 수집)됩니다.\u003c/p\u003e\n\u003cp\u003e조금 더 이해하기 쉽도록 코드를 살펴봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e sys\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSomeObject\u003c/span\u003e:\n    def \u003cspan class=\"hljs-title function_\"\u003e__del__\u003c/span\u003e(self):\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"(Deleting {self=})\"\u003c/span\u003e)\n\nobj = \u003cspan class=\"hljs-title class_\"\u003eSomeObject\u003c/span\u003e()\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(sys.\u003cspan class=\"hljs-title function_\"\u003egetrefcount\u003c/span\u003e(obj))  # \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n\nobj2 = obj\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(sys.\u003cspan class=\"hljs-title function_\"\u003egetrefcount\u003c/span\u003e(obj))  # \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\n\nobj = \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\nobj2 = \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\n\n# (\u003cspan class=\"hljs-title class_\"\u003eDeleting\u003c/span\u003e self=\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003e__main__.SomeObject\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eobject\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eat\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e0x7d303fee7e80\u003c/span\u003e\u003e\u003c/span\u003e)\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서는 \u003cstrong\u003edel\u003c/strong\u003e 메서드만 구현한 클래스를 정의하는데, 이 메서드는 객체가 가비지 수집될 때 호출되며, 가비지 수집이 발생했을 때를 확인할 수 있도록 합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 클래스의 인스턴스를 만든 후에는 sys.getrefcount를 사용하여이 객체에 대한 현재 참조 수를 가져옵니다. 여기에서는 1을 기대하지만 getrefcount가 반환하는 카운트는 일반적으로 예상보다 한 단계 높습니다. getrefcount를 호출하면 참조가 함수의 인수로 값에 의해 복사되어 객체의 참조 수가 일시적으로 증가하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e다음으로, obj2 = obj를 선언하고 다시 getrefcount를 호출하면 이제 obj와 obj2 둘 다에 의해 참조되기 때문에 3을 얻습니다. 반대로, 이러한 변수에 None을 할당하면 참조 수가 0으로 감소하고, 마침내 객체가 가비지 수집되었다는 \u003cstrong\u003edel\u003c/strong\u003e 메서드에서 메시지를 받게 됩니다.\u003c/p\u003e\n\u003cp\u003e자, 그럼 약한 참조는 어떻게 여기에 맞는 것인가요? 객체에 대한 유일한 남은 참조가 약한 참조인 경우, Python 인터프리터는 이 객체를 가비지 수집할 수 있습니다. 다른 말로하면 — 객체에 대한 약한 참조만으로는 객체를 살리는 데 충분하지 않습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e weakref\n\nobj = \u003cspan class=\"hljs-title class_\"\u003eSomeObject\u003c/span\u003e()\n\nreference = weakref.\u003cspan class=\"hljs-title function_\"\u003eref\u003c/span\u003e(obj)\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(reference)  # \u0026#x3C;weakref at \u003cspan class=\"hljs-number\"\u003e0x734b0a514590\u003c/span\u003e; to \u003cspan class=\"hljs-string\"\u003e'SomeObject'\u003c/span\u003e at \u003cspan class=\"hljs-number\"\u003e0x734b0a4e7700\u003c/span\u003e\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003ereference\u003c/span\u003e())  # \u0026#x3C;__main__.\u003cspan class=\"hljs-property\"\u003eSomeObject\u003c/span\u003e object at \u003cspan class=\"hljs-number\"\u003e0x707038c0b700\u003c/span\u003e\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(obj.\u003cspan class=\"hljs-property\"\u003e__weakref__\u003c/span\u003e)  # \u0026#x3C;weakref at \u003cspan class=\"hljs-number\"\u003e0x734b0a514590\u003c/span\u003e; to \u003cspan class=\"hljs-string\"\u003e'SomeObject'\u003c/span\u003e at \u003cspan class=\"hljs-number\"\u003e0x734b0a4e7700\u003c/span\u003e\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(sys.\u003cspan class=\"hljs-title function_\"\u003egetrefcount\u003c/span\u003e(obj))  # \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n\nobj = \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\n\n# (\u003cspan class=\"hljs-title class_\"\u003eDeleting\u003c/span\u003e self=\u0026#x3C;__main__.SomeObject object at 0x70744d42b700\u003e)\n\nprint(reference)  # \u0026#x3C;weakref at 0x7988e2d70590; dead\u003e\nprint(reference())  # None\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우리는 다시 클래스의 obj 변수를 선언합니다. 이번에는 이 객체에 대한 두 번째 강력한 참조 대신에 참조 변수에 약한 참조를 만듭니다.\u003c/p\u003e\n\u003cp\u003e그런 다음 참조 카운트를 확인하면 증가하지 않음을 알 수 있고, obj 변수를 None으로 설정하면 약한 참조가 여전히 남아 있음에도 즉시 쓰레기 수집됨을 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e마지막으로 이미 쓰레기로 처리된 객체에 대한 약한 참조에 액세스하려고 하면 “무효한” 참조 및 None이 반환됩니다.\u003c/p\u003e\n\u003cp\u003e또한 객체에 액세스하기 위해 약한 참조를 사용할 때 함수로 호출해야 했음을 주목하십시오(reference()). 따라서 객체 속성에 액세스해야 하는 경우 특히 프록시를 사용하는 것이 훨씬 편리합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eobj = \u003cspan class=\"hljs-title class_\"\u003eSomeObject\u003c/span\u003e()\n\nreference = weakref.\u003cspan class=\"hljs-title function_\"\u003eproxy\u003c/span\u003e(obj)\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(reference)  # \u0026#x3C;__main__.\u003cspan class=\"hljs-property\"\u003eSomeObject\u003c/span\u003e object at \u003cspan class=\"hljs-number\"\u003e0x78a420e6b700\u003c/span\u003e\u003e\n\nobj.\u003cspan class=\"hljs-property\"\u003eattr\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(reference.\u003cspan class=\"hljs-property\"\u003eattr\u003c/span\u003e)  # \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e사용 시기\u003c/h1\u003e\n\u003cp\u003e이제 약한 참조가 어떻게 작동하는지 알았으니, 어떻게 유용할 수 있는지 몇 가지 예시를 살펴보겠습니다.\u003c/p\u003e\n\u003cp\u003e약한 참조의 일반적인 사용 사례 중 하나는 트리와 같은 데이터 구조입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eclass Node:\r\ndef \u003cstrong\u003einit\u003c/strong\u003e(self, value):\r\nself.value = value\r\nself._parent = None\r\nself.children = []\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edef __repr__(self):\r\n    return \"Node({!r:})\".format(self.value)\r\n\r\n@property\r\ndef parent(self):\r\n    return self._parent if self._parent is None else self._parent()\r\n\r\n@parent.setter\r\ndef parent(self, node):\r\n    self._parent = weakref.ref(node)\r\n\r\ndef add_child(self, child):\r\n    self.children.append(child)\r\n    child.parent = self\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eroot = Node(\"parent\")\r\nn = Node(\"child\")\r\nroot.add_child(n)\r\nprint(n.parent)  # Node('parent')\u003c/p\u003e\n\u003cp\u003edel root\r\nprint(n.parent)  # None\u003c/p\u003e\n\u003cp\u003e여기서는 약한 참조를 사용하여 자식 노드들이 부모 노드를 가리키는 Node 클래스를 통해 트리를 구현했습니다. 이 관계에서 자식 Node는 부모 Node 없이 살 수 있어 부모가 소리 없이 제거되거나 가비지 수집될 수 있게 합니다.\u003c/p\u003e\n\u003cp\u003e또 다른 방법으로 이를 구현해보겠습니다:\u003c/p\u003e\n\u003cp\u003eclass Node:\r\ndef \u003cstrong\u003einit\u003c/strong\u003e(self, value):\r\nself.value = value\r\nself._children = weakref.WeakValueDictionary()\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@property\r\ndef children(self):\r\n    return list(self._children.items())\r\n\r\ndef add_child(self, key, child):\r\n    self._children[key] = child\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eroot = Node(\"parent\")\r\nn1 = Node(\"child one\")\r\nn2 = Node(\"child two\")\r\nroot.add_child(\"n1\", n1)\r\nroot.add_child(\"n2\", n2)\r\nprint(root.children)  # [('n1', Node('child one')), ('n2', Node('child two'))]\u003c/p\u003e\n\u003cp\u003edel n1\r\nprint(root.children)  # [('n2', Node('child two'))]\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e여기서 부모는 자식들을 약한 참조를 갖고 있습니다. 이는 WeakValueDictionary를 사용합니다. 사전에서 참조된 요소(약한 참조)가 프로그램의 다른 곳에서 참조를 제거하면, 자동으로 사전에서도 제거됩니다. 따라서 사전 항목의 수명주기를 관리할 필요가 없습니다.\u003c/p\u003e\n\u003cp\u003eweakref의 또 다른 사용 예는 Observer 디자인 패턴에 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e:\n    def \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(self):\n        self.\u003cspan class=\"hljs-property\"\u003e_observers\u003c/span\u003e = weakref.\u003cspan class=\"hljs-title class_\"\u003eWeakSet\u003c/span\u003e()\n\n    def \u003cspan class=\"hljs-title function_\"\u003eregister_observer\u003c/span\u003e(self, obs):\n        self.\u003cspan class=\"hljs-property\"\u003e_observers\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(obs)\n\n    def \u003cspan class=\"hljs-title function_\"\u003enotify_observers\u003c/span\u003e(self, *args, **kwargs):\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e obs \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e self.\u003cspan class=\"hljs-property\"\u003e_observers\u003c/span\u003e:\n            obs.\u003cspan class=\"hljs-title function_\"\u003enotify\u003c/span\u003e(self, *args, **kwargs)\n\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObserver\u003c/span\u003e:\n    def \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(self, observable):\n        observable.\u003cspan class=\"hljs-title function_\"\u003eregister_observer\u003c/span\u003e(self)\n\n    def \u003cspan class=\"hljs-title function_\"\u003enotify\u003c/span\u003e(self, observable, *args, **kwargs):\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Got\"\u003c/span\u003e, args, kwargs, \u003cspan class=\"hljs-string\"\u003e\"From\"\u003c/span\u003e, observable)\n\nsubject = \u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e()\nobserver = \u003cspan class=\"hljs-title class_\"\u003eObserver\u003c/span\u003e(subject)\nsubject.\u003cspan class=\"hljs-title function_\"\u003enotify_observers\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"test\"\u003c/span\u003e, kw=\u003cspan class=\"hljs-string\"\u003e\"python\"\u003c/span\u003e)\n# \u003cspan class=\"hljs-title class_\"\u003eGot\u003c/span\u003e (\u003cspan class=\"hljs-string\"\u003e'test'\u003c/span\u003e,) {\u003cspan class=\"hljs-string\"\u003e'kw'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'python'\u003c/span\u003e} \u003cspan class=\"hljs-title class_\"\u003eFrom\u003c/span\u003e \u0026#x3C;__main__.\u003cspan class=\"hljs-property\"\u003eObservable\u003c/span\u003e object at \u003cspan class=\"hljs-number\"\u003e0x757957b892d0\u003c/span\u003e\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eObservable 클래스는 옵저버에 대한 약한 참조를 유지합니다. 이는 그들이 제거되었는지 여부를 신경쓰지 않기 때문입니다. 이전 예제와 마찬가지로, 이를 통해 종속 객체의 수명주기를 관리할 필요가 없습니다. 아마도 주목했을 것이지만, 이 예제에서는 WeakSet을 사용했습니다. 이는 WeakValueDictionary와 비슷하지만 Set을 사용하여 구현되었습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 섹션의 최종 예제는 weakref 문서에서 빌려왔습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e tempfile, shutil\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e pathlib \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTempDir\u003c/span\u003e:\n    def \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(self):\n        self.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e = tempfile.\u003cspan class=\"hljs-title function_\"\u003emkdtemp\u003c/span\u003e()\n        self.\u003cspan class=\"hljs-property\"\u003e_finalizer\u003c/span\u003e = weakref.\u003cspan class=\"hljs-title function_\"\u003efinalize\u003c/span\u003e(self, shutil.\u003cspan class=\"hljs-property\"\u003ermtree\u003c/span\u003e, self.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e)\n\n    def \u003cspan class=\"hljs-title function_\"\u003e__repr__\u003c/span\u003e(self):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"TempDir({!r:})\"\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eformat\u003c/span\u003e(self.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e)\n\n    def \u003cspan class=\"hljs-title function_\"\u003eremove\u003c/span\u003e(self):\n        self.\u003cspan class=\"hljs-title function_\"\u003e_finalizer\u003c/span\u003e()\n\n    @property\n    def \u003cspan class=\"hljs-title function_\"\u003eremoved\u003c/span\u003e(self):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e not self.\u003cspan class=\"hljs-property\"\u003e_finalizer\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ealive\u003c/span\u003e\n\ntmp = \u003cspan class=\"hljs-title class_\"\u003eTempDir\u003c/span\u003e()\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(tmp)  # \u003cspan class=\"hljs-title class_\"\u003eTempDir\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/tmp/tmp8o0aecl3'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(tmp.\u003cspan class=\"hljs-property\"\u003eremoved\u003c/span\u003e)  # \u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e(tmp.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eis_dir\u003c/span\u003e()) # \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이를 통해 weakref 모듈의 또 다른 기능을 확인할 수 있습니다. 바로 weakref.finalize입니다. 이름에서 암시하는 바대로 종속 객체가 가비지 수집될 때 최종화 함수/콜백을 실행할 수 있습니다. 이 예제에서는 가비지 수집될 때 TempDir 객체에 대해 rmtree를 자동으로 실행할 최종화가 실행됩니다. 프로그램이 완전히 종료될 때를 포함하여 TempDir이 가비지 수집될 때 실행되는 finalizer를 통해 TempDir를 정리하기를 항상 기억해야하지만 잊어버릴 경우에 대비할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e실제 예제\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e앞서 섹션에서 weakref의 실용적인 사용 예를 보여드렸지만, 실세계 예제도 함께 살펴보겠습니다. 그 중 하나는 캐시된 인스턴스를 생성하는 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e logging\na = logging.\u003cspan class=\"hljs-title function_\"\u003egetLogger\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"first\"\u003c/span\u003e)\nb = logging.\u003cspan class=\"hljs-title function_\"\u003egetLogger\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"second\"\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(a is b)  # \u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e\n\nc = logging.\u003cspan class=\"hljs-title function_\"\u003egetLogger\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"first\"\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(a is c)  # \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 코드는 Python의 내장 logging 모듈의 기본적인 사용법입니다. 우리는 특정 이름에 하나의 로거 인스턴스만 관련시킬 수 있음을 알 수 있습니다. 즉, 동일한 로거를 여러 번 검색해도 항상 동일한 캐시된 로거 인스턴스가 반환됩니다.\u003c/p\u003e\n\u003cp\u003e만약 이를 구현하고 싶다면, 다음과 같이 할 수 있습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLogger\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, name\u003c/span\u003e):\n        self.name = name\n\n_logger_cache = weakref.WeakValueDictionary()\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eget_logger\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ename\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e name \u003cspan class=\"hljs-keyword\"\u003enot\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e _logger_cache:\n        l = Logger(name)\n        _logger_cache[name] = l\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e:\n        l = _logger_cache[name]\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e l\n\na = get_logger(\u003cspan class=\"hljs-string\"\u003e\"first\"\u003c/span\u003e)\nb = get_logger(\u003cspan class=\"hljs-string\"\u003e\"second\"\u003c/span\u003e)\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(a \u003cspan class=\"hljs-keyword\"\u003eis\u003c/span\u003e b)  \u003cspan class=\"hljs-comment\"\u003e# False\u003c/span\u003e\n\nc = get_logger(\u003cspan class=\"hljs-string\"\u003e\"first\"\u003c/span\u003e)\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(a \u003cspan class=\"hljs-keyword\"\u003eis\u003c/span\u003e c)  \u003cspan class=\"hljs-comment\"\u003e# True\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막으로, Python 자체도 약한 참조를 사용합니다. OrderedDict의 구현 예시를 보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e _weakref \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e proxy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e _proxy\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOrderedDict\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003edict\u003c/span\u003e):\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__new__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecls, /, *args, **kwds\u003c/span\u003e):\n        self = \u003cspan class=\"hljs-built_in\"\u003edict\u003c/span\u003e.__new__(cls)\n        self.__hardroot = _Link()\n        self.__root = root = _proxy(self.__hardroot)\n        root.prev = root.\u003cspan class=\"hljs-built_in\"\u003enext\u003c/span\u003e = root\n        self.__\u003cspan class=\"hljs-built_in\"\u003emap\u003c/span\u003e = {}\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e self\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위는 CPython의 collections 모듈에서의 일부 코드입니다. 여기서 weakref.proxy가 순환 참조를 막는 데 사용된다는 점을 유의하십시오 (더 많은 세부 정보는 doc-strings를 참조하세요).\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003eweakref는 꽤 낯설지만 때때로 매우 유용한 도구로 여러분의 도구상자에 넣어두어야 할 가치가 있습니다. 이는 캐시를 구현하거나 이중 연결 리스트와 같이 서로 참조하는 데이터 구조를 다룰 때 매우 도움이 될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그렇지만 여기서 말한 모든 것과 문서에서 언급된 사항은 CPython에 특화되어 있으며 다른 Python 구현체에서는 weakref 동작이 다를 수 있음을 인식해야 합니다. 또한 리스트, 튜플 또는 정수와 같은 많은 내장 타입이 약한 참조를 지원하지 않는다는 사실을 알아두어야 합니다.\u003c/p\u003e\n\u003cp\u003e본 문서는 원문이 \u003ca href=\"https://martinheinz.dev\" rel=\"nofollow\" target=\"_blank\"\u003emartinheinz.dev\u003c/a\u003e에 게시되었습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다음 항목을 추천해 드려요...\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-01-AGuidetoPythonsWeakReferencesUsingtheweakrefModule"},"buildId":"wOkGEDZCvEs3S_XaNsdwr","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>