<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>테라폼을 이용한 AWS 인프라 배포와 앤서블을 이용한 구성 설정 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="테라폼을 이용한 AWS 인프라 배포와 앤서블을 이용한 구성 설정 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="테라폼을 이용한 AWS 인프라 배포와 앤서블을 이용한 구성 설정 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible" data-gatsby-head="true"/><meta name="twitter:title" content="테라폼을 이용한 AWS 인프라 배포와 앤서블을 이용한 구성 설정 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 13:24" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_buildManifest.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">테라폼을 이용한 AWS 인프라 배포와 앤서블을 이용한 구성 설정</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="테라폼을 이용한 AWS 인프라 배포와 앤서블을 이용한 구성 설정" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">19<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>소개:</h1>
<p>현재의 동적 클라우드 컴퓨팅 환경에서는 인프라 프로비저닝을 자동화하는 것이 확장성, 신뢰성, 및 비용 효율성을 원하는 기관들에게 필수적입니다. Terraform은 오픈 소스 인프라 코드 도구로, 선언적 구성 파일을 사용하여 인프라를 정의하고 관리할 수 있도록 팀에게 권한을 부여합니다. 이 블로그에서는 Terraform이 AWS 인프라 구성 요소의 배포를 체계적이고 효율적으로 간소화하는 방법을 탐색해보겠습니다.</p>
<h1>프로젝트 개요:</h1>
<p>우리 Terraform 프로젝트는 가상 사설 클라우드(VPC), 보안 그룹, Amazon Machine Image(AMI), Elastic Block Store(EBS) 볼륨, 및 EC2 인스턴스로 구성된 AWS 인프라 스택의 배포를 자동화하는 데 초점을 맞춥니다. Terraform의 모듈식이자 반복 가능한 구성을 활용하여 환경 간 일관성과 신뢰성을 보장하고, 수동 개입과 인적 오류를 최소화합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>상세 단계:</h1>
<h2>1. AWS CLI 설치하기:</h2>
<ul>
<li>먼저 로컬 컴퓨터에 AWS CLI를 설치해야 합니다.</li>
<li>다음 링크를 따라 AWS CLI를 설치하세요:</li>
</ul>
<p><img src="/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_0.png" alt="AWS CLI 설치 링크"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>AWS CLI를 이곳에서 다운로드하여 계정에 구성하세요.</li>
<li>또는 Linux 버전을 선택하여 설치할 수도 있습니다.</li>
<li>이를 위해 계정에 IAM 사용자를 만들어야 합니다.</li>
</ul>
<p><img src="/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_1.png" alt="이미지1"></p>
<p><img src="/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_2.png" alt="이미지2"></p>
<ul>
<li>현재는 관리자 액세스를 제공하지만 좋은 실천 방법은 아닙니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_3.png" alt="2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_3.png"></p>
<p><img src="/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_4.png" alt="2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_4.png"></p>
<ul>
<li>보안 자격 증명에서 "액세스 키 생성" 옵션을 클릭하여 액세스 키 및 비밀 키를 생성하고 둘 다 복사합니다.</li>
</ul>
<p><img src="/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_5.png" alt="2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_5.png"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>Access Key ID에 액세스 키를 붙여 넣고, Secret Access Key ID에 비밀 키를 입력해주세요. 그리고 설정하고 싶은 기본 지역도 지정해주세요.</li>
</ul>
<h2>2. Terraform 초기화하기.</h2>
<ul>
<li>main.tf 파일을 생성하고, 제공자(provider) 구성을 거기에 입력해주세요.</li>
</ul>
<pre><code class="hljs language-js"># main.<span class="hljs-property">tf</span>

# <span class="hljs-title class_">Provider</span> configuration
provider <span class="hljs-string">"aws"</span> {
  region = <span class="hljs-string">"us-west-1"</span>
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>그럼 아래 명령어를 입력해주세요.</li>
</ul>
<pre><code class="hljs language-js">terraform.<span class="hljs-property">exe</span> init
</code></pre>
<h2>3. VPC 생성:</h2>
<p>우리는 VPC 구성을 정의합니다. CIDR 블록을 포함하여 네트워크 구조의 기반을 마련합니다. 이는 AWS 환경 내에서 격리되고 안전한 통신을 제공합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>이 프로젝트 전체에 대해 동일한 main.tf 파일을 사용할 것입니다.</li>
</ul>
<pre><code class="hljs language-js"># main.<span class="hljs-property">tf</span>

resource <span class="hljs-string">"aws_vpc"</span> <span class="hljs-string">"vpc"</span>{
        cidr_block = <span class="hljs-string">"192.168.0.0/16"</span>

        tags = {
                <span class="hljs-title class_">Name</span> = <span class="hljs-string">"Terraform_VPC"</span>
        }
}
</code></pre>
<h2>4. 서브넷 생성:</h2>
<ul>
<li>이제 서브넷 구성을 정의합니다. 이 구성에는 공용 서브넷과 사설 서브넷이 모두 포함됩니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"># main.<span class="hljs-property">tf</span>

변수 <span class="hljs-string">"aws_azs"</span>를 정의합니다. 여기에는 public 서브넷의 가용 영역이 저장됩니다. 그리고 public 서브넷의 <span class="hljs-variable constant_">CIDR</span> 블록을 저장하는 다른 변수를 만듭니다.

그런 다음 각 가용 영역에 <span class="hljs-number">2</span>개의 public 서브넷을 만듭니다.
- length 함수는 주어진 목록, 맵 또는 문자열의 길이를 결정합니다. 목록이나 맵이 주어지면 해당 컬렉션의 요소 수가 결과로 나옵니다.
- <span class="hljs-title function_">element</span>() 함수는 목록에서 특정 인덱스의 요소를 검색합니다. 사용 사례: 목록에서 특정 요소에 액세스하는 것은 해당 인덱스를 기준으로 목록에서 특정 리소스나 매개변수를 선택하려고 할 때 유용합니다.
- count.<span class="hljs-property">index</span> 객체는 count 내의 현재 인스턴스의 인덱스를 나타냅니다. 인덱스는 <span class="hljs-number">0</span>부터 시작하며, count가 <span class="hljs-number">4</span>인 리소스가 있으면 count.<span class="hljs-property">index</span> 객체는 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> 및 <span class="hljs-number">3</span>이 됩니다.
- 그런 다음 private 서브넷을 만드는 동일한 단계를 반복합니다.

## <span class="hljs-number">5.</span> <span class="hljs-title class_">Internet</span>-<span class="hljs-title class_">Gateway</span> 및 <span class="hljs-title class_">Route</span>-table 생성:

이제 public 서브넷에 인터넷에 연결할 <span class="hljs-title class_">Internet</span>-<span class="hljs-title class_">Gateway</span>를 만들 것입니다. 이를 위해 라우팅 테이블도 생성하여 경로를 만들어야 합니다.
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"># main.<span class="hljs-property">tf</span>

resource <span class="hljs-string">"aws_internet_gateway"</span> <span class="hljs-string">"igw"</span> {
        vpc_id = aws_vpc.<span class="hljs-property">vpc</span>.<span class="hljs-property">id</span>
        tags = {
                <span class="hljs-title class_">Name</span> = <span class="hljs-string">"terrform-vpc-igw"</span>
        }
}

resource <span class="hljs-string">"aws_route_table"</span> <span class="hljs-string">"second-rt"</span> {
        vpc_id = aws_vpc.<span class="hljs-property">vpc</span>.<span class="hljs-property">id</span>
        route {
                cidr_block = <span class="hljs-string">"0.0.0.0/0"</span>
                gateway_id = aws_internet_gateway.<span class="hljs-property">igw</span>.<span class="hljs-property">id</span>
        }

        tags = {
                <span class="hljs-title class_">Name</span> = <span class="hljs-string">"Public-route-table"</span>
        }
}

resource <span class="hljs-string">"aws_route_table_association"</span> <span class="hljs-string">"public-subnets-asso"</span> {
        count = <span class="hljs-title function_">length</span>(<span class="hljs-keyword">var</span>.<span class="hljs-property">public_subnet_cidrs</span>)
        subnet_id = <span class="hljs-title function_">element</span>(aws_subnet.<span class="hljs-property">public_subnets</span>[*].<span class="hljs-property">id</span>, count.<span class="hljs-property">index</span>)
        route_table_id = aws_route_table.<span class="hljs-property">second</span>-rt.<span class="hljs-property">id</span>
}
</code></pre>
<ul>
<li>여기서, 먼저 VPC 내에서 인터넷 게이트웨이를 생성합니다.</li>
<li>그런 다음 인터넷 게이트웨이를 통해 안전한 인터넷 연결을 가능하게 하는 라우트를 생성하는 라우트 테이블을 만듭니다.</li>
<li>그런 다음 이 라우트 테이블과 공용 서브넷을 연결해야합니다.</li>
</ul>
<h2>6. 보안 그룹 구성:</h2>
<p>EC2 인스턴스로의 들어오고 나가는 트래픽을 제어하기 위해 보안 그룹 규칙을 지정합니다. 이렇게 하면 사전 정의된 규칙 세트에 따라 액세스를 제한하여 네트워크 보안이 강화되며 잠재적인 보안 취약점을 완화할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">resource <span class="hljs-string">"aws_security_group"</span> <span class="hljs-string">"sg"</span> {
    name        = <span class="hljs-string">"terraform_sg"</span>
    description = <span class="hljs-string">"This security group is for terraform practice"</span>
    vpc_id      = aws_vpc.<span class="hljs-property">vpc</span>.<span class="hljs-property">id</span>

    tags = {
        <span class="hljs-title class_">Name</span> = <span class="hljs-string">"terraform_vg"</span>
    }
}

resource <span class="hljs-string">"aws_vpc_security_group_ingress_rule"</span> <span class="hljs-string">"sg_in_rule"</span> {
    security_group_id = aws_security_group.<span class="hljs-property">sg</span>.<span class="hljs-property">id</span>
    cidr_ipv4        = <span class="hljs-string">"0.0.0.0/0"</span>
    from_port        = <span class="hljs-number">80</span>
    ip_protocol      = <span class="hljs-string">"tcp"</span>
    to_port          = <span class="hljs-number">80</span>
}

resource <span class="hljs-string">"aws_vpc_security_group_ingress_rule"</span> <span class="hljs-string">"sg_in_rule2"</span> {
    security_group_id = aws_security_group.<span class="hljs-property">sg</span>.<span class="hljs-property">id</span>
    cidr_ipv4        = <span class="hljs-string">"0.0.0.0/0"</span>
    from_port        = <span class="hljs-number">22</span>
    ip_protocol      = <span class="hljs-string">"tcp"</span>
    to_port          = <span class="hljs-number">22</span>
}

resource <span class="hljs-string">"aws_vpc_security_group_egress_rule"</span> <span class="hljs-string">"sg_eg_rule"</span> {
    security_group_id = aws_security_group.<span class="hljs-property">sg</span>.<span class="hljs-property">id</span>
    cidr_ipv4         = <span class="hljs-string">"0.0.0.0/0"</span>
    ip_protocol       = <span class="hljs-string">"-1"</span> # semantically equivalent to all ports
}
</code></pre>
<ul>
<li>먼저 VPC 내에서 보안 그룹을 만듭니다.</li>
<li>그런 다음 보안 그룹에 대한 인바운드 규칙을 정의하여 클라이언트가 포트 80 및 22에 도달할 수 있도록 허용합니다.</li>
<li>그런 다음 아무 포트에서 어디로든 연결을 허용하는 보안 그룹에 대한 아웃바운드 규칙을 정의합니다.</li>
</ul>
<h2>7. 데이터 소스를 활용한 AMI 구성:</h2>
<p>Terraform의 데이터 소스를 활용하여 지정된 필터에 따라 기존 AWS AMI에 대한 정보를 가져올 수 있습니다. 이러한 필터는 지역, 운영 체제 및 아키텍처와 같은 미리 정의된 것으로 구성됩니다. 이는 EC2 인스턴스에 가장 적합한 AMI를 동적으로 선택함으로써 배포 간의 호환성 및 일관성을 보장합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">data <span class="hljs-string">"aws_ami"</span> <span class="hljs-string">"rhel9"</span> {
        most_recent = <span class="hljs-literal">true</span>

        owners = [<span class="hljs-string">"309956199498"</span>] <span class="hljs-comment">// Red Hat의 계정 ID.</span>

        filter {
                name   = <span class="hljs-string">"architecture"</span>
                values = [<span class="hljs-string">"x86_64"</span>]
        }

        filter {
                name   = <span class="hljs-string">"root-device-type"</span>
                values = [<span class="hljs-string">"ebs"</span>]
        }

        filter {
                name   = <span class="hljs-string">"virtualization-type"</span>
                values = [<span class="hljs-string">"hvm"</span>]
        }

        filter {
                name   = <span class="hljs-string">"name"</span>
                values = [<span class="hljs-string">"RHEL-9.*"</span>]
        }
}
</code></pre>
<ul>
<li>데이터 소스는 외부 시스템이나 기존 리소스에서 정보를 조회하고 해당 정보를 Terraform 구성에 통합하는 데 사용됩니다.</li>
</ul>
<h2>8. EC2 인스턴스 프로비저닝:</h2>
<p>인스턴스 유형, 키페어, 보안 그룹을 포함한 EC2 인스턴스 구성을 정의합니다. Terraform은 VPC 내에서 EC2 인스턴스를 프로비저닝하여 지정된 구성을 준수하면서 연결성과 리소스 격리를 보장합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-json">파일 이름 <span class="hljs-punctuation">:</span> main.tf
</code></pre>
<h2>3. EC2 인스턴스 생성 :</h2>
<p>이 코드는 Terraform을 사용하여 AWS EC2 인스턴스를 생성하는 예시입니다. 우리는 AMI ID, 인스턴스 유형, 키 이름, 서브넷 ID, 보안 그룹 ID 등을 정의하고 있습니다. 이를 통해 인프라스트럭처 스택에 EC2 인스턴스를 통합할 수 있습니다. 태그를 지정하여 리소스를 식별할 수도 있습니다.</p>
<h2>테이블</h2>

































<table><thead><tr><th>제목</th><th>설명</th></tr></thead><tbody><tr><td>AMI</td><td>data.aws_ami.rhel9.id</td></tr><tr><td>유형</td><td>"t2.micro"</td></tr><tr><td>키 이름</td><td>"IAM_California"</td></tr><tr><td>서브넷 ID</td><td>aws_subnet.public_subnets[0].id</td></tr><tr><td>VPC 보안 그룹 ID</td><td>aws_security_group.sg.id</td></tr><tr><td>퍼블릭 IP 주소 연결</td><td>true</td></tr></tbody></table>
<p>태그 :</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>이제 새로운 EBS 볼륨을 생성했습니다. 중요한 점은 ec2 인스턴스와 ebs 볼륨이 동일한 가용 영역에 있어야 한다는 것입니다. 그렇지 않으면 서로 연결할 수 없습니다.</li>
</ul>
<h2>10. EBS 볼륨 연결</h2>
<p>이제 다음 단계는 새로 생성한 ebs 볼륨을 ec2 인스턴스에 연결하는 것입니다.</p>
<pre><code class="hljs language-js">resource <span class="hljs-string">"aws_volume_attachment"</span> <span class="hljs-string">"ebs_attach"</span> {
        device_name = <span class="hljs-string">"/dev/xvdb"</span>
        volume_id = aws_ebs_volume.<span class="hljs-property">EBS</span>.<span class="hljs-property">id</span>
        instance_id = aws_instance.<span class="hljs-property">ec2</span>-<span class="hljs-number">1.</span>id
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>11. 공용 IP 주소 출력:</h2>
<p>마지막으로, 테라폼의 출력 기능을 사용하여 프로비저닝된 EC2 인스턴스의 공용 IP 주소를 표시합니다. 이는 관리자와 최종 사용자 모두가 인스턴스에 쉽게 액세스하고 관리할 수 있도록 합니다.</p>
<pre><code class="hljs language-js">output <span class="hljs-string">"ec2_instance_ip"</span> {
        value = aws_instance.<span class="hljs-property">ec2</span>-<span class="hljs-number">1.</span>public_ip
}
</code></pre>
<h2>12. 테라폼 파일 적용하기</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>지금은 여태까지 AWS 인프라를 만든 main.tf 파일을 적용할 것입니다.</p>
<pre><code class="hljs language-js">terraform.<span class="hljs-property">exe</span> apply
</code></pre>
<p><img src="/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_6.png" alt="AWS Infrastructure Deployment"></p>
<ul>
<li>먼저 전체 계획을 알려줍니다. 그렇지 않으면 계획을 보는 별도의 명령어가 있습니다. 즉, terraform.exe plan</li>
<li>계획을 알려준 후에는 앞으로 진행하고 AWS 클라우드에 적용할 것인지 물어봅니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_7.png" alt="AWS Infrastructure Deployment with Terraform and Configuration with Ansible 7"></p>
<p><img src="/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_8.png" alt="AWS Infrastructure Deployment with Terraform and Configuration with Ansible 8"></p>
<h1>Let’s Go on our AWS Console to verify this deployment.</h1>
<h2>VPC ARCHITECTURE:</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_9.png" alt="AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_9"></p>
<p><img src="/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_10.png" alt="AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_10"></p>
<h2>SECURITY GROUP :</h2>
<p><img src="/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_11.png" alt="AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_11"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>EC2-INSTANCE :</h2>
<p><img src="/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_12.png" alt="EC2-INSTANCE"></p>
<h1>Ansible Configuration Management:</h1>
<p>인프라가 프로비저닝된 후에는 프로비저닝된 인스턴스 내에서 Ansible을 사용하여 구성 관리 작업으로 신속하게 전환합니다. Ansible은 우리에게 idempotent playbooks 및 모듈을 사용하여 복잡한 구성 작업을 자동화할 수 있는 기능을 제공하여 효율적이고 확장 가능한 인프라 관리를 가능하게 합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>저희 프로젝트는 Terraform과 Ansible을 완벽하게 통합하여 일관된 배포 파이프라인을 구축합니다. Terraform은 인프라 스택의 기반을 마련하는 데 도움을 주고, Ansible은 프로비전된 인스턴스를 구성하여 그들이 그 의도한 목적을 위해 완전히 기능하고 최적화되도록 보장합니다.</p>
<h2>EC2-인스턴스 구성을 위한 Ansible의 실용적인 단계:</h2>
<ul>
<li>ANSIBLE 인벤토리:</li>
</ul>
<pre><code class="hljs language-js">vim / etc / ansible / hosts;
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>&#x3C;img src="/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_13.png" /></p>
<ol start="2">
<li>REQUIRED MODULES 설치하기.</li>
</ol>
<pre><code class="hljs language-js">ansible-galaxy collections install community.<span class="hljs-property">general</span>
ansible-galaxy collections install posix
</code></pre>
<ol start="3">
<li>ANSIBLE-PLAYBOOK:</li>
</ol>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">vim &#x3C;file-name>.<span class="hljs-property">yml</span>
</code></pre>
<p><img src="/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_14.png" alt="AWS Infrastructure Deployment with Terraform and Configuration with Ansible"></p>
<p><img src="/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_15.png" alt="AWS Infrastructure Deployment with Terraform and Configuration with Ansible"></p>
<p><img src="/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_16.png" alt="AWS Infrastructure Deployment with Terraform and Configuration with Ansible"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span> <span class="hljs-string">all</span>
  <span class="hljs-attr">become:</span> <span class="hljs-literal">yes</span>
  <span class="hljs-attr">tasks:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">"파티션 생성"</span>
      <span class="hljs-attr">community.general.parted:</span>
        <span class="hljs-attr">device:</span> <span class="hljs-string">"/dev/xvdb"</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">"GPT"</span>
        <span class="hljs-attr">number:</span> <span class="hljs-number">1</span>
        <span class="hljs-attr">part_end:</span> <span class="hljs-string">"1GiB"</span>
        <span class="hljs-attr">fs_type:</span> <span class="hljs-string">"ext4"</span>
        <span class="hljs-attr">state:</span> <span class="hljs-string">present</span>
        <span class="hljs-attr">label:</span> <span class="hljs-string">"gpt"</span>
        <span class="hljs-attr">unit:</span> <span class="hljs-string">GiB</span>

    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">"중요 명령어 실행"</span>
      <span class="hljs-attr">command:</span>
        <span class="hljs-attr">cmd:</span> <span class="hljs-string">"udevadm settle"</span>
      <span class="hljs-attr">register:</span> <span class="hljs-string">cmd</span>

    <span class="hljs-bullet">-</span> <span class="hljs-attr">debug:</span>
        <span class="hljs-attr">var:</span> <span class="hljs-string">cmd</span>

    <span class="hljs-bullet">-</span> <span class="hljs-attr">command:</span>
        <span class="hljs-attr">cmd:</span> <span class="hljs-string">"lsblk"</span>
      <span class="hljs-attr">register:</span> <span class="hljs-string">cmd2</span>

    <span class="hljs-bullet">-</span> <span class="hljs-attr">debug:</span>
        <span class="hljs-attr">var:</span> <span class="hljs-string">cmd2</span>

    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">"파티션 포맷"</span>
      <span class="hljs-attr">community.general.filesystem:</span>
        <span class="hljs-attr">fstype:</span> <span class="hljs-string">ext4</span>
        <span class="hljs-attr">dev:</span> <span class="hljs-string">"/dev/xvdb1"</span>

    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">"웹 서버 설치"</span>
      <span class="hljs-attr">package:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">"httpd"</span>
        <span class="hljs-attr">state:</span> <span class="hljs-string">present</span>

    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">"마운트된 볼륨과 연결"</span>
      <span class="hljs-attr">ansible.posix.mount:</span>
        <span class="hljs-attr">path:</span> <span class="hljs-string">"/var/www/html"</span>
        <span class="hljs-attr">src:</span> <span class="hljs-string">"/dev/xvdb1"</span>
        <span class="hljs-attr">state:</span> <span class="hljs-string">mounted</span>
        <span class="hljs-attr">fstype:</span> <span class="hljs-string">ext4</span>

    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">"데몬 다시로드"</span>
      <span class="hljs-attr">command:</span>
        <span class="hljs-attr">cmd:</span> <span class="hljs-string">"systemctl daemon-reload"</span>

    <span class="hljs-bullet">-</span> <span class="hljs-attr">command:</span>
        <span class="hljs-attr">cmd:</span> <span class="hljs-string">"lsblk"</span>
      <span class="hljs-attr">register:</span> <span class="hljs-string">cmd3</span>

    <span class="hljs-bullet">-</span> <span class="hljs-attr">debug:</span>
        <span class="hljs-attr">var:</span> <span class="hljs-string">cmd3</span>

    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">"인덱스 파일을 웹 서버로 복사"</span>
      <span class="hljs-attr">ansible.builtin.copy:</span>
        <span class="hljs-attr">src:</span> <span class="hljs-string">"index.html"</span>
        <span class="hljs-attr">dest:</span> <span class="hljs-string">"/var/www/html/index.html"</span>

    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">"서버 재시작"</span>
      <span class="hljs-attr">service:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">"httpd"</span>
        <span class="hljs-attr">state:</span> <span class="hljs-string">"started"</span>
</code></pre>
<h2>이 Playbook은 다음을 수행할 수 있습니다:</h2>
<ul>
<li>우리가 연결한 볼륨인 /dev/xvdb에 파티션 생성.</li>
<li>ext4 유형으로 새로 생성된 파티션 포맷.</li>
<li>시스템에 아파치 웹 서버 설치.</li>
<li>아파치 루트 문서인 /var/www/html에 파티션을 마운트.</li>
<li>로컬 시스템의 인덱스 파일을 대상 시스템의 루트 문서에 복사.</li>
<li>아파치 서비스 시작.</li>
</ul>
<h2>ANSIBLE PLAYBOOK 실행하기</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">ansible-playbook &#x3C;file-name>.<span class="hljs-property">yml</span>
</code></pre>
<p><img src="/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_17.png" alt="Image"></p>
<p><img src="/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_18.png" alt="Image"></p>
<h2>웹 서버가 성공적으로 시작되었는지 확인해 봅시다.</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_19.png" alt="AWS Infrastructure Deployment with Terraform and Configuration with Ansible"></p>
<h1>결론:</h1>
<p>요약하면, Terraform과 Ansible의 통합은 AWS 인프라 자동화에서 강력한 패러다임 변화를 나타냅니다. 인프라 프로비저닝에 Terraform을 활용하고 구성 관리에는 Ansible을 활용함으로써, 조직은 클라우드 배포에서 전례 없는 민첩성, 확장성 및 신뢰성을 달성할 수 있습니다. 이 통합 접근 방식을 통해 팀은 DevOps 성숙도로 나아가는 여정을 가속화하고 클라우드 자동화의 모든 잠재력을 발휘할 수 있습니다.</p>
<p>오늘 Terraform과 Ansible의 힘을 받아 AWS 인프라 배포 및 구성 워크플로를 혁신하세요! 🚀🔧</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"테라폼을 이용한 AWS 인프라 배포와 앤서블을 이용한 구성 설정","description":"","date":"2024-06-19 13:24","slug":"2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible","content":"\n# 소개:\n\n현재의 동적 클라우드 컴퓨팅 환경에서는 인프라 프로비저닝을 자동화하는 것이 확장성, 신뢰성, 및 비용 효율성을 원하는 기관들에게 필수적입니다. Terraform은 오픈 소스 인프라 코드 도구로, 선언적 구성 파일을 사용하여 인프라를 정의하고 관리할 수 있도록 팀에게 권한을 부여합니다. 이 블로그에서는 Terraform이 AWS 인프라 구성 요소의 배포를 체계적이고 효율적으로 간소화하는 방법을 탐색해보겠습니다.\n\n# 프로젝트 개요:\n\n우리 Terraform 프로젝트는 가상 사설 클라우드(VPC), 보안 그룹, Amazon Machine Image(AMI), Elastic Block Store(EBS) 볼륨, 및 EC2 인스턴스로 구성된 AWS 인프라 스택의 배포를 자동화하는 데 초점을 맞춥니다. Terraform의 모듈식이자 반복 가능한 구성을 활용하여 환경 간 일관성과 신뢰성을 보장하고, 수동 개입과 인적 오류를 최소화합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 상세 단계:\n\n## 1. AWS CLI 설치하기:\n\n- 먼저 로컬 컴퓨터에 AWS CLI를 설치해야 합니다.\n- 다음 링크를 따라 AWS CLI를 설치하세요:\n\n![AWS CLI 설치 링크](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- AWS CLI를 이곳에서 다운로드하여 계정에 구성하세요.\n- 또는 Linux 버전을 선택하여 설치할 수도 있습니다.\n- 이를 위해 계정에 IAM 사용자를 만들어야 합니다.\n\n![이미지1](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_1.png)\n\n![이미지2](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_2.png)\n\n- 현재는 관리자 액세스를 제공하지만 좋은 실천 방법은 아닙니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_3.png](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_3.png)\n\n![2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_4.png](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_4.png)\n\n- 보안 자격 증명에서 \"액세스 키 생성\" 옵션을 클릭하여 액세스 키 및 비밀 키를 생성하고 둘 다 복사합니다.\n\n![2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_5.png](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Access Key ID에 액세스 키를 붙여 넣고, Secret Access Key ID에 비밀 키를 입력해주세요. 그리고 설정하고 싶은 기본 지역도 지정해주세요.\n\n## 2. Terraform 초기화하기.\n\n- main.tf 파일을 생성하고, 제공자(provider) 구성을 거기에 입력해주세요.\n\n```js\n# main.tf\n\n# Provider configuration\nprovider \"aws\" {\n  region = \"us-west-1\"\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 그럼 아래 명령어를 입력해주세요.\n\n```js\nterraform.exe init\n```\n\n## 3. VPC 생성:\n\n우리는 VPC 구성을 정의합니다. CIDR 블록을 포함하여 네트워크 구조의 기반을 마련합니다. 이는 AWS 환경 내에서 격리되고 안전한 통신을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이 프로젝트 전체에 대해 동일한 main.tf 파일을 사용할 것입니다.\n\n```js\n# main.tf\n\nresource \"aws_vpc\" \"vpc\"{\n        cidr_block = \"192.168.0.0/16\"\n\n        tags = {\n                Name = \"Terraform_VPC\"\n        }\n}\n```\n\n## 4. 서브넷 생성:\n\n- 이제 서브넷 구성을 정의합니다. 이 구성에는 공용 서브넷과 사설 서브넷이 모두 포함됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# main.tf\n\n변수 \"aws_azs\"를 정의합니다. 여기에는 public 서브넷의 가용 영역이 저장됩니다. 그리고 public 서브넷의 CIDR 블록을 저장하는 다른 변수를 만듭니다.\n\n그런 다음 각 가용 영역에 2개의 public 서브넷을 만듭니다.\n- length 함수는 주어진 목록, 맵 또는 문자열의 길이를 결정합니다. 목록이나 맵이 주어지면 해당 컬렉션의 요소 수가 결과로 나옵니다.\n- element() 함수는 목록에서 특정 인덱스의 요소를 검색합니다. 사용 사례: 목록에서 특정 요소에 액세스하는 것은 해당 인덱스를 기준으로 목록에서 특정 리소스나 매개변수를 선택하려고 할 때 유용합니다.\n- count.index 객체는 count 내의 현재 인스턴스의 인덱스를 나타냅니다. 인덱스는 0부터 시작하며, count가 4인 리소스가 있으면 count.index 객체는 0, 1, 2 및 3이 됩니다.\n- 그런 다음 private 서브넷을 만드는 동일한 단계를 반복합니다.\n\n## 5. Internet-Gateway 및 Route-table 생성:\n\n이제 public 서브넷에 인터넷에 연결할 Internet-Gateway를 만들 것입니다. 이를 위해 라우팅 테이블도 생성하여 경로를 만들어야 합니다.\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# main.tf\n\nresource \"aws_internet_gateway\" \"igw\" {\n        vpc_id = aws_vpc.vpc.id\n        tags = {\n                Name = \"terrform-vpc-igw\"\n        }\n}\n\nresource \"aws_route_table\" \"second-rt\" {\n        vpc_id = aws_vpc.vpc.id\n        route {\n                cidr_block = \"0.0.0.0/0\"\n                gateway_id = aws_internet_gateway.igw.id\n        }\n\n        tags = {\n                Name = \"Public-route-table\"\n        }\n}\n\nresource \"aws_route_table_association\" \"public-subnets-asso\" {\n        count = length(var.public_subnet_cidrs)\n        subnet_id = element(aws_subnet.public_subnets[*].id, count.index)\n        route_table_id = aws_route_table.second-rt.id\n}\n```\n\n- 여기서, 먼저 VPC 내에서 인터넷 게이트웨이를 생성합니다.\n- 그런 다음 인터넷 게이트웨이를 통해 안전한 인터넷 연결을 가능하게 하는 라우트를 생성하는 라우트 테이블을 만듭니다.\n- 그런 다음 이 라우트 테이블과 공용 서브넷을 연결해야합니다.\n\n## 6. 보안 그룹 구성:\n\nEC2 인스턴스로의 들어오고 나가는 트래픽을 제어하기 위해 보안 그룹 규칙을 지정합니다. 이렇게 하면 사전 정의된 규칙 세트에 따라 액세스를 제한하여 네트워크 보안이 강화되며 잠재적인 보안 취약점을 완화할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nresource \"aws_security_group\" \"sg\" {\n    name        = \"terraform_sg\"\n    description = \"This security group is for terraform practice\"\n    vpc_id      = aws_vpc.vpc.id\n\n    tags = {\n        Name = \"terraform_vg\"\n    }\n}\n\nresource \"aws_vpc_security_group_ingress_rule\" \"sg_in_rule\" {\n    security_group_id = aws_security_group.sg.id\n    cidr_ipv4        = \"0.0.0.0/0\"\n    from_port        = 80\n    ip_protocol      = \"tcp\"\n    to_port          = 80\n}\n\nresource \"aws_vpc_security_group_ingress_rule\" \"sg_in_rule2\" {\n    security_group_id = aws_security_group.sg.id\n    cidr_ipv4        = \"0.0.0.0/0\"\n    from_port        = 22\n    ip_protocol      = \"tcp\"\n    to_port          = 22\n}\n\nresource \"aws_vpc_security_group_egress_rule\" \"sg_eg_rule\" {\n    security_group_id = aws_security_group.sg.id\n    cidr_ipv4         = \"0.0.0.0/0\"\n    ip_protocol       = \"-1\" # semantically equivalent to all ports\n}\n```\n\n- 먼저 VPC 내에서 보안 그룹을 만듭니다.\n- 그런 다음 보안 그룹에 대한 인바운드 규칙을 정의하여 클라이언트가 포트 80 및 22에 도달할 수 있도록 허용합니다.\n- 그런 다음 아무 포트에서 어디로든 연결을 허용하는 보안 그룹에 대한 아웃바운드 규칙을 정의합니다.\n\n## 7. 데이터 소스를 활용한 AMI 구성:\n\nTerraform의 데이터 소스를 활용하여 지정된 필터에 따라 기존 AWS AMI에 대한 정보를 가져올 수 있습니다. 이러한 필터는 지역, 운영 체제 및 아키텍처와 같은 미리 정의된 것으로 구성됩니다. 이는 EC2 인스턴스에 가장 적합한 AMI를 동적으로 선택함으로써 배포 간의 호환성 및 일관성을 보장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndata \"aws_ami\" \"rhel9\" {\n        most_recent = true\n\n        owners = [\"309956199498\"] // Red Hat의 계정 ID.\n\n        filter {\n                name   = \"architecture\"\n                values = [\"x86_64\"]\n        }\n\n        filter {\n                name   = \"root-device-type\"\n                values = [\"ebs\"]\n        }\n\n        filter {\n                name   = \"virtualization-type\"\n                values = [\"hvm\"]\n        }\n\n        filter {\n                name   = \"name\"\n                values = [\"RHEL-9.*\"]\n        }\n}\n```\n\n- 데이터 소스는 외부 시스템이나 기존 리소스에서 정보를 조회하고 해당 정보를 Terraform 구성에 통합하는 데 사용됩니다.\n\n## 8. EC2 인스턴스 프로비저닝:\n\n인스턴스 유형, 키페어, 보안 그룹을 포함한 EC2 인스턴스 구성을 정의합니다. Terraform은 VPC 내에서 EC2 인스턴스를 프로비저닝하여 지정된 구성을 준수하면서 연결성과 리소스 격리를 보장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```json\n파일 이름 : main.tf\n```\n\n## 3. EC2 인스턴스 생성 :\n\n이 코드는 Terraform을 사용하여 AWS EC2 인스턴스를 생성하는 예시입니다. 우리는 AMI ID, 인스턴스 유형, 키 이름, 서브넷 ID, 보안 그룹 ID 등을 정의하고 있습니다. 이를 통해 인프라스트럭처 스택에 EC2 인스턴스를 통합할 수 있습니다. 태그를 지정하여 리소스를 식별할 수도 있습니다.\n\n## 테이블\n\n| 제목                | 설명                            |\n| ------------------- | ------------------------------- |\n| AMI                 | data.aws_ami.rhel9.id           |\n| 유형                | \"t2.micro\"                      |\n| 키 이름             | \"IAM_California\"                |\n| 서브넷 ID           | aws_subnet.public_subnets[0].id |\n| VPC 보안 그룹 ID    | aws_security_group.sg.id        |\n| 퍼블릭 IP 주소 연결 | true                            |\n\n태그 :\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이제 새로운 EBS 볼륨을 생성했습니다. 중요한 점은 ec2 인스턴스와 ebs 볼륨이 동일한 가용 영역에 있어야 한다는 것입니다. 그렇지 않으면 서로 연결할 수 없습니다.\n\n## 10. EBS 볼륨 연결\n\n이제 다음 단계는 새로 생성한 ebs 볼륨을 ec2 인스턴스에 연결하는 것입니다.\n\n```js\nresource \"aws_volume_attachment\" \"ebs_attach\" {\n        device_name = \"/dev/xvdb\"\n        volume_id = aws_ebs_volume.EBS.id\n        instance_id = aws_instance.ec2-1.id\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 11. 공용 IP 주소 출력:\n\n마지막으로, 테라폼의 출력 기능을 사용하여 프로비저닝된 EC2 인스턴스의 공용 IP 주소를 표시합니다. 이는 관리자와 최종 사용자 모두가 인스턴스에 쉽게 액세스하고 관리할 수 있도록 합니다.\n\n```js\noutput \"ec2_instance_ip\" {\n        value = aws_instance.ec2-1.public_ip\n}\n```\n\n## 12. 테라폼 파일 적용하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금은 여태까지 AWS 인프라를 만든 main.tf 파일을 적용할 것입니다.\n\n```js\nterraform.exe apply\n```\n\n![AWS Infrastructure Deployment](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_6.png)\n\n- 먼저 전체 계획을 알려줍니다. 그렇지 않으면 계획을 보는 별도의 명령어가 있습니다. 즉, terraform.exe plan\n- 계획을 알려준 후에는 앞으로 진행하고 AWS 클라우드에 적용할 것인지 물어봅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![AWS Infrastructure Deployment with Terraform and Configuration with Ansible 7](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_7.png)\n\n![AWS Infrastructure Deployment with Terraform and Configuration with Ansible 8](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_8.png)\n\n# Let’s Go on our AWS Console to verify this deployment.\n\n## VPC ARCHITECTURE:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_9](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_9.png)\n\n![AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_10](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_10.png)\n\n## SECURITY GROUP :\n\n![AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_11](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_11.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## EC2-INSTANCE :\n\n![EC2-INSTANCE](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_12.png)\n\n# Ansible Configuration Management:\n\n인프라가 프로비저닝된 후에는 프로비저닝된 인스턴스 내에서 Ansible을 사용하여 구성 관리 작업으로 신속하게 전환합니다. Ansible은 우리에게 idempotent playbooks 및 모듈을 사용하여 복잡한 구성 작업을 자동화할 수 있는 기능을 제공하여 효율적이고 확장 가능한 인프라 관리를 가능하게 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희 프로젝트는 Terraform과 Ansible을 완벽하게 통합하여 일관된 배포 파이프라인을 구축합니다. Terraform은 인프라 스택의 기반을 마련하는 데 도움을 주고, Ansible은 프로비전된 인스턴스를 구성하여 그들이 그 의도한 목적을 위해 완전히 기능하고 최적화되도록 보장합니다.\n\n## EC2-인스턴스 구성을 위한 Ansible의 실용적인 단계:\n\n- ANSIBLE 인벤토리:\n\n```js\nvim / etc / ansible / hosts;\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\\\u003cimg src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_13.png\" /\u003e\n\n2. REQUIRED MODULES 설치하기.\n\n```js\nansible-galaxy collections install community.general\nansible-galaxy collections install posix\n```\n\n3. ANSIBLE-PLAYBOOK:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nvim \u003cfile-name\u003e.yml\n```\n\n![AWS Infrastructure Deployment with Terraform and Configuration with Ansible](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_14.png)\n\n![AWS Infrastructure Deployment with Terraform and Configuration with Ansible](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_15.png)\n\n![AWS Infrastructure Deployment with Terraform and Configuration with Ansible](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_16.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```yaml\n- hosts: all\n  become: yes\n  tasks:\n    - name: \"파티션 생성\"\n      community.general.parted:\n        device: \"/dev/xvdb\"\n        name: \"GPT\"\n        number: 1\n        part_end: \"1GiB\"\n        fs_type: \"ext4\"\n        state: present\n        label: \"gpt\"\n        unit: GiB\n\n    - name: \"중요 명령어 실행\"\n      command:\n        cmd: \"udevadm settle\"\n      register: cmd\n\n    - debug:\n        var: cmd\n\n    - command:\n        cmd: \"lsblk\"\n      register: cmd2\n\n    - debug:\n        var: cmd2\n\n    - name: \"파티션 포맷\"\n      community.general.filesystem:\n        fstype: ext4\n        dev: \"/dev/xvdb1\"\n\n    - name: \"웹 서버 설치\"\n      package:\n        name: \"httpd\"\n        state: present\n\n    - name: \"마운트된 볼륨과 연결\"\n      ansible.posix.mount:\n        path: \"/var/www/html\"\n        src: \"/dev/xvdb1\"\n        state: mounted\n        fstype: ext4\n\n    - name: \"데몬 다시로드\"\n      command:\n        cmd: \"systemctl daemon-reload\"\n\n    - command:\n        cmd: \"lsblk\"\n      register: cmd3\n\n    - debug:\n        var: cmd3\n\n    - name: \"인덱스 파일을 웹 서버로 복사\"\n      ansible.builtin.copy:\n        src: \"index.html\"\n        dest: \"/var/www/html/index.html\"\n\n    - name: \"서버 재시작\"\n      service:\n        name: \"httpd\"\n        state: \"started\"\n```\n\n## 이 Playbook은 다음을 수행할 수 있습니다:\n\n- 우리가 연결한 볼륨인 /dev/xvdb에 파티션 생성.\n- ext4 유형으로 새로 생성된 파티션 포맷.\n- 시스템에 아파치 웹 서버 설치.\n- 아파치 루트 문서인 /var/www/html에 파티션을 마운트.\n- 로컬 시스템의 인덱스 파일을 대상 시스템의 루트 문서에 복사.\n- 아파치 서비스 시작.\n\n## ANSIBLE PLAYBOOK 실행하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nansible-playbook \u003cfile-name\u003e.yml\n```\n\n![Image](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_17.png)\n\n![Image](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_18.png)\n\n## 웹 서버가 성공적으로 시작되었는지 확인해 봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![AWS Infrastructure Deployment with Terraform and Configuration with Ansible](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_19.png)\n\n# 결론:\n\n요약하면, Terraform과 Ansible의 통합은 AWS 인프라 자동화에서 강력한 패러다임 변화를 나타냅니다. 인프라 프로비저닝에 Terraform을 활용하고 구성 관리에는 Ansible을 활용함으로써, 조직은 클라우드 배포에서 전례 없는 민첩성, 확장성 및 신뢰성을 달성할 수 있습니다. 이 통합 접근 방식을 통해 팀은 DevOps 성숙도로 나아가는 여정을 가속화하고 클라우드 자동화의 모든 잠재력을 발휘할 수 있습니다.\n\n오늘 Terraform과 Ansible의 힘을 받아 AWS 인프라 배포 및 구성 워크플로를 혁신하세요! 🚀🔧\n","ogImage":{"url":"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_0.png"},"coverImage":"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_0.png","tag":["Tech"],"readingTime":19},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003e소개:\u003c/h1\u003e\n\u003cp\u003e현재의 동적 클라우드 컴퓨팅 환경에서는 인프라 프로비저닝을 자동화하는 것이 확장성, 신뢰성, 및 비용 효율성을 원하는 기관들에게 필수적입니다. Terraform은 오픈 소스 인프라 코드 도구로, 선언적 구성 파일을 사용하여 인프라를 정의하고 관리할 수 있도록 팀에게 권한을 부여합니다. 이 블로그에서는 Terraform이 AWS 인프라 구성 요소의 배포를 체계적이고 효율적으로 간소화하는 방법을 탐색해보겠습니다.\u003c/p\u003e\n\u003ch1\u003e프로젝트 개요:\u003c/h1\u003e\n\u003cp\u003e우리 Terraform 프로젝트는 가상 사설 클라우드(VPC), 보안 그룹, Amazon Machine Image(AMI), Elastic Block Store(EBS) 볼륨, 및 EC2 인스턴스로 구성된 AWS 인프라 스택의 배포를 자동화하는 데 초점을 맞춥니다. Terraform의 모듈식이자 반복 가능한 구성을 활용하여 환경 간 일관성과 신뢰성을 보장하고, 수동 개입과 인적 오류를 최소화합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e상세 단계:\u003c/h1\u003e\n\u003ch2\u003e1. AWS CLI 설치하기:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e먼저 로컬 컴퓨터에 AWS CLI를 설치해야 합니다.\u003c/li\u003e\n\u003cli\u003e다음 링크를 따라 AWS CLI를 설치하세요:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_0.png\" alt=\"AWS CLI 설치 링크\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003eAWS CLI를 이곳에서 다운로드하여 계정에 구성하세요.\u003c/li\u003e\n\u003cli\u003e또는 Linux 버전을 선택하여 설치할 수도 있습니다.\u003c/li\u003e\n\u003cli\u003e이를 위해 계정에 IAM 사용자를 만들어야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_1.png\" alt=\"이미지1\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_2.png\" alt=\"이미지2\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e현재는 관리자 액세스를 제공하지만 좋은 실천 방법은 아닙니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_3.png\" alt=\"2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_3.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_4.png\" alt=\"2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_4.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e보안 자격 증명에서 \"액세스 키 생성\" 옵션을 클릭하여 액세스 키 및 비밀 키를 생성하고 둘 다 복사합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_5.png\" alt=\"2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_5.png\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003eAccess Key ID에 액세스 키를 붙여 넣고, Secret Access Key ID에 비밀 키를 입력해주세요. 그리고 설정하고 싶은 기본 지역도 지정해주세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e2. Terraform 초기화하기.\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003emain.tf 파일을 생성하고, 제공자(provider) 구성을 거기에 입력해주세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# main.\u003cspan class=\"hljs-property\"\u003etf\u003c/span\u003e\n\n# \u003cspan class=\"hljs-title class_\"\u003eProvider\u003c/span\u003e configuration\nprovider \u003cspan class=\"hljs-string\"\u003e\"aws\"\u003c/span\u003e {\n  region = \u003cspan class=\"hljs-string\"\u003e\"us-west-1\"\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e그럼 아래 명령어를 입력해주세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eterraform.\u003cspan class=\"hljs-property\"\u003eexe\u003c/span\u003e init\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e3. VPC 생성:\u003c/h2\u003e\n\u003cp\u003e우리는 VPC 구성을 정의합니다. CIDR 블록을 포함하여 네트워크 구조의 기반을 마련합니다. 이는 AWS 환경 내에서 격리되고 안전한 통신을 제공합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e이 프로젝트 전체에 대해 동일한 main.tf 파일을 사용할 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# main.\u003cspan class=\"hljs-property\"\u003etf\u003c/span\u003e\n\nresource \u003cspan class=\"hljs-string\"\u003e\"aws_vpc\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"vpc\"\u003c/span\u003e{\n        cidr_block = \u003cspan class=\"hljs-string\"\u003e\"192.168.0.0/16\"\u003c/span\u003e\n\n        tags = {\n                \u003cspan class=\"hljs-title class_\"\u003eName\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"Terraform_VPC\"\u003c/span\u003e\n        }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e4. 서브넷 생성:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e이제 서브넷 구성을 정의합니다. 이 구성에는 공용 서브넷과 사설 서브넷이 모두 포함됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# main.\u003cspan class=\"hljs-property\"\u003etf\u003c/span\u003e\n\n변수 \u003cspan class=\"hljs-string\"\u003e\"aws_azs\"\u003c/span\u003e를 정의합니다. 여기에는 public 서브넷의 가용 영역이 저장됩니다. 그리고 public 서브넷의 \u003cspan class=\"hljs-variable constant_\"\u003eCIDR\u003c/span\u003e 블록을 저장하는 다른 변수를 만듭니다.\n\n그런 다음 각 가용 영역에 \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e개의 public 서브넷을 만듭니다.\n- length 함수는 주어진 목록, 맵 또는 문자열의 길이를 결정합니다. 목록이나 맵이 주어지면 해당 컬렉션의 요소 수가 결과로 나옵니다.\n- \u003cspan class=\"hljs-title function_\"\u003eelement\u003c/span\u003e() 함수는 목록에서 특정 인덱스의 요소를 검색합니다. 사용 사례: 목록에서 특정 요소에 액세스하는 것은 해당 인덱스를 기준으로 목록에서 특정 리소스나 매개변수를 선택하려고 할 때 유용합니다.\n- count.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e 객체는 count 내의 현재 인스턴스의 인덱스를 나타냅니다. 인덱스는 \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e부터 시작하며, count가 \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e인 리소스가 있으면 count.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e 객체는 \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e 및 \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e이 됩니다.\n- 그런 다음 private 서브넷을 만드는 동일한 단계를 반복합니다.\n\n## \u003cspan class=\"hljs-number\"\u003e5.\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInternet\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eGateway\u003c/span\u003e 및 \u003cspan class=\"hljs-title class_\"\u003eRoute\u003c/span\u003e-table 생성:\n\n이제 public 서브넷에 인터넷에 연결할 \u003cspan class=\"hljs-title class_\"\u003eInternet\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eGateway\u003c/span\u003e를 만들 것입니다. 이를 위해 라우팅 테이블도 생성하여 경로를 만들어야 합니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# main.\u003cspan class=\"hljs-property\"\u003etf\u003c/span\u003e\n\nresource \u003cspan class=\"hljs-string\"\u003e\"aws_internet_gateway\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"igw\"\u003c/span\u003e {\n        vpc_id = aws_vpc.\u003cspan class=\"hljs-property\"\u003evpc\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n        tags = {\n                \u003cspan class=\"hljs-title class_\"\u003eName\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"terrform-vpc-igw\"\u003c/span\u003e\n        }\n}\n\nresource \u003cspan class=\"hljs-string\"\u003e\"aws_route_table\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"second-rt\"\u003c/span\u003e {\n        vpc_id = aws_vpc.\u003cspan class=\"hljs-property\"\u003evpc\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n        route {\n                cidr_block = \u003cspan class=\"hljs-string\"\u003e\"0.0.0.0/0\"\u003c/span\u003e\n                gateway_id = aws_internet_gateway.\u003cspan class=\"hljs-property\"\u003eigw\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n        }\n\n        tags = {\n                \u003cspan class=\"hljs-title class_\"\u003eName\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"Public-route-table\"\u003c/span\u003e\n        }\n}\n\nresource \u003cspan class=\"hljs-string\"\u003e\"aws_route_table_association\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"public-subnets-asso\"\u003c/span\u003e {\n        count = \u003cspan class=\"hljs-title function_\"\u003elength\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003epublic_subnet_cidrs\u003c/span\u003e)\n        subnet_id = \u003cspan class=\"hljs-title function_\"\u003eelement\u003c/span\u003e(aws_subnet.\u003cspan class=\"hljs-property\"\u003epublic_subnets\u003c/span\u003e[*].\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e, count.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e)\n        route_table_id = aws_route_table.\u003cspan class=\"hljs-property\"\u003esecond\u003c/span\u003e-rt.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e여기서, 먼저 VPC 내에서 인터넷 게이트웨이를 생성합니다.\u003c/li\u003e\n\u003cli\u003e그런 다음 인터넷 게이트웨이를 통해 안전한 인터넷 연결을 가능하게 하는 라우트를 생성하는 라우트 테이블을 만듭니다.\u003c/li\u003e\n\u003cli\u003e그런 다음 이 라우트 테이블과 공용 서브넷을 연결해야합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e6. 보안 그룹 구성:\u003c/h2\u003e\n\u003cp\u003eEC2 인스턴스로의 들어오고 나가는 트래픽을 제어하기 위해 보안 그룹 규칙을 지정합니다. 이렇게 하면 사전 정의된 규칙 세트에 따라 액세스를 제한하여 네트워크 보안이 강화되며 잠재적인 보안 취약점을 완화할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eresource \u003cspan class=\"hljs-string\"\u003e\"aws_security_group\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"sg\"\u003c/span\u003e {\n    name        = \u003cspan class=\"hljs-string\"\u003e\"terraform_sg\"\u003c/span\u003e\n    description = \u003cspan class=\"hljs-string\"\u003e\"This security group is for terraform practice\"\u003c/span\u003e\n    vpc_id      = aws_vpc.\u003cspan class=\"hljs-property\"\u003evpc\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n\n    tags = {\n        \u003cspan class=\"hljs-title class_\"\u003eName\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"terraform_vg\"\u003c/span\u003e\n    }\n}\n\nresource \u003cspan class=\"hljs-string\"\u003e\"aws_vpc_security_group_ingress_rule\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"sg_in_rule\"\u003c/span\u003e {\n    security_group_id = aws_security_group.\u003cspan class=\"hljs-property\"\u003esg\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n    cidr_ipv4        = \u003cspan class=\"hljs-string\"\u003e\"0.0.0.0/0\"\u003c/span\u003e\n    from_port        = \u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e\n    ip_protocol      = \u003cspan class=\"hljs-string\"\u003e\"tcp\"\u003c/span\u003e\n    to_port          = \u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e\n}\n\nresource \u003cspan class=\"hljs-string\"\u003e\"aws_vpc_security_group_ingress_rule\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"sg_in_rule2\"\u003c/span\u003e {\n    security_group_id = aws_security_group.\u003cspan class=\"hljs-property\"\u003esg\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n    cidr_ipv4        = \u003cspan class=\"hljs-string\"\u003e\"0.0.0.0/0\"\u003c/span\u003e\n    from_port        = \u003cspan class=\"hljs-number\"\u003e22\u003c/span\u003e\n    ip_protocol      = \u003cspan class=\"hljs-string\"\u003e\"tcp\"\u003c/span\u003e\n    to_port          = \u003cspan class=\"hljs-number\"\u003e22\u003c/span\u003e\n}\n\nresource \u003cspan class=\"hljs-string\"\u003e\"aws_vpc_security_group_egress_rule\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"sg_eg_rule\"\u003c/span\u003e {\n    security_group_id = aws_security_group.\u003cspan class=\"hljs-property\"\u003esg\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n    cidr_ipv4         = \u003cspan class=\"hljs-string\"\u003e\"0.0.0.0/0\"\u003c/span\u003e\n    ip_protocol       = \u003cspan class=\"hljs-string\"\u003e\"-1\"\u003c/span\u003e # semantically equivalent to all ports\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e먼저 VPC 내에서 보안 그룹을 만듭니다.\u003c/li\u003e\n\u003cli\u003e그런 다음 보안 그룹에 대한 인바운드 규칙을 정의하여 클라이언트가 포트 80 및 22에 도달할 수 있도록 허용합니다.\u003c/li\u003e\n\u003cli\u003e그런 다음 아무 포트에서 어디로든 연결을 허용하는 보안 그룹에 대한 아웃바운드 규칙을 정의합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e7. 데이터 소스를 활용한 AMI 구성:\u003c/h2\u003e\n\u003cp\u003eTerraform의 데이터 소스를 활용하여 지정된 필터에 따라 기존 AWS AMI에 대한 정보를 가져올 수 있습니다. 이러한 필터는 지역, 운영 체제 및 아키텍처와 같은 미리 정의된 것으로 구성됩니다. 이는 EC2 인스턴스에 가장 적합한 AMI를 동적으로 선택함으로써 배포 간의 호환성 및 일관성을 보장합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edata \u003cspan class=\"hljs-string\"\u003e\"aws_ami\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"rhel9\"\u003c/span\u003e {\n        most_recent = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n\n        owners = [\u003cspan class=\"hljs-string\"\u003e\"309956199498\"\u003c/span\u003e] \u003cspan class=\"hljs-comment\"\u003e// Red Hat의 계정 ID.\u003c/span\u003e\n\n        filter {\n                name   = \u003cspan class=\"hljs-string\"\u003e\"architecture\"\u003c/span\u003e\n                values = [\u003cspan class=\"hljs-string\"\u003e\"x86_64\"\u003c/span\u003e]\n        }\n\n        filter {\n                name   = \u003cspan class=\"hljs-string\"\u003e\"root-device-type\"\u003c/span\u003e\n                values = [\u003cspan class=\"hljs-string\"\u003e\"ebs\"\u003c/span\u003e]\n        }\n\n        filter {\n                name   = \u003cspan class=\"hljs-string\"\u003e\"virtualization-type\"\u003c/span\u003e\n                values = [\u003cspan class=\"hljs-string\"\u003e\"hvm\"\u003c/span\u003e]\n        }\n\n        filter {\n                name   = \u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e\n                values = [\u003cspan class=\"hljs-string\"\u003e\"RHEL-9.*\"\u003c/span\u003e]\n        }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e데이터 소스는 외부 시스템이나 기존 리소스에서 정보를 조회하고 해당 정보를 Terraform 구성에 통합하는 데 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e8. EC2 인스턴스 프로비저닝:\u003c/h2\u003e\n\u003cp\u003e인스턴스 유형, 키페어, 보안 그룹을 포함한 EC2 인스턴스 구성을 정의합니다. Terraform은 VPC 내에서 EC2 인스턴스를 프로비저닝하여 지정된 구성을 준수하면서 연결성과 리소스 격리를 보장합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-json\"\u003e파일 이름 \u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e main.tf\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e3. EC2 인스턴스 생성 :\u003c/h2\u003e\n\u003cp\u003e이 코드는 Terraform을 사용하여 AWS EC2 인스턴스를 생성하는 예시입니다. 우리는 AMI ID, 인스턴스 유형, 키 이름, 서브넷 ID, 보안 그룹 ID 등을 정의하고 있습니다. 이를 통해 인프라스트럭처 스택에 EC2 인스턴스를 통합할 수 있습니다. 태그를 지정하여 리소스를 식별할 수도 있습니다.\u003c/p\u003e\n\u003ch2\u003e테이블\u003c/h2\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e제목\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eAMI\u003c/td\u003e\u003ctd\u003edata.aws_ami.rhel9.id\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e유형\u003c/td\u003e\u003ctd\u003e\"t2.micro\"\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e키 이름\u003c/td\u003e\u003ctd\u003e\"IAM_California\"\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e서브넷 ID\u003c/td\u003e\u003ctd\u003eaws_subnet.public_subnets[0].id\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eVPC 보안 그룹 ID\u003c/td\u003e\u003ctd\u003eaws_security_group.sg.id\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e퍼블릭 IP 주소 연결\u003c/td\u003e\u003ctd\u003etrue\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e태그 :\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e이제 새로운 EBS 볼륨을 생성했습니다. 중요한 점은 ec2 인스턴스와 ebs 볼륨이 동일한 가용 영역에 있어야 한다는 것입니다. 그렇지 않으면 서로 연결할 수 없습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e10. EBS 볼륨 연결\u003c/h2\u003e\n\u003cp\u003e이제 다음 단계는 새로 생성한 ebs 볼륨을 ec2 인스턴스에 연결하는 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eresource \u003cspan class=\"hljs-string\"\u003e\"aws_volume_attachment\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"ebs_attach\"\u003c/span\u003e {\n        device_name = \u003cspan class=\"hljs-string\"\u003e\"/dev/xvdb\"\u003c/span\u003e\n        volume_id = aws_ebs_volume.\u003cspan class=\"hljs-property\"\u003eEBS\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n        instance_id = aws_instance.\u003cspan class=\"hljs-property\"\u003eec2\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e1.\u003c/span\u003eid\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e11. 공용 IP 주소 출력:\u003c/h2\u003e\n\u003cp\u003e마지막으로, 테라폼의 출력 기능을 사용하여 프로비저닝된 EC2 인스턴스의 공용 IP 주소를 표시합니다. 이는 관리자와 최종 사용자 모두가 인스턴스에 쉽게 액세스하고 관리할 수 있도록 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eoutput \u003cspan class=\"hljs-string\"\u003e\"ec2_instance_ip\"\u003c/span\u003e {\n        value = aws_instance.\u003cspan class=\"hljs-property\"\u003eec2\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e1.\u003c/span\u003epublic_ip\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e12. 테라폼 파일 적용하기\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e지금은 여태까지 AWS 인프라를 만든 main.tf 파일을 적용할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eterraform.\u003cspan class=\"hljs-property\"\u003eexe\u003c/span\u003e apply\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_6.png\" alt=\"AWS Infrastructure Deployment\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e먼저 전체 계획을 알려줍니다. 그렇지 않으면 계획을 보는 별도의 명령어가 있습니다. 즉, terraform.exe plan\u003c/li\u003e\n\u003cli\u003e계획을 알려준 후에는 앞으로 진행하고 AWS 클라우드에 적용할 것인지 물어봅니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_7.png\" alt=\"AWS Infrastructure Deployment with Terraform and Configuration with Ansible 7\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_8.png\" alt=\"AWS Infrastructure Deployment with Terraform and Configuration with Ansible 8\"\u003e\u003c/p\u003e\n\u003ch1\u003eLet’s Go on our AWS Console to verify this deployment.\u003c/h1\u003e\n\u003ch2\u003eVPC ARCHITECTURE:\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_9.png\" alt=\"AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_9\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_10.png\" alt=\"AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_10\"\u003e\u003c/p\u003e\n\u003ch2\u003eSECURITY GROUP :\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_11.png\" alt=\"AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_11\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003eEC2-INSTANCE :\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_12.png\" alt=\"EC2-INSTANCE\"\u003e\u003c/p\u003e\n\u003ch1\u003eAnsible Configuration Management:\u003c/h1\u003e\n\u003cp\u003e인프라가 프로비저닝된 후에는 프로비저닝된 인스턴스 내에서 Ansible을 사용하여 구성 관리 작업으로 신속하게 전환합니다. Ansible은 우리에게 idempotent playbooks 및 모듈을 사용하여 복잡한 구성 작업을 자동화할 수 있는 기능을 제공하여 효율적이고 확장 가능한 인프라 관리를 가능하게 합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e저희 프로젝트는 Terraform과 Ansible을 완벽하게 통합하여 일관된 배포 파이프라인을 구축합니다. Terraform은 인프라 스택의 기반을 마련하는 데 도움을 주고, Ansible은 프로비전된 인스턴스를 구성하여 그들이 그 의도한 목적을 위해 완전히 기능하고 최적화되도록 보장합니다.\u003c/p\u003e\n\u003ch2\u003eEC2-인스턴스 구성을 위한 Ansible의 실용적인 단계:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eANSIBLE 인벤토리:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003evim / etc / ansible / hosts;\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u0026#x3C;img src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_13.png\" /\u003e\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eREQUIRED MODULES 설치하기.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eansible-galaxy collections install community.\u003cspan class=\"hljs-property\"\u003egeneral\u003c/span\u003e\nansible-galaxy collections install posix\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eANSIBLE-PLAYBOOK:\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003evim \u0026#x3C;file-name\u003e.\u003cspan class=\"hljs-property\"\u003eyml\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_14.png\" alt=\"AWS Infrastructure Deployment with Terraform and Configuration with Ansible\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_15.png\" alt=\"AWS Infrastructure Deployment with Terraform and Configuration with Ansible\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_16.png\" alt=\"AWS Infrastructure Deployment with Terraform and Configuration with Ansible\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehosts:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eall\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ebecome:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003eyes\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003etasks:\u003c/span\u003e\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"파티션 생성\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ecommunity.general.parted:\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003edevice:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"/dev/xvdb\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"GPT\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003enumber:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003epart_end:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"1GiB\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003efs_type:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"ext4\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003estate:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003epresent\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003elabel:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"gpt\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eunit:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eGiB\u003c/span\u003e\n\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"중요 명령어 실행\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ecommand:\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ecmd:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"udevadm settle\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eregister:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecmd\u003c/span\u003e\n\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edebug:\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003evar:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecmd\u003c/span\u003e\n\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecommand:\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ecmd:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"lsblk\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eregister:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecmd2\u003c/span\u003e\n\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edebug:\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003evar:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecmd2\u003c/span\u003e\n\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"파티션 포맷\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ecommunity.general.filesystem:\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003efstype:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eext4\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003edev:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"/dev/xvdb1\"\u003c/span\u003e\n\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"웹 서버 설치\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003epackage:\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"httpd\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003estate:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003epresent\u003c/span\u003e\n\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"마운트된 볼륨과 연결\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eansible.posix.mount:\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003epath:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"/var/www/html\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003esrc:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"/dev/xvdb1\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003estate:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003emounted\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003efstype:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eext4\u003c/span\u003e\n\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"데몬 다시로드\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ecommand:\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ecmd:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"systemctl daemon-reload\"\u003c/span\u003e\n\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecommand:\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ecmd:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"lsblk\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eregister:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecmd3\u003c/span\u003e\n\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edebug:\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003evar:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecmd3\u003c/span\u003e\n\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"인덱스 파일을 웹 서버로 복사\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eansible.builtin.copy:\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003esrc:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"index.html\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003edest:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"/var/www/html/index.html\"\u003c/span\u003e\n\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"서버 재시작\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eservice:\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"httpd\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003estate:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"started\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e이 Playbook은 다음을 수행할 수 있습니다:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e우리가 연결한 볼륨인 /dev/xvdb에 파티션 생성.\u003c/li\u003e\n\u003cli\u003eext4 유형으로 새로 생성된 파티션 포맷.\u003c/li\u003e\n\u003cli\u003e시스템에 아파치 웹 서버 설치.\u003c/li\u003e\n\u003cli\u003e아파치 루트 문서인 /var/www/html에 파티션을 마운트.\u003c/li\u003e\n\u003cli\u003e로컬 시스템의 인덱스 파일을 대상 시스템의 루트 문서에 복사.\u003c/li\u003e\n\u003cli\u003e아파치 서비스 시작.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eANSIBLE PLAYBOOK 실행하기\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eansible-playbook \u0026#x3C;file-name\u003e.\u003cspan class=\"hljs-property\"\u003eyml\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_17.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_18.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003ch2\u003e웹 서버가 성공적으로 시작되었는지 확인해 봅시다.\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_19.png\" alt=\"AWS Infrastructure Deployment with Terraform and Configuration with Ansible\"\u003e\u003c/p\u003e\n\u003ch1\u003e결론:\u003c/h1\u003e\n\u003cp\u003e요약하면, Terraform과 Ansible의 통합은 AWS 인프라 자동화에서 강력한 패러다임 변화를 나타냅니다. 인프라 프로비저닝에 Terraform을 활용하고 구성 관리에는 Ansible을 활용함으로써, 조직은 클라우드 배포에서 전례 없는 민첩성, 확장성 및 신뢰성을 달성할 수 있습니다. 이 통합 접근 방식을 통해 팀은 DevOps 성숙도로 나아가는 여정을 가속화하고 클라우드 자동화의 모든 잠재력을 발휘할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e오늘 Terraform과 Ansible의 힘을 받아 AWS 인프라 배포 및 구성 워크플로를 혁신하세요! 🚀🔧\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible"},"buildId":"T_Nz0g9U1yttYMSEma95P","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>