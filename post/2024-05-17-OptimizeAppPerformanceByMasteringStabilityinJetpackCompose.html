<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Jetpack Compose에서 안정성을 마스터하여 앱 성능 최적화하기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Jetpack Compose에서 안정성을 마스터하여 앱 성능 최적화하기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Jetpack Compose에서 안정성을 마스터하여 앱 성능 최적화하기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose" data-gatsby-head="true"/><meta name="twitter:title" content="Jetpack Compose에서 안정성을 마스터하여 앱 성능 최적화하기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-17 18:39" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_buildManifest.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Jetpack Compose에서 안정성을 마스터하여 앱 성능 최적화하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Jetpack Compose에서 안정성을 마스터하여 앱 성능 최적화하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 17, 2024</span><span class="posts_reading_time__f7YPP">30<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_0.png" alt="Jetpack Compose"></p>
<p>젯팩 컴포즈는 구글의 첨단 UI 툴킷으로서, 안정적인 1.0 버전 이후 뛰어난 가능성을 보여주었습니다. Google의 보고에 따르면, 제트팩 컴포즈를 사용하여 개발된 앱이 이미 12만 5천 개 이상이 Google Play Store에서 성공적으로 출시되면서 프로덕션 목적으로의 채택이 급증했습니다.</p>
<p>제트팩 컴포즈는 내장된 최적화 기능을 갖추고 있지만, 개발자들은 컴포즈가 UI 요소를 어떻게 렌더링하는지 이해하고, 다양한 시나리오에서 제트팩 컴포즈의 성능을 최적화하기 위한 전략을 파악해야 합니다. 이러한 지식은 애플리케이션의 성능에 잠재적인 영향을 최소화하고 더 나은 사용자 경험을 제공하기 위한 중요한 역할을 합니다.</p>
<p>이 기사에서는 제트팩 컴포즈의 내부 작업을 이해하고, 안정성을 관리하여 애플리케이션의 성능을 향상시키는 방법을 안내하겠습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>Jetpack Compose 단계</h1>
<p>안정성에 대해 자세히 살펴보기 전에 Jetpack Compose의 단계를 이해하는 것이 중요합니다. 이 단계에서는 화면에 Compose UI 노드를 렌더링하는 과정이 여러 연속적인 단계를 통해 진행됩니다.</p>
<p><img src="/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_1.png" alt="Jetpack Compose Phases"></p>
<p>Jetpack Compose는 한 프레임의 렌더링을 세 가지 구분된 단계를 통해 실행합니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>구성: 이 단계에서는 Composable 함수에 대한 설명을 생성하고 여러 메모리 슬롯을 할당함으로써 프로세스가 시작됩니다. 이러한 슬롯은 각 Composable 함수를 메모이즈하여 런타임 중에 효율적인 호출 및 실행을 가능하게 합니다.</li>
<li>레이아웃: 이 단계에서는 Composable 트리 내 각 노드의 위치를 설정합니다. 레이아웃 단계는 주로 각 Composable 노드를 측정하고 적절히 배치하여 UI의 전체 구조 내에서 모든 요소가 정확히 배열되도록 보장합니다.</li>
<li>그리기: 이 마지막 단계에서는 Composable 노드가 일반적으로 장치의 화면인 캔버스에 렌더링됩니다. 이 중요한 단계는 UI를 시각적으로 구축하여 설계된 Composables을 사용자 상호 작용을 위해 사용할 수 있게 합니다.</li>
</ul>
<p>내부 메커니즘은 훨씬 더 복잡하지만, 기본적으로 Composable 함수를 작성할 때 화면에 표시되기 위해 이러한 단계를 거칩니다.</p>
<p>이제 레이아웃의 크기 및 색상과 같은 UI 요소를 수정하려고 한다고 가정해 봅시다. 그림 그리기 단계가 완료된 경우, Compose는 이러한 새 값들을 적용하기 위해 처음부터 다시 이러한 단계를 다시 방문해야 합니다. 이러한 업데이트 사이클을 재구성이라고 합니다:</p>
<p><img src="/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_2.png" alt="이미지"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>재구성은 입력 변경에 대한 응담으로 조합 가능한 함수가 새롭게 실행되어 Composition 단계에서 시작됩니다. 이 프로세스는 State에서 관찰하거나 내재적으로 Compose 런타임과 컴파일러 메커니즘들이 연관된 다양한 요소에 의해 트리거될 수 있습니다.</p>
<p>전체 UI 트리와 요소를 재구성하는 것은 상당한 계산 리소스를 필요로 하며 앱의 성능에 직접적인 영향을 미칠 수 있습니다. 필요한 경우에만 재구성을 트리거함으로써(불필요할 때 재구성을 건너뛸 경우) 계산 리소스를 최소화하여 UI 성능을 향상시킬 수 있습니다.</p>
<p>따라서, Compose 런타임의 작동 방식을 포함한 재구성 프로세스에 대한 심층적인 이해, 재구성을 건너뛸 기회를 식별하고 재구성을 트리거하는 요소를 인식하는 것이 중요합니다.</p>
<p>이제 안정성 개념을 탐구하고 재구성 비용을 최적화하여 응용 프로그램 성능을 향상시킬 방법을 살펴보겠습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>안정성 이해</h1>
<p>이전 섹션에서 언급된 바와 같이, 이미 렌더링된 UI를 업데이트하기 위해 다양한 방법이 존재합니다. Composable 함수의 매개변수의 안정성은 Compose 런타임과 컴파일러의 작동과 깊이 얽혀 있어, 재구성을 시작하는 결정적인 요소로 부각됩니다.</p>
<p>Compose 컴파일러는 Composable 함수의 매개변수를 안정적인 것과 불안정한 것 두 가지로 분류합니다. 이러한 매개변수 안정성의 분류는 Compose 런타임에 의해 Composable 함수가 재구성되어야 하는지 여부를 결정하는 데 사용됩니다.</p>
<h1>안정함 vs. 불안정함</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제, 어떻게 매개변수가 안정적인지 불안정한지로 분류되는지 궁금할 수 있습니다. 이 결정은 Compose 컴파일러에 의해 이루어집니다. 컴파일러는 Composable 함수에서 사용된 매개변수의 유형을 검토하고 다음 기준에 따라 안정적인지를 분류합니다:</p>
<ul>
<li>String을 포함한 기본 유형은 본질적으로 안정적입니다.</li>
<li>(Int) -` String과 같은 람다 표현식으로 나타낸 함수 유형은 안정적으로 간주됩니다.</li>
<li>불변하고 안정적인 공개 속성으로 특징지어진 데이터 클래스 또는 안정성 주석인 @Stable이나 @Immutable과 같이 명시적으로 표시된 클래스는 안정적으로 간주됩니다. 이러한 주석의 구체적인 내용에 대해 다음 섹션에서 자세히 살펴볼 것입니다.</li>
</ul>
<p>예를 들어, 아래와 같이 데이터 클래스를 상상해 볼 수 있습니다:</p>
<p>Composable 컴파일러에 의해 안정적으로 간주되는 불변 기본 속성으로 구성된 User 데이터 클래스입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그러나, Composable 함수 내에서 매개변수 유형을 평가하는 컴파일러는 아래 기준에 따라 해당 유형을 불안정하다고 식별합니다:</p>
<ul>
<li>List, Map 등의 인터페이스와 Any와 같은 추상 클래스와 같이 컴파일 시간에 구현이 예측할 수 없는 유형은 불안정하다고 간주됩니다. 이 분류의 근거는 다음 섹션에서 더 자세히 논의될 예정입니다.</li>
<li>특히 적어도 하나의 가변 또는 본질적으로 불안정한 공용 속성을 포함하는 데이터 클래스와 같은 클래스는 불안정하다고 분류됩니다.</li>
</ul>
<p>예를 들어, 다음과 같은 데이터 클래스를 상상해볼 수 있습니다:</p>
<p>User 데이터 클래스는 기본 속성으로 구성되어 있지만, 가변 이름 속성의 존재로 인해 Compose 컴파일러가 이를 불안정하다고 분류합니다. 이 분류는 안정성이 모든 속성의 종합적인 안정성을 평가하여 단일 가변 속성이 전체 클래스를 불안정하게 만들 수 있기 때문에 발생합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>스마트 재구성</h1>
<p>안정성의 원칙을 탐색하고 Compose 컴파일러가 안정적인지 불안정한지를 구별하는 방법을 살펴봤다면, 이러한 차이점을 활용하여 재구성을 트리거하는 실용적인 사용법에 관심이 생길 수 있습니다. Compose 컴파일러는 변경 가능 함수의 각 매개변수의 안정성을 평가하여 Compose 런타임이 이 정보를 효율적으로 활용할 수 있도록 기초를 마련합니다.</p>
<p>클래스의 안정성이 결정되면, Compose 런타임은 이 통찰력을 활용하여 내부 메커니즘인 스마트 재구성을 통해 재구성을 시작합니다. 스마트 재구성은 제공된 안정성 정보를 활용하여 불필요한 재구성을 선택적으로 건너뛰어 Compose의 전체 성능을 향상시킵니다.</p>
<p>스마트 재구성이 작동하는 원칙 중 일부는 다음과 같습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>
<p>등가성 확인: Composable 함수에 새 입력이 전달될 때마다 해당 입력은 반드시 클래스의 equals() 메서드를 사용하여 이전 입력과 비교됩니다.</p>
</li>
<li>
<p>안정성에 따른 결정:</p>
</li>
<li>
<p>매개변수가 안정적이고 값이 변경되지 않은 경우 (equals()가 true를 반환), Compose는 관련 UI 구성 요소를 다시 구성하지 않습니다.</p>
</li>
<li>
<p>매개변수가 불안정하거나 안정적이지만 값이 변경된 경우 (equals()가 false를 반환), 런타임은 다시 구성을 시작하여 UI 레이아웃을 무효화하고 다시 그립니다.</p>
</li>
</ul>
<p>위 시나리오에서 불필요한 다시 구성을 피함으로써 UI 성능을 향상시킬 수 있습니다. 전체 UI 트리를 다시 구성하는 것은 상당한 계산 리소스를 필요로하며, 적절하게 처리되지 않으면 성능에 부정적인 영향을 줄 수 있습니다.</p>
<p>Jetpack Compose는 스마트한 다시 구성을 기본적으로 제공하지만, Composable 함수에서 사용되는 클래스를 안정화하고 최대한 다시 구성을 줄이는 방법을 숙지하는 것이 중요합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>합성 가능한 함수 추론하기</h1>
<p>이제 컴포즈 컴파일러가 클래스 안정성을 결정하고 컴포즈 런타임이 이 정보를 내부 메커니즘인 스마트 재구성으로 활용하는 방법을 이해했습니다. 그렇지만 이해해야 할 또 다른 중요한 개념은 합성 가능한 함수의 유형 추론입니다.</p>
<p>컴포즈 컴파일러는 코틀린 컴파일러 플러그인을 사용하여 개발자가 작성한 소스 코드를 컴파일 시 분석할 수 있게 만들어졌습니다. 더불어, 컴포즈 함수의 고유한 특성과 더 잘 일치하도록 원본 소스 코드를 조정할 수 있습니다.</p>
<p>컴파일러는 합성 가능한 함수를 시작 가능함, 이동 가능함, 대체 가능함 등으로 분류하여 실행을 최적화합니다. 이 게시물에서는 특히 재구성에 중요한 역할을 하는 시작 가능한 유형에 대해 자세히 살펴볼 것입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>다시 시작 가능한</h1>
<p>다시 시작 가능한은 Composable 함수의 일종으로, Compose 컴파일러에 의해 결정되며 recomposition 프로세스의 중추 역할을 합니다. 이전에 탐구한 대로, Compose 런타임은 입력 값의 변화를 감지하면 이러한 새 입력 값으로 함수를 다시 시작(또는 다시 호출)하여 데이터 변경을 정확하게 반영합니다.</p>
<p>Compose 런타임에서 제공하는 특정 주석으로 Composable 함수를 명시적으로 주석 처리하지 않으면 대부분의 함수는 기본적으로 다시 시작 가능하다고 간주됩니다. 이는 Compose 런타임이 언제든지 입력 또는 상태 변경이 발생할 때 해당 Composable 함수에 대해 recomposition을 트리거할 수 있다는 것을 의미합니다.</p>
<h1>건너뛰기 가능한</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Skipable은 또 다른 Composable 함수의 특성을 나타내며, 이는 이전 섹션에서 논의된 스마트 recomposition에 의해 설정된 적절한 조건 하에서 전체 recomposition 프로세스를 완전히 우회할 수 있음을 의미합니다. 따라서, skipable 함수가 바로 recomposition을 건너뛰고 UI 성능을 향상시킬 수 있는 잠재력과 직접적으로 연결된다고 단언할 수 있습니다. 이는 특정 상황에 따라서 달려있는데요.</p>
<p>이 능력은 특히 규모가 큰 함수 호출 계층 구조의 정상 Composable 함수의 성능을 향상시키는 데 중요합니다. 이러한 루트 Composable의 recomposition을 건너뛰면, Compose는 이러한 루트 Composable의 recomposition을 건너뛰면, 해당 계층의 하위 함수들 중 어떤 것도 호출할 필요가 없어지며, 전체 recomposition 프로세스가 간소화됩니다.</p>
<p>Composable 함수가 재시작 가능(restartable)이면서 동시에 skippable로 분류되는 경우도 있음을 기억하는 것이 중요합니다. skippable로 분류되면 재시작 가능한 recomposition을 거칠 수 있다는 것을 함축하므로요. 이제 작성한 Composable 함수가 재시작 가능 또는 skippable로 분류되는지 알아보는 방법을 살펴보겠습니다.</p>
<h1>Compose Compiler Metrics</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Compose 컴파일러 플러그인을 사용하면 Compose에 고유한 특정 개념에 중점을 둔 자세한 보고서와 메트릭을 생성할 수 있습니다. 이러한 통찰력은 Compose 코드의 복잡성을 파헤치는 데 유용하며, 마이크로 레벨에서 작동 방식을 정확하게 이해할 수 있도록 도와줍니다.</p>
<p>Compose 컴파일러 메트릭을 생성하려면, 아래 예제에 설명된 대로 루트 모듈의 build.gradle 파일에 컴파일러 옵션을 추가하면 됩니다:</p>
<p>프로젝트를 동기화하고 빌드한 후, /build/compose_metrics 디렉토리에 생성된 세 가지 다른 파일인 module.json, composablex.txt 및 classes.txt에 액세스할 수 있습니다. 이 파일들을 각각 자세히 살펴보겠습니다.</p>
<h2>최상위 메트릭 (modules.json)</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 보고서는 Compose에 특화된 고수준 메트릭을 제공하며, 주로 추적할 수 있는 숫자 데이터 지점을 생성하는 데 목적이 있습니다. 이러한 메트릭 간의 관계는 통찰력 있는 관찰을 제공할 수 있습니다. 예를 들어, "skippableComposables"의 수를 "restartableComposables"의 수와 비교하면, Composable 함수의 재구성이 건너뛰어질 비율을 나타내는 백분율이 도출됩니다.</p>
<p>아래는 foundation 모듈을 위한 샘플 보고서입니다:</p>
<pre><code class="hljs language-js">{
 <span class="hljs-string">"skippableComposables"</span>: <span class="hljs-number">36</span>,
 <span class="hljs-string">"restartableComposables"</span>: <span class="hljs-number">41</span>,
 <span class="hljs-string">"readonlyComposables"</span>: <span class="hljs-number">6</span>,
 <span class="hljs-string">"totalComposables"</span>: <span class="hljs-number">60</span>,
 <span class="hljs-string">"restartGroups"</span>: <span class="hljs-number">41</span>,
 <span class="hljs-string">"totalGroups"</span>: <span class="hljs-number">82</span>,
 <span class="hljs-string">"staticArguments"</span>: <span class="hljs-number">25</span>,
  <span class="hljs-string">"certainArguments"</span>: <span class="hljs-number">138</span>,
  <span class="hljs-string">"knownStableArguments"</span>: <span class="hljs-number">377</span>,
  <span class="hljs-string">"knownUnstableArguments"</span>: <span class="hljs-number">25</span>,
  <span class="hljs-string">"unknownStableArguments"</span>: <span class="hljs-number">24</span>,
  ..
</code></pre>
<h2>Composable Signatures (composables.txt)</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 보고서는 사람이 이해하기 쉽도록 작성된 의사 Kotlin 스타일 함수 서명을 사용합니다. 이 모듈 내의 각 구성 가능한 함수를 자세히 살펴보며 각 매개변수를 분석하고 특정 통찰을 제공합니다.</p>
<p>이 보고서는 전체 구성 가능한 함수가 다시 시작 가능한지, 건너뛸 수 있는지 또는 읽기 전용인지를 식별합니다. 또한 각 매개변수를 안정적인지 불안정한지로 레이블링하고 각 기본 매개변수 표현을 정적인지 동적인지로 표시하여 구성 가능한 특성에 대한 포괄적인 개요를 제공합니다.</p>
<p>기본적으로 이러한 서명들은 Composable 함수가 건너뛰기 가능한지 여부를 분석하거나 함수가 건너뛰기가 불가능하도록 제약하는 불안정한 매개변수를 식별하는 데 사용할 수 있습니다.</p>
<p>다음은 Composable 함수에 대한 샘플 보고서입니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-kotlin">restartable skippable scheme(<span class="hljs-string">"[androidx.compose.ui.UiComposable]"</span>) <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">Avatar</span><span class="hljs-params">(
  stable modifier: <span class="hljs-type">Modifier</span>? = <span class="hljs-meta">@static</span> Companion
  stable imageUrl: <span class="hljs-type">String</span>? = <span class="hljs-meta">@static</span> <span class="hljs-literal">null</span>
  stable initials: <span class="hljs-type">String</span>? = <span class="hljs-meta">@static</span> <span class="hljs-literal">null</span>
  stable shape: <span class="hljs-type">Shape</span>? = <span class="hljs-meta">@dynamic</span> VideoTheme.&#x3C;<span class="hljs-keyword">get</span>-shapes>($composer, <span class="hljs-number">0</span>b0110)</span></span>.circle
  stable textSize: StyleSize? = <span class="hljs-meta">@static</span> StyleSize.XL
  stable textStyle: TextStyle? = <span class="hljs-meta">@dynamic</span> VideoTheme.&#x3C;<span class="hljs-keyword">get</span>-typography>($composer, <span class="hljs-number">0b0110</span>).titleM
  stable contentScale: ContentScale? = <span class="hljs-meta">@static</span> Companion.Crop
  stable contentDescription: String? = <span class="hljs-meta">@static</span> <span class="hljs-literal">null</span>
)

## Classes (classes.txt)

This report also utilizes pseudo-Kotlin style function signatures crafted <span class="hljs-keyword">for</span> human readability. This file <span class="hljs-keyword">is</span> designed to help you grasp how the stability inferencing algorithm has interpreted a specific <span class="hljs-keyword">class</span>. At the top level, each <span class="hljs-keyword">class</span> <span class="hljs-title class_">is</span> <span class="hljs-title">categorized</span> <span class="hljs-title">as</span> <span class="hljs-title">stable</span>, <span class="hljs-type">unstable</span>, <span class="hljs-type">or</span> <span class="hljs-title">runtime</span>. “<span class="hljs-title">Runtime</span>” <span class="hljs-title">indicates</span> <span class="hljs-title">that</span> <span class="hljs-title">the</span> <span class="hljs-title">stability</span> <span class="hljs-title">is</span> <span class="hljs-title">contingent</span> <span class="hljs-title">on</span> <span class="hljs-title">other</span> <span class="hljs-title">dependencies</span>, <span class="hljs-type">which</span> <span class="hljs-title">will</span> <span class="hljs-title">be</span> <span class="hljs-title">determined</span> <span class="hljs-title">at</span> <span class="hljs-title">runtime</span> (such <span class="hljs-keyword">as</span> a type parameter or a type <span class="hljs-keyword">in</span> an <span class="hljs-keyword">external</span> module).

The stability assessment <span class="hljs-keyword">is</span> based on the <span class="hljs-keyword">class</span>’s fields, with each field listed under the <span class="hljs-keyword">class</span> <span class="hljs-title class_">and</span> <span class="hljs-title">labeled</span> <span class="hljs-title">as</span> <span class="hljs-title">stable</span>, <span class="hljs-type">unstable</span>, <span class="hljs-type">or</span> <span class="hljs-title">runtime</span> <span class="hljs-title">stable</span>. <span class="hljs-title">The</span> <span class="hljs-title">bottom</span> <span class="hljs-title">line</span> <span class="hljs-title">reveals</span> <span class="hljs-title">the</span> “<span class="hljs-title">expression</span>” <span class="hljs-title">employed</span> <span class="hljs-title">to</span> <span class="hljs-title">determine</span> <span class="hljs-title">this</span> <span class="hljs-title">stability</span> <span class="hljs-title">at</span> <span class="hljs-title">runtime</span>, <span class="hljs-type">providing</span> <span class="hljs-title">a</span> <span class="hljs-title">comprehensive</span> <span class="hljs-title">overview</span> <span class="hljs-title">of</span> <span class="hljs-title">how</span> <span class="hljs-title">each</span> <span class="hljs-title">class</span>`<span class="hljs-title">s</span> <span class="hljs-title">stability</span> <span class="hljs-title">is</span> <span class="hljs-title">evaluated</span>.
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-kotlin">stable <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamShapes</span> {
  stable <span class="hljs-keyword">val</span> circle: Shape
  stable <span class="hljs-keyword">val</span> square: Shape
  stable <span class="hljs-keyword">val</span> button: Shape
  stable <span class="hljs-keyword">val</span> input: Shape
  stable <span class="hljs-keyword">val</span> dialog: Shape
  stable <span class="hljs-keyword">val</span> sheet: Shape
  stable <span class="hljs-keyword">val</span> indicator: Shape
  stable <span class="hljs-keyword">val</span> container: Shape
}
</code></pre>
<p>일련의 Compose 컴파일러 메트릭을 생성하는 프로세스를 탐험하고, 각 파일의 중요성을 이해하며, 이 정보를 사용하여 더 많이 건너뛸 수 있는 Composable 함수를 작성하려고 노력하는 방법을 배웠어요. 이 주제를 깊이 있게 탐구하고 싶다면 상세한 통찰을 얻기 위해 Interpreting Compose Compiler Metrics를 확인해보세요.</p>
<h1>안정성 주석</h1>
<p>이제 Compose 컴파일러가 안정성을 처리하는 방식과 이러한 안정성 결정이 다시 구성에 어떻게 영향을 미치는지, 그리고 당신의 애플리케이션 성능에 어떻게 영향을 미칠 수 있는지 통찰력을 얻었어요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Composed of immutability and stability annotations, let's take a journey into transforming changeable classes into reliable ones using annotations from the compose-runtime library. The main actors in this process are @Immutable and @Stable.</p>
<h1>Immutability</h1>
<p>When you decorate your class with the @Immutable annotation, you reassure the Compose compiler that all public properties and fields within the class will remain unchanged (immutable) once they are created. This provides a more solid guarantee compared to the val keyword at the language level. While val prevents properties from being modified via a setter, it still allows creation through mutable data structures like Lists initialized with MutableList.</p>
<p>To make sure your classes are distinctly marked as stable with the @Immutable annotation, adhere to the guidelines below:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>모든 공용 속성에 val 키워드를 사용하여 불변성을 보장하세요.</li>
<li>사용자 지정 setter를 피하고 공용 속성이 변경 가능성을 지원하지 않도록 합니다.</li>
<li>모든 공용 속성의 유형이 본질적으로 불변 또는 안정적이거나 안정성 주석으로 명시적으로 표시되었는지 확인하세요. 예를 들어 인터페이스는 불안정하다고 간주되므로 속성으로 사용되는 모든 인터페이스 유형도 안정성을 위해 주석을 달아야 합니다.</li>
<li>컬렉션인 속성들의 경우, 안정성을 유지하기 위해 kotlinx.collections.immutable에서 제공하는 불변 컬렉션을 선택하세요.</li>
</ul>
<p>@Immutable 주석은 위의 불변성 규칙을 준수하는 클래스에 효과적이며, 불필요한 recomposition을 건너뛰어 응용프로그램 성능을 향상시킬 때 중요한 역할을 합니다.</p>
<p>그러나 @Immutable 주석을 분별하게 사용하는 것이 중요합니다. 적절하게 사용하지 않으면 의도하지 않은 recomposition 건너뛰기로 인해 Compose 레이아웃이 예상대로 업데이트되지 않을 수 있습니다.</p>
<h1>안정함</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><code>@Stable</code> 어노테이션은 <code>@Immutable</code> 어노테이션보다 Compose 컴파일러에 더 강력하지만 약간 덜 엄격한 커밋먼트를 나타냅니다. 함수나 프로퍼티에 적용되면, <code>@Stable</code> 어노테이션은 해당 유형이 가변할 수 있다는 것을 나타냅니다. 처음에는 약간 모순적으로 보일 수도 있습니다. 이 문맥에서 "Stable"이라는 용어는 함수가 동일한 입력에 대해 항상 동일한 결과를 반환할 것이라는 의미로, 잠재적인 가변성에도 불구하고 예측 가능한 동작을 보장합니다.</p>
<p>따라서 <code>@Stable</code> 어노테이션은 주로 public 프로퍼티가 불변인 클래스에 적합하지만 클래스 자체가 안정적이지 않을 수 있는 경우에 사용됩니다. 예를 들어, Jetpack Compose의 State 인터페이스는 value라는 불변 프로퍼티만 노출합니다. 그러나 이 불변 프로퍼티의 내부 값은 여전히 setValue 함수를 통해 수정될 수 있으며, 일반적으로 MutableState를 생성하여 이를 수행합니다.</p>
<p>State와 MutableState를 통한 데모로 보여 준 것처럼, MutableState에 의해 생성된 State 인스턴스는 getValue 함수(값 프로퍼티의 게터)로부터 일관되게 동일한 값을 얻을 것이며, setValue 함수에 대한 동일한 입력에 대해 동일한 결과를 반환합니다. 제공된 코드 스니펫에서는 <code>@Stable</code> 어노테이션이 지정된 State와 MutableState 인터페이스를 모두 보여줍니다.</p>
<h1>Immutable vs Stable</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><strong>@Immutable</strong>과 <strong>@Stable</strong> 주석 사이의 구별과 어떤 것을 사용해야 하는지 결정하는 것은 처음에는 혼란스러울 수 있습니다. 하지만 실제로는 꽤 간단합니다. 이전에 언급했듯이, <strong>@Immutable</strong> 주석은 클래스의 모든 공용 속성이 불변이라는 의미로, 생성된 후에 상태가 변경될 수 없음을 나타냅니다. 반면에 <strong>@Stable</strong> 주석은 가변 객체에 적용될 수 있으며, 동일한 입력에 대해 일관된 결과를 생성해야 하는 것을 요구합니다.</p>
<p><strong>@Immutable</strong> 주석은 대부분 도메인 모델에 적용되는데, 특히 Kotlin 데이터 클래스를 사용할 때 다음 예시에서와 같이 나타납니다:</p>
<p>반면에 <strong>@Stable</strong> 주석은 여러 구현 가능성을 제공하는 인터페이스에 대해 일반적으로 사용되며, 내부 가변 상태를 가질 수 있습니다. 아래 의미 있는 예시는 이 주석을 이해하는 데 도움이 됩니다:</p>
<p><strong>@Stable</strong> 주석을 적용하면 <strong>UiState</strong> 클래스를 안정적으로 지정할 수 있습니다. 이는 최적화된 건너뛰기와 지능적인 재구성을 가능하게 하여 업데이트의 효율성을 향상시킵니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>NonRestartableComposable</h1>
<p>Jetpack Compose의 @NonRestartableComposable 주석은 특정 구성 가능한 함수의 recomposition 동작을 최적화하기 위해 고안된 비교적 고급 기능입니다. 이 주석은 구성 가능한 함수가 호출 매개변수의 변경으로 인해 recomposition 중 자동으로 다시 시작되지 않아야 함을 Compose 컴파일러에 알리는 역할을 합니다. 일반적으로 구성 가능한 함수의 입력 값이 변경되면 Compose 런타임은 함수를 다시 시작하여 새로운 입력 값을 소비하게 할 수 있습니다.</p>
<p>그러나 이러한 다시 시작이 항상 필요하거나 원하는 것은 아닐 수 있습니다, 특히 함수의 내부 상태나 부작용을 다시 시작해야 할 때가 아닌 경우에 해당합니다. @NonRestartableComposable을 적용하면 런타임이 함수를 다시 시작하지 않고 매개변수를 업데이트하도록 지시하여 내부 상태와 진행 중인 부작용을 유지할 수 있습니다.</p>
<p>@NonRestartableComposable의 일부로 동작하는 대표적인 예는 Compose 런타임 라이브러리의 Side-effect API 내에서 발견됩니다. 예를 들어 LaunchedEffect의 구현은 이 주석을 사용하여 효과가 불필요하게 다시 시작되지 않도록 보장합니다. 아래 코드에서 보여진 것처럼요:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그러나 @NonRestartableComposable 주석을 사용할 때 주의해야 하며 앱 성능을 향상시키기 위한 수단으로만 사용해서는 안 됩니다. 선별적으로 사용하지 않으면 원하지 않는 결과로 이어질 수 있습니다.</p>
<h1>Composable 함수 안정화</h1>
<p>앱 성능을 최적화하는 목적으로 안정한 클래스를 작성하는 방법에 대해 알아보았습니다. 그러나 Composable 함수의 완전한 안정성 달성은 여기서 멈추지 않습니다. 왜냐하면 일부 클래스(예: Kotlin의 컬렉션 또는 제3자 라이브러리에서 제공하는 클래스)는 직접 제어할 수 없을 수 있기 때문입니다.</p>
<p>이전에 언급했던 바와 같이 스마트 recomposition 중 Composable 함수를 건너뛸 수 있는 능력은 해당 함수의 각 매개변수의 안정성에 의해 결정됩니다. 스마트 recomposition을 위해 Composable 함수 내에서 사용되는 모든 매개변수가 안정적임을 보장하는 것이 중요합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 섹션에서는 Composable 함수를 스킵할 수 있는 네 가지 다른 전략을 탐구하여 효율적인 recomposition으로 성능을 향상시킬 수 있습니다.</p>
<h1>Immutable Collections</h1>
<p>처음에는 List가 요소를 수정하는 것을 허용하지 않더라도, 인터페이스인 특히 kotlin.collections이 Jetpack Compose에서 불안정하게 여겨지는 이유를 의심할 수 있습니다.</p>
<p>아래의 좋은 예제를 살펴보면 그 이유를 이해할 수 있습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>userList 필드는 List로 선언되어 있습니다. List는 기본적으로 요소의 수정을 허용하지 않습니다. 그러나 첫 번째 줄에서 나와 있듯이, 이 List는 MutableList로부터 생성될 수 있습니다. 이는 List 인터페이스 자체가 수정을 제한하지만 해당 내부 구현이 변경 가능할 수 있다는 것을 의미합니다. Compose 컴파일러는 구현 유형을 추론할 수 없어, 이러한 인스턴스들을 안정적이지 않은 것으로 간주하여 정확한 동작을 보장합니다.</p>
<p>그러므로 공식 Android 문서에서는 Composable 함수의 컬렉션 매개변수의 안정성을 보장하기 위해 kotlinx.collections.immutable 라이브러리나 Guava의 Immutable Collections를 활용할 것을 권장합니다.</p>
<p>kotlinx.collections.immutable 라이브러리는 ImmutableList 및 ImmutableSet과 같은 여러 컬렉션을 제공하며, 이는 표준 kotlin.collections의 동작을 모방하지만 변경 불가능합니다. 이러한 컬렉션은 읽기 전용이며, 생성 후에는 수정이 불가능합니다.</p>
<p>이제 Compose 컴파일러가 kotlinx.collections 대비 kotlinx.collections.immutable의 안정성을 결정할 때 고려하는 주요 요소에 대해 궁금해 할 수 있습니다. 구분은 Compose 컴파일러가 변경 불가능 컬렉션을 이해하는 데 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>더 자세한 통찰을 얻으려면 Compose 컴파일러 라이브러리의 일부인 KnownStableConstructs.kt 파일을 참고하십시오. 아래 코드를 보면, Compose 컴파일러가 안정적으로 간주해야 하는 클래스의 패키지 이름 목록을 수동으로 유지한다는 것을 확인할 수 있습니다:</p>
<p>아래 코드 조각을 살펴보면, Composable 함수의 매개변수 안정성을 분석하는 Compose 컴파일러의 일부입니다. 알려진 안정 구조체 클래스에 나열된 매개변수 유형에 대한 안정성을 컴파일러가 유추하지 않는 것이 분명합니다:</p>
<h2>Lambda</h2>
<p>Compose 컴파일러에서는 Kotlin 람다 표현식의 처리가 독특한 접근 방식을 취합니다. 이전에 설명한 바와 같이, Compose 컴파일러는 IR(Intermediate Representation) 변환을 통해 개발자가 작성한 소스 코드를 수정합니다. 따라서 컴파일러는 Composable 함수에 전달된 람다의 실행을 최적화하기 위해 Compose 런타임에 일부 규칙을 생성합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Compose 컴파일러는 람다 표현식을 처리할 때 람다가 값을 캡처하는지 여부에 따라 다른 방식으로 다룹니다. 클로저의 맥락에서 값들을 캡처하는 것은 람다 표현식이 직접적인 범위 외부에 있는 변수에 의존한다는 의미입니다. 외부 변수에 독립적인 람다라면 아래 예시처럼 값들을 캡처하지 않는다고 말할 수 있습니다:</p>
<p>람다 매개변수가 어떤 값도 캡처하지 않는 경우, Kotlin은 이러한 람다를 싱글톤으로 처리하여 불필요한 할당을 최소화합니다. 반면, 람다가 클로저 밖의 변수에 의존하는 경우, 아래 예시에서 볼 수 있듯이 값들을 캡처한다고 간주됩니다:</p>
<p>람다 매개변수가 외부 값들을 캡처하는 경우, 그 실행 결과는 캡처된 값들에 따라 달라질 수 있습니다. 이를 해결하기 위해, Compose 컴파일러는 메모리제이션 전략을 사용하여 람다를 remember 함수 호출 내에 캡슐화합니다. 캡처된 값은 remember에 대한 키 매개변수로 작용하여, 캡처된 값들의 변화에 적절히 반응하여 람다가 적절하게 재호출되도록 합니다.</p>
<p>결과적으로, 람다가 값들을 캡처하는지 여부에 관계없이, 해당 람다는 Composable 함수 내에서 안정적으로 간주됩니다. Composable 함수가 Any 유형의 매개변수를 수용하는 시나리오를 고려해보면, Any가 변경 불가능한 값을 포함하는 등 다양한 값 범위를 포함할 수 있기 때문에, Compose 컴파일러에서는 불안정하게 취급됩니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그러나 아래 예시와 같이 람다 표현식을 사용하여 값을 제공하는 경우, Compose 컴파일러는 람다 매개변수를 안정적으로 처리합니다:</p>
<h1>Wrapper Class</h1>
<p>Composable 함수를 안정화하는 또 다른 효과적인 전략은 제어 범위를 벗어난 불안정한 클래스에 대한 래퍼 클래스를 만드는 것입니다. 이러한 경우에는 예시와 같이 안정성 주석을 직접 적용할 수 없는 클래스에 적용할 수 있습니다.</p>
<p>그런 다음 Composable 함수의 매개변수 유형으로 이 래퍼 클래스를 활용할 수 있습니다. 아래 코드에서 보여지는 것처럼요:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>파일 구성</h1>
<p>Compose 컴파일러 버전 1.5.5부터 구성 파일에서 클래스를 나열할 수 있는 옵션이 추가되었습니다. 이러한 지정된 클래스는 Compose 컴파일러에 의해 안정적으로 인식됩니다. 이 기능은 서드파티 라이브러리에서 가져온 클래스와 같이 제어할 수 없는 클래스들을 사용할 때 매우 유용합니다.</p>
<p>이 기능을 활성화하려면 아래와 같이 앱 모듈의 build.gradle.kts 파일에 Compose 컴파일러 구성을 추가하십시오:</p>
<p>다음으로, 앱 모듈의 루트 디렉토리에 compose_compiler_config.conf 파일을 아래와 같이 생성하십시오:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-comment">// LocalDateTime을 안정적으로 간주합니다.</span>
java.<span class="hljs-property">time</span>.<span class="hljs-property">LocalDateTime</span>
<span class="hljs-comment">// Kotlin 컬렉션을 안정적으로 간주합니다.</span>
kotlin.<span class="hljs-property">collections</span>.*
<span class="hljs-comment">// 내 데이터 계층과 모든 하위 모듈을 안정적으로 간주합니다.</span>
com.<span class="hljs-property">datalayer</span>.**
<span class="hljs-comment">// 제네릭 타입을 첫 번째 타입 매개변수를 기반으로 안정적으로 간주합니다.</span>
com.<span class="hljs-property">example</span>.<span class="hljs-property">GenericClass</span>&#x3C;*,_>
</code></pre>
<p>프로젝트를 빌드하고 Compose 컴파일러 메트릭을 생성하면, 구성 파일에서 지정한 클래스들이 안정적으로 인식되어 스마트 재구성을 건너뛸 수 있습니다.</p>
<p>공식 안드로이드 가이드에 따르면, Compose 컴파일러는 각 프로젝트 모듈 별로 독립적으로 작동하므로 필요에 따라 다른 모듈에 대해 각기 다른 구성을 제공할 수 있습니다. 또는 프로젝트 루트 수준에서 단일 구성을 선택하고 각 모듈에 대해 해당 경로를 지정할 수도 있습니다.</p>
<p>기억해야 할 중요한 점은 구성 파일이 정의된 클래스들을 기본적으로 안정적으로 만들지 않습니다. 대신, 구성 파일을 활용하여 Compose 컴파일러와 계약을 맺는 것입니다. 따라서이 기능을 분별있게 사용하여 특정 시나리오에서 스마트 재구성 프로세스를 우연히 건너뛰는 일을 피해야 합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>멀티 모듈 아키텍처의 안정성</h1>
<p>당신의 Gradle 모듈을 모듈화하는 것은 훌륭한 전략으로, 향상된 재사용성, 병렬 빌드, 탈중앙화된 팀 집중력 등의 혜택을 제공합니다. 안드로이드 공식 가이드도 모듈화를 권장하며, 프로젝트 규모에 맞게 코드의 확장성을 향상시키고 가독성을 개선하며 전반적인 코드 품질을 높이는 수단으로 모듈화를 소개합니다.</p>
<p>모듈화는 Jetpack Compose에서 고유한 도전 과제를 소개합니다: 독립된 모듈로부터의 클래스는 그들의 퍼블릭 프로퍼티의 불변성 여부와 상관없이 불안정하다고 간주됩니다. 이를 극복하기 위해, 데이터 모듈에 compose-runtime 라이브러리를 가져오고 데이터 클래스에 안정성 주석을 달 것을 권장합니다.</p>
<p>그러나, Jetpack Compose 런타임 라이브러리에 직접 의존하지 않고 순수한 Kotlin/JVM 라이브러리에 초점을 맞춘 경우에는 compose 런타임 라이브러리에 의존하는 것이 이상적이지 않은 경우가 있을 수 있습니다. 이러한 시나리오에서 두 가지 주요 솔루션이 제시됩니다: compose-stable 마커 라이브러리를 채택하거나 안정성을 보장하기 위해 파일 구성을 활용하는 것입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>안정적인 마커 작성기</h1>
<p>"안정적인 마커" 라이브러리는 @Immutable 및 @Stable과 같은 안정성 주석을 제공하며, 이는 compose-runtime 라이브러리 내의 유사한 주석 기능을 반영합니다. compose-runtime 라이브러리를 직접 사용하는 것 대신 compose-stable 마커 라이브러리를 선택하면 아래에 설명된 두 가지 주요 이점이 제공됩니다:</p>
<ul>
<li>가벼움: 클래스, 함수 및 확장 기능이 풍부한 compose-runtime 라이브러리는 응용 프로그램의 크기를 늘릴 수 있는 가능성이 있습니다. 반면에 compose-stable 마커 라이브러리는 안정성 주석에만 초점을 맞춘 가벼운 대안을 제공합니다. 이를 통해 응용 프로그램의 크기를 줄이고 전체 compose-runtime 라이브러리를 사용하는 것보다 빌드 시간을 단축할 수 있습니다.</li>
<li>의존성 없음: compose-runtime 라이브러리에는 SideEffect, LaunchedEffect, snapshotFlow 및 Compose 컴파일러와 관련된 기타 주석들과 같은 Compose 런타임 기능을 실행하는 데 필수적인 기능이 포함되어 있습니다. 이러한 설정은 데이터 모듈에 필요하지 않은 경우에도 모듈이 이러한 API에 액세스 할 수 있는 가능성을 발생시킬 수 있습니다. compose-stable 마커 라이브러리를 선택하면 이러한 특수화된 API에 실수로 액세스하는 위험을 제거하여 모듈이 집중되고 효율적으로 유지되도록 보장합니다.</li>
</ul>
<p>해당 라이브러리의 좋은 사용 사례는 Compose용 Stream의 적응 가능한 채팅 및 비디오 SDK의 코어 모듈에서 발견할 수 있습니다. 이러한 SDK의 코어 모듈은 compose-stable 마커를 활용하여 도메인 클래스를 안정적으로 지정합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>compose-stable-marker 라이브러리에 대해 더 알아보려면 GitHub 저장소를 방문해 주세요.</p>
<h1>파일 구성</h1>
<p>이전 섹션에서 논의한 것처럼 파일 구성은 Compose 컴파일러와의 계약을 달성하여 원본이나 가변성과 무관하게 특정 클래스를 안정적으로 다루도록 합니다. 이는 다른 모듈에서 클래스를 나열하여 파일 구성에 포함시키면 컴파일러가 자동으로 이를 안정적인 것으로 인식한다는 것을 의미합니다.</p>
<p>한 가지 강조해야 할 점은 이 기능을 분별하여 사용해야 합니다. Compose 컴파일러는 이러한 클래스들을 안정적으로 지속적으로 다룰 것이므로 스마트한 재구성 행동을 조정하여 의도하지 않은 동작을 유발할 수 있습니다. 또한, 이러한 강제적인 안정성으로 인한 디버깅 문제는 애플리케이션 내에서 해결하기 어려울 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>강한 스킵 모드</h1>
<p>컴포저블 함수를 제작할 때 건너뛸 수 있는 또 다른 전략은 강한 스킵 모드를 활성화하는 것입니다. Compose Compiler 버전 1.5.4에서 소개된 이 기능은 불안정한 매개변수를 포함한 경우에도 컴포저블 함수를 건너뛸 수 있게 해주며, 불안정한 캡처를 포함하는 람다를 최적화된 성능을 위해 메모이즈합니다.</p>
<p>현재 실험 단계에 있으며 아직 제품용으로 준비되지 않았지만, 강한 스킵 모드는 Compose 1.7 알파에서 기본으로 활성화될 예정입니다. 효과와 안정성은 베타 단계로 진행되기 전에 철저히 평가될 것입니다. 일시적으로 이 실험적 기능을 활성화하려면 다음 Compose 컴파일러 옵션을 포함시키면 됩니다:</p>
<p>강한 스킵 모드는 재구성 중에 컴포저블 함수를 건너뛸 때 Compose 컴파일러가 사용하는 전통적인 안정성 기준을 수정합니다. 일반적인 상황에서 컴포저블 함수는 오직 안정적인 매개변수만 포함하고 있는 경우에만 건너뛸 수 있는 것으로 간주됩니다. 그러나 강한 스킵 모드는 이 전통을 변경합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 기능이 활성화되면 모든 다시 시작 가능한 Composable 함수가 건카볼입니다. 이전 값을 무시하고 불안정한 매개변수가 포함되었는지 여부에 관계없이. 그러나, 다시 시작할 수 없는 Composable 함수는 영향을 받지 않으며 건너뛸 수 없습니다.</p>
<p>재조합 중 Composable 함수를 건너뛸지 여부를 평가할 때 이 모드는 불안정한 매개변수와 해당 이전 값과의 인스턴스 동등성을 비교하기 위해 사용됩니다. 반면에, 안정적 매개변수는 Object.equals()에 의해 정의된 객체 동등성을 사용하여 비교됩니다.</p>
<p>재조합 중 이러한 기준에 모든 매개변수가 일치하는 경우 Composable 함수가 우회됩니다. 불필요한 업데이트를 줄여 성능을 최적화합니다.</p>
<p>Composable 함수를 강력한 건카볼 모드에서 제외하고 다시 시작할 수 있지만 건너뛸 수 없도록 만들려면 @NonSkippableComposable 주석을 적용할 수 있습니다. 이는 매개변수 안정성과 관계없이 항상 재조합을 위해 해당 함수가 고려됨을 보장합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>한편, 객체 동등성(object equality)을 사용하여 객체를 비교하려면 여전히 도메인 모델 클래스에 @Stable 주석을 추가해야 합니다.
이 기능과 람다 메모이제이션(Lambda Memoization)의 향상된 개념에 대한 더 깊은 이해를 위해 '강력한 스킵 모드(Strong Skipping Mode)'에 대한 상세 가이드를 참조해보세요.</p>
<h1>결론</h1>
<p>탐험이 마무리되었습니다! 안정성의 개념, 안정성 추론과 스마트 recomposition 뒤에 숨은 메커니즘, 클래스 및 Composable 함수를 안정화하는 효과적인 전략, 그리고 응용 프로그램 성능을 향상시키는 방법에 대해 다루었습니다.</p>
<p>안정성의 중요성을 깨달으면 화면에 UI 노드를 렌더링하는 메커니즘에 영향을 줌으로써 최종적으로 응용 프로그램의 성능에 영향을 미치게 됩니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 테이블 태그를 마크다운 형식으로 변경해주세요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>원래 getstream.io에 게시되었습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Jetpack Compose에서 안정성을 마스터하여 앱 성능 최적화하기","description":"","date":"2024-05-17 18:39","slug":"2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose","content":"\n![Jetpack Compose](/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_0.png)\n\n젯팩 컴포즈는 구글의 첨단 UI 툴킷으로서, 안정적인 1.0 버전 이후 뛰어난 가능성을 보여주었습니다. Google의 보고에 따르면, 제트팩 컴포즈를 사용하여 개발된 앱이 이미 12만 5천 개 이상이 Google Play Store에서 성공적으로 출시되면서 프로덕션 목적으로의 채택이 급증했습니다.\n\n제트팩 컴포즈는 내장된 최적화 기능을 갖추고 있지만, 개발자들은 컴포즈가 UI 요소를 어떻게 렌더링하는지 이해하고, 다양한 시나리오에서 제트팩 컴포즈의 성능을 최적화하기 위한 전략을 파악해야 합니다. 이러한 지식은 애플리케이션의 성능에 잠재적인 영향을 최소화하고 더 나은 사용자 경험을 제공하기 위한 중요한 역할을 합니다.\n\n이 기사에서는 제트팩 컴포즈의 내부 작업을 이해하고, 안정성을 관리하여 애플리케이션의 성능을 향상시키는 방법을 안내하겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Jetpack Compose 단계\n\n안정성에 대해 자세히 살펴보기 전에 Jetpack Compose의 단계를 이해하는 것이 중요합니다. 이 단계에서는 화면에 Compose UI 노드를 렌더링하는 과정이 여러 연속적인 단계를 통해 진행됩니다.\n\n![Jetpack Compose Phases](/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_1.png)\n\nJetpack Compose는 한 프레임의 렌더링을 세 가지 구분된 단계를 통해 실행합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 구성: 이 단계에서는 Composable 함수에 대한 설명을 생성하고 여러 메모리 슬롯을 할당함으로써 프로세스가 시작됩니다. 이러한 슬롯은 각 Composable 함수를 메모이즈하여 런타임 중에 효율적인 호출 및 실행을 가능하게 합니다.\n- 레이아웃: 이 단계에서는 Composable 트리 내 각 노드의 위치를 설정합니다. 레이아웃 단계는 주로 각 Composable 노드를 측정하고 적절히 배치하여 UI의 전체 구조 내에서 모든 요소가 정확히 배열되도록 보장합니다.\n- 그리기: 이 마지막 단계에서는 Composable 노드가 일반적으로 장치의 화면인 캔버스에 렌더링됩니다. 이 중요한 단계는 UI를 시각적으로 구축하여 설계된 Composables을 사용자 상호 작용을 위해 사용할 수 있게 합니다.\n\n내부 메커니즘은 훨씬 더 복잡하지만, 기본적으로 Composable 함수를 작성할 때 화면에 표시되기 위해 이러한 단계를 거칩니다.\n\n이제 레이아웃의 크기 및 색상과 같은 UI 요소를 수정하려고 한다고 가정해 봅시다. 그림 그리기 단계가 완료된 경우, Compose는 이러한 새 값들을 적용하기 위해 처음부터 다시 이러한 단계를 다시 방문해야 합니다. 이러한 업데이트 사이클을 재구성이라고 합니다:\n\n![이미지](/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n재구성은 입력 변경에 대한 응담으로 조합 가능한 함수가 새롭게 실행되어 Composition 단계에서 시작됩니다. 이 프로세스는 State에서 관찰하거나 내재적으로 Compose 런타임과 컴파일러 메커니즘들이 연관된 다양한 요소에 의해 트리거될 수 있습니다.\n\n전체 UI 트리와 요소를 재구성하는 것은 상당한 계산 리소스를 필요로 하며 앱의 성능에 직접적인 영향을 미칠 수 있습니다. 필요한 경우에만 재구성을 트리거함으로써(불필요할 때 재구성을 건너뛸 경우) 계산 리소스를 최소화하여 UI 성능을 향상시킬 수 있습니다.\n\n따라서, Compose 런타임의 작동 방식을 포함한 재구성 프로세스에 대한 심층적인 이해, 재구성을 건너뛸 기회를 식별하고 재구성을 트리거하는 요소를 인식하는 것이 중요합니다.\n\n이제 안정성 개념을 탐구하고 재구성 비용을 최적화하여 응용 프로그램 성능을 향상시킬 방법을 살펴보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 안정성 이해\n\n이전 섹션에서 언급된 바와 같이, 이미 렌더링된 UI를 업데이트하기 위해 다양한 방법이 존재합니다. Composable 함수의 매개변수의 안정성은 Compose 런타임과 컴파일러의 작동과 깊이 얽혀 있어, 재구성을 시작하는 결정적인 요소로 부각됩니다.\n\nCompose 컴파일러는 Composable 함수의 매개변수를 안정적인 것과 불안정한 것 두 가지로 분류합니다. 이러한 매개변수 안정성의 분류는 Compose 런타임에 의해 Composable 함수가 재구성되어야 하는지 여부를 결정하는 데 사용됩니다.\n\n# 안정함 vs. 불안정함\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제, 어떻게 매개변수가 안정적인지 불안정한지로 분류되는지 궁금할 수 있습니다. 이 결정은 Compose 컴파일러에 의해 이루어집니다. 컴파일러는 Composable 함수에서 사용된 매개변수의 유형을 검토하고 다음 기준에 따라 안정적인지를 분류합니다:\n\n- String을 포함한 기본 유형은 본질적으로 안정적입니다.\n- (Int) -` String과 같은 람다 표현식으로 나타낸 함수 유형은 안정적으로 간주됩니다.\n- 불변하고 안정적인 공개 속성으로 특징지어진 데이터 클래스 또는 안정성 주석인 @Stable이나 @Immutable과 같이 명시적으로 표시된 클래스는 안정적으로 간주됩니다. 이러한 주석의 구체적인 내용에 대해 다음 섹션에서 자세히 살펴볼 것입니다.\n\n예를 들어, 아래와 같이 데이터 클래스를 상상해 볼 수 있습니다:\n\nComposable 컴파일러에 의해 안정적으로 간주되는 불변 기본 속성으로 구성된 User 데이터 클래스입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나, Composable 함수 내에서 매개변수 유형을 평가하는 컴파일러는 아래 기준에 따라 해당 유형을 불안정하다고 식별합니다:\n\n- List, Map 등의 인터페이스와 Any와 같은 추상 클래스와 같이 컴파일 시간에 구현이 예측할 수 없는 유형은 불안정하다고 간주됩니다. 이 분류의 근거는 다음 섹션에서 더 자세히 논의될 예정입니다.\n- 특히 적어도 하나의 가변 또는 본질적으로 불안정한 공용 속성을 포함하는 데이터 클래스와 같은 클래스는 불안정하다고 분류됩니다.\n\n예를 들어, 다음과 같은 데이터 클래스를 상상해볼 수 있습니다:\n\nUser 데이터 클래스는 기본 속성으로 구성되어 있지만, 가변 이름 속성의 존재로 인해 Compose 컴파일러가 이를 불안정하다고 분류합니다. 이 분류는 안정성이 모든 속성의 종합적인 안정성을 평가하여 단일 가변 속성이 전체 클래스를 불안정하게 만들 수 있기 때문에 발생합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 스마트 재구성\n\n안정성의 원칙을 탐색하고 Compose 컴파일러가 안정적인지 불안정한지를 구별하는 방법을 살펴봤다면, 이러한 차이점을 활용하여 재구성을 트리거하는 실용적인 사용법에 관심이 생길 수 있습니다. Compose 컴파일러는 변경 가능 함수의 각 매개변수의 안정성을 평가하여 Compose 런타임이 이 정보를 효율적으로 활용할 수 있도록 기초를 마련합니다.\n\n클래스의 안정성이 결정되면, Compose 런타임은 이 통찰력을 활용하여 내부 메커니즘인 스마트 재구성을 통해 재구성을 시작합니다. 스마트 재구성은 제공된 안정성 정보를 활용하여 불필요한 재구성을 선택적으로 건너뛰어 Compose의 전체 성능을 향상시킵니다.\n\n스마트 재구성이 작동하는 원칙 중 일부는 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 등가성 확인: Composable 함수에 새 입력이 전달될 때마다 해당 입력은 반드시 클래스의 equals() 메서드를 사용하여 이전 입력과 비교됩니다.\n- 안정성에 따른 결정:\n\n- 매개변수가 안정적이고 값이 변경되지 않은 경우 (equals()가 true를 반환), Compose는 관련 UI 구성 요소를 다시 구성하지 않습니다.\n- 매개변수가 불안정하거나 안정적이지만 값이 변경된 경우 (equals()가 false를 반환), 런타임은 다시 구성을 시작하여 UI 레이아웃을 무효화하고 다시 그립니다.\n\n위 시나리오에서 불필요한 다시 구성을 피함으로써 UI 성능을 향상시킬 수 있습니다. 전체 UI 트리를 다시 구성하는 것은 상당한 계산 리소스를 필요로하며, 적절하게 처리되지 않으면 성능에 부정적인 영향을 줄 수 있습니다.\n\nJetpack Compose는 스마트한 다시 구성을 기본적으로 제공하지만, Composable 함수에서 사용되는 클래스를 안정화하고 최대한 다시 구성을 줄이는 방법을 숙지하는 것이 중요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 합성 가능한 함수 추론하기\n\n이제 컴포즈 컴파일러가 클래스 안정성을 결정하고 컴포즈 런타임이 이 정보를 내부 메커니즘인 스마트 재구성으로 활용하는 방법을 이해했습니다. 그렇지만 이해해야 할 또 다른 중요한 개념은 합성 가능한 함수의 유형 추론입니다.\n\n컴포즈 컴파일러는 코틀린 컴파일러 플러그인을 사용하여 개발자가 작성한 소스 코드를 컴파일 시 분석할 수 있게 만들어졌습니다. 더불어, 컴포즈 함수의 고유한 특성과 더 잘 일치하도록 원본 소스 코드를 조정할 수 있습니다.\n\n컴파일러는 합성 가능한 함수를 시작 가능함, 이동 가능함, 대체 가능함 등으로 분류하여 실행을 최적화합니다. 이 게시물에서는 특히 재구성에 중요한 역할을 하는 시작 가능한 유형에 대해 자세히 살펴볼 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 다시 시작 가능한\n\n다시 시작 가능한은 Composable 함수의 일종으로, Compose 컴파일러에 의해 결정되며 recomposition 프로세스의 중추 역할을 합니다. 이전에 탐구한 대로, Compose 런타임은 입력 값의 변화를 감지하면 이러한 새 입력 값으로 함수를 다시 시작(또는 다시 호출)하여 데이터 변경을 정확하게 반영합니다.\n\nCompose 런타임에서 제공하는 특정 주석으로 Composable 함수를 명시적으로 주석 처리하지 않으면 대부분의 함수는 기본적으로 다시 시작 가능하다고 간주됩니다. 이는 Compose 런타임이 언제든지 입력 또는 상태 변경이 발생할 때 해당 Composable 함수에 대해 recomposition을 트리거할 수 있다는 것을 의미합니다.\n\n# 건너뛰기 가능한\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSkipable은 또 다른 Composable 함수의 특성을 나타내며, 이는 이전 섹션에서 논의된 스마트 recomposition에 의해 설정된 적절한 조건 하에서 전체 recomposition 프로세스를 완전히 우회할 수 있음을 의미합니다. 따라서, skipable 함수가 바로 recomposition을 건너뛰고 UI 성능을 향상시킬 수 있는 잠재력과 직접적으로 연결된다고 단언할 수 있습니다. 이는 특정 상황에 따라서 달려있는데요.\n\n이 능력은 특히 규모가 큰 함수 호출 계층 구조의 정상 Composable 함수의 성능을 향상시키는 데 중요합니다. 이러한 루트 Composable의 recomposition을 건너뛰면, Compose는 이러한 루트 Composable의 recomposition을 건너뛰면, 해당 계층의 하위 함수들 중 어떤 것도 호출할 필요가 없어지며, 전체 recomposition 프로세스가 간소화됩니다.\n\nComposable 함수가 재시작 가능(restartable)이면서 동시에 skippable로 분류되는 경우도 있음을 기억하는 것이 중요합니다. skippable로 분류되면 재시작 가능한 recomposition을 거칠 수 있다는 것을 함축하므로요. 이제 작성한 Composable 함수가 재시작 가능 또는 skippable로 분류되는지 알아보는 방법을 살펴보겠습니다.\n\n# Compose Compiler Metrics\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCompose 컴파일러 플러그인을 사용하면 Compose에 고유한 특정 개념에 중점을 둔 자세한 보고서와 메트릭을 생성할 수 있습니다. 이러한 통찰력은 Compose 코드의 복잡성을 파헤치는 데 유용하며, 마이크로 레벨에서 작동 방식을 정확하게 이해할 수 있도록 도와줍니다.\n\nCompose 컴파일러 메트릭을 생성하려면, 아래 예제에 설명된 대로 루트 모듈의 build.gradle 파일에 컴파일러 옵션을 추가하면 됩니다:\n\n프로젝트를 동기화하고 빌드한 후, /build/compose_metrics 디렉토리에 생성된 세 가지 다른 파일인 module.json, composablex.txt 및 classes.txt에 액세스할 수 있습니다. 이 파일들을 각각 자세히 살펴보겠습니다.\n\n## 최상위 메트릭 (modules.json)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 보고서는 Compose에 특화된 고수준 메트릭을 제공하며, 주로 추적할 수 있는 숫자 데이터 지점을 생성하는 데 목적이 있습니다. 이러한 메트릭 간의 관계는 통찰력 있는 관찰을 제공할 수 있습니다. 예를 들어, \"skippableComposables\"의 수를 \"restartableComposables\"의 수와 비교하면, Composable 함수의 재구성이 건너뛰어질 비율을 나타내는 백분율이 도출됩니다.\n\n아래는 foundation 모듈을 위한 샘플 보고서입니다:\n\n```js\n{\n \"skippableComposables\": 36,\n \"restartableComposables\": 41,\n \"readonlyComposables\": 6,\n \"totalComposables\": 60,\n \"restartGroups\": 41,\n \"totalGroups\": 82,\n \"staticArguments\": 25,\n  \"certainArguments\": 138,\n  \"knownStableArguments\": 377,\n  \"knownUnstableArguments\": 25,\n  \"unknownStableArguments\": 24,\n  ..\n```\n\n## Composable Signatures (composables.txt)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 보고서는 사람이 이해하기 쉽도록 작성된 의사 Kotlin 스타일 함수 서명을 사용합니다. 이 모듈 내의 각 구성 가능한 함수를 자세히 살펴보며 각 매개변수를 분석하고 특정 통찰을 제공합니다.\n\n이 보고서는 전체 구성 가능한 함수가 다시 시작 가능한지, 건너뛸 수 있는지 또는 읽기 전용인지를 식별합니다. 또한 각 매개변수를 안정적인지 불안정한지로 레이블링하고 각 기본 매개변수 표현을 정적인지 동적인지로 표시하여 구성 가능한 특성에 대한 포괄적인 개요를 제공합니다.\n\n기본적으로 이러한 서명들은 Composable 함수가 건너뛰기 가능한지 여부를 분석하거나 함수가 건너뛰기가 불가능하도록 제약하는 불안정한 매개변수를 식별하는 데 사용할 수 있습니다.\n\n다음은 Composable 함수에 대한 샘플 보고서입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nrestartable skippable scheme(\"[androidx.compose.ui.UiComposable]\") fun Avatar(\n  stable modifier: Modifier? = @static Companion\n  stable imageUrl: String? = @static null\n  stable initials: String? = @static null\n  stable shape: Shape? = @dynamic VideoTheme.\u003cget-shapes\u003e($composer, 0b0110).circle\n  stable textSize: StyleSize? = @static StyleSize.XL\n  stable textStyle: TextStyle? = @dynamic VideoTheme.\u003cget-typography\u003e($composer, 0b0110).titleM\n  stable contentScale: ContentScale? = @static Companion.Crop\n  stable contentDescription: String? = @static null\n)\n\n## Classes (classes.txt)\n\nThis report also utilizes pseudo-Kotlin style function signatures crafted for human readability. This file is designed to help you grasp how the stability inferencing algorithm has interpreted a specific class. At the top level, each class is categorized as stable, unstable, or runtime. “Runtime” indicates that the stability is contingent on other dependencies, which will be determined at runtime (such as a type parameter or a type in an external module).\n\nThe stability assessment is based on the class’s fields, with each field listed under the class and labeled as stable, unstable, or runtime stable. The bottom line reveals the “expression” employed to determine this stability at runtime, providing a comprehensive overview of how each class`s stability is evaluated.\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nstable class StreamShapes {\n  stable val circle: Shape\n  stable val square: Shape\n  stable val button: Shape\n  stable val input: Shape\n  stable val dialog: Shape\n  stable val sheet: Shape\n  stable val indicator: Shape\n  stable val container: Shape\n}\n```\n\n일련의 Compose 컴파일러 메트릭을 생성하는 프로세스를 탐험하고, 각 파일의 중요성을 이해하며, 이 정보를 사용하여 더 많이 건너뛸 수 있는 Composable 함수를 작성하려고 노력하는 방법을 배웠어요. 이 주제를 깊이 있게 탐구하고 싶다면 상세한 통찰을 얻기 위해 Interpreting Compose Compiler Metrics를 확인해보세요.\n\n# 안정성 주석\n\n이제 Compose 컴파일러가 안정성을 처리하는 방식과 이러한 안정성 결정이 다시 구성에 어떻게 영향을 미치는지, 그리고 당신의 애플리케이션 성능에 어떻게 영향을 미칠 수 있는지 통찰력을 얻었어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nComposed of immutability and stability annotations, let's take a journey into transforming changeable classes into reliable ones using annotations from the compose-runtime library. The main actors in this process are @Immutable and @Stable.\n\n# Immutability\n\nWhen you decorate your class with the @Immutable annotation, you reassure the Compose compiler that all public properties and fields within the class will remain unchanged (immutable) once they are created. This provides a more solid guarantee compared to the val keyword at the language level. While val prevents properties from being modified via a setter, it still allows creation through mutable data structures like Lists initialized with MutableList.\n\nTo make sure your classes are distinctly marked as stable with the @Immutable annotation, adhere to the guidelines below:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 모든 공용 속성에 val 키워드를 사용하여 불변성을 보장하세요.\n- 사용자 지정 setter를 피하고 공용 속성이 변경 가능성을 지원하지 않도록 합니다.\n- 모든 공용 속성의 유형이 본질적으로 불변 또는 안정적이거나 안정성 주석으로 명시적으로 표시되었는지 확인하세요. 예를 들어 인터페이스는 불안정하다고 간주되므로 속성으로 사용되는 모든 인터페이스 유형도 안정성을 위해 주석을 달아야 합니다.\n- 컬렉션인 속성들의 경우, 안정성을 유지하기 위해 kotlinx.collections.immutable에서 제공하는 불변 컬렉션을 선택하세요.\n\n@Immutable 주석은 위의 불변성 규칙을 준수하는 클래스에 효과적이며, 불필요한 recomposition을 건너뛰어 응용프로그램 성능을 향상시킬 때 중요한 역할을 합니다.\n\n그러나 @Immutable 주석을 분별하게 사용하는 것이 중요합니다. 적절하게 사용하지 않으면 의도하지 않은 recomposition 건너뛰기로 인해 Compose 레이아웃이 예상대로 업데이트되지 않을 수 있습니다.\n\n# 안정함\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`@Stable` 어노테이션은 `@Immutable` 어노테이션보다 Compose 컴파일러에 더 강력하지만 약간 덜 엄격한 커밋먼트를 나타냅니다. 함수나 프로퍼티에 적용되면, `@Stable` 어노테이션은 해당 유형이 가변할 수 있다는 것을 나타냅니다. 처음에는 약간 모순적으로 보일 수도 있습니다. 이 문맥에서 \"Stable\"이라는 용어는 함수가 동일한 입력에 대해 항상 동일한 결과를 반환할 것이라는 의미로, 잠재적인 가변성에도 불구하고 예측 가능한 동작을 보장합니다.\n\n따라서 `@Stable` 어노테이션은 주로 public 프로퍼티가 불변인 클래스에 적합하지만 클래스 자체가 안정적이지 않을 수 있는 경우에 사용됩니다. 예를 들어, Jetpack Compose의 State 인터페이스는 value라는 불변 프로퍼티만 노출합니다. 그러나 이 불변 프로퍼티의 내부 값은 여전히 setValue 함수를 통해 수정될 수 있으며, 일반적으로 MutableState를 생성하여 이를 수행합니다.\n\nState와 MutableState를 통한 데모로 보여 준 것처럼, MutableState에 의해 생성된 State 인스턴스는 getValue 함수(값 프로퍼티의 게터)로부터 일관되게 동일한 값을 얻을 것이며, setValue 함수에 대한 동일한 입력에 대해 동일한 결과를 반환합니다. 제공된 코드 스니펫에서는 `@Stable` 어노테이션이 지정된 State와 MutableState 인터페이스를 모두 보여줍니다.\n\n# Immutable vs Stable\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**@Immutable**과 **@Stable** 주석 사이의 구별과 어떤 것을 사용해야 하는지 결정하는 것은 처음에는 혼란스러울 수 있습니다. 하지만 실제로는 꽤 간단합니다. 이전에 언급했듯이, **@Immutable** 주석은 클래스의 모든 공용 속성이 불변이라는 의미로, 생성된 후에 상태가 변경될 수 없음을 나타냅니다. 반면에 **@Stable** 주석은 가변 객체에 적용될 수 있으며, 동일한 입력에 대해 일관된 결과를 생성해야 하는 것을 요구합니다.\n\n**@Immutable** 주석은 대부분 도메인 모델에 적용되는데, 특히 Kotlin 데이터 클래스를 사용할 때 다음 예시에서와 같이 나타납니다:\n\n반면에 **@Stable** 주석은 여러 구현 가능성을 제공하는 인터페이스에 대해 일반적으로 사용되며, 내부 가변 상태를 가질 수 있습니다. 아래 의미 있는 예시는 이 주석을 이해하는 데 도움이 됩니다:\n\n**@Stable** 주석을 적용하면 **UiState** 클래스를 안정적으로 지정할 수 있습니다. 이는 최적화된 건너뛰기와 지능적인 재구성을 가능하게 하여 업데이트의 효율성을 향상시킵니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# NonRestartableComposable\n\nJetpack Compose의 @NonRestartableComposable 주석은 특정 구성 가능한 함수의 recomposition 동작을 최적화하기 위해 고안된 비교적 고급 기능입니다. 이 주석은 구성 가능한 함수가 호출 매개변수의 변경으로 인해 recomposition 중 자동으로 다시 시작되지 않아야 함을 Compose 컴파일러에 알리는 역할을 합니다. 일반적으로 구성 가능한 함수의 입력 값이 변경되면 Compose 런타임은 함수를 다시 시작하여 새로운 입력 값을 소비하게 할 수 있습니다.\n\n그러나 이러한 다시 시작이 항상 필요하거나 원하는 것은 아닐 수 있습니다, 특히 함수의 내부 상태나 부작용을 다시 시작해야 할 때가 아닌 경우에 해당합니다. @NonRestartableComposable을 적용하면 런타임이 함수를 다시 시작하지 않고 매개변수를 업데이트하도록 지시하여 내부 상태와 진행 중인 부작용을 유지할 수 있습니다.\n\n@NonRestartableComposable의 일부로 동작하는 대표적인 예는 Compose 런타임 라이브러리의 Side-effect API 내에서 발견됩니다. 예를 들어 LaunchedEffect의 구현은 이 주석을 사용하여 효과가 불필요하게 다시 시작되지 않도록 보장합니다. 아래 코드에서 보여진 것처럼요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 @NonRestartableComposable 주석을 사용할 때 주의해야 하며 앱 성능을 향상시키기 위한 수단으로만 사용해서는 안 됩니다. 선별적으로 사용하지 않으면 원하지 않는 결과로 이어질 수 있습니다.\n\n# Composable 함수 안정화\n\n앱 성능을 최적화하는 목적으로 안정한 클래스를 작성하는 방법에 대해 알아보았습니다. 그러나 Composable 함수의 완전한 안정성 달성은 여기서 멈추지 않습니다. 왜냐하면 일부 클래스(예: Kotlin의 컬렉션 또는 제3자 라이브러리에서 제공하는 클래스)는 직접 제어할 수 없을 수 있기 때문입니다.\n\n이전에 언급했던 바와 같이 스마트 recomposition 중 Composable 함수를 건너뛸 수 있는 능력은 해당 함수의 각 매개변수의 안정성에 의해 결정됩니다. 스마트 recomposition을 위해 Composable 함수 내에서 사용되는 모든 매개변수가 안정적임을 보장하는 것이 중요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 섹션에서는 Composable 함수를 스킵할 수 있는 네 가지 다른 전략을 탐구하여 효율적인 recomposition으로 성능을 향상시킬 수 있습니다.\n\n# Immutable Collections\n\n처음에는 List가 요소를 수정하는 것을 허용하지 않더라도, 인터페이스인 특히 kotlin.collections이 Jetpack Compose에서 불안정하게 여겨지는 이유를 의심할 수 있습니다.\n\n아래의 좋은 예제를 살펴보면 그 이유를 이해할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nuserList 필드는 List로 선언되어 있습니다. List는 기본적으로 요소의 수정을 허용하지 않습니다. 그러나 첫 번째 줄에서 나와 있듯이, 이 List는 MutableList로부터 생성될 수 있습니다. 이는 List 인터페이스 자체가 수정을 제한하지만 해당 내부 구현이 변경 가능할 수 있다는 것을 의미합니다. Compose 컴파일러는 구현 유형을 추론할 수 없어, 이러한 인스턴스들을 안정적이지 않은 것으로 간주하여 정확한 동작을 보장합니다.\n\n그러므로 공식 Android 문서에서는 Composable 함수의 컬렉션 매개변수의 안정성을 보장하기 위해 kotlinx.collections.immutable 라이브러리나 Guava의 Immutable Collections를 활용할 것을 권장합니다.\n\nkotlinx.collections.immutable 라이브러리는 ImmutableList 및 ImmutableSet과 같은 여러 컬렉션을 제공하며, 이는 표준 kotlin.collections의 동작을 모방하지만 변경 불가능합니다. 이러한 컬렉션은 읽기 전용이며, 생성 후에는 수정이 불가능합니다.\n\n이제 Compose 컴파일러가 kotlinx.collections 대비 kotlinx.collections.immutable의 안정성을 결정할 때 고려하는 주요 요소에 대해 궁금해 할 수 있습니다. 구분은 Compose 컴파일러가 변경 불가능 컬렉션을 이해하는 데 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n더 자세한 통찰을 얻으려면 Compose 컴파일러 라이브러리의 일부인 KnownStableConstructs.kt 파일을 참고하십시오. 아래 코드를 보면, Compose 컴파일러가 안정적으로 간주해야 하는 클래스의 패키지 이름 목록을 수동으로 유지한다는 것을 확인할 수 있습니다:\n\n아래 코드 조각을 살펴보면, Composable 함수의 매개변수 안정성을 분석하는 Compose 컴파일러의 일부입니다. 알려진 안정 구조체 클래스에 나열된 매개변수 유형에 대한 안정성을 컴파일러가 유추하지 않는 것이 분명합니다:\n\n## Lambda\n\nCompose 컴파일러에서는 Kotlin 람다 표현식의 처리가 독특한 접근 방식을 취합니다. 이전에 설명한 바와 같이, Compose 컴파일러는 IR(Intermediate Representation) 변환을 통해 개발자가 작성한 소스 코드를 수정합니다. 따라서 컴파일러는 Composable 함수에 전달된 람다의 실행을 최적화하기 위해 Compose 런타임에 일부 규칙을 생성합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCompose 컴파일러는 람다 표현식을 처리할 때 람다가 값을 캡처하는지 여부에 따라 다른 방식으로 다룹니다. 클로저의 맥락에서 값들을 캡처하는 것은 람다 표현식이 직접적인 범위 외부에 있는 변수에 의존한다는 의미입니다. 외부 변수에 독립적인 람다라면 아래 예시처럼 값들을 캡처하지 않는다고 말할 수 있습니다:\n\n람다 매개변수가 어떤 값도 캡처하지 않는 경우, Kotlin은 이러한 람다를 싱글톤으로 처리하여 불필요한 할당을 최소화합니다. 반면, 람다가 클로저 밖의 변수에 의존하는 경우, 아래 예시에서 볼 수 있듯이 값들을 캡처한다고 간주됩니다:\n\n람다 매개변수가 외부 값들을 캡처하는 경우, 그 실행 결과는 캡처된 값들에 따라 달라질 수 있습니다. 이를 해결하기 위해, Compose 컴파일러는 메모리제이션 전략을 사용하여 람다를 remember 함수 호출 내에 캡슐화합니다. 캡처된 값은 remember에 대한 키 매개변수로 작용하여, 캡처된 값들의 변화에 적절히 반응하여 람다가 적절하게 재호출되도록 합니다.\n\n결과적으로, 람다가 값들을 캡처하는지 여부에 관계없이, 해당 람다는 Composable 함수 내에서 안정적으로 간주됩니다. Composable 함수가 Any 유형의 매개변수를 수용하는 시나리오를 고려해보면, Any가 변경 불가능한 값을 포함하는 등 다양한 값 범위를 포함할 수 있기 때문에, Compose 컴파일러에서는 불안정하게 취급됩니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 아래 예시와 같이 람다 표현식을 사용하여 값을 제공하는 경우, Compose 컴파일러는 람다 매개변수를 안정적으로 처리합니다:\n\n# Wrapper Class\n\nComposable 함수를 안정화하는 또 다른 효과적인 전략은 제어 범위를 벗어난 불안정한 클래스에 대한 래퍼 클래스를 만드는 것입니다. 이러한 경우에는 예시와 같이 안정성 주석을 직접 적용할 수 없는 클래스에 적용할 수 있습니다.\n\n그런 다음 Composable 함수의 매개변수 유형으로 이 래퍼 클래스를 활용할 수 있습니다. 아래 코드에서 보여지는 것처럼요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 파일 구성\n\nCompose 컴파일러 버전 1.5.5부터 구성 파일에서 클래스를 나열할 수 있는 옵션이 추가되었습니다. 이러한 지정된 클래스는 Compose 컴파일러에 의해 안정적으로 인식됩니다. 이 기능은 서드파티 라이브러리에서 가져온 클래스와 같이 제어할 수 없는 클래스들을 사용할 때 매우 유용합니다.\n\n이 기능을 활성화하려면 아래와 같이 앱 모듈의 build.gradle.kts 파일에 Compose 컴파일러 구성을 추가하십시오:\n\n다음으로, 앱 모듈의 루트 디렉토리에 compose_compiler_config.conf 파일을 아래와 같이 생성하십시오:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// LocalDateTime을 안정적으로 간주합니다.\njava.time.LocalDateTime\n// Kotlin 컬렉션을 안정적으로 간주합니다.\nkotlin.collections.*\n// 내 데이터 계층과 모든 하위 모듈을 안정적으로 간주합니다.\ncom.datalayer.**\n// 제네릭 타입을 첫 번째 타입 매개변수를 기반으로 안정적으로 간주합니다.\ncom.example.GenericClass\u003c*,_\u003e\n```\n\n프로젝트를 빌드하고 Compose 컴파일러 메트릭을 생성하면, 구성 파일에서 지정한 클래스들이 안정적으로 인식되어 스마트 재구성을 건너뛸 수 있습니다.\n\n공식 안드로이드 가이드에 따르면, Compose 컴파일러는 각 프로젝트 모듈 별로 독립적으로 작동하므로 필요에 따라 다른 모듈에 대해 각기 다른 구성을 제공할 수 있습니다. 또는 프로젝트 루트 수준에서 단일 구성을 선택하고 각 모듈에 대해 해당 경로를 지정할 수도 있습니다.\n\n기억해야 할 중요한 점은 구성 파일이 정의된 클래스들을 기본적으로 안정적으로 만들지 않습니다. 대신, 구성 파일을 활용하여 Compose 컴파일러와 계약을 맺는 것입니다. 따라서이 기능을 분별있게 사용하여 특정 시나리오에서 스마트 재구성 프로세스를 우연히 건너뛰는 일을 피해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 멀티 모듈 아키텍처의 안정성\n\n당신의 Gradle 모듈을 모듈화하는 것은 훌륭한 전략으로, 향상된 재사용성, 병렬 빌드, 탈중앙화된 팀 집중력 등의 혜택을 제공합니다. 안드로이드 공식 가이드도 모듈화를 권장하며, 프로젝트 규모에 맞게 코드의 확장성을 향상시키고 가독성을 개선하며 전반적인 코드 품질을 높이는 수단으로 모듈화를 소개합니다.\n\n모듈화는 Jetpack Compose에서 고유한 도전 과제를 소개합니다: 독립된 모듈로부터의 클래스는 그들의 퍼블릭 프로퍼티의 불변성 여부와 상관없이 불안정하다고 간주됩니다. 이를 극복하기 위해, 데이터 모듈에 compose-runtime 라이브러리를 가져오고 데이터 클래스에 안정성 주석을 달 것을 권장합니다.\n\n그러나, Jetpack Compose 런타임 라이브러리에 직접 의존하지 않고 순수한 Kotlin/JVM 라이브러리에 초점을 맞춘 경우에는 compose 런타임 라이브러리에 의존하는 것이 이상적이지 않은 경우가 있을 수 있습니다. 이러한 시나리오에서 두 가지 주요 솔루션이 제시됩니다: compose-stable 마커 라이브러리를 채택하거나 안정성을 보장하기 위해 파일 구성을 활용하는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 안정적인 마커 작성기\n\n\"안정적인 마커\" 라이브러리는 @Immutable 및 @Stable과 같은 안정성 주석을 제공하며, 이는 compose-runtime 라이브러리 내의 유사한 주석 기능을 반영합니다. compose-runtime 라이브러리를 직접 사용하는 것 대신 compose-stable 마커 라이브러리를 선택하면 아래에 설명된 두 가지 주요 이점이 제공됩니다:\n\n- 가벼움: 클래스, 함수 및 확장 기능이 풍부한 compose-runtime 라이브러리는 응용 프로그램의 크기를 늘릴 수 있는 가능성이 있습니다. 반면에 compose-stable 마커 라이브러리는 안정성 주석에만 초점을 맞춘 가벼운 대안을 제공합니다. 이를 통해 응용 프로그램의 크기를 줄이고 전체 compose-runtime 라이브러리를 사용하는 것보다 빌드 시간을 단축할 수 있습니다.\n- 의존성 없음: compose-runtime 라이브러리에는 SideEffect, LaunchedEffect, snapshotFlow 및 Compose 컴파일러와 관련된 기타 주석들과 같은 Compose 런타임 기능을 실행하는 데 필수적인 기능이 포함되어 있습니다. 이러한 설정은 데이터 모듈에 필요하지 않은 경우에도 모듈이 이러한 API에 액세스 할 수 있는 가능성을 발생시킬 수 있습니다. compose-stable 마커 라이브러리를 선택하면 이러한 특수화된 API에 실수로 액세스하는 위험을 제거하여 모듈이 집중되고 효율적으로 유지되도록 보장합니다.\n\n해당 라이브러리의 좋은 사용 사례는 Compose용 Stream의 적응 가능한 채팅 및 비디오 SDK의 코어 모듈에서 발견할 수 있습니다. 이러한 SDK의 코어 모듈은 compose-stable 마커를 활용하여 도메인 클래스를 안정적으로 지정합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ncompose-stable-marker 라이브러리에 대해 더 알아보려면 GitHub 저장소를 방문해 주세요.\n\n# 파일 구성\n\n이전 섹션에서 논의한 것처럼 파일 구성은 Compose 컴파일러와의 계약을 달성하여 원본이나 가변성과 무관하게 특정 클래스를 안정적으로 다루도록 합니다. 이는 다른 모듈에서 클래스를 나열하여 파일 구성에 포함시키면 컴파일러가 자동으로 이를 안정적인 것으로 인식한다는 것을 의미합니다.\n\n한 가지 강조해야 할 점은 이 기능을 분별하여 사용해야 합니다. Compose 컴파일러는 이러한 클래스들을 안정적으로 지속적으로 다룰 것이므로 스마트한 재구성 행동을 조정하여 의도하지 않은 동작을 유발할 수 있습니다. 또한, 이러한 강제적인 안정성으로 인한 디버깅 문제는 애플리케이션 내에서 해결하기 어려울 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 강한 스킵 모드\n\n컴포저블 함수를 제작할 때 건너뛸 수 있는 또 다른 전략은 강한 스킵 모드를 활성화하는 것입니다. Compose Compiler 버전 1.5.4에서 소개된 이 기능은 불안정한 매개변수를 포함한 경우에도 컴포저블 함수를 건너뛸 수 있게 해주며, 불안정한 캡처를 포함하는 람다를 최적화된 성능을 위해 메모이즈합니다.\n\n현재 실험 단계에 있으며 아직 제품용으로 준비되지 않았지만, 강한 스킵 모드는 Compose 1.7 알파에서 기본으로 활성화될 예정입니다. 효과와 안정성은 베타 단계로 진행되기 전에 철저히 평가될 것입니다. 일시적으로 이 실험적 기능을 활성화하려면 다음 Compose 컴파일러 옵션을 포함시키면 됩니다:\n\n강한 스킵 모드는 재구성 중에 컴포저블 함수를 건너뛸 때 Compose 컴파일러가 사용하는 전통적인 안정성 기준을 수정합니다. 일반적인 상황에서 컴포저블 함수는 오직 안정적인 매개변수만 포함하고 있는 경우에만 건너뛸 수 있는 것으로 간주됩니다. 그러나 강한 스킵 모드는 이 전통을 변경합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기능이 활성화되면 모든 다시 시작 가능한 Composable 함수가 건카볼입니다. 이전 값을 무시하고 불안정한 매개변수가 포함되었는지 여부에 관계없이. 그러나, 다시 시작할 수 없는 Composable 함수는 영향을 받지 않으며 건너뛸 수 없습니다.\n\n재조합 중 Composable 함수를 건너뛸지 여부를 평가할 때 이 모드는 불안정한 매개변수와 해당 이전 값과의 인스턴스 동등성을 비교하기 위해 사용됩니다. 반면에, 안정적 매개변수는 Object.equals()에 의해 정의된 객체 동등성을 사용하여 비교됩니다.\n\n재조합 중 이러한 기준에 모든 매개변수가 일치하는 경우 Composable 함수가 우회됩니다. 불필요한 업데이트를 줄여 성능을 최적화합니다.\n\nComposable 함수를 강력한 건카볼 모드에서 제외하고 다시 시작할 수 있지만 건너뛸 수 없도록 만들려면 @NonSkippableComposable 주석을 적용할 수 있습니다. 이는 매개변수 안정성과 관계없이 항상 재조합을 위해 해당 함수가 고려됨을 보장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한편, 객체 동등성(object equality)을 사용하여 객체를 비교하려면 여전히 도메인 모델 클래스에 @Stable 주석을 추가해야 합니다.\n이 기능과 람다 메모이제이션(Lambda Memoization)의 향상된 개념에 대한 더 깊은 이해를 위해 '강력한 스킵 모드(Strong Skipping Mode)'에 대한 상세 가이드를 참조해보세요.\n\n# 결론\n\n탐험이 마무리되었습니다! 안정성의 개념, 안정성 추론과 스마트 recomposition 뒤에 숨은 메커니즘, 클래스 및 Composable 함수를 안정화하는 효과적인 전략, 그리고 응용 프로그램 성능을 향상시키는 방법에 대해 다루었습니다.\n\n안정성의 중요성을 깨달으면 화면에 UI 노드를 렌더링하는 메커니즘에 영향을 줌으로써 최종적으로 응용 프로그램의 성능에 영향을 미치게 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 테이블 태그를 마크다운 형식으로 변경해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n원래 getstream.io에 게시되었습니다.\n","ogImage":{"url":"/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_0.png"},"coverImage":"/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_0.png","tag":["Tech"],"readingTime":30},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_0.png\" alt=\"Jetpack Compose\"\u003e\u003c/p\u003e\n\u003cp\u003e젯팩 컴포즈는 구글의 첨단 UI 툴킷으로서, 안정적인 1.0 버전 이후 뛰어난 가능성을 보여주었습니다. Google의 보고에 따르면, 제트팩 컴포즈를 사용하여 개발된 앱이 이미 12만 5천 개 이상이 Google Play Store에서 성공적으로 출시되면서 프로덕션 목적으로의 채택이 급증했습니다.\u003c/p\u003e\n\u003cp\u003e제트팩 컴포즈는 내장된 최적화 기능을 갖추고 있지만, 개발자들은 컴포즈가 UI 요소를 어떻게 렌더링하는지 이해하고, 다양한 시나리오에서 제트팩 컴포즈의 성능을 최적화하기 위한 전략을 파악해야 합니다. 이러한 지식은 애플리케이션의 성능에 잠재적인 영향을 최소화하고 더 나은 사용자 경험을 제공하기 위한 중요한 역할을 합니다.\u003c/p\u003e\n\u003cp\u003e이 기사에서는 제트팩 컴포즈의 내부 작업을 이해하고, 안정성을 관리하여 애플리케이션의 성능을 향상시키는 방법을 안내하겠습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eJetpack Compose 단계\u003c/h1\u003e\n\u003cp\u003e안정성에 대해 자세히 살펴보기 전에 Jetpack Compose의 단계를 이해하는 것이 중요합니다. 이 단계에서는 화면에 Compose UI 노드를 렌더링하는 과정이 여러 연속적인 단계를 통해 진행됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_1.png\" alt=\"Jetpack Compose Phases\"\u003e\u003c/p\u003e\n\u003cp\u003eJetpack Compose는 한 프레임의 렌더링을 세 가지 구분된 단계를 통해 실행합니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e구성: 이 단계에서는 Composable 함수에 대한 설명을 생성하고 여러 메모리 슬롯을 할당함으로써 프로세스가 시작됩니다. 이러한 슬롯은 각 Composable 함수를 메모이즈하여 런타임 중에 효율적인 호출 및 실행을 가능하게 합니다.\u003c/li\u003e\n\u003cli\u003e레이아웃: 이 단계에서는 Composable 트리 내 각 노드의 위치를 설정합니다. 레이아웃 단계는 주로 각 Composable 노드를 측정하고 적절히 배치하여 UI의 전체 구조 내에서 모든 요소가 정확히 배열되도록 보장합니다.\u003c/li\u003e\n\u003cli\u003e그리기: 이 마지막 단계에서는 Composable 노드가 일반적으로 장치의 화면인 캔버스에 렌더링됩니다. 이 중요한 단계는 UI를 시각적으로 구축하여 설계된 Composables을 사용자 상호 작용을 위해 사용할 수 있게 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e내부 메커니즘은 훨씬 더 복잡하지만, 기본적으로 Composable 함수를 작성할 때 화면에 표시되기 위해 이러한 단계를 거칩니다.\u003c/p\u003e\n\u003cp\u003e이제 레이아웃의 크기 및 색상과 같은 UI 요소를 수정하려고 한다고 가정해 봅시다. 그림 그리기 단계가 완료된 경우, Compose는 이러한 새 값들을 적용하기 위해 처음부터 다시 이러한 단계를 다시 방문해야 합니다. 이러한 업데이트 사이클을 재구성이라고 합니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e재구성은 입력 변경에 대한 응담으로 조합 가능한 함수가 새롭게 실행되어 Composition 단계에서 시작됩니다. 이 프로세스는 State에서 관찰하거나 내재적으로 Compose 런타임과 컴파일러 메커니즘들이 연관된 다양한 요소에 의해 트리거될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e전체 UI 트리와 요소를 재구성하는 것은 상당한 계산 리소스를 필요로 하며 앱의 성능에 직접적인 영향을 미칠 수 있습니다. 필요한 경우에만 재구성을 트리거함으로써(불필요할 때 재구성을 건너뛸 경우) 계산 리소스를 최소화하여 UI 성능을 향상시킬 수 있습니다.\u003c/p\u003e\n\u003cp\u003e따라서, Compose 런타임의 작동 방식을 포함한 재구성 프로세스에 대한 심층적인 이해, 재구성을 건너뛸 기회를 식별하고 재구성을 트리거하는 요소를 인식하는 것이 중요합니다.\u003c/p\u003e\n\u003cp\u003e이제 안정성 개념을 탐구하고 재구성 비용을 최적화하여 응용 프로그램 성능을 향상시킬 방법을 살펴보겠습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e안정성 이해\u003c/h1\u003e\n\u003cp\u003e이전 섹션에서 언급된 바와 같이, 이미 렌더링된 UI를 업데이트하기 위해 다양한 방법이 존재합니다. Composable 함수의 매개변수의 안정성은 Compose 런타임과 컴파일러의 작동과 깊이 얽혀 있어, 재구성을 시작하는 결정적인 요소로 부각됩니다.\u003c/p\u003e\n\u003cp\u003eCompose 컴파일러는 Composable 함수의 매개변수를 안정적인 것과 불안정한 것 두 가지로 분류합니다. 이러한 매개변수 안정성의 분류는 Compose 런타임에 의해 Composable 함수가 재구성되어야 하는지 여부를 결정하는 데 사용됩니다.\u003c/p\u003e\n\u003ch1\u003e안정함 vs. 불안정함\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제, 어떻게 매개변수가 안정적인지 불안정한지로 분류되는지 궁금할 수 있습니다. 이 결정은 Compose 컴파일러에 의해 이루어집니다. 컴파일러는 Composable 함수에서 사용된 매개변수의 유형을 검토하고 다음 기준에 따라 안정적인지를 분류합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eString을 포함한 기본 유형은 본질적으로 안정적입니다.\u003c/li\u003e\n\u003cli\u003e(Int) -` String과 같은 람다 표현식으로 나타낸 함수 유형은 안정적으로 간주됩니다.\u003c/li\u003e\n\u003cli\u003e불변하고 안정적인 공개 속성으로 특징지어진 데이터 클래스 또는 안정성 주석인 @Stable이나 @Immutable과 같이 명시적으로 표시된 클래스는 안정적으로 간주됩니다. 이러한 주석의 구체적인 내용에 대해 다음 섹션에서 자세히 살펴볼 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예를 들어, 아래와 같이 데이터 클래스를 상상해 볼 수 있습니다:\u003c/p\u003e\n\u003cp\u003eComposable 컴파일러에 의해 안정적으로 간주되는 불변 기본 속성으로 구성된 User 데이터 클래스입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그러나, Composable 함수 내에서 매개변수 유형을 평가하는 컴파일러는 아래 기준에 따라 해당 유형을 불안정하다고 식별합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eList, Map 등의 인터페이스와 Any와 같은 추상 클래스와 같이 컴파일 시간에 구현이 예측할 수 없는 유형은 불안정하다고 간주됩니다. 이 분류의 근거는 다음 섹션에서 더 자세히 논의될 예정입니다.\u003c/li\u003e\n\u003cli\u003e특히 적어도 하나의 가변 또는 본질적으로 불안정한 공용 속성을 포함하는 데이터 클래스와 같은 클래스는 불안정하다고 분류됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예를 들어, 다음과 같은 데이터 클래스를 상상해볼 수 있습니다:\u003c/p\u003e\n\u003cp\u003eUser 데이터 클래스는 기본 속성으로 구성되어 있지만, 가변 이름 속성의 존재로 인해 Compose 컴파일러가 이를 불안정하다고 분류합니다. 이 분류는 안정성이 모든 속성의 종합적인 안정성을 평가하여 단일 가변 속성이 전체 클래스를 불안정하게 만들 수 있기 때문에 발생합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e스마트 재구성\u003c/h1\u003e\n\u003cp\u003e안정성의 원칙을 탐색하고 Compose 컴파일러가 안정적인지 불안정한지를 구별하는 방법을 살펴봤다면, 이러한 차이점을 활용하여 재구성을 트리거하는 실용적인 사용법에 관심이 생길 수 있습니다. Compose 컴파일러는 변경 가능 함수의 각 매개변수의 안정성을 평가하여 Compose 런타임이 이 정보를 효율적으로 활용할 수 있도록 기초를 마련합니다.\u003c/p\u003e\n\u003cp\u003e클래스의 안정성이 결정되면, Compose 런타임은 이 통찰력을 활용하여 내부 메커니즘인 스마트 재구성을 통해 재구성을 시작합니다. 스마트 재구성은 제공된 안정성 정보를 활용하여 불필요한 재구성을 선택적으로 건너뛰어 Compose의 전체 성능을 향상시킵니다.\u003c/p\u003e\n\u003cp\u003e스마트 재구성이 작동하는 원칙 중 일부는 다음과 같습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e등가성 확인: Composable 함수에 새 입력이 전달될 때마다 해당 입력은 반드시 클래스의 equals() 메서드를 사용하여 이전 입력과 비교됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e안정성에 따른 결정:\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e매개변수가 안정적이고 값이 변경되지 않은 경우 (equals()가 true를 반환), Compose는 관련 UI 구성 요소를 다시 구성하지 않습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e매개변수가 불안정하거나 안정적이지만 값이 변경된 경우 (equals()가 false를 반환), 런타임은 다시 구성을 시작하여 UI 레이아웃을 무효화하고 다시 그립니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위 시나리오에서 불필요한 다시 구성을 피함으로써 UI 성능을 향상시킬 수 있습니다. 전체 UI 트리를 다시 구성하는 것은 상당한 계산 리소스를 필요로하며, 적절하게 처리되지 않으면 성능에 부정적인 영향을 줄 수 있습니다.\u003c/p\u003e\n\u003cp\u003eJetpack Compose는 스마트한 다시 구성을 기본적으로 제공하지만, Composable 함수에서 사용되는 클래스를 안정화하고 최대한 다시 구성을 줄이는 방법을 숙지하는 것이 중요합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e합성 가능한 함수 추론하기\u003c/h1\u003e\n\u003cp\u003e이제 컴포즈 컴파일러가 클래스 안정성을 결정하고 컴포즈 런타임이 이 정보를 내부 메커니즘인 스마트 재구성으로 활용하는 방법을 이해했습니다. 그렇지만 이해해야 할 또 다른 중요한 개념은 합성 가능한 함수의 유형 추론입니다.\u003c/p\u003e\n\u003cp\u003e컴포즈 컴파일러는 코틀린 컴파일러 플러그인을 사용하여 개발자가 작성한 소스 코드를 컴파일 시 분석할 수 있게 만들어졌습니다. 더불어, 컴포즈 함수의 고유한 특성과 더 잘 일치하도록 원본 소스 코드를 조정할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e컴파일러는 합성 가능한 함수를 시작 가능함, 이동 가능함, 대체 가능함 등으로 분류하여 실행을 최적화합니다. 이 게시물에서는 특히 재구성에 중요한 역할을 하는 시작 가능한 유형에 대해 자세히 살펴볼 것입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e다시 시작 가능한\u003c/h1\u003e\n\u003cp\u003e다시 시작 가능한은 Composable 함수의 일종으로, Compose 컴파일러에 의해 결정되며 recomposition 프로세스의 중추 역할을 합니다. 이전에 탐구한 대로, Compose 런타임은 입력 값의 변화를 감지하면 이러한 새 입력 값으로 함수를 다시 시작(또는 다시 호출)하여 데이터 변경을 정확하게 반영합니다.\u003c/p\u003e\n\u003cp\u003eCompose 런타임에서 제공하는 특정 주석으로 Composable 함수를 명시적으로 주석 처리하지 않으면 대부분의 함수는 기본적으로 다시 시작 가능하다고 간주됩니다. 이는 Compose 런타임이 언제든지 입력 또는 상태 변경이 발생할 때 해당 Composable 함수에 대해 recomposition을 트리거할 수 있다는 것을 의미합니다.\u003c/p\u003e\n\u003ch1\u003e건너뛰기 가능한\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eSkipable은 또 다른 Composable 함수의 특성을 나타내며, 이는 이전 섹션에서 논의된 스마트 recomposition에 의해 설정된 적절한 조건 하에서 전체 recomposition 프로세스를 완전히 우회할 수 있음을 의미합니다. 따라서, skipable 함수가 바로 recomposition을 건너뛰고 UI 성능을 향상시킬 수 있는 잠재력과 직접적으로 연결된다고 단언할 수 있습니다. 이는 특정 상황에 따라서 달려있는데요.\u003c/p\u003e\n\u003cp\u003e이 능력은 특히 규모가 큰 함수 호출 계층 구조의 정상 Composable 함수의 성능을 향상시키는 데 중요합니다. 이러한 루트 Composable의 recomposition을 건너뛰면, Compose는 이러한 루트 Composable의 recomposition을 건너뛰면, 해당 계층의 하위 함수들 중 어떤 것도 호출할 필요가 없어지며, 전체 recomposition 프로세스가 간소화됩니다.\u003c/p\u003e\n\u003cp\u003eComposable 함수가 재시작 가능(restartable)이면서 동시에 skippable로 분류되는 경우도 있음을 기억하는 것이 중요합니다. skippable로 분류되면 재시작 가능한 recomposition을 거칠 수 있다는 것을 함축하므로요. 이제 작성한 Composable 함수가 재시작 가능 또는 skippable로 분류되는지 알아보는 방법을 살펴보겠습니다.\u003c/p\u003e\n\u003ch1\u003eCompose Compiler Metrics\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eCompose 컴파일러 플러그인을 사용하면 Compose에 고유한 특정 개념에 중점을 둔 자세한 보고서와 메트릭을 생성할 수 있습니다. 이러한 통찰력은 Compose 코드의 복잡성을 파헤치는 데 유용하며, 마이크로 레벨에서 작동 방식을 정확하게 이해할 수 있도록 도와줍니다.\u003c/p\u003e\n\u003cp\u003eCompose 컴파일러 메트릭을 생성하려면, 아래 예제에 설명된 대로 루트 모듈의 build.gradle 파일에 컴파일러 옵션을 추가하면 됩니다:\u003c/p\u003e\n\u003cp\u003e프로젝트를 동기화하고 빌드한 후, /build/compose_metrics 디렉토리에 생성된 세 가지 다른 파일인 module.json, composablex.txt 및 classes.txt에 액세스할 수 있습니다. 이 파일들을 각각 자세히 살펴보겠습니다.\u003c/p\u003e\n\u003ch2\u003e최상위 메트릭 (modules.json)\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 보고서는 Compose에 특화된 고수준 메트릭을 제공하며, 주로 추적할 수 있는 숫자 데이터 지점을 생성하는 데 목적이 있습니다. 이러한 메트릭 간의 관계는 통찰력 있는 관찰을 제공할 수 있습니다. 예를 들어, \"skippableComposables\"의 수를 \"restartableComposables\"의 수와 비교하면, Composable 함수의 재구성이 건너뛰어질 비율을 나타내는 백분율이 도출됩니다.\u003c/p\u003e\n\u003cp\u003e아래는 foundation 모듈을 위한 샘플 보고서입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{\n \u003cspan class=\"hljs-string\"\u003e\"skippableComposables\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e36\u003c/span\u003e,\n \u003cspan class=\"hljs-string\"\u003e\"restartableComposables\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e41\u003c/span\u003e,\n \u003cspan class=\"hljs-string\"\u003e\"readonlyComposables\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e,\n \u003cspan class=\"hljs-string\"\u003e\"totalComposables\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e,\n \u003cspan class=\"hljs-string\"\u003e\"restartGroups\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e41\u003c/span\u003e,\n \u003cspan class=\"hljs-string\"\u003e\"totalGroups\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e82\u003c/span\u003e,\n \u003cspan class=\"hljs-string\"\u003e\"staticArguments\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"certainArguments\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e138\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"knownStableArguments\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e377\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"knownUnstableArguments\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"unknownStableArguments\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e24\u003c/span\u003e,\n  ..\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eComposable Signatures (composables.txt)\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 보고서는 사람이 이해하기 쉽도록 작성된 의사 Kotlin 스타일 함수 서명을 사용합니다. 이 모듈 내의 각 구성 가능한 함수를 자세히 살펴보며 각 매개변수를 분석하고 특정 통찰을 제공합니다.\u003c/p\u003e\n\u003cp\u003e이 보고서는 전체 구성 가능한 함수가 다시 시작 가능한지, 건너뛸 수 있는지 또는 읽기 전용인지를 식별합니다. 또한 각 매개변수를 안정적인지 불안정한지로 레이블링하고 각 기본 매개변수 표현을 정적인지 동적인지로 표시하여 구성 가능한 특성에 대한 포괄적인 개요를 제공합니다.\u003c/p\u003e\n\u003cp\u003e기본적으로 이러한 서명들은 Composable 함수가 건너뛰기 가능한지 여부를 분석하거나 함수가 건너뛰기가 불가능하도록 제약하는 불안정한 매개변수를 식별하는 데 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음은 Composable 함수에 대한 샘플 보고서입니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003erestartable skippable scheme(\u003cspan class=\"hljs-string\"\u003e\"[androidx.compose.ui.UiComposable]\"\u003c/span\u003e) \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eAvatar\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\n  stable modifier: \u003cspan class=\"hljs-type\"\u003eModifier\u003c/span\u003e? = \u003cspan class=\"hljs-meta\"\u003e@static\u003c/span\u003e Companion\n  stable imageUrl: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e? = \u003cspan class=\"hljs-meta\"\u003e@static\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n  stable initials: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e? = \u003cspan class=\"hljs-meta\"\u003e@static\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n  stable shape: \u003cspan class=\"hljs-type\"\u003eShape\u003c/span\u003e? = \u003cspan class=\"hljs-meta\"\u003e@dynamic\u003c/span\u003e VideoTheme.\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e-shapes\u003e($composer, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003eb0110)\u003c/span\u003e\u003c/span\u003e.circle\n  stable textSize: StyleSize? = \u003cspan class=\"hljs-meta\"\u003e@static\u003c/span\u003e StyleSize.XL\n  stable textStyle: TextStyle? = \u003cspan class=\"hljs-meta\"\u003e@dynamic\u003c/span\u003e VideoTheme.\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e-typography\u003e($composer, \u003cspan class=\"hljs-number\"\u003e0b0110\u003c/span\u003e).titleM\n  stable contentScale: ContentScale? = \u003cspan class=\"hljs-meta\"\u003e@static\u003c/span\u003e Companion.Crop\n  stable contentDescription: String? = \u003cspan class=\"hljs-meta\"\u003e@static\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n)\n\n## Classes (classes.txt)\n\nThis report also utilizes pseudo-Kotlin style function signatures crafted \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e human readability. This file \u003cspan class=\"hljs-keyword\"\u003eis\u003c/span\u003e designed to help you grasp how the stability inferencing algorithm has interpreted a specific \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e. At the top level, each \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eis\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecategorized\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003estable\u003c/span\u003e, \u003cspan class=\"hljs-type\"\u003eunstable\u003c/span\u003e, \u003cspan class=\"hljs-type\"\u003eor\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eruntime\u003c/span\u003e. “\u003cspan class=\"hljs-title\"\u003eRuntime\u003c/span\u003e” \u003cspan class=\"hljs-title\"\u003eindicates\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ethat\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ethe\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003estability\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eis\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003econtingent\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eon\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eother\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003edependencies\u003c/span\u003e, \u003cspan class=\"hljs-type\"\u003ewhich\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ewill\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ebe\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003edetermined\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eat\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eruntime\u003c/span\u003e (such \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e a type parameter or a type \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e an \u003cspan class=\"hljs-keyword\"\u003eexternal\u003c/span\u003e module).\n\nThe stability assessment \u003cspan class=\"hljs-keyword\"\u003eis\u003c/span\u003e based on the \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e’s fields, with each field listed under the \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eand\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003elabeled\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003estable\u003c/span\u003e, \u003cspan class=\"hljs-type\"\u003eunstable\u003c/span\u003e, \u003cspan class=\"hljs-type\"\u003eor\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eruntime\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003estable\u003c/span\u003e. \u003cspan class=\"hljs-title\"\u003eThe\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ebottom\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eline\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ereveals\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ethe\u003c/span\u003e “\u003cspan class=\"hljs-title\"\u003eexpression\u003c/span\u003e” \u003cspan class=\"hljs-title\"\u003eemployed\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eto\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003edetermine\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ethis\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003estability\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eat\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eruntime\u003c/span\u003e, \u003cspan class=\"hljs-type\"\u003eproviding\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecomprehensive\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eoverview\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eof\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ehow\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eeach\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eclass\u003c/span\u003e`\u003cspan class=\"hljs-title\"\u003es\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003estability\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eis\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eevaluated\u003c/span\u003e.\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003estable \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStreamShapes\u003c/span\u003e {\n  stable \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e circle: Shape\n  stable \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e square: Shape\n  stable \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e button: Shape\n  stable \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e input: Shape\n  stable \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e dialog: Shape\n  stable \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e sheet: Shape\n  stable \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e indicator: Shape\n  stable \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e container: Shape\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e일련의 Compose 컴파일러 메트릭을 생성하는 프로세스를 탐험하고, 각 파일의 중요성을 이해하며, 이 정보를 사용하여 더 많이 건너뛸 수 있는 Composable 함수를 작성하려고 노력하는 방법을 배웠어요. 이 주제를 깊이 있게 탐구하고 싶다면 상세한 통찰을 얻기 위해 Interpreting Compose Compiler Metrics를 확인해보세요.\u003c/p\u003e\n\u003ch1\u003e안정성 주석\u003c/h1\u003e\n\u003cp\u003e이제 Compose 컴파일러가 안정성을 처리하는 방식과 이러한 안정성 결정이 다시 구성에 어떻게 영향을 미치는지, 그리고 당신의 애플리케이션 성능에 어떻게 영향을 미칠 수 있는지 통찰력을 얻었어요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eComposed of immutability and stability annotations, let's take a journey into transforming changeable classes into reliable ones using annotations from the compose-runtime library. The main actors in this process are @Immutable and @Stable.\u003c/p\u003e\n\u003ch1\u003eImmutability\u003c/h1\u003e\n\u003cp\u003eWhen you decorate your class with the @Immutable annotation, you reassure the Compose compiler that all public properties and fields within the class will remain unchanged (immutable) once they are created. This provides a more solid guarantee compared to the val keyword at the language level. While val prevents properties from being modified via a setter, it still allows creation through mutable data structures like Lists initialized with MutableList.\u003c/p\u003e\n\u003cp\u003eTo make sure your classes are distinctly marked as stable with the @Immutable annotation, adhere to the guidelines below:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e모든 공용 속성에 val 키워드를 사용하여 불변성을 보장하세요.\u003c/li\u003e\n\u003cli\u003e사용자 지정 setter를 피하고 공용 속성이 변경 가능성을 지원하지 않도록 합니다.\u003c/li\u003e\n\u003cli\u003e모든 공용 속성의 유형이 본질적으로 불변 또는 안정적이거나 안정성 주석으로 명시적으로 표시되었는지 확인하세요. 예를 들어 인터페이스는 불안정하다고 간주되므로 속성으로 사용되는 모든 인터페이스 유형도 안정성을 위해 주석을 달아야 합니다.\u003c/li\u003e\n\u003cli\u003e컬렉션인 속성들의 경우, 안정성을 유지하기 위해 kotlinx.collections.immutable에서 제공하는 불변 컬렉션을 선택하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e@Immutable 주석은 위의 불변성 규칙을 준수하는 클래스에 효과적이며, 불필요한 recomposition을 건너뛰어 응용프로그램 성능을 향상시킬 때 중요한 역할을 합니다.\u003c/p\u003e\n\u003cp\u003e그러나 @Immutable 주석을 분별하게 사용하는 것이 중요합니다. 적절하게 사용하지 않으면 의도하지 않은 recomposition 건너뛰기로 인해 Compose 레이아웃이 예상대로 업데이트되지 않을 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e안정함\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003ccode\u003e@Stable\u003c/code\u003e 어노테이션은 \u003ccode\u003e@Immutable\u003c/code\u003e 어노테이션보다 Compose 컴파일러에 더 강력하지만 약간 덜 엄격한 커밋먼트를 나타냅니다. 함수나 프로퍼티에 적용되면, \u003ccode\u003e@Stable\u003c/code\u003e 어노테이션은 해당 유형이 가변할 수 있다는 것을 나타냅니다. 처음에는 약간 모순적으로 보일 수도 있습니다. 이 문맥에서 \"Stable\"이라는 용어는 함수가 동일한 입력에 대해 항상 동일한 결과를 반환할 것이라는 의미로, 잠재적인 가변성에도 불구하고 예측 가능한 동작을 보장합니다.\u003c/p\u003e\n\u003cp\u003e따라서 \u003ccode\u003e@Stable\u003c/code\u003e 어노테이션은 주로 public 프로퍼티가 불변인 클래스에 적합하지만 클래스 자체가 안정적이지 않을 수 있는 경우에 사용됩니다. 예를 들어, Jetpack Compose의 State 인터페이스는 value라는 불변 프로퍼티만 노출합니다. 그러나 이 불변 프로퍼티의 내부 값은 여전히 setValue 함수를 통해 수정될 수 있으며, 일반적으로 MutableState를 생성하여 이를 수행합니다.\u003c/p\u003e\n\u003cp\u003eState와 MutableState를 통한 데모로 보여 준 것처럼, MutableState에 의해 생성된 State 인스턴스는 getValue 함수(값 프로퍼티의 게터)로부터 일관되게 동일한 값을 얻을 것이며, setValue 함수에 대한 동일한 입력에 대해 동일한 결과를 반환합니다. 제공된 코드 스니펫에서는 \u003ccode\u003e@Stable\u003c/code\u003e 어노테이션이 지정된 State와 MutableState 인터페이스를 모두 보여줍니다.\u003c/p\u003e\n\u003ch1\u003eImmutable vs Stable\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cstrong\u003e@Immutable\u003c/strong\u003e과 \u003cstrong\u003e@Stable\u003c/strong\u003e 주석 사이의 구별과 어떤 것을 사용해야 하는지 결정하는 것은 처음에는 혼란스러울 수 있습니다. 하지만 실제로는 꽤 간단합니다. 이전에 언급했듯이, \u003cstrong\u003e@Immutable\u003c/strong\u003e 주석은 클래스의 모든 공용 속성이 불변이라는 의미로, 생성된 후에 상태가 변경될 수 없음을 나타냅니다. 반면에 \u003cstrong\u003e@Stable\u003c/strong\u003e 주석은 가변 객체에 적용될 수 있으며, 동일한 입력에 대해 일관된 결과를 생성해야 하는 것을 요구합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e@Immutable\u003c/strong\u003e 주석은 대부분 도메인 모델에 적용되는데, 특히 Kotlin 데이터 클래스를 사용할 때 다음 예시에서와 같이 나타납니다:\u003c/p\u003e\n\u003cp\u003e반면에 \u003cstrong\u003e@Stable\u003c/strong\u003e 주석은 여러 구현 가능성을 제공하는 인터페이스에 대해 일반적으로 사용되며, 내부 가변 상태를 가질 수 있습니다. 아래 의미 있는 예시는 이 주석을 이해하는 데 도움이 됩니다:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e@Stable\u003c/strong\u003e 주석을 적용하면 \u003cstrong\u003eUiState\u003c/strong\u003e 클래스를 안정적으로 지정할 수 있습니다. 이는 최적화된 건너뛰기와 지능적인 재구성을 가능하게 하여 업데이트의 효율성을 향상시킵니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eNonRestartableComposable\u003c/h1\u003e\n\u003cp\u003eJetpack Compose의 @NonRestartableComposable 주석은 특정 구성 가능한 함수의 recomposition 동작을 최적화하기 위해 고안된 비교적 고급 기능입니다. 이 주석은 구성 가능한 함수가 호출 매개변수의 변경으로 인해 recomposition 중 자동으로 다시 시작되지 않아야 함을 Compose 컴파일러에 알리는 역할을 합니다. 일반적으로 구성 가능한 함수의 입력 값이 변경되면 Compose 런타임은 함수를 다시 시작하여 새로운 입력 값을 소비하게 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그러나 이러한 다시 시작이 항상 필요하거나 원하는 것은 아닐 수 있습니다, 특히 함수의 내부 상태나 부작용을 다시 시작해야 할 때가 아닌 경우에 해당합니다. @NonRestartableComposable을 적용하면 런타임이 함수를 다시 시작하지 않고 매개변수를 업데이트하도록 지시하여 내부 상태와 진행 중인 부작용을 유지할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e@NonRestartableComposable의 일부로 동작하는 대표적인 예는 Compose 런타임 라이브러리의 Side-effect API 내에서 발견됩니다. 예를 들어 LaunchedEffect의 구현은 이 주석을 사용하여 효과가 불필요하게 다시 시작되지 않도록 보장합니다. 아래 코드에서 보여진 것처럼요:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그러나 @NonRestartableComposable 주석을 사용할 때 주의해야 하며 앱 성능을 향상시키기 위한 수단으로만 사용해서는 안 됩니다. 선별적으로 사용하지 않으면 원하지 않는 결과로 이어질 수 있습니다.\u003c/p\u003e\n\u003ch1\u003eComposable 함수 안정화\u003c/h1\u003e\n\u003cp\u003e앱 성능을 최적화하는 목적으로 안정한 클래스를 작성하는 방법에 대해 알아보았습니다. 그러나 Composable 함수의 완전한 안정성 달성은 여기서 멈추지 않습니다. 왜냐하면 일부 클래스(예: Kotlin의 컬렉션 또는 제3자 라이브러리에서 제공하는 클래스)는 직접 제어할 수 없을 수 있기 때문입니다.\u003c/p\u003e\n\u003cp\u003e이전에 언급했던 바와 같이 스마트 recomposition 중 Composable 함수를 건너뛸 수 있는 능력은 해당 함수의 각 매개변수의 안정성에 의해 결정됩니다. 스마트 recomposition을 위해 Composable 함수 내에서 사용되는 모든 매개변수가 안정적임을 보장하는 것이 중요합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 섹션에서는 Composable 함수를 스킵할 수 있는 네 가지 다른 전략을 탐구하여 효율적인 recomposition으로 성능을 향상시킬 수 있습니다.\u003c/p\u003e\n\u003ch1\u003eImmutable Collections\u003c/h1\u003e\n\u003cp\u003e처음에는 List가 요소를 수정하는 것을 허용하지 않더라도, 인터페이스인 특히 kotlin.collections이 Jetpack Compose에서 불안정하게 여겨지는 이유를 의심할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e아래의 좋은 예제를 살펴보면 그 이유를 이해할 수 있습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003euserList 필드는 List로 선언되어 있습니다. List는 기본적으로 요소의 수정을 허용하지 않습니다. 그러나 첫 번째 줄에서 나와 있듯이, 이 List는 MutableList로부터 생성될 수 있습니다. 이는 List 인터페이스 자체가 수정을 제한하지만 해당 내부 구현이 변경 가능할 수 있다는 것을 의미합니다. Compose 컴파일러는 구현 유형을 추론할 수 없어, 이러한 인스턴스들을 안정적이지 않은 것으로 간주하여 정확한 동작을 보장합니다.\u003c/p\u003e\n\u003cp\u003e그러므로 공식 Android 문서에서는 Composable 함수의 컬렉션 매개변수의 안정성을 보장하기 위해 kotlinx.collections.immutable 라이브러리나 Guava의 Immutable Collections를 활용할 것을 권장합니다.\u003c/p\u003e\n\u003cp\u003ekotlinx.collections.immutable 라이브러리는 ImmutableList 및 ImmutableSet과 같은 여러 컬렉션을 제공하며, 이는 표준 kotlin.collections의 동작을 모방하지만 변경 불가능합니다. 이러한 컬렉션은 읽기 전용이며, 생성 후에는 수정이 불가능합니다.\u003c/p\u003e\n\u003cp\u003e이제 Compose 컴파일러가 kotlinx.collections 대비 kotlinx.collections.immutable의 안정성을 결정할 때 고려하는 주요 요소에 대해 궁금해 할 수 있습니다. 구분은 Compose 컴파일러가 변경 불가능 컬렉션을 이해하는 데 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e더 자세한 통찰을 얻으려면 Compose 컴파일러 라이브러리의 일부인 KnownStableConstructs.kt 파일을 참고하십시오. 아래 코드를 보면, Compose 컴파일러가 안정적으로 간주해야 하는 클래스의 패키지 이름 목록을 수동으로 유지한다는 것을 확인할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e아래 코드 조각을 살펴보면, Composable 함수의 매개변수 안정성을 분석하는 Compose 컴파일러의 일부입니다. 알려진 안정 구조체 클래스에 나열된 매개변수 유형에 대한 안정성을 컴파일러가 유추하지 않는 것이 분명합니다:\u003c/p\u003e\n\u003ch2\u003eLambda\u003c/h2\u003e\n\u003cp\u003eCompose 컴파일러에서는 Kotlin 람다 표현식의 처리가 독특한 접근 방식을 취합니다. 이전에 설명한 바와 같이, Compose 컴파일러는 IR(Intermediate Representation) 변환을 통해 개발자가 작성한 소스 코드를 수정합니다. 따라서 컴파일러는 Composable 함수에 전달된 람다의 실행을 최적화하기 위해 Compose 런타임에 일부 규칙을 생성합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eCompose 컴파일러는 람다 표현식을 처리할 때 람다가 값을 캡처하는지 여부에 따라 다른 방식으로 다룹니다. 클로저의 맥락에서 값들을 캡처하는 것은 람다 표현식이 직접적인 범위 외부에 있는 변수에 의존한다는 의미입니다. 외부 변수에 독립적인 람다라면 아래 예시처럼 값들을 캡처하지 않는다고 말할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e람다 매개변수가 어떤 값도 캡처하지 않는 경우, Kotlin은 이러한 람다를 싱글톤으로 처리하여 불필요한 할당을 최소화합니다. 반면, 람다가 클로저 밖의 변수에 의존하는 경우, 아래 예시에서 볼 수 있듯이 값들을 캡처한다고 간주됩니다:\u003c/p\u003e\n\u003cp\u003e람다 매개변수가 외부 값들을 캡처하는 경우, 그 실행 결과는 캡처된 값들에 따라 달라질 수 있습니다. 이를 해결하기 위해, Compose 컴파일러는 메모리제이션 전략을 사용하여 람다를 remember 함수 호출 내에 캡슐화합니다. 캡처된 값은 remember에 대한 키 매개변수로 작용하여, 캡처된 값들의 변화에 적절히 반응하여 람다가 적절하게 재호출되도록 합니다.\u003c/p\u003e\n\u003cp\u003e결과적으로, 람다가 값들을 캡처하는지 여부에 관계없이, 해당 람다는 Composable 함수 내에서 안정적으로 간주됩니다. Composable 함수가 Any 유형의 매개변수를 수용하는 시나리오를 고려해보면, Any가 변경 불가능한 값을 포함하는 등 다양한 값 범위를 포함할 수 있기 때문에, Compose 컴파일러에서는 불안정하게 취급됩니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그러나 아래 예시와 같이 람다 표현식을 사용하여 값을 제공하는 경우, Compose 컴파일러는 람다 매개변수를 안정적으로 처리합니다:\u003c/p\u003e\n\u003ch1\u003eWrapper Class\u003c/h1\u003e\n\u003cp\u003eComposable 함수를 안정화하는 또 다른 효과적인 전략은 제어 범위를 벗어난 불안정한 클래스에 대한 래퍼 클래스를 만드는 것입니다. 이러한 경우에는 예시와 같이 안정성 주석을 직접 적용할 수 없는 클래스에 적용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그런 다음 Composable 함수의 매개변수 유형으로 이 래퍼 클래스를 활용할 수 있습니다. 아래 코드에서 보여지는 것처럼요:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e파일 구성\u003c/h1\u003e\n\u003cp\u003eCompose 컴파일러 버전 1.5.5부터 구성 파일에서 클래스를 나열할 수 있는 옵션이 추가되었습니다. 이러한 지정된 클래스는 Compose 컴파일러에 의해 안정적으로 인식됩니다. 이 기능은 서드파티 라이브러리에서 가져온 클래스와 같이 제어할 수 없는 클래스들을 사용할 때 매우 유용합니다.\u003c/p\u003e\n\u003cp\u003e이 기능을 활성화하려면 아래와 같이 앱 모듈의 build.gradle.kts 파일에 Compose 컴파일러 구성을 추가하십시오:\u003c/p\u003e\n\u003cp\u003e다음으로, 앱 모듈의 루트 디렉토리에 compose_compiler_config.conf 파일을 아래와 같이 생성하십시오:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// LocalDateTime을 안정적으로 간주합니다.\u003c/span\u003e\njava.\u003cspan class=\"hljs-property\"\u003etime\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eLocalDateTime\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// Kotlin 컬렉션을 안정적으로 간주합니다.\u003c/span\u003e\nkotlin.\u003cspan class=\"hljs-property\"\u003ecollections\u003c/span\u003e.*\n\u003cspan class=\"hljs-comment\"\u003e// 내 데이터 계층과 모든 하위 모듈을 안정적으로 간주합니다.\u003c/span\u003e\ncom.\u003cspan class=\"hljs-property\"\u003edatalayer\u003c/span\u003e.**\n\u003cspan class=\"hljs-comment\"\u003e// 제네릭 타입을 첫 번째 타입 매개변수를 기반으로 안정적으로 간주합니다.\u003c/span\u003e\ncom.\u003cspan class=\"hljs-property\"\u003eexample\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eGenericClass\u003c/span\u003e\u0026#x3C;*,_\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e프로젝트를 빌드하고 Compose 컴파일러 메트릭을 생성하면, 구성 파일에서 지정한 클래스들이 안정적으로 인식되어 스마트 재구성을 건너뛸 수 있습니다.\u003c/p\u003e\n\u003cp\u003e공식 안드로이드 가이드에 따르면, Compose 컴파일러는 각 프로젝트 모듈 별로 독립적으로 작동하므로 필요에 따라 다른 모듈에 대해 각기 다른 구성을 제공할 수 있습니다. 또는 프로젝트 루트 수준에서 단일 구성을 선택하고 각 모듈에 대해 해당 경로를 지정할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e기억해야 할 중요한 점은 구성 파일이 정의된 클래스들을 기본적으로 안정적으로 만들지 않습니다. 대신, 구성 파일을 활용하여 Compose 컴파일러와 계약을 맺는 것입니다. 따라서이 기능을 분별있게 사용하여 특정 시나리오에서 스마트 재구성 프로세스를 우연히 건너뛰는 일을 피해야 합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e멀티 모듈 아키텍처의 안정성\u003c/h1\u003e\n\u003cp\u003e당신의 Gradle 모듈을 모듈화하는 것은 훌륭한 전략으로, 향상된 재사용성, 병렬 빌드, 탈중앙화된 팀 집중력 등의 혜택을 제공합니다. 안드로이드 공식 가이드도 모듈화를 권장하며, 프로젝트 규모에 맞게 코드의 확장성을 향상시키고 가독성을 개선하며 전반적인 코드 품질을 높이는 수단으로 모듈화를 소개합니다.\u003c/p\u003e\n\u003cp\u003e모듈화는 Jetpack Compose에서 고유한 도전 과제를 소개합니다: 독립된 모듈로부터의 클래스는 그들의 퍼블릭 프로퍼티의 불변성 여부와 상관없이 불안정하다고 간주됩니다. 이를 극복하기 위해, 데이터 모듈에 compose-runtime 라이브러리를 가져오고 데이터 클래스에 안정성 주석을 달 것을 권장합니다.\u003c/p\u003e\n\u003cp\u003e그러나, Jetpack Compose 런타임 라이브러리에 직접 의존하지 않고 순수한 Kotlin/JVM 라이브러리에 초점을 맞춘 경우에는 compose 런타임 라이브러리에 의존하는 것이 이상적이지 않은 경우가 있을 수 있습니다. 이러한 시나리오에서 두 가지 주요 솔루션이 제시됩니다: compose-stable 마커 라이브러리를 채택하거나 안정성을 보장하기 위해 파일 구성을 활용하는 것입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e안정적인 마커 작성기\u003c/h1\u003e\n\u003cp\u003e\"안정적인 마커\" 라이브러리는 @Immutable 및 @Stable과 같은 안정성 주석을 제공하며, 이는 compose-runtime 라이브러리 내의 유사한 주석 기능을 반영합니다. compose-runtime 라이브러리를 직접 사용하는 것 대신 compose-stable 마커 라이브러리를 선택하면 아래에 설명된 두 가지 주요 이점이 제공됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e가벼움: 클래스, 함수 및 확장 기능이 풍부한 compose-runtime 라이브러리는 응용 프로그램의 크기를 늘릴 수 있는 가능성이 있습니다. 반면에 compose-stable 마커 라이브러리는 안정성 주석에만 초점을 맞춘 가벼운 대안을 제공합니다. 이를 통해 응용 프로그램의 크기를 줄이고 전체 compose-runtime 라이브러리를 사용하는 것보다 빌드 시간을 단축할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e의존성 없음: compose-runtime 라이브러리에는 SideEffect, LaunchedEffect, snapshotFlow 및 Compose 컴파일러와 관련된 기타 주석들과 같은 Compose 런타임 기능을 실행하는 데 필수적인 기능이 포함되어 있습니다. 이러한 설정은 데이터 모듈에 필요하지 않은 경우에도 모듈이 이러한 API에 액세스 할 수 있는 가능성을 발생시킬 수 있습니다. compose-stable 마커 라이브러리를 선택하면 이러한 특수화된 API에 실수로 액세스하는 위험을 제거하여 모듈이 집중되고 효율적으로 유지되도록 보장합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e해당 라이브러리의 좋은 사용 사례는 Compose용 Stream의 적응 가능한 채팅 및 비디오 SDK의 코어 모듈에서 발견할 수 있습니다. 이러한 SDK의 코어 모듈은 compose-stable 마커를 활용하여 도메인 클래스를 안정적으로 지정합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003ecompose-stable-marker 라이브러리에 대해 더 알아보려면 GitHub 저장소를 방문해 주세요.\u003c/p\u003e\n\u003ch1\u003e파일 구성\u003c/h1\u003e\n\u003cp\u003e이전 섹션에서 논의한 것처럼 파일 구성은 Compose 컴파일러와의 계약을 달성하여 원본이나 가변성과 무관하게 특정 클래스를 안정적으로 다루도록 합니다. 이는 다른 모듈에서 클래스를 나열하여 파일 구성에 포함시키면 컴파일러가 자동으로 이를 안정적인 것으로 인식한다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e한 가지 강조해야 할 점은 이 기능을 분별하여 사용해야 합니다. Compose 컴파일러는 이러한 클래스들을 안정적으로 지속적으로 다룰 것이므로 스마트한 재구성 행동을 조정하여 의도하지 않은 동작을 유발할 수 있습니다. 또한, 이러한 강제적인 안정성으로 인한 디버깅 문제는 애플리케이션 내에서 해결하기 어려울 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e강한 스킵 모드\u003c/h1\u003e\n\u003cp\u003e컴포저블 함수를 제작할 때 건너뛸 수 있는 또 다른 전략은 강한 스킵 모드를 활성화하는 것입니다. Compose Compiler 버전 1.5.4에서 소개된 이 기능은 불안정한 매개변수를 포함한 경우에도 컴포저블 함수를 건너뛸 수 있게 해주며, 불안정한 캡처를 포함하는 람다를 최적화된 성능을 위해 메모이즈합니다.\u003c/p\u003e\n\u003cp\u003e현재 실험 단계에 있으며 아직 제품용으로 준비되지 않았지만, 강한 스킵 모드는 Compose 1.7 알파에서 기본으로 활성화될 예정입니다. 효과와 안정성은 베타 단계로 진행되기 전에 철저히 평가될 것입니다. 일시적으로 이 실험적 기능을 활성화하려면 다음 Compose 컴파일러 옵션을 포함시키면 됩니다:\u003c/p\u003e\n\u003cp\u003e강한 스킵 모드는 재구성 중에 컴포저블 함수를 건너뛸 때 Compose 컴파일러가 사용하는 전통적인 안정성 기준을 수정합니다. 일반적인 상황에서 컴포저블 함수는 오직 안정적인 매개변수만 포함하고 있는 경우에만 건너뛸 수 있는 것으로 간주됩니다. 그러나 강한 스킵 모드는 이 전통을 변경합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 기능이 활성화되면 모든 다시 시작 가능한 Composable 함수가 건카볼입니다. 이전 값을 무시하고 불안정한 매개변수가 포함되었는지 여부에 관계없이. 그러나, 다시 시작할 수 없는 Composable 함수는 영향을 받지 않으며 건너뛸 수 없습니다.\u003c/p\u003e\n\u003cp\u003e재조합 중 Composable 함수를 건너뛸지 여부를 평가할 때 이 모드는 불안정한 매개변수와 해당 이전 값과의 인스턴스 동등성을 비교하기 위해 사용됩니다. 반면에, 안정적 매개변수는 Object.equals()에 의해 정의된 객체 동등성을 사용하여 비교됩니다.\u003c/p\u003e\n\u003cp\u003e재조합 중 이러한 기준에 모든 매개변수가 일치하는 경우 Composable 함수가 우회됩니다. 불필요한 업데이트를 줄여 성능을 최적화합니다.\u003c/p\u003e\n\u003cp\u003eComposable 함수를 강력한 건카볼 모드에서 제외하고 다시 시작할 수 있지만 건너뛸 수 없도록 만들려면 @NonSkippableComposable 주석을 적용할 수 있습니다. 이는 매개변수 안정성과 관계없이 항상 재조합을 위해 해당 함수가 고려됨을 보장합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e한편, 객체 동등성(object equality)을 사용하여 객체를 비교하려면 여전히 도메인 모델 클래스에 @Stable 주석을 추가해야 합니다.\n이 기능과 람다 메모이제이션(Lambda Memoization)의 향상된 개념에 대한 더 깊은 이해를 위해 '강력한 스킵 모드(Strong Skipping Mode)'에 대한 상세 가이드를 참조해보세요.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e탐험이 마무리되었습니다! 안정성의 개념, 안정성 추론과 스마트 recomposition 뒤에 숨은 메커니즘, 클래스 및 Composable 함수를 안정화하는 효과적인 전략, 그리고 응용 프로그램 성능을 향상시키는 방법에 대해 다루었습니다.\u003c/p\u003e\n\u003cp\u003e안정성의 중요성을 깨달으면 화면에 UI 노드를 렌더링하는 메커니즘에 영향을 줌으로써 최종적으로 응용 프로그램의 성능에 영향을 미치게 됩니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 테이블 태그를 마크다운 형식으로 변경해주세요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e원래 getstream.io에 게시되었습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose"},"buildId":"GsgRekSb--BvxYwv9FPn6","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>