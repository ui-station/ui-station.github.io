<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>SwfitUI 네비게이션 - 코디네이터 패턴 2부 -  경고  | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="SwfitUI 네비게이션 - 코디네이터 패턴 2부 -  경고  | ui-station" data-gatsby-head="true"/><meta property="og:title" content="SwfitUI 네비게이션 - 코디네이터 패턴 2부 -  경고  | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert" data-gatsby-head="true"/><meta name="twitter:title" content="SwfitUI 네비게이션 - 코디네이터 패턴 2부 -  경고  | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-20 16:08" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_buildManifest.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">SwfitUI 네비게이션 - 코디네이터 패턴 2부 -  경고 </h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="SwfitUI 네비게이션 - 코디네이터 패턴 2부 -  경고 " loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 20, 2024</span><span class="posts_reading_time__f7YPP">10<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_0.png">
<p>만약 Part 1을 아직 읽지 않았다면 여기에서 찾아볼 수 있어요. 이 글은 이전 글의 연장선입니다.</p>
<p>Part 1에서는 네비게이션 라우팅 로직을 coordinators로 격리시켰습니다. 이를 통해 앱을 위한 확장 가능하고 모듈식 네비게이션 설정을 만들었습니다. 하지만 이것은 기본에 불과해요. SwiftUI에서는 navigationPath로 push하는 것 이외에도 더 많은 종류의 네비게이션이 있어요. 이 중 하나는 "네비게이션"으로 팝업 알람을 표시하는 것이죠.</p>
<p>오늘은 이 주제에 대해 이야기할 거에요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>SwiftUI에서는 다양한 수정자(modifier)를 제공하여 Alert를 표시할 수 있습니다. 일반적으로 이러한 Alert 수정자는 뷰(View)에 설정되며, ViewModel/View에는 Alert를 표시할지 여부를 결정하는 데 사용되는 Binding<code>Bool</code>이 있습니다. 이 논리는 저에게는 좀 더 화면에 적합하게 표현되도록 조정되어야 한다고 생각합니다. 그렇다면 그에 대비할 방법을 찾아봅시다.</p>
<p>Alert에는 다양한 기능이 있을 수 있습니다. 타이틀, 메시지, 한 개 또는 두 개 이상의 버튼(primaryAction, cancelAction)이 포함될 수 있으며, 이러한 버튼은 .destructive 역할을 갖는 등 다양한 역할을 할 수 있습니다. 이는 시스템이 설계된 방식의 일부이며 그것이 예상대로 작동할 것으로 예상됩니다. 그래서 모든 이러한 경우의 Alert를 표시하는 데 필요한 정보를 제공하기 위한 프로토콜을 생성해 봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">SwiftUI</span>

protocol <span class="hljs-title class_">AlertDisplayable</span> {
    <span class="hljs-keyword">var</span> <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span> { get }
    <span class="hljs-keyword">var</span> <span class="hljs-attr">message</span>: <span class="hljs-title class_">String</span>? { get }
    <span class="hljs-keyword">var</span> <span class="hljs-attr">buttons</span>: [<span class="hljs-title class_">AlertButton</span>] { get }
}

struct <span class="hljs-title class_">AlertButton</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>
    <span class="hljs-keyword">let</span> <span class="hljs-attr">role</span>: <span class="hljs-title class_">ButtonRole</span>?
    <span class="hljs-keyword">let</span> <span class="hljs-attr">action</span>: () -> <span class="hljs-title class_">Void</span>

    private <span class="hljs-title function_">init</span>(<span class="hljs-params">title: <span class="hljs-built_in">String</span>, role: ButtonRole?, action: @escaping () -> Void</span>) {
        self.<span class="hljs-property">title</span> = title
        self.<span class="hljs-property">role</span> = role
        self.<span class="hljs-property">action</span> = action
    }

    <span class="hljs-keyword">static</span> func <span class="hljs-title function_">actionButton</span>(<span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">action</span>: @escaping () -> <span class="hljs-title class_">Void</span>) -> <span class="hljs-title class_">Self</span> {
        <span class="hljs-title class_">AlertButton</span>(<span class="hljs-attr">title</span>: title, <span class="hljs-attr">role</span>: nil, <span class="hljs-attr">action</span>: action)
    }

    <span class="hljs-keyword">static</span> func <span class="hljs-title function_">cancelButton</span>(<span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">action</span>: @escaping () -> <span class="hljs-title class_">Void</span>) -> <span class="hljs-title class_">Self</span> {
        <span class="hljs-title class_">AlertButton</span>(<span class="hljs-attr">title</span>: title, <span class="hljs-attr">role</span>: .<span class="hljs-property">cancel</span>, <span class="hljs-attr">action</span>: action)
    }

    <span class="hljs-keyword">static</span> func <span class="hljs-title function_">destructiveButton</span>(<span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">action</span>: @escaping () -> <span class="hljs-title class_">Void</span>) -> <span class="hljs-title class_">Self</span> {
        <span class="hljs-title class_">AlertButton</span>(<span class="hljs-attr">title</span>: title, <span class="hljs-attr">role</span>: .<span class="hljs-property">destructive</span>, <span class="hljs-attr">action</span>: action)
    }
}
</code></pre>
<p>이제 part 1에서 생성한 NavigationController에 다음을 추가할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-swift"><span class="hljs-meta">@Observable</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NavigationController</span> {
    <span class="hljs-keyword">var</span> navigationPath <span class="hljs-operator">=</span> <span class="hljs-type">NavigationPath</span>()
    <span class="hljs-keyword">var</span> alertPath <span class="hljs-operator">=</span> <span class="hljs-type">AlertPath</span>()

    <span class="hljs-keyword">func</span> <span class="hljs-title function_">presentAlert</span>&#x3C;<span class="hljs-type">T</span>>(<span class="hljs-keyword">_</span> <span class="hljs-params">alert</span>: <span class="hljs-type">T</span>) <span class="hljs-keyword">where</span> <span class="hljs-type">T</span>: <span class="hljs-type">AlertDisplayable</span> {
        alertPath.setAlert(alert)
    }
}
</code></pre>
<p>일관성을 유지하기 위해 ****Path 규칙을 따르고 있지만 원하는 대로 이름을 지정할 수 있습니다.</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">import</span> SwiftUI

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">AlertPath</span> {

    <span class="hljs-keyword">var</span> alert: <span class="hljs-type">AlertDisplayable</span>?

    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">setAlert</span>&#x3C;<span class="hljs-type">T</span>>(<span class="hljs-keyword">_</span> <span class="hljs-params">alert</span>: <span class="hljs-type">T</span>) <span class="hljs-keyword">where</span> <span class="hljs-type">T</span>: <span class="hljs-type">AlertDisplayable</span> {
        <span class="hljs-keyword">self</span>.alert <span class="hljs-operator">=</span> alert
    }
}
</code></pre>
<p>또한 설정한 후 경고를 처리하는 CoordinatedView를 업데이트해야 합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CoordinatedView</span>&#x3C;<span class="hljs-title class_">C</span>: <span class="hljs-title class_">Coordinator</span>>: <span class="hljs-title class_">View</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> coordinator: <span class="hljs-type">C</span>

    <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">coordinator</span>: <span class="hljs-type">C</span>) {
        <span class="hljs-keyword">self</span>.coordinator <span class="hljs-operator">=</span> coordinator
    }

    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {
        <span class="hljs-meta">@Bindable</span> <span class="hljs-keyword">var</span> navigationController <span class="hljs-operator">=</span> coordinator.navigationController
        <span class="hljs-type">NavigationStack</span>(path: <span class="hljs-variable">$navigationController</span>.navigationPath) {
            coordinator.rootView
        }
        .alert(for: <span class="hljs-variable">$navigationController</span>.alertPath) <span class="hljs-comment">// &#x3C;-- Here we add a new viewModifier</span>
    }
}
</code></pre>
<p>이 alert modifier는 alertPath의 바인딩을 받아 설정된 알림이 있을 경우 알림을 표시하는 사용자 정의 ViewModifier입니다.</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">View</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">alert</span>(<span class="hljs-params">for</span> <span class="hljs-params">alertPath</span>: <span class="hljs-type">Binding</span>&#x3C;<span class="hljs-type">AlertPath</span>>) -> <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {
        <span class="hljs-keyword">self</span>.modifier(<span class="hljs-type">AlertModifier</span>(alertPath: alertPath))
    }
}

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">AlertModifier</span>: <span class="hljs-title class_">ViewModifier</span> {

    <span class="hljs-meta">@Binding</span> <span class="hljs-keyword">var</span> alertPath: <span class="hljs-type">AlertPath</span>

    <span class="hljs-keyword">init</span>(<span class="hljs-params">alertPath</span>: <span class="hljs-type">Binding</span>&#x3C;<span class="hljs-type">AlertPath</span>>) {
        <span class="hljs-keyword">self</span>._alertPath <span class="hljs-operator">=</span> alertPath
    }

    <span class="hljs-keyword">func</span> <span class="hljs-title function_">body</span>(<span class="hljs-params">content</span>: <span class="hljs-type">Content</span>) -> <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {
        content
            .alert(
                alertPath.alert<span class="hljs-operator">?</span>.title <span class="hljs-operator">??</span> <span class="hljs-string">""</span>,
                isPresented: <span class="hljs-type">Binding</span>(get: { alertPath.alert <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> }, set: { <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> alertPath.alert <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span> }),
                actions: {
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> buttons <span class="hljs-operator">=</span> alertPath.alert<span class="hljs-operator">?</span>.buttons {
                        <span class="hljs-type">ForEach</span>(buttons) { button <span class="hljs-keyword">in</span>
                            <span class="hljs-type">Button</span>(button.title, role: button.role, action: button.action)
                        }
                    }

                }, message: {
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> message <span class="hljs-operator">=</span> alertPath.alert<span class="hljs-operator">?</span>.message {
                        <span class="hljs-type">Text</span>(message)
                    }
                })
    }
}
</code></pre>
<ul>
<li>알림의 제목은 title 속성에서 가져옵니다.</li>
<li>alertPath의 존재 여부에 따라 수동으로 getter 및 setter를 설정한 Binding<code>Bool</code>를 전달합니다. 따라서 alert가 존재하는 경우 알림을 표시합니다. 그리고 알림이 닫힐 때 alert를 nil로 설정합니다.</li>
<li>사용 가능한 각 버튼에 대해 제공된 title, role 및 action으로 SwiftUI Button을 만듭니다. 버튼을 하나도 보내지 않으면 시스템이 단일 'OK' 버튼 알림으로 기본 설정됩니다.</li>
<li>필요에 따라 알림 아래에 제목 아래에 알림에 대한 일부 설명 정보가 포함될 수 있습니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>한 번 시도해 보고 실제로 잘 작동하는지 확인해 봅시다. 알림 유형을 생성해 보겠습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 비슷한 알림을 그룹화하거나 케이스별 알림을 만들고 싶다면 emum을 생성할 수 있습니다.</span>
enum <span class="hljs-title class_">SomeAlert</span>: <span class="hljs-title class_">AlertDisplayable</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-title function_">alert</span>(<span class="hljs-attr">buttons</span>: [<span class="hljs-title class_">AlertButton</span>]) <span class="hljs-comment">// &#x3C;-- 액션을 주입합니다</span>
    <span class="hljs-keyword">case</span> <span class="hljs-title function_">alertWithTitleAndMessage</span>(<span class="hljs-attr">buttons</span>: [<span class="hljs-title class_">AlertButton</span>])

    <span class="hljs-keyword">var</span> <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span> {
        <span class="hljs-keyword">switch</span> self {
        <span class="hljs-keyword">case</span> .<span class="hljs-property">alert</span>:                        <span class="hljs-keyword">return</span> <span class="hljs-string">"제목만 있는 알림"</span>
        <span class="hljs-keyword">case</span> .<span class="hljs-property">alertWithTitleAndMessage</span>:     <span class="hljs-keyword">return</span> <span class="hljs-string">"제목과 메시지가 있는 알림"</span>
        }
    }

    <span class="hljs-keyword">var</span> <span class="hljs-attr">message</span>: <span class="hljs-title class_">String</span>? {
        <span class="hljs-keyword">switch</span> self {
        <span class="hljs-keyword">case</span> .<span class="hljs-property">alert</span>:                    <span class="hljs-keyword">return</span> nil
        <span class="hljs-keyword">case</span> .<span class="hljs-property">alertWithTitleAndMessage</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"이것은 메시지입니다"</span>
        }
    }

    <span class="hljs-keyword">var</span> <span class="hljs-attr">buttons</span>: [<span class="hljs-title class_">AlertButton</span>] {
        <span class="hljs-keyword">switch</span> self {
        <span class="hljs-keyword">case</span> .<span class="hljs-title function_">alert</span>(<span class="hljs-keyword">let</span> buttons),
             .<span class="hljs-title function_">alertWithTitleAndMessage</span>(<span class="hljs-keyword">let</span> buttons):    <span class="hljs-keyword">return</span> buttons
        }
    }
}

<span class="hljs-comment">// 또는</span>
<span class="hljs-comment">// 알림을 따로 모델로 사용하고 싶다면 하드코딩된 값들을 가진 구조체를 만들 수 있습니다.</span>
struct <span class="hljs-title class_">SomeSpecificAlertType</span>: <span class="hljs-title class_">AlertDisplayable</span> {
    <span class="hljs-keyword">var</span> <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span> = <span class="hljs-string">"특정 알림 제목"</span>
    <span class="hljs-keyword">var</span> <span class="hljs-attr">message</span>: <span class="hljs-title class_">String</span>? = <span class="hljs-string">"특정 메시지"</span>
    <span class="hljs-keyword">var</span> <span class="hljs-attr">buttons</span>: [<span class="hljs-title class_">AlertButton</span>]

    <span class="hljs-title function_">init</span>(<span class="hljs-params">onAction: () -> Void, onCancel: () -> Void</span>) { <span class="hljs-comment">// &#x3C;- 액션을 주입하고 해당 액션을 처리합니다</span>
      self.<span class="hljs-property">buttons</span> = [
          .<span class="hljs-title function_">actionButton</span>(<span class="hljs-attr">title</span>: <span class="hljs-string">"두 번째 작업"</span>, <span class="hljs-attr">action</span>: onAction),
          .<span class="hljs-title function_">cancelButton</span>(<span class="hljs-attr">title</span>: <span class="hljs-string">"취소"</span>, <span class="hljs-attr">action</span>: onCancel)
      ]
    }
}
</code></pre>
<p>알 수 있듯이, enum 케이스별로 Alert 유형을 생성하고 비슷한 알림 유형을 하나의 개체로 그룹화할 수 있습니다. 예를 들어, 모든 권한 알림을 한 곳에 유지하고 싶다면, 개별 알림 구조체/객체로 만들거나 선택은 여러분의 몫입니다. 중요한 점은 처음에 생성한 AlertDisplayable 프로토콜을 준수하는지입니다. 이제 모바일 앱에서 구현이 어떻게 보일지 살펴보겠습니다.</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">FirstView</span>: <span class="hljs-title class_">View</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-attr">viewModel</span>: <span class="hljs-title class_">FirstViewModel</span>

    <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span> {
        <span class="hljs-title class_">VStack</span> {
            <span class="hljs-title class_">Text</span>(<span class="hljs-string">"첫 번째 화면"</span>)
            <span class="hljs-title class_">Button</span>(<span class="hljs-string">"알림 표시"</span>) {
                viewModel.<span class="hljs-title function_">didTapButton</span>()
            }
        }
    }
}

@<span class="hljs-title class_">Observable</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FirstViewModel</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-attr">coordinator</span>: <span class="hljs-title class_">FirstCoordinator</span>

    <span class="hljs-title function_">init</span>(<span class="hljs-params">coordinator: FirstCoordinator</span>) {
        self.<span class="hljs-property">coordinator</span> = coordinator
    }

    func <span class="hljs-title function_">didTapButton</span>(<span class="hljs-params"></span>) {
        coordinator.<span class="hljs-title function_">presentAlert</span>(
                <span class="hljs-title class_">SomeAlert</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-attr">buttons</span>: [
                    .<span class="hljs-title function_">actionButton</span>(<span class="hljs-params">title: <span class="hljs-string">"주요 작업"</span></span>) {
                        <span class="hljs-title function_">print</span>(<span class="hljs-string">"작업 버튼 누름"</span>) <span class="hljs-comment">// &#x3C;- 버튼 클릭 시 호출되는 클로저</span>
                    },
                    .<span class="hljs-title function_">cancelButton</span>(<span class="hljs-params">title: <span class="hljs-string">"취소"</span></span>) {
                        <span class="hljs-title function_">print</span>(<span class="hljs-string">"취소 버튼 누름"</span>) <span class="hljs-comment">// &#x3C;- 버튼 클릭 시 호출되는 클로저</span>
                    }
                ]))
    }
}

@<span class="hljs-title class_">Observable</span> final <span class="hljs-keyword">class</span> <span class="hljs-title class_">FirstCoordinator</span>: <span class="hljs-title class_">Coordinator</span> {
    typealias <span class="hljs-title class_">Route</span> = <span class="hljs-title class_">FirstCoordinatorRoute</span>

    <span class="hljs-keyword">let</span> <span class="hljs-attr">navigationController</span>: <span class="hljs-title class_">NavigationController</span>

    @<span class="hljs-title class_">MainActor</span> @<span class="hljs-title class_">ViewBuilder</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">rootView</span>: some <span class="hljs-title class_">View</span> {
        <span class="hljs-title class_">FirstView</span>(<span class="hljs-title class_">FirstViewModel</span>(self)).<span class="hljs-title function_">navigationDestination</span>(<span class="hljs-attr">for</span>: <span class="hljs-title class_">Route</span>.<span class="hljs-property">self</span>, <span class="hljs-attr">destination</span>: <span class="hljs-title function_">coordinate</span>(<span class="hljs-attr">_</span>:))
    }

    func presentAlert&#x3C;T>(_ <span class="hljs-attr">alert</span>: T) where <span class="hljs-attr">T</span>: <span class="hljs-title class_">AlertDisplayable</span> {
        navigationController.<span class="hljs-title function_">presentAlert</span>(alert)
    }
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이는 viewModel에서 프로그래밍 방식으로 알림을 표시할 수 있게 해주며, 사용자가 버튼을 클릭할 때 viewModel이 선택적으로 콜백을 처리할 수 있게 합니다. 이 경우 뷰 자체 "FirstView"는 무엇이 일어나는지 전혀 모릅니다. 알고 있는 것은 didTapButton뿐입니다.</p>
<p><img src="/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_1.png" alt="image"></p>
<p>부분 2에 대한 내용은 여기까지입니다.</p>
<p>이 내용이 유용하다고 생각되면 좋겠습니다. 피드백이나 개선 제안이 있으면 알려주세요. 이 글이 유익했다면 공유해 주세요!</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>좋은 하루 보내세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"SwfitUI 네비게이션 - 코디네이터 패턴 2부 -  경고 ","description":"","date":"2024-05-20 16:08","slug":"2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert","content":"\n\u003cimg src=\"/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_0.png\" /\u003e\n\n만약 Part 1을 아직 읽지 않았다면 여기에서 찾아볼 수 있어요. 이 글은 이전 글의 연장선입니다.\n\nPart 1에서는 네비게이션 라우팅 로직을 coordinators로 격리시켰습니다. 이를 통해 앱을 위한 확장 가능하고 모듈식 네비게이션 설정을 만들었습니다. 하지만 이것은 기본에 불과해요. SwiftUI에서는 navigationPath로 push하는 것 이외에도 더 많은 종류의 네비게이션이 있어요. 이 중 하나는 \"네비게이션\"으로 팝업 알람을 표시하는 것이죠.\n\n오늘은 이 주제에 대해 이야기할 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSwiftUI에서는 다양한 수정자(modifier)를 제공하여 Alert를 표시할 수 있습니다. 일반적으로 이러한 Alert 수정자는 뷰(View)에 설정되며, ViewModel/View에는 Alert를 표시할지 여부를 결정하는 데 사용되는 Binding`Bool`이 있습니다. 이 논리는 저에게는 좀 더 화면에 적합하게 표현되도록 조정되어야 한다고 생각합니다. 그렇다면 그에 대비할 방법을 찾아봅시다.\n\nAlert에는 다양한 기능이 있을 수 있습니다. 타이틀, 메시지, 한 개 또는 두 개 이상의 버튼(primaryAction, cancelAction)이 포함될 수 있으며, 이러한 버튼은 .destructive 역할을 갖는 등 다양한 역할을 할 수 있습니다. 이는 시스템이 설계된 방식의 일부이며 그것이 예상대로 작동할 것으로 예상됩니다. 그래서 모든 이러한 경우의 Alert를 표시하는 데 필요한 정보를 제공하기 위한 프로토콜을 생성해 봅시다.\n\n```js\nimport SwiftUI\n\nprotocol AlertDisplayable {\n    var title: String { get }\n    var message: String? { get }\n    var buttons: [AlertButton] { get }\n}\n\nstruct AlertButton {\n    let title: String\n    let role: ButtonRole?\n    let action: () -\u003e Void\n\n    private init(title: String, role: ButtonRole?, action: @escaping () -\u003e Void) {\n        self.title = title\n        self.role = role\n        self.action = action\n    }\n\n    static func actionButton(title: String, action: @escaping () -\u003e Void) -\u003e Self {\n        AlertButton(title: title, role: nil, action: action)\n    }\n\n    static func cancelButton(title: String, action: @escaping () -\u003e Void) -\u003e Self {\n        AlertButton(title: title, role: .cancel, action: action)\n    }\n\n    static func destructiveButton(title: String, action: @escaping () -\u003e Void) -\u003e Self {\n        AlertButton(title: title, role: .destructive, action: action)\n    }\n}\n```\n\n이제 part 1에서 생성한 NavigationController에 다음을 추가할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\n@Observable final class NavigationController {\n    var navigationPath = NavigationPath()\n    var alertPath = AlertPath()\n\n    func presentAlert\u003cT\u003e(_ alert: T) where T: AlertDisplayable {\n        alertPath.setAlert(alert)\n    }\n}\n```\n\n일관성을 유지하기 위해 \\*\\*\\*\\*Path 규칙을 따르고 있지만 원하는 대로 이름을 지정할 수 있습니다.\n\n```swift\nimport SwiftUI\n\nstruct AlertPath {\n\n    var alert: AlertDisplayable?\n\n    mutating func setAlert\u003cT\u003e(_ alert: T) where T: AlertDisplayable {\n        self.alert = alert\n    }\n}\n```\n\n또한 설정한 후 경고를 처리하는 CoordinatedView를 업데이트해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nstruct CoordinatedView\u003cC: Coordinator\u003e: View {\n    private let coordinator: C\n\n    init(_ coordinator: C) {\n        self.coordinator = coordinator\n    }\n\n    var body: some View {\n        @Bindable var navigationController = coordinator.navigationController\n        NavigationStack(path: $navigationController.navigationPath) {\n            coordinator.rootView\n        }\n        .alert(for: $navigationController.alertPath) // \u003c-- Here we add a new viewModifier\n    }\n}\n```\n\n이 alert modifier는 alertPath의 바인딩을 받아 설정된 알림이 있을 경우 알림을 표시하는 사용자 정의 ViewModifier입니다.\n\n```swift\nextension View {\n    func alert(for alertPath: Binding\u003cAlertPath\u003e) -\u003e some View {\n        self.modifier(AlertModifier(alertPath: alertPath))\n    }\n}\n\nstruct AlertModifier: ViewModifier {\n\n    @Binding var alertPath: AlertPath\n\n    init(alertPath: Binding\u003cAlertPath\u003e) {\n        self._alertPath = alertPath\n    }\n\n    func body(content: Content) -\u003e some View {\n        content\n            .alert(\n                alertPath.alert?.title ?? \"\",\n                isPresented: Binding(get: { alertPath.alert != nil }, set: { _ in alertPath.alert = nil }),\n                actions: {\n                    if let buttons = alertPath.alert?.buttons {\n                        ForEach(buttons) { button in\n                            Button(button.title, role: button.role, action: button.action)\n                        }\n                    }\n\n                }, message: {\n                    if let message = alertPath.alert?.message {\n                        Text(message)\n                    }\n                })\n    }\n}\n```\n\n- 알림의 제목은 title 속성에서 가져옵니다.\n- alertPath의 존재 여부에 따라 수동으로 getter 및 setter를 설정한 Binding`Bool`를 전달합니다. 따라서 alert가 존재하는 경우 알림을 표시합니다. 그리고 알림이 닫힐 때 alert를 nil로 설정합니다.\n- 사용 가능한 각 버튼에 대해 제공된 title, role 및 action으로 SwiftUI Button을 만듭니다. 버튼을 하나도 보내지 않으면 시스템이 단일 'OK' 버튼 알림으로 기본 설정됩니다.\n- 필요에 따라 알림 아래에 제목 아래에 알림에 대한 일부 설명 정보가 포함될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 번 시도해 보고 실제로 잘 작동하는지 확인해 봅시다. 알림 유형을 생성해 보겠습니다.\n\n```js\n// 비슷한 알림을 그룹화하거나 케이스별 알림을 만들고 싶다면 emum을 생성할 수 있습니다.\nenum SomeAlert: AlertDisplayable {\n    case alert(buttons: [AlertButton]) // \u003c-- 액션을 주입합니다\n    case alertWithTitleAndMessage(buttons: [AlertButton])\n\n    var title: String {\n        switch self {\n        case .alert:                        return \"제목만 있는 알림\"\n        case .alertWithTitleAndMessage:     return \"제목과 메시지가 있는 알림\"\n        }\n    }\n\n    var message: String? {\n        switch self {\n        case .alert:                    return nil\n        case .alertWithTitleAndMessage: return \"이것은 메시지입니다\"\n        }\n    }\n\n    var buttons: [AlertButton] {\n        switch self {\n        case .alert(let buttons),\n             .alertWithTitleAndMessage(let buttons):    return buttons\n        }\n    }\n}\n\n// 또는\n// 알림을 따로 모델로 사용하고 싶다면 하드코딩된 값들을 가진 구조체를 만들 수 있습니다.\nstruct SomeSpecificAlertType: AlertDisplayable {\n    var title: String = \"특정 알림 제목\"\n    var message: String? = \"특정 메시지\"\n    var buttons: [AlertButton]\n\n    init(onAction: () -\u003e Void, onCancel: () -\u003e Void) { // \u003c- 액션을 주입하고 해당 액션을 처리합니다\n      self.buttons = [\n          .actionButton(title: \"두 번째 작업\", action: onAction),\n          .cancelButton(title: \"취소\", action: onCancel)\n      ]\n    }\n}\n```\n\n알 수 있듯이, enum 케이스별로 Alert 유형을 생성하고 비슷한 알림 유형을 하나의 개체로 그룹화할 수 있습니다. 예를 들어, 모든 권한 알림을 한 곳에 유지하고 싶다면, 개별 알림 구조체/객체로 만들거나 선택은 여러분의 몫입니다. 중요한 점은 처음에 생성한 AlertDisplayable 프로토콜을 준수하는지입니다. 이제 모바일 앱에서 구현이 어떻게 보일지 살펴보겠습니다.\n\n```js\nstruct FirstView: View {\n    let viewModel: FirstViewModel\n\n    var body: some View {\n        VStack {\n            Text(\"첫 번째 화면\")\n            Button(\"알림 표시\") {\n                viewModel.didTapButton()\n            }\n        }\n    }\n}\n\n@Observable class FirstViewModel {\n    let coordinator: FirstCoordinator\n\n    init(coordinator: FirstCoordinator) {\n        self.coordinator = coordinator\n    }\n\n    func didTapButton() {\n        coordinator.presentAlert(\n                SomeAlert.alert(buttons: [\n                    .actionButton(title: \"주요 작업\") {\n                        print(\"작업 버튼 누름\") // \u003c- 버튼 클릭 시 호출되는 클로저\n                    },\n                    .cancelButton(title: \"취소\") {\n                        print(\"취소 버튼 누름\") // \u003c- 버튼 클릭 시 호출되는 클로저\n                    }\n                ]))\n    }\n}\n\n@Observable final class FirstCoordinator: Coordinator {\n    typealias Route = FirstCoordinatorRoute\n\n    let navigationController: NavigationController\n\n    @MainActor @ViewBuilder var rootView: some View {\n        FirstView(FirstViewModel(self)).navigationDestination(for: Route.self, destination: coordinate(_:))\n    }\n\n    func presentAlert\u003cT\u003e(_ alert: T) where T: AlertDisplayable {\n        navigationController.presentAlert(alert)\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이는 viewModel에서 프로그래밍 방식으로 알림을 표시할 수 있게 해주며, 사용자가 버튼을 클릭할 때 viewModel이 선택적으로 콜백을 처리할 수 있게 합니다. 이 경우 뷰 자체 \"FirstView\"는 무엇이 일어나는지 전혀 모릅니다. 알고 있는 것은 didTapButton뿐입니다.\n\n![image](/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_1.png)\n\n부분 2에 대한 내용은 여기까지입니다.\n\n이 내용이 유용하다고 생각되면 좋겠습니다. 피드백이나 개선 제안이 있으면 알려주세요. 이 글이 유익했다면 공유해 주세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n좋은 하루 보내세요!\n","ogImage":{"url":"/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_0.png"},"coverImage":"/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_0.png","tag":["Tech"],"readingTime":10},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_0.png\"\u003e\n\u003cp\u003e만약 Part 1을 아직 읽지 않았다면 여기에서 찾아볼 수 있어요. 이 글은 이전 글의 연장선입니다.\u003c/p\u003e\n\u003cp\u003ePart 1에서는 네비게이션 라우팅 로직을 coordinators로 격리시켰습니다. 이를 통해 앱을 위한 확장 가능하고 모듈식 네비게이션 설정을 만들었습니다. 하지만 이것은 기본에 불과해요. SwiftUI에서는 navigationPath로 push하는 것 이외에도 더 많은 종류의 네비게이션이 있어요. 이 중 하나는 \"네비게이션\"으로 팝업 알람을 표시하는 것이죠.\u003c/p\u003e\n\u003cp\u003e오늘은 이 주제에 대해 이야기할 거에요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eSwiftUI에서는 다양한 수정자(modifier)를 제공하여 Alert를 표시할 수 있습니다. 일반적으로 이러한 Alert 수정자는 뷰(View)에 설정되며, ViewModel/View에는 Alert를 표시할지 여부를 결정하는 데 사용되는 Binding\u003ccode\u003eBool\u003c/code\u003e이 있습니다. 이 논리는 저에게는 좀 더 화면에 적합하게 표현되도록 조정되어야 한다고 생각합니다. 그렇다면 그에 대비할 방법을 찾아봅시다.\u003c/p\u003e\n\u003cp\u003eAlert에는 다양한 기능이 있을 수 있습니다. 타이틀, 메시지, 한 개 또는 두 개 이상의 버튼(primaryAction, cancelAction)이 포함될 수 있으며, 이러한 버튼은 .destructive 역할을 갖는 등 다양한 역할을 할 수 있습니다. 이는 시스템이 설계된 방식의 일부이며 그것이 예상대로 작동할 것으로 예상됩니다. 그래서 모든 이러한 경우의 Alert를 표시하는 데 필요한 정보를 제공하기 위한 프로토콜을 생성해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSwiftUI\u003c/span\u003e\n\nprotocol \u003cspan class=\"hljs-title class_\"\u003eAlertDisplayable\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e { get }\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e? { get }\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebuttons\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eAlertButton\u003c/span\u003e] { get }\n}\n\nstruct \u003cspan class=\"hljs-title class_\"\u003eAlertButton\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erole\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eButtonRole\u003c/span\u003e?\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eaction\u003c/span\u003e: () -\u003e \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e\n\n    private \u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etitle: \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e, role: ButtonRole?, action: @escaping () -\u003e Void\u003c/span\u003e) {\n        self.\u003cspan class=\"hljs-property\"\u003etitle\u003c/span\u003e = title\n        self.\u003cspan class=\"hljs-property\"\u003erole\u003c/span\u003e = role\n        self.\u003cspan class=\"hljs-property\"\u003eaction\u003c/span\u003e = action\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e func \u003cspan class=\"hljs-title function_\"\u003eactionButton\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eaction\u003c/span\u003e: @escaping () -\u003e \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-title class_\"\u003eSelf\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eAlertButton\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: title, \u003cspan class=\"hljs-attr\"\u003erole\u003c/span\u003e: nil, \u003cspan class=\"hljs-attr\"\u003eaction\u003c/span\u003e: action)\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e func \u003cspan class=\"hljs-title function_\"\u003ecancelButton\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eaction\u003c/span\u003e: @escaping () -\u003e \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-title class_\"\u003eSelf\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eAlertButton\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: title, \u003cspan class=\"hljs-attr\"\u003erole\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003ecancel\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eaction\u003c/span\u003e: action)\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e func \u003cspan class=\"hljs-title function_\"\u003edestructiveButton\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eaction\u003c/span\u003e: @escaping () -\u003e \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-title class_\"\u003eSelf\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eAlertButton\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: title, \u003cspan class=\"hljs-attr\"\u003erole\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003edestructive\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eaction\u003c/span\u003e: action)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 part 1에서 생성한 NavigationController에 다음을 추가할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Observable\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNavigationController\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e navigationPath \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eNavigationPath\u003c/span\u003e()\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e alertPath \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eAlertPath\u003c/span\u003e()\n\n    \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003epresentAlert\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-type\"\u003eT\u003c/span\u003e\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003ealert\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eT\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ewhere\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eT\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eAlertDisplayable\u003c/span\u003e {\n        alertPath.setAlert(alert)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e일관성을 유지하기 위해 ****Path 규칙을 따르고 있지만 원하는 대로 이름을 지정할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e SwiftUI\n\n\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAlertPath\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e alert: \u003cspan class=\"hljs-type\"\u003eAlertDisplayable\u003c/span\u003e?\n\n    \u003cspan class=\"hljs-keyword\"\u003emutating\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetAlert\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-type\"\u003eT\u003c/span\u003e\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003ealert\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eT\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ewhere\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eT\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eAlertDisplayable\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.alert \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e alert\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또한 설정한 후 경고를 처리하는 CoordinatedView를 업데이트해야 합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCoordinatedView\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eC\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCoordinator\u003c/span\u003e\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e coordinator: \u003cspan class=\"hljs-type\"\u003eC\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003einit\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003ecoordinator\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eC\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.coordinator \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e coordinator\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e body: \u003cspan class=\"hljs-keyword\"\u003esome\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-meta\"\u003e@Bindable\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e navigationController \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e coordinator.navigationController\n        \u003cspan class=\"hljs-type\"\u003eNavigationStack\u003c/span\u003e(path: \u003cspan class=\"hljs-variable\"\u003e$navigationController\u003c/span\u003e.navigationPath) {\n            coordinator.rootView\n        }\n        .alert(for: \u003cspan class=\"hljs-variable\"\u003e$navigationController\u003c/span\u003e.alertPath) \u003cspan class=\"hljs-comment\"\u003e// \u0026#x3C;-- Here we add a new viewModifier\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 alert modifier는 alertPath의 바인딩을 받아 설정된 알림이 있을 경우 알림을 표시하는 사용자 정의 ViewModifier입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003eextension\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ealert\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003ealertPath\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eBinding\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-type\"\u003eAlertPath\u003c/span\u003e\u003e) -\u003e \u003cspan class=\"hljs-keyword\"\u003esome\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.modifier(\u003cspan class=\"hljs-type\"\u003eAlertModifier\u003c/span\u003e(alertPath: alertPath))\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAlertModifier\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eViewModifier\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-meta\"\u003e@Binding\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e alertPath: \u003cspan class=\"hljs-type\"\u003eAlertPath\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003einit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ealertPath\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eBinding\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-type\"\u003eAlertPath\u003c/span\u003e\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e._alertPath \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e alertPath\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebody\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003econtent\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eContent\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-keyword\"\u003esome\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eView\u003c/span\u003e {\n        content\n            .alert(\n                alertPath.alert\u003cspan class=\"hljs-operator\"\u003e?\u003c/span\u003e.title \u003cspan class=\"hljs-operator\"\u003e??\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e,\n                isPresented: \u003cspan class=\"hljs-type\"\u003eBinding\u003c/span\u003e(get: { alertPath.alert \u003cspan class=\"hljs-operator\"\u003e!=\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e }, set: { \u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e alertPath.alert \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e }),\n                actions: {\n                    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e buttons \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e alertPath.alert\u003cspan class=\"hljs-operator\"\u003e?\u003c/span\u003e.buttons {\n                        \u003cspan class=\"hljs-type\"\u003eForEach\u003c/span\u003e(buttons) { button \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n                            \u003cspan class=\"hljs-type\"\u003eButton\u003c/span\u003e(button.title, role: button.role, action: button.action)\n                        }\n                    }\n\n                }, message: {\n                    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e message \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e alertPath.alert\u003cspan class=\"hljs-operator\"\u003e?\u003c/span\u003e.message {\n                        \u003cspan class=\"hljs-type\"\u003eText\u003c/span\u003e(message)\n                    }\n                })\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e알림의 제목은 title 속성에서 가져옵니다.\u003c/li\u003e\n\u003cli\u003ealertPath의 존재 여부에 따라 수동으로 getter 및 setter를 설정한 Binding\u003ccode\u003eBool\u003c/code\u003e를 전달합니다. 따라서 alert가 존재하는 경우 알림을 표시합니다. 그리고 알림이 닫힐 때 alert를 nil로 설정합니다.\u003c/li\u003e\n\u003cli\u003e사용 가능한 각 버튼에 대해 제공된 title, role 및 action으로 SwiftUI Button을 만듭니다. 버튼을 하나도 보내지 않으면 시스템이 단일 'OK' 버튼 알림으로 기본 설정됩니다.\u003c/li\u003e\n\u003cli\u003e필요에 따라 알림 아래에 제목 아래에 알림에 대한 일부 설명 정보가 포함될 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e한 번 시도해 보고 실제로 잘 작동하는지 확인해 봅시다. 알림 유형을 생성해 보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 비슷한 알림을 그룹화하거나 케이스별 알림을 만들고 싶다면 emum을 생성할 수 있습니다.\u003c/span\u003e\nenum \u003cspan class=\"hljs-title class_\"\u003eSomeAlert\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAlertDisplayable\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ealert\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ebuttons\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eAlertButton\u003c/span\u003e]) \u003cspan class=\"hljs-comment\"\u003e// \u0026#x3C;-- 액션을 주입합니다\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ealertWithTitleAndMessage\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ebuttons\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eAlertButton\u003c/span\u003e])\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e self {\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003ealert\u003c/span\u003e:                        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"제목만 있는 알림\"\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003ealertWithTitleAndMessage\u003c/span\u003e:     \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"제목과 메시지가 있는 알림\"\u003c/span\u003e\n        }\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e? {\n        \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e self {\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003ealert\u003c/span\u003e:                    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e nil\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003ealertWithTitleAndMessage\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"이것은 메시지입니다\"\u003c/span\u003e\n        }\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebuttons\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eAlertButton\u003c/span\u003e] {\n        \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e self {\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-title function_\"\u003ealert\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e buttons),\n             .\u003cspan class=\"hljs-title function_\"\u003ealertWithTitleAndMessage\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e buttons):    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e buttons\n        }\n    }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 또는\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 알림을 따로 모델로 사용하고 싶다면 하드코딩된 값들을 가진 구조체를 만들 수 있습니다.\u003c/span\u003e\nstruct \u003cspan class=\"hljs-title class_\"\u003eSomeSpecificAlertType\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAlertDisplayable\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"특정 알림 제목\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e? = \u003cspan class=\"hljs-string\"\u003e\"특정 메시지\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebuttons\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eAlertButton\u003c/span\u003e]\n\n    \u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eonAction: () -\u003e Void, onCancel: () -\u003e Void\u003c/span\u003e) { \u003cspan class=\"hljs-comment\"\u003e// \u0026#x3C;- 액션을 주입하고 해당 액션을 처리합니다\u003c/span\u003e\n      self.\u003cspan class=\"hljs-property\"\u003ebuttons\u003c/span\u003e = [\n          .\u003cspan class=\"hljs-title function_\"\u003eactionButton\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"두 번째 작업\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eaction\u003c/span\u003e: onAction),\n          .\u003cspan class=\"hljs-title function_\"\u003ecancelButton\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"취소\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eaction\u003c/span\u003e: onCancel)\n      ]\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e알 수 있듯이, enum 케이스별로 Alert 유형을 생성하고 비슷한 알림 유형을 하나의 개체로 그룹화할 수 있습니다. 예를 들어, 모든 권한 알림을 한 곳에 유지하고 싶다면, 개별 알림 구조체/객체로 만들거나 선택은 여러분의 몫입니다. 중요한 점은 처음에 생성한 AlertDisplayable 프로토콜을 준수하는지입니다. 이제 모바일 앱에서 구현이 어떻게 보일지 살펴보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eFirstView\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eviewModel\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFirstViewModel\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eVStack\u003c/span\u003e {\n            \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"첫 번째 화면\"\u003c/span\u003e)\n            \u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"알림 표시\"\u003c/span\u003e) {\n                viewModel.\u003cspan class=\"hljs-title function_\"\u003edidTapButton\u003c/span\u003e()\n            }\n        }\n    }\n}\n\n@\u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFirstViewModel\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecoordinator\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFirstCoordinator\u003c/span\u003e\n\n    \u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecoordinator: FirstCoordinator\u003c/span\u003e) {\n        self.\u003cspan class=\"hljs-property\"\u003ecoordinator\u003c/span\u003e = coordinator\n    }\n\n    func \u003cspan class=\"hljs-title function_\"\u003edidTapButton\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        coordinator.\u003cspan class=\"hljs-title function_\"\u003epresentAlert\u003c/span\u003e(\n                \u003cspan class=\"hljs-title class_\"\u003eSomeAlert\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ealert\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ebuttons\u003c/span\u003e: [\n                    .\u003cspan class=\"hljs-title function_\"\u003eactionButton\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etitle: \u003cspan class=\"hljs-string\"\u003e\"주요 작업\"\u003c/span\u003e\u003c/span\u003e) {\n                        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"작업 버튼 누름\"\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// \u0026#x3C;- 버튼 클릭 시 호출되는 클로저\u003c/span\u003e\n                    },\n                    .\u003cspan class=\"hljs-title function_\"\u003ecancelButton\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etitle: \u003cspan class=\"hljs-string\"\u003e\"취소\"\u003c/span\u003e\u003c/span\u003e) {\n                        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"취소 버튼 누름\"\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// \u0026#x3C;- 버튼 클릭 시 호출되는 클로저\u003c/span\u003e\n                    }\n                ]))\n    }\n}\n\n@\u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e final \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFirstCoordinator\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCoordinator\u003c/span\u003e {\n    typealias \u003cspan class=\"hljs-title class_\"\u003eRoute\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eFirstCoordinatorRoute\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003enavigationController\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eNavigationController\u003c/span\u003e\n\n    @\u003cspan class=\"hljs-title class_\"\u003eMainActor\u003c/span\u003e @\u003cspan class=\"hljs-title class_\"\u003eViewBuilder\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erootView\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eFirstView\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eFirstViewModel\u003c/span\u003e(self)).\u003cspan class=\"hljs-title function_\"\u003enavigationDestination\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003efor\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eRoute\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eself\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003ecoordinate\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003e_\u003c/span\u003e:))\n    }\n\n    func presentAlert\u0026#x3C;T\u003e(_ \u003cspan class=\"hljs-attr\"\u003ealert\u003c/span\u003e: T) where \u003cspan class=\"hljs-attr\"\u003eT\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAlertDisplayable\u003c/span\u003e {\n        navigationController.\u003cspan class=\"hljs-title function_\"\u003epresentAlert\u003c/span\u003e(alert)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이는 viewModel에서 프로그래밍 방식으로 알림을 표시할 수 있게 해주며, 사용자가 버튼을 클릭할 때 viewModel이 선택적으로 콜백을 처리할 수 있게 합니다. 이 경우 뷰 자체 \"FirstView\"는 무엇이 일어나는지 전혀 모릅니다. 알고 있는 것은 didTapButton뿐입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e부분 2에 대한 내용은 여기까지입니다.\u003c/p\u003e\n\u003cp\u003e이 내용이 유용하다고 생각되면 좋겠습니다. 피드백이나 개선 제안이 있으면 알려주세요. 이 글이 유익했다면 공유해 주세요!\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e좋은 하루 보내세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert"},"buildId":"GsgRekSb--BvxYwv9FPn6","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>