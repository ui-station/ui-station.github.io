<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>적응형 컴포즈 레이아웃 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-27-AdaptiveComposeLayouts" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="적응형 컴포즈 레이아웃 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="적응형 컴포즈 레이아웃 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-27-AdaptiveComposeLayouts_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-27-AdaptiveComposeLayouts" data-gatsby-head="true"/><meta name="twitter:title" content="적응형 컴포즈 레이아웃 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-27-AdaptiveComposeLayouts_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-27 17:51" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/RZIEBQ2aNAp_DXFVTV6eL/_buildManifest.js" defer=""></script><script src="/_next/static/RZIEBQ2aNAp_DXFVTV6eL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">적응형 컴포즈 레이아웃</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="적응형 컴포즈 레이아웃" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 27, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-27-AdaptiveComposeLayouts&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>모든 창 크기에 대한 흥미로운 소식</h2>
<p><img src="/assets/img/2024-05-27-AdaptiveComposeLayouts_0.png" alt="이미지"></p>
<p>올해 구글 I/O는 흥미로운 발표들로 가득 찼는데, AI 분야뿐만 아니라 (물론 그것도 하이라이트였지만) 적응형 레이아웃을 구축하기 위한 Jetpack Compose의 발전에 중점을 둔 것이 나에게는 핵심적인 교훈이었습니다. 안드로이드는 스마트폰뿐만 아니라 태블릿, 폴더블폰, 대형 화면 등으로 확장되고 있어서 다양한 형태 요소에 적응하는 앱을 개발하는 것이 더 중요해지고 있습니다.</p>
<p>이전에 내가 이전 게시물에서 창 크기 클래스를 사용하여 반응형 레이아웃을 탐구했습니다. 그러나 Jetpack Compose의 흥미로운 새로운 발전으로 인해 해당 주제를 다시 살펴보게 되었습니다. WindowSizeClass의 새로운 구현뿐만 아니라 사용법을 간단하게 하는 새로운 Composable 함수들도 새롭게 나왔습니다. 또한 일반적인 레이아웃 동작을 단순화하는 새로운 Composable 함수들도 나왔는데, 사용자 정의 함수가 필요 없어졌습니다.</p>
<p>많은 내용을 다뤄야 하니까, 첫 번째 주요 측면으로 넘어가 볼까요? WindowSizeClass의 새로운 구현을 살펴봅시다. 이해를 돕기 위해, 제 이전 글에서의 구현을 이전해 보겠습니다. 원하신다면 확인해보세요.</p>
<h2>WindowSizeClass의 이전</h2>
<p>Gradle 파일을 업데이트하는 것부터 시작해봅시다. 이전 종속성을 제거하고 새롭게 개선된 구현을 위한 새로운 것을 추가할 겁니다.</p>
<pre><code class="hljs language-js">[versions]
adaptive = <span class="hljs-string">"1.0.0-beta01"</span>
...
[libraries]

-- androidx-material3-windowSizeClass = { group = <span class="hljs-string">"androidx.compose.material3"</span>, name = <span class="hljs-string">"material3-window-size-class"</span> }
androidx-adaptive = { <span class="hljs-variable language_">module</span> = <span class="hljs-string">"androidx.compose.material3.adaptive:adaptive"</span>, version.<span class="hljs-property">ref</span> = <span class="hljs-string">"adaptive"</span> }
...
</code></pre>
<p>Gradle 종속성을 업데이트한 후 이제 이전 WindowSizeClass 구현에 의존했던 코드 섹션을 이주해 보겠습니다. 예를 들어, 창 크기에 따라 동적으로 열의 수를 결정하는 코드가 있다면 다음과 같이 업데이트할 수 있습니다:</p>
<pre><code class="hljs language-js">val windowWidthSize = <span class="hljs-title function_">currentWindowAdaptiveInfo</span>().<span class="hljs-property">windowSizeClass</span>.<span class="hljs-property">windowWidthSizeClass</span>  

val columns = when (windowWidthSize) {
       <span class="hljs-title class_">WindowWidthSizeClass</span>.<span class="hljs-property">COMPACT</span> -> <span class="hljs-number">1</span>
       <span class="hljs-title class_">WindowWidthSizeClass</span>.<span class="hljs-property">MEDIUM</span> -> <span class="hljs-number">2</span>
       <span class="hljs-keyword">else</span> -> <span class="hljs-number">3</span>
}
</code></pre>
<p>업데이트가 함수 변경을 넘어 이동했다는 것을 알 수 있습니다! 주요 개선 사항 중 하나는 composable 함수 내에서 windowSizeClass를 직접 가져올 수 있는 능력입니다. 이제 activity를 통해 액세스할 필요 없이 이를 가져올 수 있습니다. 즉, 앱 전반에 걸쳐 창 크기 클래스를 매개변수로 전달할 필요가 없어졌습니다! 이것은 더 깨끗한 코드를 위한 중요한 발전입니다.</p>
<h2>NavigationSuiteScaffold</h2>
<p>윈도우 크기 클래스 이주를 다루었으니, 이제는 새로운 구성 가능 함수를 살펴봅시다. 먼저, NavigationSuiteScaffold가 등장합니다. 이 중요한 구성 가능 함수는 창 크기에 따라 하단 탐색 표시줄, 탐색 레일 및 서랍 사이를 전환할 때 사용자 정의 논리가 필요 없도록 해줍니다.</p>
<p>이전 글에서는 탐색 요소 전환을 위한 사용자 정의 솔루션 구축을 탐구했습니다. 이제 NavigationSuiteScaffold가 이 프로세스를 간단하게 하는 방법을 살펴보겠습니다. 이 새로운 함수를 사용하여 동일한 결과를 얻는 방법은 다음과 같습니다:</p>
<pre><code class="hljs language-js">... 
<span class="hljs-title class_">NavigationSuiteScaffold</span>(
        modifier = <span class="hljs-title class_">Modifier</span>, 
        navigationSuiteItems = {

            bottomNavigationItems.<span class="hljs-property">forEach</span> { bottomBarElement ->

                val selected =
                    currentScreen.<span class="hljs-title function_">instanceOf</span>(bottomBarElement.<span class="hljs-property">screen</span>::<span class="hljs-keyword">class</span>)

                <span class="hljs-title function_">item</span>(
                    icon = bottomBarElement.<span class="hljs-property">icon</span>,
                    selected = selected,
                    alwaysShowLabel = <span class="hljs-literal">true</span>,
                    label = {
                        <span class="hljs-title class_">Text</span>(
                            text = <span class="hljs-title function_">stringResource</span>(id = bottomBarElement.<span class="hljs-property">title</span>),
                            style = <span class="hljs-title class_">MaterialTheme</span>.<span class="hljs-property">typography</span>.<span class="hljs-property">labelMedium</span>.<span class="hljs-title function_">copy</span>(
                                textAlign = <span class="hljs-title class_">TextAlign</span>.<span class="hljs-property">Center</span>,
                                fontWeight = <span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Normal</span>
                            ),
                            maxLines = <span class="hljs-number">1</span>
                        )
                    },
                    onClick = {
                        <span class="hljs-keyword">if</span> (!selected) {
                                <span class="hljs-title class_">NavigationEvent</span>.<span class="hljs-title class_">OnNavigateBottomBar</span>(
                                    bottomBarElement.<span class="hljs-property">screen</span>
                                )
                        }
                    }
                )
            }
        }

    ) {
        <span class="hljs-title class_">Scaffold</span>() { innerPadding ->
            <span class="hljs-title class_">MainNavHost</span>(
                modifier = <span class="hljs-title class_">Modifier</span>.<span class="hljs-title function_">padding</span>(innerPadding),
            )
        }
    }
</code></pre>
<p>이 단일 구현은 현재 창 크기에 따라 적절한 탐색 경험을 제공하도록 자동으로 동작합니다. 이는 작은 화면의 경우 하단 표시줄과 큰 화면의 경우 탐색 레일과 같은 요소 간에 전환하는 적절한 탐색 경험을 제공합니다.</p>
<p>그러나 더 맞춤화된 접근을 선호하는 분들을 위해 NavigationSuiteScaffold는 NavigationSuiteType을 통해 유연성을 제공합니다. 여러분은 해당 스캐폴드 내에서 사용자 정의 동작을 매끄럽게 통합하여 스마트폰의 가로 모드에서도 네비게이션 레일과 같은 요소를 사용할 수 있습니다.</p>
<pre><code class="hljs language-js">... 
val adaptiveInfo = <span class="hljs-title function_">currentWindowAdaptiveInfo</span>()
val customNavSuiteType = <span class="hljs-title function_">with</span>(<span class="hljs-params">adaptiveInfo</span>) {
            <span class="hljs-keyword">if</span> (windowSizeClass.<span class="hljs-property">windowWidthSizeClass</span> == <span class="hljs-title class_">WindowWidthSizeClass</span>.<span class="hljs-property">EXPANDED</span>) {
                <span class="hljs-title class_">NavigationSuiteType</span>.<span class="hljs-property">NavigationRail</span>
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-title class_">NavigationSuiteScaffoldDefaults</span>.<span class="hljs-title function_">calculateFromAdaptiveInfo</span>(adaptiveInfo)
            }
}

<span class="hljs-title class_">NavigationSuiteScaffold</span>(
        modifier = <span class="hljs-title class_">Modifier</span>,
        layoutType = customNavSuiteType,
        navigationSuiteItems = {
...
</code></pre>
<p>동일한 원칙이 특정 시나리오에서 네비게이션을 완전히 숨기고 싶은 경우에도 적용됩니다.</p>
<pre><code class="hljs language-js">... 
val adaptiveInfo = <span class="hljs-title function_">currentWindowAdaptiveInfo</span>()
    val customNavSuiteType = <span class="hljs-title function_">with</span>(<span class="hljs-params">adaptiveInfo</span>) {
         when {
            !shouldShowBottomBar -> {
                <span class="hljs-title class_">NavigationSuiteType</span>.<span class="hljs-property">None</span>
            }
            windowSizeClass.<span class="hljs-property">windowWidthSizeClass</span> == <span class="hljs-title class_">WindowWidthSizeClass</span>.<span class="hljs-property">EXPANDED</span> -> {
                <span class="hljs-title class_">NavigationSuiteType</span>.<span class="hljs-property">NavigationRail</span>
            }
            <span class="hljs-keyword">else</span> -> {
                <span class="hljs-title class_">NavigationSuiteScaffoldDefaults</span>.<span class="hljs-title function_">calculateFromAdaptiveInfo</span>(adaptiveInfo)
            }
        }
    }
...
</code></pre>
<h2>ListDetailPaneScaffold</h2>
<p>안녕하세요, 또 다른 강력한 Composable인 ListDetailPaneScaffold를 살펴보겠습니다. 이 함수는 화면 크기가 큰 경우 두 개의 화면(또는 패널로 표시)을 옆에 나란히 표시하고 싶을 때 이상적입니다. 주요 장점 중 하나는 단일 패널을 표시하거나 이중 패널 레이아웃을 활용하든 내부 내비게이션을 자동으로 처리한다는 점입니다. 이것은 개발을 간소화할 뿐만 아니라 창 크기에 관계없이 부드러운 사용자 경험을 보장합니다.</p>
<pre><code class="hljs language-js">[versions]
material3AdaptiveNavigationSuiteAndroid = <span class="hljs-string">"1.3.0-beta01"</span>
...
[libraries]

androidx-material3-adaptive-navigation-suite-android = { group = <span class="hljs-string">"androidx.compose.material3"</span>, name = <span class="hljs-string">"material3-adaptive-navigation-suite-android"</span>, version.<span class="hljs-property">ref</span> = <span class="hljs-string">"material3AdaptiveNavigationSuiteAndroid"</span> }
...
</code></pre>
<p>Gradle 종속성을 사용하여 코드를 업데이트할 수 있습니다.</p>
<pre><code class="hljs language-js"> val navigator = rememberListDetailPaneScaffoldNavigator&#x3C;<span class="hljs-title class_">String</span>>()

    <span class="hljs-title class_">BackHandler</span>(navigator.<span class="hljs-title function_">canNavigateBack</span>()) {
        navigator.<span class="hljs-title function_">navigateBack</span>()
    }

    <span class="hljs-title class_">ListDetailPaneScaffold</span>(
        directive = navigator.<span class="hljs-property">scaffoldDirective</span>,
        value = navigator.<span class="hljs-property">scaffoldValue</span>,
        listPane = {
            <span class="hljs-title class_">AnimatedPane</span> {
                <span class="hljs-title class_">HomeScreen</span>(
                    onClickOnItem = {
                        navigator.<span class="hljs-title function_">navigateTo</span>(
                            <span class="hljs-title class_">ListDetailPaneScaffoldRole</span>.<span class="hljs-property">Detail</span>,
                            it
                        )
                    }
                )
            }
        },
        detailPane = {
            <span class="hljs-title class_">AnimatedPane</span> {
                navigator.<span class="hljs-property">currentDestination</span>?.<span class="hljs-property">content</span>?.<span class="hljs-property">let</span> {
                    <span class="hljs-title class_">ZoomBookInitScreen</span>(book = it.<span class="hljs-property">id</span>)
                }
            }
        },
    )
</code></pre>
<p>이름에서 알 수 있듯이 navigator는 패널 내에서의 네비게이션을 관리하는 역할을 합니다. 이는 상세 패널로 이동하거나, 단일 패널 모드에서 백 네비게이션을 처리하는 것을 포함합니다. 또한 상세 패널로 전달된 데이터 객체를 포함합니다. 특히, Parcelable인 경우 사용자 정의 객체도 공유할 수 있습니다.</p>
<p>WindowSizeClass와 함께 ListDetailPaneScaffold를 사용하여 현재 창 크기에 기반한 동작을 맞춤화할 수 있습니다. 예를 들어 (스크린샷에서 볼 수 있듯이) 단일 패널 모드에서만 뒤로 화살표와 같은 요소를 조건부로 표시할 수 있습니다.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> windowWidthSize = currentWindowAdaptiveInfo().windowSizeClass.windowWidthSizeClass
<span class="hljs-keyword">val</span> backVisible = <span class="hljs-keyword">when</span> (windowWidthSize) {
    WindowWidthSizeClass.EXPANDED -> <span class="hljs-literal">false</span>
    <span class="hljs-keyword">else</span> -> <span class="hljs-literal">true</span>
}
</code></pre>
<p>이 수준의 제어는 모든 다양한 디바이스 크기에서 정교한 사용자 경험을 보장합니다.</p>
<h2>SupportingPaneScaffold</h2>
<p>새로운 적응형 레이아웃 기능을 탐색하기 위해 SupportingPaneScaffold를 간단히 살펴보겠습니다. 이 구성 요소는 핵심 기능인 탐색 관리와 창 내용 표시를 ListDetailPaneScaffold와 유사한 점을 가지고 있습니다. 하지만 SupportingPaneScaffold는 주요 콘텐츠 창과 오른쪽에 있는 더 작은 "보조" 창을 함께 사용하는 경우에 맞게 설계되었습니다. 이는 보조 콘텐츠가 주요 콘텐츠를 보완하거나 부가 정보를 제공하지만 동일한 화면 공간이 필요하지 않은 상황에 이상적입니다.</p>
<p>프로젝트에서 SupportingPaneScaffold을 구현하려면 ListDetailPaneScaffold에서 얻은 지식을 기반으로 활용할 수 있습니다. 더 깊은 이해를 위해 젯팩 코믹스의 공식 문서를 여기에 남겨 두겠습니다.</p>
<h1>결론</h1>
<p>본 문서를 통해 Google I/O 2024에서 젯팩 코믹스를 사용한 적응형 레이아웃 구축의 흥미로운 발전을 확인하였습니다. 새로운 WindowSizeClass 구현은 액세스 및 사용을 간단하게 만들어주며, NavigationSuiteScaffold, ListDetailPaneScaffold 및 SupportingPaneScaffold와 같은 강력한 조합 가능 함수들은 다양한 화면 크기와 형태 요인을 통해 탐색 및 콘텐츠 표현을 간소화하는 접근 방식을 제공합니다.</p>
<p>이러한 새로운 기능은 Android 애플리케이션을 위한 정말로 반응적이고 사용자 친화적인 경험을 만들 수 있게 해줍니다. 적응형 레이아웃을 위한 최상의 실천 방법을 준수하고 이러한 도구들을 수용함으로써, 앱이 지속적으로 진화하는 Android 생태계에 매끄럽게 적응하여 모든 기기의 사용자에게 탁월한 경험을 제공할 수 있습니다.</p>
<p>의견을 자유롭게 공유해주시거나, 원하신다면 LinkedIn에서 연락 주셔도 좋습니다.</p>
<p>좋은 하루되세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"적응형 컴포즈 레이아웃","description":"","date":"2024-05-27 17:51","slug":"2024-05-27-AdaptiveComposeLayouts","content":"\n\n## 모든 창 크기에 대한 흥미로운 소식\n\n![이미지](/assets/img/2024-05-27-AdaptiveComposeLayouts_0.png)\n\n올해 구글 I/O는 흥미로운 발표들로 가득 찼는데, AI 분야뿐만 아니라 (물론 그것도 하이라이트였지만) 적응형 레이아웃을 구축하기 위한 Jetpack Compose의 발전에 중점을 둔 것이 나에게는 핵심적인 교훈이었습니다. 안드로이드는 스마트폰뿐만 아니라 태블릿, 폴더블폰, 대형 화면 등으로 확장되고 있어서 다양한 형태 요소에 적응하는 앱을 개발하는 것이 더 중요해지고 있습니다.\n\n이전에 내가 이전 게시물에서 창 크기 클래스를 사용하여 반응형 레이아웃을 탐구했습니다. 그러나 Jetpack Compose의 흥미로운 새로운 발전으로 인해 해당 주제를 다시 살펴보게 되었습니다. WindowSizeClass의 새로운 구현뿐만 아니라 사용법을 간단하게 하는 새로운 Composable 함수들도 새롭게 나왔습니다. 또한 일반적인 레이아웃 동작을 단순화하는 새로운 Composable 함수들도 나왔는데, 사용자 정의 함수가 필요 없어졌습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n많은 내용을 다뤄야 하니까, 첫 번째 주요 측면으로 넘어가 볼까요? WindowSizeClass의 새로운 구현을 살펴봅시다. 이해를 돕기 위해, 제 이전 글에서의 구현을 이전해 보겠습니다. 원하신다면 확인해보세요.\n\n## WindowSizeClass의 이전\n\nGradle 파일을 업데이트하는 것부터 시작해봅시다. 이전 종속성을 제거하고 새롭게 개선된 구현을 위한 새로운 것을 추가할 겁니다.\n\n```js\n[versions]\nadaptive = \"1.0.0-beta01\"\n...\n[libraries]\n\n-- androidx-material3-windowSizeClass = { group = \"androidx.compose.material3\", name = \"material3-window-size-class\" }\nandroidx-adaptive = { module = \"androidx.compose.material3.adaptive:adaptive\", version.ref = \"adaptive\" }\n...\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGradle 종속성을 업데이트한 후 이제 이전 WindowSizeClass 구현에 의존했던 코드 섹션을 이주해 보겠습니다. 예를 들어, 창 크기에 따라 동적으로 열의 수를 결정하는 코드가 있다면 다음과 같이 업데이트할 수 있습니다:\n\n```js\nval windowWidthSize = currentWindowAdaptiveInfo().windowSizeClass.windowWidthSizeClass  \n\nval columns = when (windowWidthSize) {\n       WindowWidthSizeClass.COMPACT -\u003e 1\n       WindowWidthSizeClass.MEDIUM -\u003e 2\n       else -\u003e 3\n}\n```\n\n업데이트가 함수 변경을 넘어 이동했다는 것을 알 수 있습니다! 주요 개선 사항 중 하나는 composable 함수 내에서 windowSizeClass를 직접 가져올 수 있는 능력입니다. 이제 activity를 통해 액세스할 필요 없이 이를 가져올 수 있습니다. 즉, 앱 전반에 걸쳐 창 크기 클래스를 매개변수로 전달할 필요가 없어졌습니다! 이것은 더 깨끗한 코드를 위한 중요한 발전입니다.\n\n## NavigationSuiteScaffold\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n윈도우 크기 클래스 이주를 다루었으니, 이제는 새로운 구성 가능 함수를 살펴봅시다. 먼저, NavigationSuiteScaffold가 등장합니다. 이 중요한 구성 가능 함수는 창 크기에 따라 하단 탐색 표시줄, 탐색 레일 및 서랍 사이를 전환할 때 사용자 정의 논리가 필요 없도록 해줍니다.\n\n이전 글에서는 탐색 요소 전환을 위한 사용자 정의 솔루션 구축을 탐구했습니다. 이제 NavigationSuiteScaffold가 이 프로세스를 간단하게 하는 방법을 살펴보겠습니다. 이 새로운 함수를 사용하여 동일한 결과를 얻는 방법은 다음과 같습니다:\n\n```js\n... \nNavigationSuiteScaffold(\n        modifier = Modifier, \n        navigationSuiteItems = {\n\n            bottomNavigationItems.forEach { bottomBarElement -\u003e\n\n                val selected =\n                    currentScreen.instanceOf(bottomBarElement.screen::class)\n\n                item(\n                    icon = bottomBarElement.icon,\n                    selected = selected,\n                    alwaysShowLabel = true,\n                    label = {\n                        Text(\n                            text = stringResource(id = bottomBarElement.title),\n                            style = MaterialTheme.typography.labelMedium.copy(\n                                textAlign = TextAlign.Center,\n                                fontWeight = FontWeight.Normal\n                            ),\n                            maxLines = 1\n                        )\n                    },\n                    onClick = {\n                        if (!selected) {\n                                NavigationEvent.OnNavigateBottomBar(\n                                    bottomBarElement.screen\n                                )\n                        }\n                    }\n                )\n            }\n        }\n\n    ) {\n        Scaffold() { innerPadding -\u003e\n            MainNavHost(\n                modifier = Modifier.padding(innerPadding),\n            )\n        }\n    }\n```\n\n이 단일 구현은 현재 창 크기에 따라 적절한 탐색 경험을 제공하도록 자동으로 동작합니다. 이는 작은 화면의 경우 하단 표시줄과 큰 화면의 경우 탐색 레일과 같은 요소 간에 전환하는 적절한 탐색 경험을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 더 맞춤화된 접근을 선호하는 분들을 위해 NavigationSuiteScaffold는 NavigationSuiteType을 통해 유연성을 제공합니다. 여러분은 해당 스캐폴드 내에서 사용자 정의 동작을 매끄럽게 통합하여 스마트폰의 가로 모드에서도 네비게이션 레일과 같은 요소를 사용할 수 있습니다.\n\n```js\n... \nval adaptiveInfo = currentWindowAdaptiveInfo()\nval customNavSuiteType = with(adaptiveInfo) {\n            if (windowSizeClass.windowWidthSizeClass == WindowWidthSizeClass.EXPANDED) {\n                NavigationSuiteType.NavigationRail\n            } else {\n                NavigationSuiteScaffoldDefaults.calculateFromAdaptiveInfo(adaptiveInfo)\n            }\n}\n\nNavigationSuiteScaffold(\n        modifier = Modifier,\n        layoutType = customNavSuiteType,\n        navigationSuiteItems = {\n...\n```\n\n동일한 원칙이 특정 시나리오에서 네비게이션을 완전히 숨기고 싶은 경우에도 적용됩니다.\n\n```js\n... \nval adaptiveInfo = currentWindowAdaptiveInfo()\n    val customNavSuiteType = with(adaptiveInfo) {\n         when {\n            !shouldShowBottomBar -\u003e {\n                NavigationSuiteType.None\n            }\n            windowSizeClass.windowWidthSizeClass == WindowWidthSizeClass.EXPANDED -\u003e {\n                NavigationSuiteType.NavigationRail\n            }\n            else -\u003e {\n                NavigationSuiteScaffoldDefaults.calculateFromAdaptiveInfo(adaptiveInfo)\n            }\n        }\n    }\n...\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## ListDetailPaneScaffold\n\n안녕하세요, 또 다른 강력한 Composable인 ListDetailPaneScaffold를 살펴보겠습니다. 이 함수는 화면 크기가 큰 경우 두 개의 화면(또는 패널로 표시)을 옆에 나란히 표시하고 싶을 때 이상적입니다. 주요 장점 중 하나는 단일 패널을 표시하거나 이중 패널 레이아웃을 활용하든 내부 내비게이션을 자동으로 처리한다는 점입니다. 이것은 개발을 간소화할 뿐만 아니라 창 크기에 관계없이 부드러운 사용자 경험을 보장합니다.\n\n```js\n[versions]\nmaterial3AdaptiveNavigationSuiteAndroid = \"1.3.0-beta01\"\n...\n[libraries]\n\nandroidx-material3-adaptive-navigation-suite-android = { group = \"androidx.compose.material3\", name = \"material3-adaptive-navigation-suite-android\", version.ref = \"material3AdaptiveNavigationSuiteAndroid\" }\n...\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGradle 종속성을 사용하여 코드를 업데이트할 수 있습니다.\n\n```js\n val navigator = rememberListDetailPaneScaffoldNavigator\u003cString\u003e()\n\n    BackHandler(navigator.canNavigateBack()) {\n        navigator.navigateBack()\n    }\n\n    ListDetailPaneScaffold(\n        directive = navigator.scaffoldDirective,\n        value = navigator.scaffoldValue,\n        listPane = {\n            AnimatedPane {\n                HomeScreen(\n                    onClickOnItem = {\n                        navigator.navigateTo(\n                            ListDetailPaneScaffoldRole.Detail,\n                            it\n                        )\n                    }\n                )\n            }\n        },\n        detailPane = {\n            AnimatedPane {\n                navigator.currentDestination?.content?.let {\n                    ZoomBookInitScreen(book = it.id)\n                }\n            }\n        },\n    )\n```\n\n이름에서 알 수 있듯이 navigator는 패널 내에서의 네비게이션을 관리하는 역할을 합니다. 이는 상세 패널로 이동하거나, 단일 패널 모드에서 백 네비게이션을 처리하는 것을 포함합니다. 또한 상세 패널로 전달된 데이터 객체를 포함합니다. 특히, Parcelable인 경우 사용자 정의 객체도 공유할 수 있습니다.\n\nWindowSizeClass와 함께 ListDetailPaneScaffold를 사용하여 현재 창 크기에 기반한 동작을 맞춤화할 수 있습니다. 예를 들어 (스크린샷에서 볼 수 있듯이) 단일 패널 모드에서만 뒤로 화살표와 같은 요소를 조건부로 표시할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nval windowWidthSize = currentWindowAdaptiveInfo().windowSizeClass.windowWidthSizeClass\nval backVisible = when (windowWidthSize) {\n    WindowWidthSizeClass.EXPANDED -\u003e false\n    else -\u003e true\n}\n```\n\n이 수준의 제어는 모든 다양한 디바이스 크기에서 정교한 사용자 경험을 보장합니다.\n\n## SupportingPaneScaffold\n\n새로운 적응형 레이아웃 기능을 탐색하기 위해 SupportingPaneScaffold를 간단히 살펴보겠습니다. 이 구성 요소는 핵심 기능인 탐색 관리와 창 내용 표시를 ListDetailPaneScaffold와 유사한 점을 가지고 있습니다. 하지만 SupportingPaneScaffold는 주요 콘텐츠 창과 오른쪽에 있는 더 작은 \"보조\" 창을 함께 사용하는 경우에 맞게 설계되었습니다. 이는 보조 콘텐츠가 주요 콘텐츠를 보완하거나 부가 정보를 제공하지만 동일한 화면 공간이 필요하지 않은 상황에 이상적입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트에서 SupportingPaneScaffold을 구현하려면 ListDetailPaneScaffold에서 얻은 지식을 기반으로 활용할 수 있습니다. 더 깊은 이해를 위해 젯팩 코믹스의 공식 문서를 여기에 남겨 두겠습니다.\n\n# 결론\n\n본 문서를 통해 Google I/O 2024에서 젯팩 코믹스를 사용한 적응형 레이아웃 구축의 흥미로운 발전을 확인하였습니다. 새로운 WindowSizeClass 구현은 액세스 및 사용을 간단하게 만들어주며, NavigationSuiteScaffold, ListDetailPaneScaffold 및 SupportingPaneScaffold와 같은 강력한 조합 가능 함수들은 다양한 화면 크기와 형태 요인을 통해 탐색 및 콘텐츠 표현을 간소화하는 접근 방식을 제공합니다.\n\n이러한 새로운 기능은 Android 애플리케이션을 위한 정말로 반응적이고 사용자 친화적인 경험을 만들 수 있게 해줍니다. 적응형 레이아웃을 위한 최상의 실천 방법을 준수하고 이러한 도구들을 수용함으로써, 앱이 지속적으로 진화하는 Android 생태계에 매끄럽게 적응하여 모든 기기의 사용자에게 탁월한 경험을 제공할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n의견을 자유롭게 공유해주시거나, 원하신다면 LinkedIn에서 연락 주셔도 좋습니다.\n\n좋은 하루되세요!","ogImage":{"url":"/assets/img/2024-05-27-AdaptiveComposeLayouts_0.png"},"coverImage":"/assets/img/2024-05-27-AdaptiveComposeLayouts_0.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e모든 창 크기에 대한 흥미로운 소식\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AdaptiveComposeLayouts_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e올해 구글 I/O는 흥미로운 발표들로 가득 찼는데, AI 분야뿐만 아니라 (물론 그것도 하이라이트였지만) 적응형 레이아웃을 구축하기 위한 Jetpack Compose의 발전에 중점을 둔 것이 나에게는 핵심적인 교훈이었습니다. 안드로이드는 스마트폰뿐만 아니라 태블릿, 폴더블폰, 대형 화면 등으로 확장되고 있어서 다양한 형태 요소에 적응하는 앱을 개발하는 것이 더 중요해지고 있습니다.\u003c/p\u003e\n\u003cp\u003e이전에 내가 이전 게시물에서 창 크기 클래스를 사용하여 반응형 레이아웃을 탐구했습니다. 그러나 Jetpack Compose의 흥미로운 새로운 발전으로 인해 해당 주제를 다시 살펴보게 되었습니다. WindowSizeClass의 새로운 구현뿐만 아니라 사용법을 간단하게 하는 새로운 Composable 함수들도 새롭게 나왔습니다. 또한 일반적인 레이아웃 동작을 단순화하는 새로운 Composable 함수들도 나왔는데, 사용자 정의 함수가 필요 없어졌습니다.\u003c/p\u003e\n\u003cp\u003e많은 내용을 다뤄야 하니까, 첫 번째 주요 측면으로 넘어가 볼까요? WindowSizeClass의 새로운 구현을 살펴봅시다. 이해를 돕기 위해, 제 이전 글에서의 구현을 이전해 보겠습니다. 원하신다면 확인해보세요.\u003c/p\u003e\n\u003ch2\u003eWindowSizeClass의 이전\u003c/h2\u003e\n\u003cp\u003eGradle 파일을 업데이트하는 것부터 시작해봅시다. 이전 종속성을 제거하고 새롭게 개선된 구현을 위한 새로운 것을 추가할 겁니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e[versions]\nadaptive = \u003cspan class=\"hljs-string\"\u003e\"1.0.0-beta01\"\u003c/span\u003e\n...\n[libraries]\n\n-- androidx-material3-windowSizeClass = { group = \u003cspan class=\"hljs-string\"\u003e\"androidx.compose.material3\"\u003c/span\u003e, name = \u003cspan class=\"hljs-string\"\u003e\"material3-window-size-class\"\u003c/span\u003e }\nandroidx-adaptive = { \u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"androidx.compose.material3.adaptive:adaptive\"\u003c/span\u003e, version.\u003cspan class=\"hljs-property\"\u003eref\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"adaptive\"\u003c/span\u003e }\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGradle 종속성을 업데이트한 후 이제 이전 WindowSizeClass 구현에 의존했던 코드 섹션을 이주해 보겠습니다. 예를 들어, 창 크기에 따라 동적으로 열의 수를 결정하는 코드가 있다면 다음과 같이 업데이트할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eval windowWidthSize = \u003cspan class=\"hljs-title function_\"\u003ecurrentWindowAdaptiveInfo\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003ewindowSizeClass\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ewindowWidthSizeClass\u003c/span\u003e  \n\nval columns = when (windowWidthSize) {\n       \u003cspan class=\"hljs-title class_\"\u003eWindowWidthSizeClass\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eCOMPACT\u003c/span\u003e -\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n       \u003cspan class=\"hljs-title class_\"\u003eWindowWidthSizeClass\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eMEDIUM\u003c/span\u003e -\u003e \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n       \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e -\u003e \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e업데이트가 함수 변경을 넘어 이동했다는 것을 알 수 있습니다! 주요 개선 사항 중 하나는 composable 함수 내에서 windowSizeClass를 직접 가져올 수 있는 능력입니다. 이제 activity를 통해 액세스할 필요 없이 이를 가져올 수 있습니다. 즉, 앱 전반에 걸쳐 창 크기 클래스를 매개변수로 전달할 필요가 없어졌습니다! 이것은 더 깨끗한 코드를 위한 중요한 발전입니다.\u003c/p\u003e\n\u003ch2\u003eNavigationSuiteScaffold\u003c/h2\u003e\n\u003cp\u003e윈도우 크기 클래스 이주를 다루었으니, 이제는 새로운 구성 가능 함수를 살펴봅시다. 먼저, NavigationSuiteScaffold가 등장합니다. 이 중요한 구성 가능 함수는 창 크기에 따라 하단 탐색 표시줄, 탐색 레일 및 서랍 사이를 전환할 때 사용자 정의 논리가 필요 없도록 해줍니다.\u003c/p\u003e\n\u003cp\u003e이전 글에서는 탐색 요소 전환을 위한 사용자 정의 솔루션 구축을 탐구했습니다. 이제 NavigationSuiteScaffold가 이 프로세스를 간단하게 하는 방법을 살펴보겠습니다. 이 새로운 함수를 사용하여 동일한 결과를 얻는 방법은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e... \n\u003cspan class=\"hljs-title class_\"\u003eNavigationSuiteScaffold\u003c/span\u003e(\n        modifier = \u003cspan class=\"hljs-title class_\"\u003eModifier\u003c/span\u003e, \n        navigationSuiteItems = {\n\n            bottomNavigationItems.\u003cspan class=\"hljs-property\"\u003eforEach\u003c/span\u003e { bottomBarElement -\u003e\n\n                val selected =\n                    currentScreen.\u003cspan class=\"hljs-title function_\"\u003einstanceOf\u003c/span\u003e(bottomBarElement.\u003cspan class=\"hljs-property\"\u003escreen\u003c/span\u003e::\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e)\n\n                \u003cspan class=\"hljs-title function_\"\u003eitem\u003c/span\u003e(\n                    icon = bottomBarElement.\u003cspan class=\"hljs-property\"\u003eicon\u003c/span\u003e,\n                    selected = selected,\n                    alwaysShowLabel = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n                    label = {\n                        \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\n                            text = \u003cspan class=\"hljs-title function_\"\u003estringResource\u003c/span\u003e(id = bottomBarElement.\u003cspan class=\"hljs-property\"\u003etitle\u003c/span\u003e),\n                            style = \u003cspan class=\"hljs-title class_\"\u003eMaterialTheme\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etypography\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elabelMedium\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecopy\u003c/span\u003e(\n                                textAlign = \u003cspan class=\"hljs-title class_\"\u003eTextAlign\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eCenter\u003c/span\u003e,\n                                fontWeight = \u003cspan class=\"hljs-title class_\"\u003eFontWeight\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eNormal\u003c/span\u003e\n                            ),\n                            maxLines = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n                        )\n                    },\n                    onClick = {\n                        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!selected) {\n                                \u003cspan class=\"hljs-title class_\"\u003eNavigationEvent\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eOnNavigateBottomBar\u003c/span\u003e(\n                                    bottomBarElement.\u003cspan class=\"hljs-property\"\u003escreen\u003c/span\u003e\n                                )\n                        }\n                    }\n                )\n            }\n        }\n\n    ) {\n        \u003cspan class=\"hljs-title class_\"\u003eScaffold\u003c/span\u003e() { innerPadding -\u003e\n            \u003cspan class=\"hljs-title class_\"\u003eMainNavHost\u003c/span\u003e(\n                modifier = \u003cspan class=\"hljs-title class_\"\u003eModifier\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epadding\u003c/span\u003e(innerPadding),\n            )\n        }\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 단일 구현은 현재 창 크기에 따라 적절한 탐색 경험을 제공하도록 자동으로 동작합니다. 이는 작은 화면의 경우 하단 표시줄과 큰 화면의 경우 탐색 레일과 같은 요소 간에 전환하는 적절한 탐색 경험을 제공합니다.\u003c/p\u003e\n\u003cp\u003e그러나 더 맞춤화된 접근을 선호하는 분들을 위해 NavigationSuiteScaffold는 NavigationSuiteType을 통해 유연성을 제공합니다. 여러분은 해당 스캐폴드 내에서 사용자 정의 동작을 매끄럽게 통합하여 스마트폰의 가로 모드에서도 네비게이션 레일과 같은 요소를 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e... \nval adaptiveInfo = \u003cspan class=\"hljs-title function_\"\u003ecurrentWindowAdaptiveInfo\u003c/span\u003e()\nval customNavSuiteType = \u003cspan class=\"hljs-title function_\"\u003ewith\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eadaptiveInfo\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (windowSizeClass.\u003cspan class=\"hljs-property\"\u003ewindowWidthSizeClass\u003c/span\u003e == \u003cspan class=\"hljs-title class_\"\u003eWindowWidthSizeClass\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eEXPANDED\u003c/span\u003e) {\n                \u003cspan class=\"hljs-title class_\"\u003eNavigationSuiteType\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eNavigationRail\u003c/span\u003e\n            } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n                \u003cspan class=\"hljs-title class_\"\u003eNavigationSuiteScaffoldDefaults\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecalculateFromAdaptiveInfo\u003c/span\u003e(adaptiveInfo)\n            }\n}\n\n\u003cspan class=\"hljs-title class_\"\u003eNavigationSuiteScaffold\u003c/span\u003e(\n        modifier = \u003cspan class=\"hljs-title class_\"\u003eModifier\u003c/span\u003e,\n        layoutType = customNavSuiteType,\n        navigationSuiteItems = {\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e동일한 원칙이 특정 시나리오에서 네비게이션을 완전히 숨기고 싶은 경우에도 적용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e... \nval adaptiveInfo = \u003cspan class=\"hljs-title function_\"\u003ecurrentWindowAdaptiveInfo\u003c/span\u003e()\n    val customNavSuiteType = \u003cspan class=\"hljs-title function_\"\u003ewith\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eadaptiveInfo\u003c/span\u003e) {\n         when {\n            !shouldShowBottomBar -\u003e {\n                \u003cspan class=\"hljs-title class_\"\u003eNavigationSuiteType\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eNone\u003c/span\u003e\n            }\n            windowSizeClass.\u003cspan class=\"hljs-property\"\u003ewindowWidthSizeClass\u003c/span\u003e == \u003cspan class=\"hljs-title class_\"\u003eWindowWidthSizeClass\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eEXPANDED\u003c/span\u003e -\u003e {\n                \u003cspan class=\"hljs-title class_\"\u003eNavigationSuiteType\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eNavigationRail\u003c/span\u003e\n            }\n            \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e -\u003e {\n                \u003cspan class=\"hljs-title class_\"\u003eNavigationSuiteScaffoldDefaults\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecalculateFromAdaptiveInfo\u003c/span\u003e(adaptiveInfo)\n            }\n        }\n    }\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eListDetailPaneScaffold\u003c/h2\u003e\n\u003cp\u003e안녕하세요, 또 다른 강력한 Composable인 ListDetailPaneScaffold를 살펴보겠습니다. 이 함수는 화면 크기가 큰 경우 두 개의 화면(또는 패널로 표시)을 옆에 나란히 표시하고 싶을 때 이상적입니다. 주요 장점 중 하나는 단일 패널을 표시하거나 이중 패널 레이아웃을 활용하든 내부 내비게이션을 자동으로 처리한다는 점입니다. 이것은 개발을 간소화할 뿐만 아니라 창 크기에 관계없이 부드러운 사용자 경험을 보장합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e[versions]\nmaterial3AdaptiveNavigationSuiteAndroid = \u003cspan class=\"hljs-string\"\u003e\"1.3.0-beta01\"\u003c/span\u003e\n...\n[libraries]\n\nandroidx-material3-adaptive-navigation-suite-android = { group = \u003cspan class=\"hljs-string\"\u003e\"androidx.compose.material3\"\u003c/span\u003e, name = \u003cspan class=\"hljs-string\"\u003e\"material3-adaptive-navigation-suite-android\"\u003c/span\u003e, version.\u003cspan class=\"hljs-property\"\u003eref\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"material3AdaptiveNavigationSuiteAndroid\"\u003c/span\u003e }\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGradle 종속성을 사용하여 코드를 업데이트할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e val navigator = rememberListDetailPaneScaffoldNavigator\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\u003e()\n\n    \u003cspan class=\"hljs-title class_\"\u003eBackHandler\u003c/span\u003e(navigator.\u003cspan class=\"hljs-title function_\"\u003ecanNavigateBack\u003c/span\u003e()) {\n        navigator.\u003cspan class=\"hljs-title function_\"\u003enavigateBack\u003c/span\u003e()\n    }\n\n    \u003cspan class=\"hljs-title class_\"\u003eListDetailPaneScaffold\u003c/span\u003e(\n        directive = navigator.\u003cspan class=\"hljs-property\"\u003escaffoldDirective\u003c/span\u003e,\n        value = navigator.\u003cspan class=\"hljs-property\"\u003escaffoldValue\u003c/span\u003e,\n        listPane = {\n            \u003cspan class=\"hljs-title class_\"\u003eAnimatedPane\u003c/span\u003e {\n                \u003cspan class=\"hljs-title class_\"\u003eHomeScreen\u003c/span\u003e(\n                    onClickOnItem = {\n                        navigator.\u003cspan class=\"hljs-title function_\"\u003enavigateTo\u003c/span\u003e(\n                            \u003cspan class=\"hljs-title class_\"\u003eListDetailPaneScaffoldRole\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eDetail\u003c/span\u003e,\n                            it\n                        )\n                    }\n                )\n            }\n        },\n        detailPane = {\n            \u003cspan class=\"hljs-title class_\"\u003eAnimatedPane\u003c/span\u003e {\n                navigator.\u003cspan class=\"hljs-property\"\u003ecurrentDestination\u003c/span\u003e?.\u003cspan class=\"hljs-property\"\u003econtent\u003c/span\u003e?.\u003cspan class=\"hljs-property\"\u003elet\u003c/span\u003e {\n                    \u003cspan class=\"hljs-title class_\"\u003eZoomBookInitScreen\u003c/span\u003e(book = it.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e)\n                }\n            }\n        },\n    )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이름에서 알 수 있듯이 navigator는 패널 내에서의 네비게이션을 관리하는 역할을 합니다. 이는 상세 패널로 이동하거나, 단일 패널 모드에서 백 네비게이션을 처리하는 것을 포함합니다. 또한 상세 패널로 전달된 데이터 객체를 포함합니다. 특히, Parcelable인 경우 사용자 정의 객체도 공유할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eWindowSizeClass와 함께 ListDetailPaneScaffold를 사용하여 현재 창 크기에 기반한 동작을 맞춤화할 수 있습니다. 예를 들어 (스크린샷에서 볼 수 있듯이) 단일 패널 모드에서만 뒤로 화살표와 같은 요소를 조건부로 표시할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e windowWidthSize = currentWindowAdaptiveInfo().windowSizeClass.windowWidthSizeClass\n\u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e backVisible = \u003cspan class=\"hljs-keyword\"\u003ewhen\u003c/span\u003e (windowWidthSize) {\n    WindowWidthSizeClass.EXPANDED -\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e -\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 수준의 제어는 모든 다양한 디바이스 크기에서 정교한 사용자 경험을 보장합니다.\u003c/p\u003e\n\u003ch2\u003eSupportingPaneScaffold\u003c/h2\u003e\n\u003cp\u003e새로운 적응형 레이아웃 기능을 탐색하기 위해 SupportingPaneScaffold를 간단히 살펴보겠습니다. 이 구성 요소는 핵심 기능인 탐색 관리와 창 내용 표시를 ListDetailPaneScaffold와 유사한 점을 가지고 있습니다. 하지만 SupportingPaneScaffold는 주요 콘텐츠 창과 오른쪽에 있는 더 작은 \"보조\" 창을 함께 사용하는 경우에 맞게 설계되었습니다. 이는 보조 콘텐츠가 주요 콘텐츠를 보완하거나 부가 정보를 제공하지만 동일한 화면 공간이 필요하지 않은 상황에 이상적입니다.\u003c/p\u003e\n\u003cp\u003e프로젝트에서 SupportingPaneScaffold을 구현하려면 ListDetailPaneScaffold에서 얻은 지식을 기반으로 활용할 수 있습니다. 더 깊은 이해를 위해 젯팩 코믹스의 공식 문서를 여기에 남겨 두겠습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e본 문서를 통해 Google I/O 2024에서 젯팩 코믹스를 사용한 적응형 레이아웃 구축의 흥미로운 발전을 확인하였습니다. 새로운 WindowSizeClass 구현은 액세스 및 사용을 간단하게 만들어주며, NavigationSuiteScaffold, ListDetailPaneScaffold 및 SupportingPaneScaffold와 같은 강력한 조합 가능 함수들은 다양한 화면 크기와 형태 요인을 통해 탐색 및 콘텐츠 표현을 간소화하는 접근 방식을 제공합니다.\u003c/p\u003e\n\u003cp\u003e이러한 새로운 기능은 Android 애플리케이션을 위한 정말로 반응적이고 사용자 친화적인 경험을 만들 수 있게 해줍니다. 적응형 레이아웃을 위한 최상의 실천 방법을 준수하고 이러한 도구들을 수용함으로써, 앱이 지속적으로 진화하는 Android 생태계에 매끄럽게 적응하여 모든 기기의 사용자에게 탁월한 경험을 제공할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e의견을 자유롭게 공유해주시거나, 원하신다면 LinkedIn에서 연락 주셔도 좋습니다.\u003c/p\u003e\n\u003cp\u003e좋은 하루되세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-27-AdaptiveComposeLayouts"},"buildId":"RZIEBQ2aNAp_DXFVTV6eL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>