<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Apple Vision Pro 디자인하기 Puzzling Places에서 배운 교훈 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-22-DesigningforAppleVisionProLessonsLearnedfromPuzzlingPlaces" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Apple Vision Pro 디자인하기 Puzzling Places에서 배운 교훈 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Apple Vision Pro 디자인하기 Puzzling Places에서 배운 교훈 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-DesigningforAppleVisionProLessonsLearnedfromPuzzlingPlaces_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-22-DesigningforAppleVisionProLessonsLearnedfromPuzzlingPlaces" data-gatsby-head="true"/><meta name="twitter:title" content="Apple Vision Pro 디자인하기 Puzzling Places에서 배운 교훈 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-DesigningforAppleVisionProLessonsLearnedfromPuzzlingPlaces_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 23:57" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/YUMR4jSyk_WlOHHc7UfOk/_buildManifest.js" defer=""></script><script src="/_next/static/YUMR4jSyk_WlOHHc7UfOk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Apple Vision Pro 디자인하기 Puzzling Places에서 배운 교훈</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Apple Vision Pro 디자인하기 Puzzling Places에서 배운 교훈" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">13<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-DesigningforAppleVisionProLessonsLearnedfromPuzzlingPlaces&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>애플 비전 프로는 새로운 디자인 도전 과제를 제시합니다. 여기에는 Apple Vision Pro를 위해 Puzzling Places를 처음부터 다시 디자인하는 과정에서 배운 몇 가지 교훈이 있습니다.</p>
<p>이 글에서는 주로 디바이스를 위해 디자인하고 싶은 모든 것에 적용할 수 있는 우리가 배운 일반적인 교훈을 다룰 것입니다. 이외에도 Puzzling Places의 게임 루프에 특화된 몇 가지 교훈이 수반될 것입니다. 디자인 도전 과제뿐만 아니라 기술적 측면에 대해서도 간단히 다루겠습니다.</p>
<p>간단한 고지: 여기서 읽는 내용은 주관적인 의견을 반영하며 Apple의 공식 입장을 대변하는 것이 아닙니다. 맥락을 이해하기 위해 게임 루프의 짧은 예고편이 여기 있습니다.</p>
<h2>새로운 플랫폼</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>애플의 AR 시장 진출은 많은 기대를 받고 있었습니다. 그래서 우리는 이 게임을 새로운 헤드셋으로 이식하기로 결정했습니다. 일반적으로 VR 헤드셋 간의 이식 과정은 기술 백엔드를 조정하여 새 플랫폼에서 작동하도록 하는 것이지만, 대부분 디자인은 그대로 유지합니다. 그러나 우리가 헤드셋에 대해 알아갈수록, 이것이 실제로 진정한 의미의 새로운 플랫폼일 수도 있다고 생각했습니다. 공식적으로 애플은 AR이나 VR에 대해 이야기하지 않고, 공간 컴퓨팅에 대해 언급합니다. 그 중 일부는 마케팅이지만, 퀘스트 3과 같은 것과 비교하여 이 헤드셋이 어떻게 설계되었는지에는 몇 가지 실제적인 차이가 있습니다. 그래서 이 플랫폼에 디자인을 시작하기 전에는 이것이 실제로 무엇을 의미하는지 생각하는 가치가 있습니다.</p>
<p>지금 당장은 Apple Vision Pro를 위해 만들 수 있는 앱 유형이 세 가지라고 말할 수 있습니다. 이것은 윈도우, 바운드 및 언바운드입니다. 바운드 및 언바운드는 유니티 용어입니다. 기술적으로는 분할이 없습니다. Apple 측에서는 Shared 또는 Full Space에서 생성될 수 있는 창 또는 볼륨이 있습니다. 앱은 이러한 요소들을 각기 다른 방식으로 결합할 수 있습니다. 예를 들어, 여러 창을 함께 다양한 방식으로 볼륨들과 결합할 수 있습니다. 사용자의 필요에 따라 이들 간을 전환하여 매우 창의적일 수 있습니다. 따라서 참조한 페이지를 읽으면 실제 분할은 콘텐츠가 어떻게 표현되는지(2D 창 또는 3D 볼륨) 및 어느 공간에 있는지(다른 앱과 공유되는 공간 또는 완전히 독립된 공간)과 Passthrough 또는 혼합된 VR 환경 여부 사이에 있음을 알 수 있습니다.</p>
<p>실제로 우리에게는 2D(윈도우), 바운드(공유 공간의 하나의 볼륨) 및 언바운드(풀 스페이스의 하나의 볼륨) 사이에서 선택해야 했던 문제였습니다. 이들이 실제 옵션으로 선택된 이유는 대부분 제한된 시간과 예산 및 유니티 엔진을 사용하는 기술적 한계에 있었습니다. 추후 자세한 내용은 뒤에서 다루겠습니다.</p>
<p>VR에서 AVP로 디자인을 이동하려면, 가장 간단한 해결책은 풀 스페이스를 사용하는 것입니다. 당신은 자신만의 헤드셋을 사용하여 Passthrough 환경이나 완전히 가상 환경을 만들 수 있습니다. 해야 할 일은 컨트롤러 기반 상호작용 대신 손/눈 추적을 고려하여 디자인하는 것뿐입니다. 그렇게 하면 원만하게 작동할 것입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Unbounded/Full Space은 많은 이점을 가지고 있지만, 한 가지 주요 단점이 있습니다: 사용자가 사용자와 나란히 애플리케이션을 열 수 없다는 것입니다.</p>
<p>퀘스트 3의 Puzzling Places에서 가장 많이 요청되는 기능 중 하나는 음악을 듣거나 YouTube 비디오를 시청하거나 오디오북을 듣는 기능입니다. 이러한 기능은 우리에게 매우 비싸게 들어갈 수 있는데, 그것들은 Apple Vision Pro에서만 작동합니다. 당신의 앱이 바운드되어 있고 공유 공간에 있는 경우, 사용자는 퍼즐을 즐기는 동안 원하는 대로 활동할 수 있습니다. 더 긴 퍼즐을 해결하는 동안 FaceTime에서 미팅에 참여하는 능력은 매우 자연스럽고 마법 같이 느껴집니다. Apple이 공간 컴퓨팅을 언급할 때, 아마도 그것이 의미하는 것일 겁니다. AVP는 VR 헤드셋이 아닙니다, 하드웨어 때문이 아니라 생태계 때문에 그렇습니다. Apple은 그것을 얼굴에 착용한 개인용 컴퓨터로 보는 것으로 보입니다. 당신이 많은 일을 할 수 있는 그런 장치입니다.</p>
<p>이전에 언급한 대로, 이상적으로는 사용자가 상호작용할 수 있는 다양한 방법을 모두 지원하는 것이 좋습니다, 공유 공간이든 전체 공간이든 말이죠. 하지만 현실적으로 하나에 집중할 시간이 있어서, 우리는 헤드셋을 위한 Apple의 비전에 맞추기로 결정했고, 헤드셋을 특별하게 만드는 것에 집중했으며, 이미 작동하는 것을 그대로 옮기기보다는 게임 루프에 새로운 것을 배우기로 했습니다.</p>
<p>그러나 앱이 어떤 공간에 있는지를 선택하는 것은 그저 시작에 불과합니다. 이미 장치에 대한 Apple의 비전과 일치하도록 결정했기 때문에, 게임을 위한 제어 패러다임을 디자인하는 것이 더 쉬웠습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>직접 및 간접적인 제어</h1>
<p>지난 몇 년 동안 놀라운 일 중 하나는 비게이머들에게도 VR 게임이 얼마나 접근하기 쉽다는 것입니다. 그 이유 중 하나는 아마도 VR의 주요 제어 패러다임이 '직접 제어'라는 것일 것입니다. 이는 게임을 직접적으로 몸으로 체험하여 플레이하는 것이라는 멋진 말입니다. 이러한 제어 형태는 매우 직관적이며, 모두가 자신의 몸을 사용하는 방법을 알기 때문입니다.</p>
<p>AVP의 운영 체제 및 공유 공간을 위한 제어 패러다임은 거의 정 반대입니다. 상호 작용하려는 대상을 살펴보고 핀치(pinch)하는 것입니다. 당신의 눈을 마우스 커서로, 핀치를 마우스 왼쪽 클릭으로 생각할 수 있습니다. 이를 애플은 '간접적인 제어'라고 합니다. 직접적인 제어가 직관적이라면, 간접적인 제어는 배워야 합니다. AVP와 상호 작용이 어색하다는 느낌은 아니지만, 선택을 핀치하여 하는 방법이나 손 위치의 이해는 즉시 이해되지 않습니다.</p>
<p>게임에 따라 직접 제어와 간접 제어를 모두 동등하게 지원할 수 있습니다. 그러나 주요 상호 작용 모드 중 하나를 선택하여 더 많은 예산을 들여 그 부분을 개선해야 할 것입니다. 그렇다면 어느 것을 선택하시겠습니까?</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>AVP의 간접 제어는 배워야 할 필요가 있습니다. 하지만 그것이 나쁜 것은 아닙니다. 비디오 게임에서 아날로그 스틱이 처음 소개된 것과 마찬가지로 일부 기자들은 그겼더라도 이들이 익히기에 너무 복잡하다고 주장했습니다. 그러나 현재, 대부분의 게임은 컨트롤러로 플레이됩니다. 심지어 마우스 커서와 운영 체제와의 상호 작용도 익히는 데 시간이 필요합니다.</p>
<p>이러한 상호 작용 시스템이 왜 이렇게 널리 사용되는 것일까요? 저는 그것들이 매우 다목적이며 게으름을 허용한다는 두 가지 주요 이유가 있다고 믿습니다. AVP 간접 제어는 나에게 둘 다 해당됩니다. 실제 세계에서 거의 한 칸도 옮기지 않으면서 많은 일을 할 수 있습니다. 직접적인 제어는 투명한 물리적 인터페이스를 갖고 있는 반면 간접 제어는 투명한 개념적 인터페이스를 가지고 있습니다!</p>
<p>우리가 한 공유 공간에서 경계가 있는 부피로 만족한다면, 좋은 간접 제어를 활성화할 수밖에 없습니다. 사용자가 볼륨 내부에 있어서가 아니라 그 방향을 향해 있어야 한다는 점 때문입니다. 기본 설정에서 볼륨은 사용자로부터 한 미터 정도 떨어진 곳에 생성될 것입니다. 이 거리 때문에 사용자가 게임 세계를 직접 이동과 게임 플레이로 매핑하는 입력 방법을 통해 조작할 수 없습니다. 경계가 있는 공유 공간에서 볼륨을 신체적으로 상호 작용하는 물리적 공간 대신 3D 공간 모니터로 생각할 수 있습니다.</p>
<p>Puzzling Places의 경우, 게임 플레이 방식이 변경되었다는 것을 의미했습니다. VR 버전에서 퍼즐을 조각으로 걸어가거나 퍼즐을 당겨오는 방식으로 진행합니다. 올바른 방향으로 조각을 물리적으로 회전시키고 올바른 위치에 물리적으로 놓습니다. 말할 필요도 없이 게임 필드가 팔 길이 밖에 있을 경우 그렇게 게임을 할 수 없습니다. 따라서 우리는 게임 루프를 변경했습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>어떤 앵커 역할을 하는 중심 부분이 있습니다. 이 앵커는 공용 공간의 볼륨에 미터 정도 떨어진 곳에 배치됩니다. 중심 부분과 연결할 수 있는 여러 조각들이 제시됩니다. 연결하고 싶은 조각을 보고, 그 조각을 끌어 마우스로 드래그하는 것처럼 조각을 놓을 위치에 끌어올립니다. 당신의 움직임은 마우스처럼 2D 평면 상에서 이루어지지만, 게임 로직은 깊이와 올바른 방향을 자동으로 계산합니다!</p>
<p>이를 통해 당신은 200조각 짜리 퍼즐을 사무실 책상 위에서 풀 수 있고, 마우스를 움직이는 것만큼 손을 움직일 필요가 없습니다.</p>
<p>간접 제어를 위해 디자인하는 것은 마우스나 컨트롤러를 위해 디자인하는 방식으로 돌아가는 것을 의미합니다. 플레이어의 물리적 움직임을 가상 세계로 일대일로 매핑하는 대신, 약간의 움직임만으로 게임 세계에서 많은 가능성을 열어주는 방식으로 다시 매핑합니다.</p>
<p>이 제어 체계는 주로 눈 추적에 의존하며, 눈 추적을 통해 흥미로운 정보들을 발견하게 되었습니다!</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>Eyetracking의 문제점</h1>
<p>AVP의 eyetracking은 실제로 매우 안정적입니다. 기술적으로는 내 시선이 어디를 보고 있는지를 결코 잘못 파악하지 않지만, 여전히 패러다임에는 몇 가지 재미있는 문제가 있습니다.</p>
<p><strong>일련의 의도 문제</strong>라고 부르고 싶은 가장 두드러진 문제는 무언가를 선택하려면 그 곳을 봐야 한다는 것입니다. 이는 일부 작업을 순차적으로만 수행할 수 있다는 것을 의미합니다. 이것은 크게 중요해 보이지 않을 수 있지만, 컴퓨터를 사용할 때 얼마나 자주 두 가지 이상의 작업을 동시에 하는지에 놀랐습니다. 예를 들어, 어딘가를 보면서 다른 곳을 클릭하는 것과 같은 여러 가지 작업을 한 번에 수행할 때 가장 많은 막힘을 느꼈습니다.
AVP에서 익숙해지는 데 시간이 걸립니다. 이는 AVP로 멀티태스킹을 못 한다는 뜻이 아니라 기기에 의도를 순차적으로 전달할 수 있다는 것을 의미합니다.</p>
<p>예를 들어, 오른손으로 퍼즐 조각을 선택하고 바로 왼손으로 다른 것을 선택하는 것처럼 두 손에 든 조각을 사용하여 동시에 여러 작업을 수행할 수 있습니다. 그러나 눈을 입력 방법으로 사용하는 모든 것은 인터랙션을 대역폭 제한 인터페이스를 통해 진행해야 한다는 것을 의미합니다.</p>
<p>또한 우리의 눈이 어디를 보는지를 기반으로 우리의 의도를 가정하는 데 추가적인 문제가 있습니다. Saccadic masking과 시각적으로 산만한 것들이 가장 두드러진 문제였습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우리의 눈은 일반적으로 삽시적으로 움직입니다. 즉, 빠르고 이산적인 움직임으로 이동합니다. 당연히 이것이 우리가 세계를 지각하는 방식은 아닙니다. 우리의 시각은 부드럽고 지속적인 느낌을 줍니다. 이것은 일종의 후처리인 삽시적 가리기로 인해 발생하는 것인데, 시각 데이터를 왜곡하여 부드러운 전환을 만들 뿐만 아니라 기억을 되짚어 삽시적 움직임의 증거를 가리기 위해 변경합니다. 이것은 눈 추적에 대한 좋지 않은 소식입니다. 우리가 어디를 바라보고 있었는지 생각했던 곳이 실제로 눈이 향하고 있던 곳이 아닐 수도 있습니다! 입력을 활성화하려고 눌렀을 때 과거나 현재에 대해 뇌가 당신에게 거짓말을 하는 것을 명백히 깨닫게 됩니다. 이것은 미묘하게 표현되지만, 저는 이를 전혀 적응하지 못했던 감정이었습니다.</p>
<p>두 번째 문제는 우리의 눈이 여전히 의식 밖에서 때로는 생존을 보장하기 위해 반응하는 감각 입력 방법이라는 점입니다. 빠른 움직임, 매력적인 시각적 자극 또는 부호나 텍스트와 같은 고수준 시멘틱 요소들이 게임 플레이에서 내 눈을 끌어당겼는데, 내가 아무것도 할 수 없는 상황이 발생하는 것입니다. 이와는 별개로, 뇌가 눈이 실제로 하는 일과 병렬 또는 분리되어 동작을 대기열에 넣는 것처럼 보입니다. 예를 들어, 내가 한 조각을 집고 싶다고 결정하면 손가락에 집기 명령을 보내고 눈에는 "그 조각을 보라" 를 명령합니다. 이 과정에서 어떤 이유로 인해 내 눈은 오른쪽의 버튼으로 이동하여 그 버튼에 적힌 내용을 읽으려고 합니다. 버튼에는 "재시작" 이라고 적혀 있습니다. 그것을 보고 있는 동안, 손가락으로 실행된 집기 명령이 AVP에서 수행되어 게임 루프로 전달됩니다. 그 결과, 내 진행 상황이 다시 시작됩니다. 그런 상황이 발생할 때마다 웃음이 나왔습니다!</p>
<p>그 자체로 컴퓨팅과 지연 시간이 이러한 문제를 가지게 되었음에 실제로 흥미로운 사실입니다! 이것이 디자인 측면에서 의미하는 바는 무엇일까요? 위에 언급된 문제들에는 동일한 해결책이 있습니다. 다음과 같은 요소들로 결정됩니다: 1. 게임과 상호작용의 템포 2. 시각적 요소들 간의 거리 3. 잘못된 긍정의 비용.</p>
<p>첫 번째로, 눈 추적 및 집기 조합으로 플레이어에게 요구되는 더 빠른 반응 시간일수록 뭔가 잘못될 가능성이 높아집니다. 눈 추적을 사용한 빠른 속도의 게임을 가질 수 없다는 것이 아닙니다. 단지 게임 플레이와 관련된 반응 시간이 눈/뇌가 하는 다른 일과 심각하게 겹치는 경우에 문제가 발생할 수 있다는 것입니다. 둘째, 눈 공간에서 상호작용할 수 있는 객체들 사이의 거리가 멀수록 이러한 문제가 발생할 확률이 낮아집니다. 흥미로운 점은 우리가 다양한 알려지지 않은 요소들을 고려하기 위해 아날로그 스틱 제어 입력에 "데드 존"을 구축하는 것처럼, 장면에서 상호작용할 수 있는 물체들 간에 물리적인 최소 거리를 제공함으로써 눈의 이상한 행동을 고려할 수 있다는 점입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>마지막으로, 잘못된 긍정적인 결과의 비용이 얼마나 큰지 평가하고 그것을 줄일 수 있는지 알 수 있습니다. 실수로 재시작 버튼을 누르는 것은 정말 최악이에요! 그러나 사용자가 누른 후에 추가 확인 창이 표시된다면, 그저 귀찮은 일이 되는 것뿐입니다. 우리 게임의 한 예는 선반 위의 조각들 간을 바꾸는 방법이었습니다. OS 디자인에 맞추기 위해 먼저 스와이프 동작을 사용하기로 결정했지만, 선반 배경과 조각들이 너무 가까워서 스와이프하는 동안 실수로 조각을 선택하는 경우가 있었습니다. 이로 인해 조각이 왼쪽이나 오른쪽으로 던져지면서 불편한 애니메이션이 발생했습니다. 그 대신에 버튼으로 전환했습니다. 이제 사용자가 버튼을 선택하고 실수로 조각을 선택하는 경우, 잘못된 소리가 재생되고 조각이 교체되지 않는 것 이외에는 아무 일도 일어나지 않습니다.</p>
<h1>공유 공간은 모든 것을 공유</h1>
<p>공유 공간을 고려할 때 직면할 도전 중 하나는 앱이 다른 앱 옆에서 매끄럽게 실행될 때 무엇을 의미하는지입니다. 가장 명백한 함의는 컴퓨팅 리소스가 공유된다는 것이므로 전체 처리 능력이 앱에 특화되어 있다고 가정해서는 안 된다는 것입니다.</p>
<p>그러나 인지적 부담과 같은 추가적인 함의도 있습니다. 공유 공간을 위해 디자인하는 경우, 사람들이 당신의 앱을 다른 앱 옆에서 사용할 것으로 의도된다는 것을 의미합니다. 그렇지 않은 경우, 왜 Full Space로 가려하지 않고 추가 작업을 하려고 하는 걸까요? 그렇게 하려면 게임 루프의 인지 부담이 사용자가 FaceTime으로 회의에 참석하거나 작업 문제에 대해 생각할 수 있는 정신적 처리 능력을 남겨두도록 해야 합니다. 이것은 AVP를 위해 Puzzling Places의 루프를 단순화하기로 결정한 이유 중 하나였습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다른 앱들에게 숨 쉬는 공간을 남기는 것은 게임의 모든 영역에서 사용하는 패턴입니다. 사운드스케이프를 디자인하는 동안 다른 앱들도 약간의 소리를 생산할 뿐만 아니라 사용자가 결정할 수 있는 Apple 환경에서도 소리를 내게 될 수 있음을 염두에 두어야 합니다.</p>
<p>소리에 대해 이야기할 때, AVP는 Passthrough에서 충분히 좋아서 소리 스케이프의 합성 반향 프로필이 내가 보고 있는 공간과 일치하지 않을 때 이상하다고 느낄 정도입니다. 이런 일이 발생하지 않는 예로는 Quest 3 Passthrough가 있습니다.</p>
<h1>기술적인 제한 사항</h1>
<p>이 블로그 글을 쓸 당시, 당신이 게임을 개발하고 싶은 위치를 결정해야 하는 첫 번째 결정은 어디에서 게임을 개발할지입니다. 네이티브 Swift / RealitityKit 조합 또는 Unity Engine 중 하나를 선택할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우리에게는 네이티브 Swift가 사실 유효한 옵션이 아니었어요. 왜냐면 애플용으로 개발한 경험이 없었거든요. 매우 촉박한 개발 시간을 고려하면, 적어도 계산할 수 있는 위험성이 있는 생태계를 유지하는 것이 더 합리적이었어요. 하지만 Swift 경험이 있으면, 원하신다면 게임을 네이티브로 개발하는 데 많은 이점이 있을 거예요.</p>
<p>가장 큰 제한은 기능에 있어요. Unity에는 AVP로 제한 사항이 몇 가지 있었어요. 예를 들어, 공간 오디오의 부족, 한 번에 하나의 볼륨만 지원하거나 기본 Swift UI 기능에 액세스할 수 없는 등입니다. 이러한 제약 사항 중 일부는 애플 측면, 일부는 Unity 측면, 일부는 AVP 렌더링 아키텍처가 작동하는 방식에 있습니다. 그러나 어쨌든, 언제든지 참여를 결정하더라도, 대부분의 서드파티 라이브러리는 최신 네이티브 기능보다 조금 뒤쳐질 것입니다.</p>
<p>Unity에서 게임을 만들면, Unity는 게임을 두 부분으로 분할하겠죠. 게임 로직은 대부분 CPP 라이브러리로 컴파일되어 주요 게임 루프가 있는 곳에 위치하며, 프로그램을 초기화하는 Swift 코드가 조율됩니다. 씬은 Apple 백엔드가 이해하는 형식으로 변환되며, 관련 구성 요소는 다양한 Apple 구성 요소로 매핑됩니다. Apple은 다른 방식으로 작업하기 때문에, Unity 구성 요소는 당연히 최종 결과물과 일치하지 않아요. 이것은 귀찮은 일입니다.</p>
<p>렌더링 관련해서 일부 머티리얼은 MaterialX로 변환됩니다. 이들은 Apple이 제공한 셰이더의 다양한 PBR 기능을 활용할 수 있을 뿐 아니라, Unity에서 사용할 수 없는 정보를 많이 활용할 수 있어요. 반면, 내 테스트 결과로는 이러한 셰이더가 Metal에서 컴파일할 수 있는 사용자 정의 셰이더보다 훨씬 비용이 많이 듭니다. 성능과 렌더링에 대해 말하자면, AVP의 성능은 어느 정도일까요? 제게는 아이디어가 없네요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>하드웨어 측면에서, AVP는 분명히 현재 시장에서 가장 강력한 상용 헤드셋입니다. 그러나 매우 높은 해상도, 프레임 속도, 그리고 지연 시간을 가지고 있습니다. 따라서 여전히 채움율이 문제가 될 수 있습니다. 렌더링은 Apple 프로세스로 처리되고 게임 로직은 Unity CPP 코드에서 발생하기 때문에 항상 어느 쪽이 지연을 일으키는 원인인지를 파악해야 합니다. 더 나빠진 점은 Unity 코드를 프로파일링할 수 있지만, Apple 측이 무엇을 하는지에 대한 정보는 제공되지 않는다는 것입니다. 현재 Xcode 프로파일러는 상당히 제한된 기능을 가지고 있습니다. Apple 측에서 렌더링이 얼마나 많이 소요되는지에 대한 정보를 더 얻고 싶었을 것입니다.</p>
<p>제한사항에 대해 이야기하자면, 액세스할 수 있는 데이터에 관한 많은 제한이 있습니다. 이는 특히 공유 공간 및 사용자가 전용 볼륨 외부에 있는 경우에 심각한데요. 사용자의 눈이 어디를 보고 있는지 알 필요가 없는 이유에 대한 데이터 보호 관점에서 이해할 수 있지만, 카메라 위치와 같은 정보는 게임 개발에 매우 관련이 있습니다. 예를 들어, 미래에는 눈이 호버링하는 요소들의 하이라이트 행동을 예술적으로 조정할 수 있는 방법이 있었으면 좋겠습니다.</p>
<p>Apple Vision Pro에는 이를 활용하는 방법에 대한 많은 아이디어가 있습니다. 이를 위해 디자인할 때, 어디까지 해당 아이디어들과 조화를 이룰 것인지를 결정해야 합니다. 시간이 경과함에 따라 이러한 아이디어 중 몇 개가 남을지, 얼마나 많이 잊힐지가 결정될 것입니다.</p>
<p>읽어주셔서 감사합니다. 계속해서 아래 내 소셜 미디어를 팔로우하실 수 있습니다: <a href="https://ircss.github.io/" rel="nofollow" target="_blank">https://ircss.github.io/</a></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Apple Vision Pro 디자인하기 Puzzling Places에서 배운 교훈","description":"","date":"2024-06-22 23:57","slug":"2024-06-22-DesigningforAppleVisionProLessonsLearnedfromPuzzlingPlaces","content":"\n애플 비전 프로는 새로운 디자인 도전 과제를 제시합니다. 여기에는 Apple Vision Pro를 위해 Puzzling Places를 처음부터 다시 디자인하는 과정에서 배운 몇 가지 교훈이 있습니다.\n\n이 글에서는 주로 디바이스를 위해 디자인하고 싶은 모든 것에 적용할 수 있는 우리가 배운 일반적인 교훈을 다룰 것입니다. 이외에도 Puzzling Places의 게임 루프에 특화된 몇 가지 교훈이 수반될 것입니다. 디자인 도전 과제뿐만 아니라 기술적 측면에 대해서도 간단히 다루겠습니다.\n\n간단한 고지: 여기서 읽는 내용은 주관적인 의견을 반영하며 Apple의 공식 입장을 대변하는 것이 아닙니다. 맥락을 이해하기 위해 게임 루프의 짧은 예고편이 여기 있습니다.\n\n## 새로운 플랫폼\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n애플의 AR 시장 진출은 많은 기대를 받고 있었습니다. 그래서 우리는 이 게임을 새로운 헤드셋으로 이식하기로 결정했습니다. 일반적으로 VR 헤드셋 간의 이식 과정은 기술 백엔드를 조정하여 새 플랫폼에서 작동하도록 하는 것이지만, 대부분 디자인은 그대로 유지합니다. 그러나 우리가 헤드셋에 대해 알아갈수록, 이것이 실제로 진정한 의미의 새로운 플랫폼일 수도 있다고 생각했습니다. 공식적으로 애플은 AR이나 VR에 대해 이야기하지 않고, 공간 컴퓨팅에 대해 언급합니다. 그 중 일부는 마케팅이지만, 퀘스트 3과 같은 것과 비교하여 이 헤드셋이 어떻게 설계되었는지에는 몇 가지 실제적인 차이가 있습니다. 그래서 이 플랫폼에 디자인을 시작하기 전에는 이것이 실제로 무엇을 의미하는지 생각하는 가치가 있습니다.\n\n지금 당장은 Apple Vision Pro를 위해 만들 수 있는 앱 유형이 세 가지라고 말할 수 있습니다. 이것은 윈도우, 바운드 및 언바운드입니다. 바운드 및 언바운드는 유니티 용어입니다. 기술적으로는 분할이 없습니다. Apple 측에서는 Shared 또는 Full Space에서 생성될 수 있는 창 또는 볼륨이 있습니다. 앱은 이러한 요소들을 각기 다른 방식으로 결합할 수 있습니다. 예를 들어, 여러 창을 함께 다양한 방식으로 볼륨들과 결합할 수 있습니다. 사용자의 필요에 따라 이들 간을 전환하여 매우 창의적일 수 있습니다. 따라서 참조한 페이지를 읽으면 실제 분할은 콘텐츠가 어떻게 표현되는지(2D 창 또는 3D 볼륨) 및 어느 공간에 있는지(다른 앱과 공유되는 공간 또는 완전히 독립된 공간)과 Passthrough 또는 혼합된 VR 환경 여부 사이에 있음을 알 수 있습니다.\n\n실제로 우리에게는 2D(윈도우), 바운드(공유 공간의 하나의 볼륨) 및 언바운드(풀 스페이스의 하나의 볼륨) 사이에서 선택해야 했던 문제였습니다. 이들이 실제 옵션으로 선택된 이유는 대부분 제한된 시간과 예산 및 유니티 엔진을 사용하는 기술적 한계에 있었습니다. 추후 자세한 내용은 뒤에서 다루겠습니다.\n\nVR에서 AVP로 디자인을 이동하려면, 가장 간단한 해결책은 풀 스페이스를 사용하는 것입니다. 당신은 자신만의 헤드셋을 사용하여 Passthrough 환경이나 완전히 가상 환경을 만들 수 있습니다. 해야 할 일은 컨트롤러 기반 상호작용 대신 손/눈 추적을 고려하여 디자인하는 것뿐입니다. 그렇게 하면 원만하게 작동할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nUnbounded/Full Space은 많은 이점을 가지고 있지만, 한 가지 주요 단점이 있습니다: 사용자가 사용자와 나란히 애플리케이션을 열 수 없다는 것입니다.\n\n퀘스트 3의 Puzzling Places에서 가장 많이 요청되는 기능 중 하나는 음악을 듣거나 YouTube 비디오를 시청하거나 오디오북을 듣는 기능입니다. 이러한 기능은 우리에게 매우 비싸게 들어갈 수 있는데, 그것들은 Apple Vision Pro에서만 작동합니다. 당신의 앱이 바운드되어 있고 공유 공간에 있는 경우, 사용자는 퍼즐을 즐기는 동안 원하는 대로 활동할 수 있습니다. 더 긴 퍼즐을 해결하는 동안 FaceTime에서 미팅에 참여하는 능력은 매우 자연스럽고 마법 같이 느껴집니다. Apple이 공간 컴퓨팅을 언급할 때, 아마도 그것이 의미하는 것일 겁니다. AVP는 VR 헤드셋이 아닙니다, 하드웨어 때문이 아니라 생태계 때문에 그렇습니다. Apple은 그것을 얼굴에 착용한 개인용 컴퓨터로 보는 것으로 보입니다. 당신이 많은 일을 할 수 있는 그런 장치입니다.\n\n이전에 언급한 대로, 이상적으로는 사용자가 상호작용할 수 있는 다양한 방법을 모두 지원하는 것이 좋습니다, 공유 공간이든 전체 공간이든 말이죠. 하지만 현실적으로 하나에 집중할 시간이 있어서, 우리는 헤드셋을 위한 Apple의 비전에 맞추기로 결정했고, 헤드셋을 특별하게 만드는 것에 집중했으며, 이미 작동하는 것을 그대로 옮기기보다는 게임 루프에 새로운 것을 배우기로 했습니다.\n\n그러나 앱이 어떤 공간에 있는지를 선택하는 것은 그저 시작에 불과합니다. 이미 장치에 대한 Apple의 비전과 일치하도록 결정했기 때문에, 게임을 위한 제어 패러다임을 디자인하는 것이 더 쉬웠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 직접 및 간접적인 제어\n\n지난 몇 년 동안 놀라운 일 중 하나는 비게이머들에게도 VR 게임이 얼마나 접근하기 쉽다는 것입니다. 그 이유 중 하나는 아마도 VR의 주요 제어 패러다임이 '직접 제어'라는 것일 것입니다. 이는 게임을 직접적으로 몸으로 체험하여 플레이하는 것이라는 멋진 말입니다. 이러한 제어 형태는 매우 직관적이며, 모두가 자신의 몸을 사용하는 방법을 알기 때문입니다.\n\nAVP의 운영 체제 및 공유 공간을 위한 제어 패러다임은 거의 정 반대입니다. 상호 작용하려는 대상을 살펴보고 핀치(pinch)하는 것입니다. 당신의 눈을 마우스 커서로, 핀치를 마우스 왼쪽 클릭으로 생각할 수 있습니다. 이를 애플은 '간접적인 제어'라고 합니다. 직접적인 제어가 직관적이라면, 간접적인 제어는 배워야 합니다. AVP와 상호 작용이 어색하다는 느낌은 아니지만, 선택을 핀치하여 하는 방법이나 손 위치의 이해는 즉시 이해되지 않습니다.\n\n게임에 따라 직접 제어와 간접 제어를 모두 동등하게 지원할 수 있습니다. 그러나 주요 상호 작용 모드 중 하나를 선택하여 더 많은 예산을 들여 그 부분을 개선해야 할 것입니다. 그렇다면 어느 것을 선택하시겠습니까?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAVP의 간접 제어는 배워야 할 필요가 있습니다. 하지만 그것이 나쁜 것은 아닙니다. 비디오 게임에서 아날로그 스틱이 처음 소개된 것과 마찬가지로 일부 기자들은 그겼더라도 이들이 익히기에 너무 복잡하다고 주장했습니다. 그러나 현재, 대부분의 게임은 컨트롤러로 플레이됩니다. 심지어 마우스 커서와 운영 체제와의 상호 작용도 익히는 데 시간이 필요합니다.\n\n이러한 상호 작용 시스템이 왜 이렇게 널리 사용되는 것일까요? 저는 그것들이 매우 다목적이며 게으름을 허용한다는 두 가지 주요 이유가 있다고 믿습니다. AVP 간접 제어는 나에게 둘 다 해당됩니다. 실제 세계에서 거의 한 칸도 옮기지 않으면서 많은 일을 할 수 있습니다. 직접적인 제어는 투명한 물리적 인터페이스를 갖고 있는 반면 간접 제어는 투명한 개념적 인터페이스를 가지고 있습니다!\n\n우리가 한 공유 공간에서 경계가 있는 부피로 만족한다면, 좋은 간접 제어를 활성화할 수밖에 없습니다. 사용자가 볼륨 내부에 있어서가 아니라 그 방향을 향해 있어야 한다는 점 때문입니다. 기본 설정에서 볼륨은 사용자로부터 한 미터 정도 떨어진 곳에 생성될 것입니다. 이 거리 때문에 사용자가 게임 세계를 직접 이동과 게임 플레이로 매핑하는 입력 방법을 통해 조작할 수 없습니다. 경계가 있는 공유 공간에서 볼륨을 신체적으로 상호 작용하는 물리적 공간 대신 3D 공간 모니터로 생각할 수 있습니다.\n\nPuzzling Places의 경우, 게임 플레이 방식이 변경되었다는 것을 의미했습니다. VR 버전에서 퍼즐을 조각으로 걸어가거나 퍼즐을 당겨오는 방식으로 진행합니다. 올바른 방향으로 조각을 물리적으로 회전시키고 올바른 위치에 물리적으로 놓습니다. 말할 필요도 없이 게임 필드가 팔 길이 밖에 있을 경우 그렇게 게임을 할 수 없습니다. 따라서 우리는 게임 루프를 변경했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어떤 앵커 역할을 하는 중심 부분이 있습니다. 이 앵커는 공용 공간의 볼륨에 미터 정도 떨어진 곳에 배치됩니다. 중심 부분과 연결할 수 있는 여러 조각들이 제시됩니다. 연결하고 싶은 조각을 보고, 그 조각을 끌어 마우스로 드래그하는 것처럼 조각을 놓을 위치에 끌어올립니다. 당신의 움직임은 마우스처럼 2D 평면 상에서 이루어지지만, 게임 로직은 깊이와 올바른 방향을 자동으로 계산합니다!\n\n이를 통해 당신은 200조각 짜리 퍼즐을 사무실 책상 위에서 풀 수 있고, 마우스를 움직이는 것만큼 손을 움직일 필요가 없습니다.\n\n간접 제어를 위해 디자인하는 것은 마우스나 컨트롤러를 위해 디자인하는 방식으로 돌아가는 것을 의미합니다. 플레이어의 물리적 움직임을 가상 세계로 일대일로 매핑하는 대신, 약간의 움직임만으로 게임 세계에서 많은 가능성을 열어주는 방식으로 다시 매핑합니다.\n\n이 제어 체계는 주로 눈 추적에 의존하며, 눈 추적을 통해 흥미로운 정보들을 발견하게 되었습니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Eyetracking의 문제점\n\nAVP의 eyetracking은 실제로 매우 안정적입니다. 기술적으로는 내 시선이 어디를 보고 있는지를 결코 잘못 파악하지 않지만, 여전히 패러다임에는 몇 가지 재미있는 문제가 있습니다.\n\n**일련의 의도 문제**라고 부르고 싶은 가장 두드러진 문제는 무언가를 선택하려면 그 곳을 봐야 한다는 것입니다. 이는 일부 작업을 순차적으로만 수행할 수 있다는 것을 의미합니다. 이것은 크게 중요해 보이지 않을 수 있지만, 컴퓨터를 사용할 때 얼마나 자주 두 가지 이상의 작업을 동시에 하는지에 놀랐습니다. 예를 들어, 어딘가를 보면서 다른 곳을 클릭하는 것과 같은 여러 가지 작업을 한 번에 수행할 때 가장 많은 막힘을 느꼈습니다.\nAVP에서 익숙해지는 데 시간이 걸립니다. 이는 AVP로 멀티태스킹을 못 한다는 뜻이 아니라 기기에 의도를 순차적으로 전달할 수 있다는 것을 의미합니다.\n\n예를 들어, 오른손으로 퍼즐 조각을 선택하고 바로 왼손으로 다른 것을 선택하는 것처럼 두 손에 든 조각을 사용하여 동시에 여러 작업을 수행할 수 있습니다. 그러나 눈을 입력 방법으로 사용하는 모든 것은 인터랙션을 대역폭 제한 인터페이스를 통해 진행해야 한다는 것을 의미합니다.\n\n또한 우리의 눈이 어디를 보는지를 기반으로 우리의 의도를 가정하는 데 추가적인 문제가 있습니다. Saccadic masking과 시각적으로 산만한 것들이 가장 두드러진 문제였습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리의 눈은 일반적으로 삽시적으로 움직입니다. 즉, 빠르고 이산적인 움직임으로 이동합니다. 당연히 이것이 우리가 세계를 지각하는 방식은 아닙니다. 우리의 시각은 부드럽고 지속적인 느낌을 줍니다. 이것은 일종의 후처리인 삽시적 가리기로 인해 발생하는 것인데, 시각 데이터를 왜곡하여 부드러운 전환을 만들 뿐만 아니라 기억을 되짚어 삽시적 움직임의 증거를 가리기 위해 변경합니다. 이것은 눈 추적에 대한 좋지 않은 소식입니다. 우리가 어디를 바라보고 있었는지 생각했던 곳이 실제로 눈이 향하고 있던 곳이 아닐 수도 있습니다! 입력을 활성화하려고 눌렀을 때 과거나 현재에 대해 뇌가 당신에게 거짓말을 하는 것을 명백히 깨닫게 됩니다. 이것은 미묘하게 표현되지만, 저는 이를 전혀 적응하지 못했던 감정이었습니다.\n\n두 번째 문제는 우리의 눈이 여전히 의식 밖에서 때로는 생존을 보장하기 위해 반응하는 감각 입력 방법이라는 점입니다. 빠른 움직임, 매력적인 시각적 자극 또는 부호나 텍스트와 같은 고수준 시멘틱 요소들이 게임 플레이에서 내 눈을 끌어당겼는데, 내가 아무것도 할 수 없는 상황이 발생하는 것입니다. 이와는 별개로, 뇌가 눈이 실제로 하는 일과 병렬 또는 분리되어 동작을 대기열에 넣는 것처럼 보입니다. 예를 들어, 내가 한 조각을 집고 싶다고 결정하면 손가락에 집기 명령을 보내고 눈에는 \"그 조각을 보라\" 를 명령합니다. 이 과정에서 어떤 이유로 인해 내 눈은 오른쪽의 버튼으로 이동하여 그 버튼에 적힌 내용을 읽으려고 합니다. 버튼에는 \"재시작\" 이라고 적혀 있습니다. 그것을 보고 있는 동안, 손가락으로 실행된 집기 명령이 AVP에서 수행되어 게임 루프로 전달됩니다. 그 결과, 내 진행 상황이 다시 시작됩니다. 그런 상황이 발생할 때마다 웃음이 나왔습니다!\n\n그 자체로 컴퓨팅과 지연 시간이 이러한 문제를 가지게 되었음에 실제로 흥미로운 사실입니다! 이것이 디자인 측면에서 의미하는 바는 무엇일까요? 위에 언급된 문제들에는 동일한 해결책이 있습니다. 다음과 같은 요소들로 결정됩니다: 1. 게임과 상호작용의 템포 2. 시각적 요소들 간의 거리 3. 잘못된 긍정의 비용.\n\n첫 번째로, 눈 추적 및 집기 조합으로 플레이어에게 요구되는 더 빠른 반응 시간일수록 뭔가 잘못될 가능성이 높아집니다. 눈 추적을 사용한 빠른 속도의 게임을 가질 수 없다는 것이 아닙니다. 단지 게임 플레이와 관련된 반응 시간이 눈/뇌가 하는 다른 일과 심각하게 겹치는 경우에 문제가 발생할 수 있다는 것입니다. 둘째, 눈 공간에서 상호작용할 수 있는 객체들 사이의 거리가 멀수록 이러한 문제가 발생할 확률이 낮아집니다. 흥미로운 점은 우리가 다양한 알려지지 않은 요소들을 고려하기 위해 아날로그 스틱 제어 입력에 \"데드 존\"을 구축하는 것처럼, 장면에서 상호작용할 수 있는 물체들 간에 물리적인 최소 거리를 제공함으로써 눈의 이상한 행동을 고려할 수 있다는 점입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로, 잘못된 긍정적인 결과의 비용이 얼마나 큰지 평가하고 그것을 줄일 수 있는지 알 수 있습니다. 실수로 재시작 버튼을 누르는 것은 정말 최악이에요! 그러나 사용자가 누른 후에 추가 확인 창이 표시된다면, 그저 귀찮은 일이 되는 것뿐입니다. 우리 게임의 한 예는 선반 위의 조각들 간을 바꾸는 방법이었습니다. OS 디자인에 맞추기 위해 먼저 스와이프 동작을 사용하기로 결정했지만, 선반 배경과 조각들이 너무 가까워서 스와이프하는 동안 실수로 조각을 선택하는 경우가 있었습니다. 이로 인해 조각이 왼쪽이나 오른쪽으로 던져지면서 불편한 애니메이션이 발생했습니다. 그 대신에 버튼으로 전환했습니다. 이제 사용자가 버튼을 선택하고 실수로 조각을 선택하는 경우, 잘못된 소리가 재생되고 조각이 교체되지 않는 것 이외에는 아무 일도 일어나지 않습니다.\n\n# 공유 공간은 모든 것을 공유\n\n공유 공간을 고려할 때 직면할 도전 중 하나는 앱이 다른 앱 옆에서 매끄럽게 실행될 때 무엇을 의미하는지입니다. 가장 명백한 함의는 컴퓨팅 리소스가 공유된다는 것이므로 전체 처리 능력이 앱에 특화되어 있다고 가정해서는 안 된다는 것입니다.\n\n그러나 인지적 부담과 같은 추가적인 함의도 있습니다. 공유 공간을 위해 디자인하는 경우, 사람들이 당신의 앱을 다른 앱 옆에서 사용할 것으로 의도된다는 것을 의미합니다. 그렇지 않은 경우, 왜 Full Space로 가려하지 않고 추가 작업을 하려고 하는 걸까요? 그렇게 하려면 게임 루프의 인지 부담이 사용자가 FaceTime으로 회의에 참석하거나 작업 문제에 대해 생각할 수 있는 정신적 처리 능력을 남겨두도록 해야 합니다. 이것은 AVP를 위해 Puzzling Places의 루프를 단순화하기로 결정한 이유 중 하나였습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다른 앱들에게 숨 쉬는 공간을 남기는 것은 게임의 모든 영역에서 사용하는 패턴입니다. 사운드스케이프를 디자인하는 동안 다른 앱들도 약간의 소리를 생산할 뿐만 아니라 사용자가 결정할 수 있는 Apple 환경에서도 소리를 내게 될 수 있음을 염두에 두어야 합니다.\n\n소리에 대해 이야기할 때, AVP는 Passthrough에서 충분히 좋아서 소리 스케이프의 합성 반향 프로필이 내가 보고 있는 공간과 일치하지 않을 때 이상하다고 느낄 정도입니다. 이런 일이 발생하지 않는 예로는 Quest 3 Passthrough가 있습니다.\n\n# 기술적인 제한 사항\n\n이 블로그 글을 쓸 당시, 당신이 게임을 개발하고 싶은 위치를 결정해야 하는 첫 번째 결정은 어디에서 게임을 개발할지입니다. 네이티브 Swift / RealitityKit 조합 또는 Unity Engine 중 하나를 선택할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리에게는 네이티브 Swift가 사실 유효한 옵션이 아니었어요. 왜냐면 애플용으로 개발한 경험이 없었거든요. 매우 촉박한 개발 시간을 고려하면, 적어도 계산할 수 있는 위험성이 있는 생태계를 유지하는 것이 더 합리적이었어요. 하지만 Swift 경험이 있으면, 원하신다면 게임을 네이티브로 개발하는 데 많은 이점이 있을 거예요.\n\n가장 큰 제한은 기능에 있어요. Unity에는 AVP로 제한 사항이 몇 가지 있었어요. 예를 들어, 공간 오디오의 부족, 한 번에 하나의 볼륨만 지원하거나 기본 Swift UI 기능에 액세스할 수 없는 등입니다. 이러한 제약 사항 중 일부는 애플 측면, 일부는 Unity 측면, 일부는 AVP 렌더링 아키텍처가 작동하는 방식에 있습니다. 그러나 어쨌든, 언제든지 참여를 결정하더라도, 대부분의 서드파티 라이브러리는 최신 네이티브 기능보다 조금 뒤쳐질 것입니다.\n\nUnity에서 게임을 만들면, Unity는 게임을 두 부분으로 분할하겠죠. 게임 로직은 대부분 CPP 라이브러리로 컴파일되어 주요 게임 루프가 있는 곳에 위치하며, 프로그램을 초기화하는 Swift 코드가 조율됩니다. 씬은 Apple 백엔드가 이해하는 형식으로 변환되며, 관련 구성 요소는 다양한 Apple 구성 요소로 매핑됩니다. Apple은 다른 방식으로 작업하기 때문에, Unity 구성 요소는 당연히 최종 결과물과 일치하지 않아요. 이것은 귀찮은 일입니다.\n\n렌더링 관련해서 일부 머티리얼은 MaterialX로 변환됩니다. 이들은 Apple이 제공한 셰이더의 다양한 PBR 기능을 활용할 수 있을 뿐 아니라, Unity에서 사용할 수 없는 정보를 많이 활용할 수 있어요. 반면, 내 테스트 결과로는 이러한 셰이더가 Metal에서 컴파일할 수 있는 사용자 정의 셰이더보다 훨씬 비용이 많이 듭니다. 성능과 렌더링에 대해 말하자면, AVP의 성능은 어느 정도일까요? 제게는 아이디어가 없네요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하드웨어 측면에서, AVP는 분명히 현재 시장에서 가장 강력한 상용 헤드셋입니다. 그러나 매우 높은 해상도, 프레임 속도, 그리고 지연 시간을 가지고 있습니다. 따라서 여전히 채움율이 문제가 될 수 있습니다. 렌더링은 Apple 프로세스로 처리되고 게임 로직은 Unity CPP 코드에서 발생하기 때문에 항상 어느 쪽이 지연을 일으키는 원인인지를 파악해야 합니다. 더 나빠진 점은 Unity 코드를 프로파일링할 수 있지만, Apple 측이 무엇을 하는지에 대한 정보는 제공되지 않는다는 것입니다. 현재 Xcode 프로파일러는 상당히 제한된 기능을 가지고 있습니다. Apple 측에서 렌더링이 얼마나 많이 소요되는지에 대한 정보를 더 얻고 싶었을 것입니다.\n\n제한사항에 대해 이야기하자면, 액세스할 수 있는 데이터에 관한 많은 제한이 있습니다. 이는 특히 공유 공간 및 사용자가 전용 볼륨 외부에 있는 경우에 심각한데요. 사용자의 눈이 어디를 보고 있는지 알 필요가 없는 이유에 대한 데이터 보호 관점에서 이해할 수 있지만, 카메라 위치와 같은 정보는 게임 개발에 매우 관련이 있습니다. 예를 들어, 미래에는 눈이 호버링하는 요소들의 하이라이트 행동을 예술적으로 조정할 수 있는 방법이 있었으면 좋겠습니다.\n\nApple Vision Pro에는 이를 활용하는 방법에 대한 많은 아이디어가 있습니다. 이를 위해 디자인할 때, 어디까지 해당 아이디어들과 조화를 이룰 것인지를 결정해야 합니다. 시간이 경과함에 따라 이러한 아이디어 중 몇 개가 남을지, 얼마나 많이 잊힐지가 결정될 것입니다.\n\n읽어주셔서 감사합니다. 계속해서 아래 내 소셜 미디어를 팔로우하실 수 있습니다: https://ircss.github.io/\n","ogImage":{"url":"/assets/img/2024-06-22-DesigningforAppleVisionProLessonsLearnedfromPuzzlingPlaces_0.png"},"coverImage":"/assets/img/2024-06-22-DesigningforAppleVisionProLessonsLearnedfromPuzzlingPlaces_0.png","tag":["Tech"],"readingTime":13},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e애플 비전 프로는 새로운 디자인 도전 과제를 제시합니다. 여기에는 Apple Vision Pro를 위해 Puzzling Places를 처음부터 다시 디자인하는 과정에서 배운 몇 가지 교훈이 있습니다.\u003c/p\u003e\n\u003cp\u003e이 글에서는 주로 디바이스를 위해 디자인하고 싶은 모든 것에 적용할 수 있는 우리가 배운 일반적인 교훈을 다룰 것입니다. 이외에도 Puzzling Places의 게임 루프에 특화된 몇 가지 교훈이 수반될 것입니다. 디자인 도전 과제뿐만 아니라 기술적 측면에 대해서도 간단히 다루겠습니다.\u003c/p\u003e\n\u003cp\u003e간단한 고지: 여기서 읽는 내용은 주관적인 의견을 반영하며 Apple의 공식 입장을 대변하는 것이 아닙니다. 맥락을 이해하기 위해 게임 루프의 짧은 예고편이 여기 있습니다.\u003c/p\u003e\n\u003ch2\u003e새로운 플랫폼\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e애플의 AR 시장 진출은 많은 기대를 받고 있었습니다. 그래서 우리는 이 게임을 새로운 헤드셋으로 이식하기로 결정했습니다. 일반적으로 VR 헤드셋 간의 이식 과정은 기술 백엔드를 조정하여 새 플랫폼에서 작동하도록 하는 것이지만, 대부분 디자인은 그대로 유지합니다. 그러나 우리가 헤드셋에 대해 알아갈수록, 이것이 실제로 진정한 의미의 새로운 플랫폼일 수도 있다고 생각했습니다. 공식적으로 애플은 AR이나 VR에 대해 이야기하지 않고, 공간 컴퓨팅에 대해 언급합니다. 그 중 일부는 마케팅이지만, 퀘스트 3과 같은 것과 비교하여 이 헤드셋이 어떻게 설계되었는지에는 몇 가지 실제적인 차이가 있습니다. 그래서 이 플랫폼에 디자인을 시작하기 전에는 이것이 실제로 무엇을 의미하는지 생각하는 가치가 있습니다.\u003c/p\u003e\n\u003cp\u003e지금 당장은 Apple Vision Pro를 위해 만들 수 있는 앱 유형이 세 가지라고 말할 수 있습니다. 이것은 윈도우, 바운드 및 언바운드입니다. 바운드 및 언바운드는 유니티 용어입니다. 기술적으로는 분할이 없습니다. Apple 측에서는 Shared 또는 Full Space에서 생성될 수 있는 창 또는 볼륨이 있습니다. 앱은 이러한 요소들을 각기 다른 방식으로 결합할 수 있습니다. 예를 들어, 여러 창을 함께 다양한 방식으로 볼륨들과 결합할 수 있습니다. 사용자의 필요에 따라 이들 간을 전환하여 매우 창의적일 수 있습니다. 따라서 참조한 페이지를 읽으면 실제 분할은 콘텐츠가 어떻게 표현되는지(2D 창 또는 3D 볼륨) 및 어느 공간에 있는지(다른 앱과 공유되는 공간 또는 완전히 독립된 공간)과 Passthrough 또는 혼합된 VR 환경 여부 사이에 있음을 알 수 있습니다.\u003c/p\u003e\n\u003cp\u003e실제로 우리에게는 2D(윈도우), 바운드(공유 공간의 하나의 볼륨) 및 언바운드(풀 스페이스의 하나의 볼륨) 사이에서 선택해야 했던 문제였습니다. 이들이 실제 옵션으로 선택된 이유는 대부분 제한된 시간과 예산 및 유니티 엔진을 사용하는 기술적 한계에 있었습니다. 추후 자세한 내용은 뒤에서 다루겠습니다.\u003c/p\u003e\n\u003cp\u003eVR에서 AVP로 디자인을 이동하려면, 가장 간단한 해결책은 풀 스페이스를 사용하는 것입니다. 당신은 자신만의 헤드셋을 사용하여 Passthrough 환경이나 완전히 가상 환경을 만들 수 있습니다. 해야 할 일은 컨트롤러 기반 상호작용 대신 손/눈 추적을 고려하여 디자인하는 것뿐입니다. 그렇게 하면 원만하게 작동할 것입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eUnbounded/Full Space은 많은 이점을 가지고 있지만, 한 가지 주요 단점이 있습니다: 사용자가 사용자와 나란히 애플리케이션을 열 수 없다는 것입니다.\u003c/p\u003e\n\u003cp\u003e퀘스트 3의 Puzzling Places에서 가장 많이 요청되는 기능 중 하나는 음악을 듣거나 YouTube 비디오를 시청하거나 오디오북을 듣는 기능입니다. 이러한 기능은 우리에게 매우 비싸게 들어갈 수 있는데, 그것들은 Apple Vision Pro에서만 작동합니다. 당신의 앱이 바운드되어 있고 공유 공간에 있는 경우, 사용자는 퍼즐을 즐기는 동안 원하는 대로 활동할 수 있습니다. 더 긴 퍼즐을 해결하는 동안 FaceTime에서 미팅에 참여하는 능력은 매우 자연스럽고 마법 같이 느껴집니다. Apple이 공간 컴퓨팅을 언급할 때, 아마도 그것이 의미하는 것일 겁니다. AVP는 VR 헤드셋이 아닙니다, 하드웨어 때문이 아니라 생태계 때문에 그렇습니다. Apple은 그것을 얼굴에 착용한 개인용 컴퓨터로 보는 것으로 보입니다. 당신이 많은 일을 할 수 있는 그런 장치입니다.\u003c/p\u003e\n\u003cp\u003e이전에 언급한 대로, 이상적으로는 사용자가 상호작용할 수 있는 다양한 방법을 모두 지원하는 것이 좋습니다, 공유 공간이든 전체 공간이든 말이죠. 하지만 현실적으로 하나에 집중할 시간이 있어서, 우리는 헤드셋을 위한 Apple의 비전에 맞추기로 결정했고, 헤드셋을 특별하게 만드는 것에 집중했으며, 이미 작동하는 것을 그대로 옮기기보다는 게임 루프에 새로운 것을 배우기로 했습니다.\u003c/p\u003e\n\u003cp\u003e그러나 앱이 어떤 공간에 있는지를 선택하는 것은 그저 시작에 불과합니다. 이미 장치에 대한 Apple의 비전과 일치하도록 결정했기 때문에, 게임을 위한 제어 패러다임을 디자인하는 것이 더 쉬웠습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e직접 및 간접적인 제어\u003c/h1\u003e\n\u003cp\u003e지난 몇 년 동안 놀라운 일 중 하나는 비게이머들에게도 VR 게임이 얼마나 접근하기 쉽다는 것입니다. 그 이유 중 하나는 아마도 VR의 주요 제어 패러다임이 '직접 제어'라는 것일 것입니다. 이는 게임을 직접적으로 몸으로 체험하여 플레이하는 것이라는 멋진 말입니다. 이러한 제어 형태는 매우 직관적이며, 모두가 자신의 몸을 사용하는 방법을 알기 때문입니다.\u003c/p\u003e\n\u003cp\u003eAVP의 운영 체제 및 공유 공간을 위한 제어 패러다임은 거의 정 반대입니다. 상호 작용하려는 대상을 살펴보고 핀치(pinch)하는 것입니다. 당신의 눈을 마우스 커서로, 핀치를 마우스 왼쪽 클릭으로 생각할 수 있습니다. 이를 애플은 '간접적인 제어'라고 합니다. 직접적인 제어가 직관적이라면, 간접적인 제어는 배워야 합니다. AVP와 상호 작용이 어색하다는 느낌은 아니지만, 선택을 핀치하여 하는 방법이나 손 위치의 이해는 즉시 이해되지 않습니다.\u003c/p\u003e\n\u003cp\u003e게임에 따라 직접 제어와 간접 제어를 모두 동등하게 지원할 수 있습니다. 그러나 주요 상호 작용 모드 중 하나를 선택하여 더 많은 예산을 들여 그 부분을 개선해야 할 것입니다. 그렇다면 어느 것을 선택하시겠습니까?\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eAVP의 간접 제어는 배워야 할 필요가 있습니다. 하지만 그것이 나쁜 것은 아닙니다. 비디오 게임에서 아날로그 스틱이 처음 소개된 것과 마찬가지로 일부 기자들은 그겼더라도 이들이 익히기에 너무 복잡하다고 주장했습니다. 그러나 현재, 대부분의 게임은 컨트롤러로 플레이됩니다. 심지어 마우스 커서와 운영 체제와의 상호 작용도 익히는 데 시간이 필요합니다.\u003c/p\u003e\n\u003cp\u003e이러한 상호 작용 시스템이 왜 이렇게 널리 사용되는 것일까요? 저는 그것들이 매우 다목적이며 게으름을 허용한다는 두 가지 주요 이유가 있다고 믿습니다. AVP 간접 제어는 나에게 둘 다 해당됩니다. 실제 세계에서 거의 한 칸도 옮기지 않으면서 많은 일을 할 수 있습니다. 직접적인 제어는 투명한 물리적 인터페이스를 갖고 있는 반면 간접 제어는 투명한 개념적 인터페이스를 가지고 있습니다!\u003c/p\u003e\n\u003cp\u003e우리가 한 공유 공간에서 경계가 있는 부피로 만족한다면, 좋은 간접 제어를 활성화할 수밖에 없습니다. 사용자가 볼륨 내부에 있어서가 아니라 그 방향을 향해 있어야 한다는 점 때문입니다. 기본 설정에서 볼륨은 사용자로부터 한 미터 정도 떨어진 곳에 생성될 것입니다. 이 거리 때문에 사용자가 게임 세계를 직접 이동과 게임 플레이로 매핑하는 입력 방법을 통해 조작할 수 없습니다. 경계가 있는 공유 공간에서 볼륨을 신체적으로 상호 작용하는 물리적 공간 대신 3D 공간 모니터로 생각할 수 있습니다.\u003c/p\u003e\n\u003cp\u003ePuzzling Places의 경우, 게임 플레이 방식이 변경되었다는 것을 의미했습니다. VR 버전에서 퍼즐을 조각으로 걸어가거나 퍼즐을 당겨오는 방식으로 진행합니다. 올바른 방향으로 조각을 물리적으로 회전시키고 올바른 위치에 물리적으로 놓습니다. 말할 필요도 없이 게임 필드가 팔 길이 밖에 있을 경우 그렇게 게임을 할 수 없습니다. 따라서 우리는 게임 루프를 변경했습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e어떤 앵커 역할을 하는 중심 부분이 있습니다. 이 앵커는 공용 공간의 볼륨에 미터 정도 떨어진 곳에 배치됩니다. 중심 부분과 연결할 수 있는 여러 조각들이 제시됩니다. 연결하고 싶은 조각을 보고, 그 조각을 끌어 마우스로 드래그하는 것처럼 조각을 놓을 위치에 끌어올립니다. 당신의 움직임은 마우스처럼 2D 평면 상에서 이루어지지만, 게임 로직은 깊이와 올바른 방향을 자동으로 계산합니다!\u003c/p\u003e\n\u003cp\u003e이를 통해 당신은 200조각 짜리 퍼즐을 사무실 책상 위에서 풀 수 있고, 마우스를 움직이는 것만큼 손을 움직일 필요가 없습니다.\u003c/p\u003e\n\u003cp\u003e간접 제어를 위해 디자인하는 것은 마우스나 컨트롤러를 위해 디자인하는 방식으로 돌아가는 것을 의미합니다. 플레이어의 물리적 움직임을 가상 세계로 일대일로 매핑하는 대신, 약간의 움직임만으로 게임 세계에서 많은 가능성을 열어주는 방식으로 다시 매핑합니다.\u003c/p\u003e\n\u003cp\u003e이 제어 체계는 주로 눈 추적에 의존하며, 눈 추적을 통해 흥미로운 정보들을 발견하게 되었습니다!\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eEyetracking의 문제점\u003c/h1\u003e\n\u003cp\u003eAVP의 eyetracking은 실제로 매우 안정적입니다. 기술적으로는 내 시선이 어디를 보고 있는지를 결코 잘못 파악하지 않지만, 여전히 패러다임에는 몇 가지 재미있는 문제가 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e일련의 의도 문제\u003c/strong\u003e라고 부르고 싶은 가장 두드러진 문제는 무언가를 선택하려면 그 곳을 봐야 한다는 것입니다. 이는 일부 작업을 순차적으로만 수행할 수 있다는 것을 의미합니다. 이것은 크게 중요해 보이지 않을 수 있지만, 컴퓨터를 사용할 때 얼마나 자주 두 가지 이상의 작업을 동시에 하는지에 놀랐습니다. 예를 들어, 어딘가를 보면서 다른 곳을 클릭하는 것과 같은 여러 가지 작업을 한 번에 수행할 때 가장 많은 막힘을 느꼈습니다.\nAVP에서 익숙해지는 데 시간이 걸립니다. 이는 AVP로 멀티태스킹을 못 한다는 뜻이 아니라 기기에 의도를 순차적으로 전달할 수 있다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 오른손으로 퍼즐 조각을 선택하고 바로 왼손으로 다른 것을 선택하는 것처럼 두 손에 든 조각을 사용하여 동시에 여러 작업을 수행할 수 있습니다. 그러나 눈을 입력 방법으로 사용하는 모든 것은 인터랙션을 대역폭 제한 인터페이스를 통해 진행해야 한다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e또한 우리의 눈이 어디를 보는지를 기반으로 우리의 의도를 가정하는 데 추가적인 문제가 있습니다. Saccadic masking과 시각적으로 산만한 것들이 가장 두드러진 문제였습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우리의 눈은 일반적으로 삽시적으로 움직입니다. 즉, 빠르고 이산적인 움직임으로 이동합니다. 당연히 이것이 우리가 세계를 지각하는 방식은 아닙니다. 우리의 시각은 부드럽고 지속적인 느낌을 줍니다. 이것은 일종의 후처리인 삽시적 가리기로 인해 발생하는 것인데, 시각 데이터를 왜곡하여 부드러운 전환을 만들 뿐만 아니라 기억을 되짚어 삽시적 움직임의 증거를 가리기 위해 변경합니다. 이것은 눈 추적에 대한 좋지 않은 소식입니다. 우리가 어디를 바라보고 있었는지 생각했던 곳이 실제로 눈이 향하고 있던 곳이 아닐 수도 있습니다! 입력을 활성화하려고 눌렀을 때 과거나 현재에 대해 뇌가 당신에게 거짓말을 하는 것을 명백히 깨닫게 됩니다. 이것은 미묘하게 표현되지만, 저는 이를 전혀 적응하지 못했던 감정이었습니다.\u003c/p\u003e\n\u003cp\u003e두 번째 문제는 우리의 눈이 여전히 의식 밖에서 때로는 생존을 보장하기 위해 반응하는 감각 입력 방법이라는 점입니다. 빠른 움직임, 매력적인 시각적 자극 또는 부호나 텍스트와 같은 고수준 시멘틱 요소들이 게임 플레이에서 내 눈을 끌어당겼는데, 내가 아무것도 할 수 없는 상황이 발생하는 것입니다. 이와는 별개로, 뇌가 눈이 실제로 하는 일과 병렬 또는 분리되어 동작을 대기열에 넣는 것처럼 보입니다. 예를 들어, 내가 한 조각을 집고 싶다고 결정하면 손가락에 집기 명령을 보내고 눈에는 \"그 조각을 보라\" 를 명령합니다. 이 과정에서 어떤 이유로 인해 내 눈은 오른쪽의 버튼으로 이동하여 그 버튼에 적힌 내용을 읽으려고 합니다. 버튼에는 \"재시작\" 이라고 적혀 있습니다. 그것을 보고 있는 동안, 손가락으로 실행된 집기 명령이 AVP에서 수행되어 게임 루프로 전달됩니다. 그 결과, 내 진행 상황이 다시 시작됩니다. 그런 상황이 발생할 때마다 웃음이 나왔습니다!\u003c/p\u003e\n\u003cp\u003e그 자체로 컴퓨팅과 지연 시간이 이러한 문제를 가지게 되었음에 실제로 흥미로운 사실입니다! 이것이 디자인 측면에서 의미하는 바는 무엇일까요? 위에 언급된 문제들에는 동일한 해결책이 있습니다. 다음과 같은 요소들로 결정됩니다: 1. 게임과 상호작용의 템포 2. 시각적 요소들 간의 거리 3. 잘못된 긍정의 비용.\u003c/p\u003e\n\u003cp\u003e첫 번째로, 눈 추적 및 집기 조합으로 플레이어에게 요구되는 더 빠른 반응 시간일수록 뭔가 잘못될 가능성이 높아집니다. 눈 추적을 사용한 빠른 속도의 게임을 가질 수 없다는 것이 아닙니다. 단지 게임 플레이와 관련된 반응 시간이 눈/뇌가 하는 다른 일과 심각하게 겹치는 경우에 문제가 발생할 수 있다는 것입니다. 둘째, 눈 공간에서 상호작용할 수 있는 객체들 사이의 거리가 멀수록 이러한 문제가 발생할 확률이 낮아집니다. 흥미로운 점은 우리가 다양한 알려지지 않은 요소들을 고려하기 위해 아날로그 스틱 제어 입력에 \"데드 존\"을 구축하는 것처럼, 장면에서 상호작용할 수 있는 물체들 간에 물리적인 최소 거리를 제공함으로써 눈의 이상한 행동을 고려할 수 있다는 점입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e마지막으로, 잘못된 긍정적인 결과의 비용이 얼마나 큰지 평가하고 그것을 줄일 수 있는지 알 수 있습니다. 실수로 재시작 버튼을 누르는 것은 정말 최악이에요! 그러나 사용자가 누른 후에 추가 확인 창이 표시된다면, 그저 귀찮은 일이 되는 것뿐입니다. 우리 게임의 한 예는 선반 위의 조각들 간을 바꾸는 방법이었습니다. OS 디자인에 맞추기 위해 먼저 스와이프 동작을 사용하기로 결정했지만, 선반 배경과 조각들이 너무 가까워서 스와이프하는 동안 실수로 조각을 선택하는 경우가 있었습니다. 이로 인해 조각이 왼쪽이나 오른쪽으로 던져지면서 불편한 애니메이션이 발생했습니다. 그 대신에 버튼으로 전환했습니다. 이제 사용자가 버튼을 선택하고 실수로 조각을 선택하는 경우, 잘못된 소리가 재생되고 조각이 교체되지 않는 것 이외에는 아무 일도 일어나지 않습니다.\u003c/p\u003e\n\u003ch1\u003e공유 공간은 모든 것을 공유\u003c/h1\u003e\n\u003cp\u003e공유 공간을 고려할 때 직면할 도전 중 하나는 앱이 다른 앱 옆에서 매끄럽게 실행될 때 무엇을 의미하는지입니다. 가장 명백한 함의는 컴퓨팅 리소스가 공유된다는 것이므로 전체 처리 능력이 앱에 특화되어 있다고 가정해서는 안 된다는 것입니다.\u003c/p\u003e\n\u003cp\u003e그러나 인지적 부담과 같은 추가적인 함의도 있습니다. 공유 공간을 위해 디자인하는 경우, 사람들이 당신의 앱을 다른 앱 옆에서 사용할 것으로 의도된다는 것을 의미합니다. 그렇지 않은 경우, 왜 Full Space로 가려하지 않고 추가 작업을 하려고 하는 걸까요? 그렇게 하려면 게임 루프의 인지 부담이 사용자가 FaceTime으로 회의에 참석하거나 작업 문제에 대해 생각할 수 있는 정신적 처리 능력을 남겨두도록 해야 합니다. 이것은 AVP를 위해 Puzzling Places의 루프를 단순화하기로 결정한 이유 중 하나였습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다른 앱들에게 숨 쉬는 공간을 남기는 것은 게임의 모든 영역에서 사용하는 패턴입니다. 사운드스케이프를 디자인하는 동안 다른 앱들도 약간의 소리를 생산할 뿐만 아니라 사용자가 결정할 수 있는 Apple 환경에서도 소리를 내게 될 수 있음을 염두에 두어야 합니다.\u003c/p\u003e\n\u003cp\u003e소리에 대해 이야기할 때, AVP는 Passthrough에서 충분히 좋아서 소리 스케이프의 합성 반향 프로필이 내가 보고 있는 공간과 일치하지 않을 때 이상하다고 느낄 정도입니다. 이런 일이 발생하지 않는 예로는 Quest 3 Passthrough가 있습니다.\u003c/p\u003e\n\u003ch1\u003e기술적인 제한 사항\u003c/h1\u003e\n\u003cp\u003e이 블로그 글을 쓸 당시, 당신이 게임을 개발하고 싶은 위치를 결정해야 하는 첫 번째 결정은 어디에서 게임을 개발할지입니다. 네이티브 Swift / RealitityKit 조합 또는 Unity Engine 중 하나를 선택할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우리에게는 네이티브 Swift가 사실 유효한 옵션이 아니었어요. 왜냐면 애플용으로 개발한 경험이 없었거든요. 매우 촉박한 개발 시간을 고려하면, 적어도 계산할 수 있는 위험성이 있는 생태계를 유지하는 것이 더 합리적이었어요. 하지만 Swift 경험이 있으면, 원하신다면 게임을 네이티브로 개발하는 데 많은 이점이 있을 거예요.\u003c/p\u003e\n\u003cp\u003e가장 큰 제한은 기능에 있어요. Unity에는 AVP로 제한 사항이 몇 가지 있었어요. 예를 들어, 공간 오디오의 부족, 한 번에 하나의 볼륨만 지원하거나 기본 Swift UI 기능에 액세스할 수 없는 등입니다. 이러한 제약 사항 중 일부는 애플 측면, 일부는 Unity 측면, 일부는 AVP 렌더링 아키텍처가 작동하는 방식에 있습니다. 그러나 어쨌든, 언제든지 참여를 결정하더라도, 대부분의 서드파티 라이브러리는 최신 네이티브 기능보다 조금 뒤쳐질 것입니다.\u003c/p\u003e\n\u003cp\u003eUnity에서 게임을 만들면, Unity는 게임을 두 부분으로 분할하겠죠. 게임 로직은 대부분 CPP 라이브러리로 컴파일되어 주요 게임 루프가 있는 곳에 위치하며, 프로그램을 초기화하는 Swift 코드가 조율됩니다. 씬은 Apple 백엔드가 이해하는 형식으로 변환되며, 관련 구성 요소는 다양한 Apple 구성 요소로 매핑됩니다. Apple은 다른 방식으로 작업하기 때문에, Unity 구성 요소는 당연히 최종 결과물과 일치하지 않아요. 이것은 귀찮은 일입니다.\u003c/p\u003e\n\u003cp\u003e렌더링 관련해서 일부 머티리얼은 MaterialX로 변환됩니다. 이들은 Apple이 제공한 셰이더의 다양한 PBR 기능을 활용할 수 있을 뿐 아니라, Unity에서 사용할 수 없는 정보를 많이 활용할 수 있어요. 반면, 내 테스트 결과로는 이러한 셰이더가 Metal에서 컴파일할 수 있는 사용자 정의 셰이더보다 훨씬 비용이 많이 듭니다. 성능과 렌더링에 대해 말하자면, AVP의 성능은 어느 정도일까요? 제게는 아이디어가 없네요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e하드웨어 측면에서, AVP는 분명히 현재 시장에서 가장 강력한 상용 헤드셋입니다. 그러나 매우 높은 해상도, 프레임 속도, 그리고 지연 시간을 가지고 있습니다. 따라서 여전히 채움율이 문제가 될 수 있습니다. 렌더링은 Apple 프로세스로 처리되고 게임 로직은 Unity CPP 코드에서 발생하기 때문에 항상 어느 쪽이 지연을 일으키는 원인인지를 파악해야 합니다. 더 나빠진 점은 Unity 코드를 프로파일링할 수 있지만, Apple 측이 무엇을 하는지에 대한 정보는 제공되지 않는다는 것입니다. 현재 Xcode 프로파일러는 상당히 제한된 기능을 가지고 있습니다. Apple 측에서 렌더링이 얼마나 많이 소요되는지에 대한 정보를 더 얻고 싶었을 것입니다.\u003c/p\u003e\n\u003cp\u003e제한사항에 대해 이야기하자면, 액세스할 수 있는 데이터에 관한 많은 제한이 있습니다. 이는 특히 공유 공간 및 사용자가 전용 볼륨 외부에 있는 경우에 심각한데요. 사용자의 눈이 어디를 보고 있는지 알 필요가 없는 이유에 대한 데이터 보호 관점에서 이해할 수 있지만, 카메라 위치와 같은 정보는 게임 개발에 매우 관련이 있습니다. 예를 들어, 미래에는 눈이 호버링하는 요소들의 하이라이트 행동을 예술적으로 조정할 수 있는 방법이 있었으면 좋겠습니다.\u003c/p\u003e\n\u003cp\u003eApple Vision Pro에는 이를 활용하는 방법에 대한 많은 아이디어가 있습니다. 이를 위해 디자인할 때, 어디까지 해당 아이디어들과 조화를 이룰 것인지를 결정해야 합니다. 시간이 경과함에 따라 이러한 아이디어 중 몇 개가 남을지, 얼마나 많이 잊힐지가 결정될 것입니다.\u003c/p\u003e\n\u003cp\u003e읽어주셔서 감사합니다. 계속해서 아래 내 소셜 미디어를 팔로우하실 수 있습니다: \u003ca href=\"https://ircss.github.io/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://ircss.github.io/\u003c/a\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-DesigningforAppleVisionProLessonsLearnedfromPuzzlingPlaces"},"buildId":"YUMR4jSyk_WlOHHc7UfOk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>