<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ViewChild를 사용하지 말아요 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-27-StopusingViewChild" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ViewChild를 사용하지 말아요 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="ViewChild를 사용하지 말아요 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-27-StopusingViewChild_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-27-StopusingViewChild" data-gatsby-head="true"/><meta name="twitter:title" content="ViewChild를 사용하지 말아요 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-27-StopusingViewChild_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-27 16:16" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_buildManifest.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">ViewChild를 사용하지 말아요</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="ViewChild를 사용하지 말아요" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 27, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-27-StopusingViewChild&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>네이티브 DOM 요소에 액세스하는 것은 웹 개발에서 기본적인 작업입니다. 그러나 현대적인 프레임워크는 다양한 전략을 활용하여 직접 DOM 액세스의 필요성을 최소화합니다. 예를 들어 Angular는 *ngIf와 같은 디렉티브를 사용하여 요소를 조건부로 추가하거나 제거하고 *ngFor를 사용하여 요소를 반복합니다. 이러한 기술은 직접적인 DOM 조작을 추상화하여 Angular이나 유사한 프레임워크에서 어플리케이션을 개발할 때 덜 걱정해도 되도록 만듭니다.</p>
<p>이러한 추상화에도 불구하고 직접적인 DOM 액세스가 여전히 필요한 시나리오가 있습니다. 구글 맵과 같은 일부 써드파티 라이브러리는 동작을 위해 직접적인 DOM 요소가 필요합니다. 구글 맵은 맵을 초기화하고 표시하기 위해 div 요소가 필요합니다. 일반적으로 개발자는 @ViewChild 데코레이터를 사용하여 div 요소에 액세스하고 그것을 맵 API에 제공하여 초기화합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/// &#x3C;reference types="@types/google.maps" /></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AfterViewInit</span>, <span class="hljs-title class_">Component</span>, <span class="hljs-title class_">ElementRef</span>, <span class="hljs-title class_">ViewChild</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

@<span class="hljs-title class_">Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-map-component'</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`&#x3C;div class="map-container" #googleMap>&#x3C;/div>`</span>,
  <span class="hljs-attr">styles</span>: [<span class="hljs-string">'.map-container {height: 500px;}'</span>],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapComponentComponent</span> implements <span class="hljs-title class_">AfterViewInit</span> {
  @<span class="hljs-title class_">ViewChild</span>(<span class="hljs-string">'googleMap'</span>, { <span class="hljs-attr">read</span>: <span class="hljs-title class_">ElementRef</span> }) googleMapElement!: <span class="hljs-title class_">ElementRef</span>&#x3C;<span class="hljs-title class_">HTMLDivElement</span>>;
  map?: google.<span class="hljs-property">maps</span>.<span class="hljs-property">Map</span>;

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">ngAfterViewInit</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> { <span class="hljs-title class_">Map</span> } = <span class="hljs-keyword">await</span> google.<span class="hljs-property">maps</span>.importLibrary(<span class="hljs-string">"maps"</span>) <span class="hljs-keyword">as</span> google.<span class="hljs-property">maps</span>.<span class="hljs-property">MapsLibrary</span>;
    <span class="hljs-comment">// Pass the nativeElement to google map library</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">googleMapElement</span>.<span class="hljs-property">nativeElement</span>, {
      <span class="hljs-attr">center</span>: { <span class="hljs-attr">lat</span>: -<span class="hljs-number">34.397</span>, <span class="hljs-attr">lng</span>: <span class="hljs-number">150.644</span> },
      <span class="hljs-attr">zoom</span>: <span class="hljs-number">8</span>,
    });
  }
}
</code></pre>
<p>이 접근 방식은 작동하지만 세 가지 주요 문제점을 도입합니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>템플릿에서 div 요소를 제거하면 코드가 깨져서 맵 기능을 재사용할 수 없게 됩니다.</li>
<li>네이티브 요소에 대한 참조는 ngAfterViewInit 라이프사이클 후크 이후에만 사용할 수 있습니다.</li>
<li>SOLID 디자인 원칙 중 단일 책임 원칙을 위반합니다. @ViewChild를 사용하는 컴포넌트는 맵을위한 데이터를 가져오는 것, 초기화하는 것, 설정하고 사용하는 것에 대한 책임이 생깁니다.</li>
</ul>
<p>더 나은 접근 방식이 있습니다: 속성 지시자 사용.</p>
<p>이전 컴포넌트를 리팩토링하고 맵 속성 지시자를 만들어 봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/// &#x3C;reference types="@types/google.maps" /></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Directive</span>, <span class="hljs-title class_">ElementRef</span>, <span class="hljs-title class_">OnInit</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

@<span class="hljs-title class_">Directive</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'div[appGoogleMap]'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GoogleMapDirective</span> implements <span class="hljs-title class_">OnInit</span> {
  map?: google.<span class="hljs-property">maps</span>.<span class="hljs-property">Map</span>;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private elementRef: ElementRef&#x3C;HTMLDivElement></span>) { }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">ngOnInit</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> { <span class="hljs-title class_">Map</span> } = <span class="hljs-keyword">await</span> google.<span class="hljs-property">maps</span>.importLibrary(<span class="hljs-string">"maps"</span>) <span class="hljs-keyword">as</span> google.<span class="hljs-property">maps</span>.<span class="hljs-property">MapsLibrary</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">elementRef</span>.<span class="hljs-property">nativeElement</span>, {
      <span class="hljs-attr">center</span>: { <span class="hljs-attr">lat</span>: -<span class="hljs-number">34.397</span>, <span class="hljs-attr">lng</span>: <span class="hljs-number">150.644</span> },
      <span class="hljs-attr">zoom</span>: <span class="hljs-number">8</span>,
    });
  }
}

<span class="hljs-comment">// 속성 지시자 사용</span>
&#x3C;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"map-container"</span> appGoogleMap>&#x3C;/div>
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다른 사용 사례를 고려해 보겠습니다: 캔버스 요소에 도형이나 이미지를 그리는 것입니다. 간단한 방법은 @ViewChild를 사용하여 네이티브 요소에서 그리기 컨텍스트를 가져오는 것입니다.</p>
<p>더 나은 대안은 속성 지시자를 사용하고 @Input 속성을 통해 그리기 정보를 전달하는 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Component</span>, <span class="hljs-title class_">ElementRef</span>, <span class="hljs-title class_">ViewChild</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

@<span class="hljs-title class_">Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-canvas-component'</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`&#x3C;canvas #myCanvas>&#x3C;/canvas>`</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CanvasComponentComponent</span> {
  <span class="hljs-comment">// 빌드 시 myCanvas를 확인할 수 있는 방법이 없음</span>
  @<span class="hljs-title class_">ViewChild</span>(<span class="hljs-string">'myCanvas'</span>, { <span class="hljs-attr">read</span>: <span class="hljs-title class_">ElementRef</span> }) canvasRef!: <span class="hljs-title class_">ElementRef</span>&#x3C;<span class="hljs-title class_">HTMLCanvasElement</span>>;

  <span class="hljs-title function_">ngAfterViewInit</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRef</span>.<span class="hljs-property">nativeElement</span>;
    <span class="hljs-keyword">const</span> canvasContext = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">'2d'</span>);
    <span class="hljs-comment">// 캔버스 컨텍스트를 사용하여 그리기</span>
    canvasContext?.<span class="hljs-title function_">beginPath</span>();
    canvasContext?.<span class="hljs-title function_">arc</span>(<span class="hljs-number">75</span>, <span class="hljs-number">75</span>, <span class="hljs-number">50</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>);
    canvasContext?.<span class="hljs-title function_">stroke</span>();
  }
}

<span class="hljs-comment">// Vs</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Directive</span>, <span class="hljs-title class_">ElementRef</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

@<span class="hljs-title class_">Directive</span>({
  <span class="hljs-comment">// 이 지시자는 Cavas 요소만 사용할 수 있습니다</span>
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'canvas[appCanvas]'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CanvasDirective</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private elementRef: ElementRef&#x3C;HTMLCanvasElement></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">draw</span>();
  }

  <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementRef</span>.<span class="hljs-property">nativeElement</span>;
    <span class="hljs-keyword">const</span> canvasContext = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">'2d'</span>);
    <span class="hljs-comment">// 캔버스 컨텍스트를 사용하여 그리기</span>
    canvasContext?.<span class="hljs-title function_">beginPath</span>();
    canvasContext?.<span class="hljs-title function_">arc</span>(<span class="hljs-number">75</span>, <span class="hljs-number">75</span>, <span class="hljs-number">50</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>);
    canvasContext?.<span class="hljs-title function_">stroke</span>();
  }
}
<span class="hljs-comment">// 속성 지시자 사용</span>
&#x3C;canvas appCanvas>&#x3C;/canvas>
</code></pre>
<p>좋아 보이죠? 그런데 기다려 보세요, 더 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우리는 첫 두 문제를 해결했지만 속성 지시자는 여전히 여러 책임을 처리하고 있습니다. 더 분해할 수 있을까요? 다음 블로그에서 그것을 더 탐구해보겠습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"ViewChild를 사용하지 말아요","description":"","date":"2024-05-27 16:16","slug":"2024-05-27-StopusingViewChild","content":"\n네이티브 DOM 요소에 액세스하는 것은 웹 개발에서 기본적인 작업입니다. 그러나 현대적인 프레임워크는 다양한 전략을 활용하여 직접 DOM 액세스의 필요성을 최소화합니다. 예를 들어 Angular는 *ngIf와 같은 디렉티브를 사용하여 요소를 조건부로 추가하거나 제거하고 *ngFor를 사용하여 요소를 반복합니다. 이러한 기술은 직접적인 DOM 조작을 추상화하여 Angular이나 유사한 프레임워크에서 어플리케이션을 개발할 때 덜 걱정해도 되도록 만듭니다.\n\n이러한 추상화에도 불구하고 직접적인 DOM 액세스가 여전히 필요한 시나리오가 있습니다. 구글 맵과 같은 일부 써드파티 라이브러리는 동작을 위해 직접적인 DOM 요소가 필요합니다. 구글 맵은 맵을 초기화하고 표시하기 위해 div 요소가 필요합니다. 일반적으로 개발자는 @ViewChild 데코레이터를 사용하여 div 요소에 액세스하고 그것을 맵 API에 제공하여 초기화합니다.\n\n```js\n/// \u003creference types=\"@types/google.maps\" /\u003e\nimport { AfterViewInit, Component, ElementRef, ViewChild } from '@angular/core';\n\n@Component({\n  selector: 'app-map-component',\n  template: `\u003cdiv class=\"map-container\" #googleMap\u003e\u003c/div\u003e`,\n  styles: ['.map-container {height: 500px;}'],\n})\nexport class MapComponentComponent implements AfterViewInit {\n  @ViewChild('googleMap', { read: ElementRef }) googleMapElement!: ElementRef\u003cHTMLDivElement\u003e;\n  map?: google.maps.Map;\n\n  async ngAfterViewInit() {\n    const { Map } = await google.maps.importLibrary(\"maps\") as google.maps.MapsLibrary;\n    // Pass the nativeElement to google map library\n    this.map = new Map(this.googleMapElement.nativeElement, {\n      center: { lat: -34.397, lng: 150.644 },\n      zoom: 8,\n    });\n  }\n}\n```\n\n이 접근 방식은 작동하지만 세 가지 주요 문제점을 도입합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 템플릿에서 div 요소를 제거하면 코드가 깨져서 맵 기능을 재사용할 수 없게 됩니다.\n- 네이티브 요소에 대한 참조는 ngAfterViewInit 라이프사이클 후크 이후에만 사용할 수 있습니다.\n- SOLID 디자인 원칙 중 단일 책임 원칙을 위반합니다. @ViewChild를 사용하는 컴포넌트는 맵을위한 데이터를 가져오는 것, 초기화하는 것, 설정하고 사용하는 것에 대한 책임이 생깁니다.\n\n더 나은 접근 방식이 있습니다: 속성 지시자 사용.\n\n이전 컴포넌트를 리팩토링하고 맵 속성 지시자를 만들어 봅시다.\n\n```js\n/// \u003creference types=\"@types/google.maps\" /\u003e\nimport { Directive, ElementRef, OnInit } from '@angular/core';\n\n@Directive({\n  selector: 'div[appGoogleMap]'\n})\nexport class GoogleMapDirective implements OnInit {\n  map?: google.maps.Map;\n  constructor(private elementRef: ElementRef\u003cHTMLDivElement\u003e) { }\n\n  async ngOnInit() {\n    const { Map } = await google.maps.importLibrary(\"maps\") as google.maps.MapsLibrary;\n    this.map = new Map(this.elementRef.nativeElement, {\n      center: { lat: -34.397, lng: 150.644 },\n      zoom: 8,\n    });\n  }\n}\n\n// 속성 지시자 사용\n\u003cdiv class=\"map-container\" appGoogleMap\u003e\u003c/div\u003e\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다른 사용 사례를 고려해 보겠습니다: 캔버스 요소에 도형이나 이미지를 그리는 것입니다. 간단한 방법은 @ViewChild를 사용하여 네이티브 요소에서 그리기 컨텍스트를 가져오는 것입니다.\n\n더 나은 대안은 속성 지시자를 사용하고 @Input 속성을 통해 그리기 정보를 전달하는 것입니다.\n\n```js\nimport { Component, ElementRef, ViewChild } from '@angular/core';\n\n@Component({\n  selector: 'app-canvas-component',\n  template: `\u003ccanvas #myCanvas\u003e\u003c/canvas\u003e`,\n})\nexport class CanvasComponentComponent {\n  // 빌드 시 myCanvas를 확인할 수 있는 방법이 없음\n  @ViewChild('myCanvas', { read: ElementRef }) canvasRef!: ElementRef\u003cHTMLCanvasElement\u003e;\n\n  ngAfterViewInit() {\n    const canvas = this.canvasRef.nativeElement;\n    const canvasContext = canvas.getContext('2d');\n    // 캔버스 컨텍스트를 사용하여 그리기\n    canvasContext?.beginPath();\n    canvasContext?.arc(75, 75, 50, 0, 2 * Math.PI);\n    canvasContext?.stroke();\n  }\n}\n\n// Vs\nimport { Directive, ElementRef } from '@angular/core';\n\n@Directive({\n  // 이 지시자는 Cavas 요소만 사용할 수 있습니다\n  selector: 'canvas[appCanvas]'\n})\nexport class CanvasDirective {\n  constructor(private elementRef: ElementRef\u003cHTMLCanvasElement\u003e) {\n    this.draw();\n  }\n\n  draw() {\n    const canvas = this.elementRef.nativeElement;\n    const canvasContext = canvas.getContext('2d');\n    // 캔버스 컨텍스트를 사용하여 그리기\n    canvasContext?.beginPath();\n    canvasContext?.arc(75, 75, 50, 0, 2 * Math.PI);\n    canvasContext?.stroke();\n  }\n}\n// 속성 지시자 사용\n\u003ccanvas appCanvas\u003e\u003c/canvas\u003e\n```\n\n좋아 보이죠? 그런데 기다려 보세요, 더 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 첫 두 문제를 해결했지만 속성 지시자는 여전히 여러 책임을 처리하고 있습니다. 더 분해할 수 있을까요? 다음 블로그에서 그것을 더 탐구해보겠습니다.\n","ogImage":{"url":"/assets/img/2024-05-27-StopusingViewChild_0.png"},"coverImage":"/assets/img/2024-05-27-StopusingViewChild_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e네이티브 DOM 요소에 액세스하는 것은 웹 개발에서 기본적인 작업입니다. 그러나 현대적인 프레임워크는 다양한 전략을 활용하여 직접 DOM 액세스의 필요성을 최소화합니다. 예를 들어 Angular는 *ngIf와 같은 디렉티브를 사용하여 요소를 조건부로 추가하거나 제거하고 *ngFor를 사용하여 요소를 반복합니다. 이러한 기술은 직접적인 DOM 조작을 추상화하여 Angular이나 유사한 프레임워크에서 어플리케이션을 개발할 때 덜 걱정해도 되도록 만듭니다.\u003c/p\u003e\n\u003cp\u003e이러한 추상화에도 불구하고 직접적인 DOM 액세스가 여전히 필요한 시나리오가 있습니다. 구글 맵과 같은 일부 써드파티 라이브러리는 동작을 위해 직접적인 DOM 요소가 필요합니다. 구글 맵은 맵을 초기화하고 표시하기 위해 div 요소가 필요합니다. 일반적으로 개발자는 @ViewChild 데코레이터를 사용하여 div 요소에 액세스하고 그것을 맵 API에 제공하여 초기화합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/// \u0026#x3C;reference types=\"@types/google.maps\" /\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eAfterViewInit\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eElementRef\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eViewChild\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'app-map-component'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`\u0026#x3C;div class=\"map-container\" #googleMap\u003e\u0026#x3C;/div\u003e`\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003estyles\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'.map-container {height: 500px;}'\u003c/span\u003e],\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMapComponentComponent\u003c/span\u003e implements \u003cspan class=\"hljs-title class_\"\u003eAfterViewInit\u003c/span\u003e {\n  @\u003cspan class=\"hljs-title class_\"\u003eViewChild\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'googleMap'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003eread\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eElementRef\u003c/span\u003e }) googleMapElement!: \u003cspan class=\"hljs-title class_\"\u003eElementRef\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eHTMLDivElement\u003c/span\u003e\u003e;\n  map?: google.\u003cspan class=\"hljs-property\"\u003emaps\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eMap\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003engAfterViewInit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eMap\u003c/span\u003e } = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e google.\u003cspan class=\"hljs-property\"\u003emaps\u003c/span\u003e.importLibrary(\u003cspan class=\"hljs-string\"\u003e\"maps\"\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e google.\u003cspan class=\"hljs-property\"\u003emaps\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eMapsLibrary\u003c/span\u003e;\n    \u003cspan class=\"hljs-comment\"\u003e// Pass the nativeElement to google map library\u003c/span\u003e\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emap\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMap\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003egoogleMapElement\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enativeElement\u003c/span\u003e, {\n      \u003cspan class=\"hljs-attr\"\u003ecenter\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003elat\u003c/span\u003e: -\u003cspan class=\"hljs-number\"\u003e34.397\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003elng\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e150.644\u003c/span\u003e },\n      \u003cspan class=\"hljs-attr\"\u003ezoom\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e,\n    });\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 접근 방식은 작동하지만 세 가지 주요 문제점을 도입합니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e템플릿에서 div 요소를 제거하면 코드가 깨져서 맵 기능을 재사용할 수 없게 됩니다.\u003c/li\u003e\n\u003cli\u003e네이티브 요소에 대한 참조는 ngAfterViewInit 라이프사이클 후크 이후에만 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003eSOLID 디자인 원칙 중 단일 책임 원칙을 위반합니다. @ViewChild를 사용하는 컴포넌트는 맵을위한 데이터를 가져오는 것, 초기화하는 것, 설정하고 사용하는 것에 대한 책임이 생깁니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e더 나은 접근 방식이 있습니다: 속성 지시자 사용.\u003c/p\u003e\n\u003cp\u003e이전 컴포넌트를 리팩토링하고 맵 속성 지시자를 만들어 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/// \u0026#x3C;reference types=\"@types/google.maps\" /\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eDirective\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eElementRef\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eOnInit\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eDirective\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'div[appGoogleMap]'\u003c/span\u003e\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGoogleMapDirective\u003c/span\u003e implements \u003cspan class=\"hljs-title class_\"\u003eOnInit\u003c/span\u003e {\n  map?: google.\u003cspan class=\"hljs-property\"\u003emaps\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eMap\u003c/span\u003e;\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprivate elementRef: ElementRef\u0026#x3C;HTMLDivElement\u003e\u003c/span\u003e) { }\n\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003engOnInit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eMap\u003c/span\u003e } = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e google.\u003cspan class=\"hljs-property\"\u003emaps\u003c/span\u003e.importLibrary(\u003cspan class=\"hljs-string\"\u003e\"maps\"\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e google.\u003cspan class=\"hljs-property\"\u003emaps\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eMapsLibrary\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emap\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMap\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eelementRef\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enativeElement\u003c/span\u003e, {\n      \u003cspan class=\"hljs-attr\"\u003ecenter\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003elat\u003c/span\u003e: -\u003cspan class=\"hljs-number\"\u003e34.397\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003elng\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e150.644\u003c/span\u003e },\n      \u003cspan class=\"hljs-attr\"\u003ezoom\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e,\n    });\n  }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 속성 지시자 사용\u003c/span\u003e\n\u0026#x3C;div \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"map-container\"\u003c/span\u003e appGoogleMap\u003e\u0026#x3C;/div\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다른 사용 사례를 고려해 보겠습니다: 캔버스 요소에 도형이나 이미지를 그리는 것입니다. 간단한 방법은 @ViewChild를 사용하여 네이티브 요소에서 그리기 컨텍스트를 가져오는 것입니다.\u003c/p\u003e\n\u003cp\u003e더 나은 대안은 속성 지시자를 사용하고 @Input 속성을 통해 그리기 정보를 전달하는 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eElementRef\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eViewChild\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'app-canvas-component'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`\u0026#x3C;canvas #myCanvas\u003e\u0026#x3C;/canvas\u003e`\u003c/span\u003e,\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCanvasComponentComponent\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 빌드 시 myCanvas를 확인할 수 있는 방법이 없음\u003c/span\u003e\n  @\u003cspan class=\"hljs-title class_\"\u003eViewChild\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'myCanvas'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003eread\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eElementRef\u003c/span\u003e }) canvasRef!: \u003cspan class=\"hljs-title class_\"\u003eElementRef\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eHTMLCanvasElement\u003c/span\u003e\u003e;\n\n  \u003cspan class=\"hljs-title function_\"\u003engAfterViewInit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e canvas = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecanvasRef\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enativeElement\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e canvasContext = canvas.\u003cspan class=\"hljs-title function_\"\u003egetContext\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'2d'\u003c/span\u003e);\n    \u003cspan class=\"hljs-comment\"\u003e// 캔버스 컨텍스트를 사용하여 그리기\u003c/span\u003e\n    canvasContext?.\u003cspan class=\"hljs-title function_\"\u003ebeginPath\u003c/span\u003e();\n    canvasContext?.\u003cspan class=\"hljs-title function_\"\u003earc\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePI\u003c/span\u003e);\n    canvasContext?.\u003cspan class=\"hljs-title function_\"\u003estroke\u003c/span\u003e();\n  }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// Vs\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eDirective\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eElementRef\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eDirective\u003c/span\u003e({\n  \u003cspan class=\"hljs-comment\"\u003e// 이 지시자는 Cavas 요소만 사용할 수 있습니다\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'canvas[appCanvas]'\u003c/span\u003e\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCanvasDirective\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprivate elementRef: ElementRef\u0026#x3C;HTMLCanvasElement\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edraw\u003c/span\u003e();\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003edraw\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e canvas = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eelementRef\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enativeElement\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e canvasContext = canvas.\u003cspan class=\"hljs-title function_\"\u003egetContext\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'2d'\u003c/span\u003e);\n    \u003cspan class=\"hljs-comment\"\u003e// 캔버스 컨텍스트를 사용하여 그리기\u003c/span\u003e\n    canvasContext?.\u003cspan class=\"hljs-title function_\"\u003ebeginPath\u003c/span\u003e();\n    canvasContext?.\u003cspan class=\"hljs-title function_\"\u003earc\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePI\u003c/span\u003e);\n    canvasContext?.\u003cspan class=\"hljs-title function_\"\u003estroke\u003c/span\u003e();\n  }\n}\n\u003cspan class=\"hljs-comment\"\u003e// 속성 지시자 사용\u003c/span\u003e\n\u0026#x3C;canvas appCanvas\u003e\u0026#x3C;/canvas\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e좋아 보이죠? 그런데 기다려 보세요, 더 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우리는 첫 두 문제를 해결했지만 속성 지시자는 여전히 여러 책임을 처리하고 있습니다. 더 분해할 수 있을까요? 다음 블로그에서 그것을 더 탐구해보겠습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-27-StopusingViewChild"},"buildId":"wOkGEDZCvEs3S_XaNsdwr","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>