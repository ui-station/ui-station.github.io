<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>고 오류 정복하기 오류 반환과 처리에 관한 안내 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="고 오류 정복하기 오류 반환과 처리에 관한 안내 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="고 오류 정복하기 오류 반환과 처리에 관한 안내 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors" data-gatsby-head="true"/><meta name="twitter:title" content="고 오류 정복하기 오류 반환과 처리에 관한 안내 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-20 16:27" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_buildManifest.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">고 오류 정복하기 오류 반환과 처리에 관한 안내</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="고 오류 정복하기 오류 반환과 처리에 관한 안내" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 20, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>Go 오류 처리 마스터하기 위한 초보자 가이드</h2>
<p><img src="/assets/img/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors_0.png" alt="이미지"></p>
<h1>레벨 1: if err != nil</h1>
<p>이것은 오류를 반환하는 가장 간단한 방법입니다. 대부분의 사람들은 이 패턴에 익숙합니다. 오류를 반환할 수 있는 함수를 호출하고, 오류가 nil인지 확인하고, nil이 아니면 오류를 반환합니다.</p>
<p></p>
<pre><code class="hljs language-Go"><span class="hljs-keyword">import</span> (
 <span class="hljs-string">"errors"</span>
 <span class="hljs-string">"fmt"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> (<span class="hljs-type">float64</span>, <span class="hljs-type">error</span>) {
 result, err := mayReturnError();
 <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, err
 }
 <span class="hljs-keyword">return</span> result, <span class="hljs-literal">nil</span>
}
</code></pre>
<h2>이 방식의 문제점</h2>
<p>이 방식이 가장 간단하고 사실상 가장 많이 사용되는 방법이지만 중대한 문제점이 있습니다: 컨텍스트 부족. 깊은 호출 스택이 있는 경우 어떤 함수가 오류를 발생시켰는지 알 수 없습니다.</p>
<p>A() 함수가 B()를 호출하고, B()가 C()를 호출하고, C()가 다음과 같은 오류를 반환하는 호출 스택을 상상해보십시오:</p>
<p></p>
<pre><code class="hljs language-js">package main

<span class="hljs-keyword">import</span> (
 <span class="hljs-string">"errors"</span>
 <span class="hljs-string">"fmt"</span>
)

func <span class="hljs-title function_">A</span>(x int) (int, error) {
 result, err := <span class="hljs-title function_">B</span>(x)
 <span class="hljs-keyword">if</span> err != nil {
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, err
 }
 <span class="hljs-keyword">return</span> result * <span class="hljs-number">3</span>, nil
}

func <span class="hljs-title function_">B</span>(x int) (int, error) {
 result, err := <span class="hljs-title function_">C</span>(x)
 <span class="hljs-keyword">if</span> err != nil {
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, err
 }
 <span class="hljs-keyword">return</span> result + <span class="hljs-number">2</span>, nil
}

func <span class="hljs-title function_">C</span>(x int) (int, error) {
 <span class="hljs-keyword">if</span> x &#x3C; <span class="hljs-number">0</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.<span class="hljs-title class_">New</span>(<span class="hljs-string">"negative value not allowed"</span>)
 }
 <span class="hljs-keyword">return</span> x * x, nil
}

func <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
 <span class="hljs-comment">// Call function A with invalid input</span>
 result, err := <span class="hljs-title function_">A</span>(-<span class="hljs-number">2</span>)
 <span class="hljs-keyword">if</span> err == nil {
  fmt.<span class="hljs-title class_">Println</span>(<span class="hljs-string">"결과:"</span>, result)
 } <span class="hljs-keyword">else</span> {
  fmt.<span class="hljs-title class_">Println</span>(<span class="hljs-string">"에러:"</span>, err)
 }
}
</code></pre>
<p>만약 이 프로그램을 실행하면 다음과 같이 출력됩니다.</p>
<pre><code class="hljs language-js">에러: negative value not allowed
</code></pre>
<p>우리는 호출 스택에서 이 오류가 어디에서 발생했는지에 대한 컨텍스트가 없습니다. 특정 오류 문자열을 찾아 해당 오류가 어디에서 발생했는지를 알아내기 위해 프로그램을 코드 편집기에서 열어야 합니다.</p>
<p></p>
<h1>레벨 2: 에러 감싸기</h1>
<p>에러에 대한 컨텍스트를 추가하기 위해 fmt.Errorf를 사용하여 에러를 감싸줍니다.</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"errors"</span>
	<span class="hljs-string">"fmt"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">A</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) {
	result, err := B(x)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.Errorf(<span class="hljs-string">"A: %w"</span>, err)
	}
	<span class="hljs-keyword">return</span> result * <span class="hljs-number">3</span>, <span class="hljs-literal">nil</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">B</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) {
	result, err := C(x)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.Errorf(<span class="hljs-string">"B: %w"</span>, err)
	}
	<span class="hljs-keyword">return</span> result + <span class="hljs-number">2</span>, <span class="hljs-literal">nil</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">C</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) {
	<span class="hljs-keyword">if</span> x &#x3C; <span class="hljs-number">0</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.Errorf(<span class="hljs-string">"C: %w"</span>, errors.New(<span class="hljs-string">"음수 값은 허용되지 않습니다"</span>))
	}
	<span class="hljs-keyword">return</span> x * x, <span class="hljs-literal">nil</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	<span class="hljs-comment">// 잘못된 입력으로 함수 A를 호출합니다.</span>
	result, err := A(<span class="hljs-number">-2</span>)
	<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> {
		fmt.Println(<span class="hljs-string">"결과:"</span>, result)
	} <span class="hljs-keyword">else</span> {
		fmt.Println(<span class="hljs-string">"에러:"</span>, err)
	}
}
</code></pre>
<p>이 프로그램을 실행하면 아래와 같은 출력을 얻게 됩니다.</p>
<p></p>
<pre><code class="hljs language-js">오류: <span class="hljs-attr">A</span>: <span class="hljs-attr">B</span>: <span class="hljs-attr">C</span>: 음수 값은 허용되지 않습니다
</code></pre>
<p>이제 우리는 콜 스택을 이해했습니다.</p>
<p>하지만 여전히 문제가 있습니다.</p>
<h2>이 방법의 문제</h2>
<p></p>
<p>에러가 발생한 위치를 알게 되었지만 여전히 어떤 부분이 잘못되었는지는 알 수 없습니다.</p>
<h1>Level 3: 세부적인 에러</h1>
<p>에러가 충분히 설명이 되지 않았습니다. 이것을 보다 복잡한 예제로 보여주기 위해 다음과 같이 조금 더 복잡한 예제가 필요합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> (
 <span class="hljs-string">"errors"</span>
 <span class="hljs-string">"fmt"</span>
)

func <span class="hljs-title class_">DoSomething</span>() (int, error) {
 result, err := <span class="hljs-title class_">DoSomethingElseWithTwoSteps</span>()
 <span class="hljs-keyword">if</span> err != nil {
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.<span class="hljs-title class_">Errorf</span>(<span class="hljs-string">"DoSomething: %w"</span>, err)
 }
 <span class="hljs-keyword">return</span> result * <span class="hljs-number">3</span>, nil
}

func <span class="hljs-title class_">DoSomethingElseWithTwoSteps</span>() (int, error) {
 stepOne, err := <span class="hljs-title class_">StepOne</span>()
 <span class="hljs-keyword">if</span> err != nil {
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.<span class="hljs-title class_">Errorf</span>(<span class="hljs-string">"DoSomethingElseWithTwoSteps:%w"</span>, err)
 }

 stepTwo, err := <span class="hljs-title class_">StepTwo</span>()
 <span class="hljs-keyword">if</span> err != nil {
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.<span class="hljs-title class_">Errorf</span>(<span class="hljs-string">"DoSomethingElseWithTwoSteps: %w"</span>, err)
 }

 <span class="hljs-keyword">return</span> stepOne + <span class="hljs-title class_">StepTwo</span>, nil
}
</code></pre>
<p></p>
<p>이 예시에서 오류가 반환되면 어떤 작업이 실패했는지 명확하지 않습니다. StepOne인지 StepTwo인지 알 수 없습니다. 동일한 오류인 Error: DoSomething: DoSomethingElseWithTwoSteps: UnderlyingError가 발생합니다.</p>
<p>그 문제를 해결하려면 발생한 구체적인 문제에 대한 문맥을 추가해야 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> (
 <span class="hljs-string">"errors"</span>
 <span class="hljs-string">"fmt"</span>
)

func <span class="hljs-title class_">DoSomething</span>() (int, error) {
 result, err := <span class="hljs-title class_">DoSomethingElseWithTwoSteps</span>()
 <span class="hljs-keyword">if</span> err != nil {
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.<span class="hljs-title class_">Errorf</span>(<span class="hljs-string">"DoSomething: %w"</span>, err)
 }
 <span class="hljs-keyword">return</span> result * <span class="hljs-number">3</span>, nil
}

func <span class="hljs-title class_">DoSomethingElseWithTwoSteps</span>() (int, error) {
 stepOne, err := <span class="hljs-title class_">StepOne</span>()
 <span class="hljs-keyword">if</span> err != nil {
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.<span class="hljs-title class_">Errorf</span>(<span class="hljs-string">"DoSomethingElseWithTwoSteps: StepOne: %w"</span>, err)
 }

 stepTwo, err := <span class="hljs-title class_">StepTwo</span>()
 <span class="hljs-keyword">if</span> err != nil {
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.<span class="hljs-title class_">Errorf</span>(<span class="hljs-string">"DoSomethingElseWithTwoSteps: StepTwo: %w"</span>, err)
 }

 <span class="hljs-keyword">return</span> stepOne + <span class="hljs-title class_">StepTwo</span>, nil
}
</code></pre>
<p>이제 StepOne이 실패하면 Error: DoSomething: DoSomethingElseWithTwoSteps: StepOne failed: UnderlyingError를 반환합니다.</p>
<p></p>
<h2>이 방법의 문제점</h2>
<p>이 오류는 이제 함수 이름을 사용하여 호출 스택을 표현합니다. 그러나 오류의 본질을 표현하지는 않습니다. 오류는 이야기를 전달해야 합니다.</p>
<p>좋은 예는 HTTP 상태 코드입니다. 404를 받으면 원하는 리소스가 존재하지 않음을 알 수 있습니다.</p>
<h1>레벨 4: 오류 표식</h1>
<p></p>
<p>에러 센티널은 재사용할 수 있는 미리 정의된 오류 상수입니다.</p>
<p>함수가 실패할 수 있는 원인은 다양할 수 있지만, 일반적으로 4가지 카테고리로 나눌 수 있습니다. "찾을 수 없음" 오류, "이미 존재함" 오류, "실패한 전제조건" 오류, 그리고 "내부 오류"입니다. 이는 gRPC 상태 코드에서 영감을 받았습니다. 각 카테고리를 한 문장으로 설명해 드릴게요.</p>
<p>"찾을 수 없음" 오류: 호출자가 원하는 리소스가 존재하지 않습니다. 예시: 삭제된 게시물.</p>
<p>"이미 존재함" 오류: 호출자가 생성하려는 리소스가 이미 존재합니다. 예시: 같은 이름을 가진 조직.</p>
<p></p>
<p>실패한 전제조건 오류: 작업 요청자가 실행하려는 작업이 실행 조건을 충족하지 않거나 나쁜 상태에 있습니다. 예시: 잔액이 0원인 계좌에서 출금을 시도하는 경우.</p>
<p>내부 오류: 이러한 카테고리에 속하지 않는 다른 오류로 내부 오류가 발생한 경우입니다.</p>
<p>이러한 종류의 오류만 가지고 있어도 충분하지 않습니다. 호출자에게 어떤 종류의 오류인지 알려주어야 합니다. 이를 위해 오류 센티널 및 errors.Is를 사용합니다.</p>
<p>사용자가 지갑 잔액을 조회하고 업데이트할 수 있는 REST API가 있다고 상상해보세요. 데이터베이스에서 지갑을 조회할 때 오류 센티널을 활용하는 방법을 살펴봅시다.</p>
<p></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> (
 <span class="hljs-string">"fmt"</span>
 <span class="hljs-string">"net/http"</span>
 <span class="hljs-string">"errors"</span>
)

<span class="hljs-comment">// 이것들은 에러를 표현하는 상수들입니다.</span>
<span class="hljs-keyword">var</span> (
  <span class="hljs-title class_">WalletDoesNotExistErr</span> = errors.<span class="hljs-title class_">New</span>(<span class="hljs-string">"지갑이 존재하지 않습니다"</span>) <span class="hljs-comment">// 발견되지 않은 에러 타입</span>
  <span class="hljs-title class_">CouldNotGetWalletErr</span> = errors.<span class="hljs-title class_">New</span>(<span class="hljs-string">"지갑을 가져올 수 없습니다"</span>) <span class="hljs-comment">// 내부 에러 타입</span>
)

func <span class="hljs-title function_">getWalletFromDB</span>(id int) (int, error) {
 <span class="hljs-comment">// 더미 구현: 데이터베이스에서 지갑을 검색하는 시뮬레이션</span>
 balance, err := db.<span class="hljs-title function_">get</span>(id)

 <span class="hljs-keyword">if</span> err != nil {
  <span class="hljs-keyword">if</span> balance == nil {
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.<span class="hljs-title class_">Errorf</span>(<span class="hljs-string">"%w: Wallet(id:%s)가 존재하지 않습니다: %w"</span>, <span class="hljs-title class_">WalletDoesNotExistErr</span>, id, err)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.<span class="hljs-title class_">Errorf</span>(<span class="hljs-string">"%w: 데이터베이스에서 Wallet(id:%s)를 가져올 수 없습니다: %w"</span>, <span class="hljs-title class_">CouldNotGetWalletErr</span>, id, err)
  }
 }

 <span class="hljs-keyword">return</span> *balance, nil
}
</code></pre>
<p>이제 이제 REST 핸들러에서 다음과 같이 할 수 있는 것을 보여줍니다.</p>
<pre><code class="hljs language-js">func <span class="hljs-title function_">getWalletBalance</span>(<span class="hljs-params"></span>) {
 wallet, err := <span class="hljs-title function_">getWalletFromDB</span>(id)

 <span class="hljs-keyword">if</span> errors.<span class="hljs-title class_">Is</span>(err, <span class="hljs-title class_">WalletDoesNotExistErr</span>) {
  <span class="hljs-comment">// 404 반환</span>
 } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> errors.<span class="hljs-title class_">Is</span>(err, <span class="hljs-title class_">CouldNotGetWalletErr</span>) {
  <span class="hljs-comment">// 500 반환</span>
 }
}
</code></pre>
<p>다른 예제를 살펴보겠습니다. 사용자가 잔액을 업데이트하고자 하는 경우를 보겠습니다.</p>
<p></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> (
 <span class="hljs-string">"fmt"</span>
 <span class="hljs-string">"net/http"</span>
 <span class="hljs-string">"errors"</span>
)

<span class="hljs-keyword">var</span> (
  <span class="hljs-title class_">WalletDoesNotExistErr</span> = errors.<span class="hljs-title class_">New</span>(<span class="hljs-string">"Wallet does not exist"</span>) <span class="hljs-comment">// Not Found Error Type</span>
  <span class="hljs-title class_">CouldNotDebitWalletErr</span> = errors.<span class="hljs-title class_">New</span>(<span class="hljs-string">"Could not debit Wallet"</span>) <span class="hljs-comment">// Internal Error Type</span>
  <span class="hljs-title class_">InsufficientWalletBalanceErr</span> = errors.<span class="hljs-title class_">New</span>(<span class="hljs-string">"Insufficient balance in Wallet"</span>) <span class="hljs-comment">// Failed Precondition Error Type</span>
)

func <span class="hljs-title function_">debitWalletInDB</span>(id int, amount int) error {
 <span class="hljs-comment">// Dummy implementation: simulate retrieving a wallet from a database</span>
 balance, err := db.<span class="hljs-title function_">get</span>(id)

 <span class="hljs-keyword">if</span> err != nil {
  <span class="hljs-keyword">if</span> balance == nil {
    <span class="hljs-keyword">return</span> fmt.<span class="hljs-title class_">Errorf</span>(<span class="hljs-string">"%w: Wallet(id:%s) does not exist: %w"</span>, <span class="hljs-title class_">WalletDoesNotExistErr</span>, id, err)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> fmt.<span class="hljs-title class_">Errorf</span>(<span class="hljs-string">"%w: could not get Wallet(id:%s) from db: %w"</span>, <span class="hljs-title class_">CouldNotDebitWalletErr</span>, id, err)
  }
 }

 <span class="hljs-keyword">if</span> *balance &#x3C;= <span class="hljs-number">0</span> {
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.<span class="hljs-title class_">Errorf</span>(<span class="hljs-string">"%w: Wallet(id:%s) balance is 0"</span>, <span class="hljs-title class_">InsufficientWalletBalanceErr</span>, id)
 }

 updatedBalance := *balance - amount

 <span class="hljs-comment">// Dummy implementation: simulate updating a wallet in a database</span>
 err := db.<span class="hljs-title function_">update</span>(id, updatedBalance)

 <span class="hljs-keyword">if</span> err != nil {
   <span class="hljs-keyword">return</span> fmt.<span class="hljs-title class_">Errorf</span>(<span class="hljs-string">"%w: could not update Wallet(id:%s) in db: %w"</span>, <span class="hljs-title class_">CouldNotDebitWalletErr</span>, id, err)
 }

 <span class="hljs-keyword">return</span> nil
}
</code></pre>
<h2>Using sentinels for better error messages</h2>
<p>You might have noticed that I have a particular way of formatting errors. I prefer structuring an error message in one of two ways:</p>
<ul>
<li><code>fmt.Errorf("%w: description: %w", Sentinel, err)</code> or</li>
<li><code>fmt.Errorf("%w: description", Sentinel)</code></li>
</ul>
<p></p>
<p>이것은 오류가 발생한 이유와 근본적인 원인을 알려주는 이야기를 만듭니다.</p>
<p>이것은 중요합니다. 왜냐하면 위 예제에서 보는 바와 같이 동일한 유형의 오류가 두 가지 다른 근본적인 이슈로 인해 발생할 수 있기 때문입니다. 따라서 설명이 우리가 정확히 무엇이 잘못되었는지와 그 이유를 정확히 찾게 도와줍니다.</p>
<h1>보너스: 에러를 기록하는 곳</h1>
<p>당신이 발견한 모든 오류를 기록해서는 안 된다는 것에 놀랄지도 모릅니다. 왜냐하면 로그가 아래와 같이 보이기 때문입니다.</p>
<p></p>
<pre><code class="hljs language-js">에러: <span class="hljs-attr">C</span>: 음수 값은 허용되지 않습니다
에러: <span class="hljs-attr">B</span>: <span class="hljs-attr">C</span>: 음수 값은 허용되지 않습니다
에러: <span class="hljs-attr">A</span>: <span class="hljs-attr">B</span>: <span class="hljs-attr">C</span>: 음수 값은 허용되지 않습니다
</code></pre>
<p>에러를 기록하는 곳은 반드시 "처리"할 수 있는 경우에만 해야 합니다. 여기서 처리란 호출자가 에러를 받아서 무언가 처리하고 계속 실행할 수 있도록 하는 것을 의미합니다.</p>
<p>전형적인 예시는 다시 말해 REST 핸들러일 것입니다. REST 핸들러가 에러를 받으면 해당 에러의 타입을 살펴보고, 적절한 상태 코드로 응답을 보내고 에러 전파를 중단할 수 있습니다.</p>
<pre><code class="hljs language-js">func <span class="hljs-title function_">getWalletBalance</span>(<span class="hljs-params"></span>) {
 wallet, err := <span class="hljs-title function_">getWalletFromDB</span>(id)

 <span class="hljs-keyword">if</span> err != nil {
  fmt.<span class="hljs-title class_">Printf</span>(<span class="hljs-string">"%w"</span>, err) <span class="hljs-comment">// 여기에서는 오직 에러를 로깅합니다</span>
 }

 <span class="hljs-keyword">if</span> errors.<span class="hljs-title class_">Is</span>(err, <span class="hljs-title class_">WalletDoesNotExistErr</span>) {
  <span class="hljs-comment">// 404 반환</span>
 } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> errors.<span class="hljs-title class_">Is</span>(err, <span class="hljs-title class_">CouldNotGetWalletErr</span>) {
  <span class="hljs-comment">// 500 반환</span>
 }
}
</code></pre>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"고 오류 정복하기 오류 반환과 처리에 관한 안내","description":"","date":"2024-05-20 16:27","slug":"2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors","content":"\n## Go 오류 처리 마스터하기 위한 초보자 가이드\n\n![이미지](/assets/img/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors_0.png)\n\n# 레벨 1: if err != nil\n\n이것은 오류를 반환하는 가장 간단한 방법입니다. 대부분의 사람들은 이 패턴에 익숙합니다. 오류를 반환할 수 있는 함수를 호출하고, 오류가 nil인지 확인하고, nil이 아니면 오류를 반환합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```Go\nimport (\n \"errors\"\n \"fmt\"\n)\n\nfunc doSomething() (float64, error) {\n result, err := mayReturnError();\n if err != nil {\n  return 0, err\n }\n return result, nil\n}\n```\n\n## 이 방식의 문제점\n\n이 방식이 가장 간단하고 사실상 가장 많이 사용되는 방법이지만 중대한 문제점이 있습니다: 컨텍스트 부족. 깊은 호출 스택이 있는 경우 어떤 함수가 오류를 발생시켰는지 알 수 없습니다.\n\nA() 함수가 B()를 호출하고, B()가 C()를 호출하고, C()가 다음과 같은 오류를 반환하는 호출 스택을 상상해보십시오:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npackage main\n\nimport (\n \"errors\"\n \"fmt\"\n)\n\nfunc A(x int) (int, error) {\n result, err := B(x)\n if err != nil {\n  return 0, err\n }\n return result * 3, nil\n}\n\nfunc B(x int) (int, error) {\n result, err := C(x)\n if err != nil {\n  return 0, err\n }\n return result + 2, nil\n}\n\nfunc C(x int) (int, error) {\n if x \u003c 0 {\n  return 0, errors.New(\"negative value not allowed\")\n }\n return x * x, nil\n}\n\nfunc main() {\n // Call function A with invalid input\n result, err := A(-2)\n if err == nil {\n  fmt.Println(\"결과:\", result)\n } else {\n  fmt.Println(\"에러:\", err)\n }\n}\n```\n\n만약 이 프로그램을 실행하면 다음과 같이 출력됩니다.\n\n```js\n에러: negative value not allowed\n```\n\n우리는 호출 스택에서 이 오류가 어디에서 발생했는지에 대한 컨텍스트가 없습니다. 특정 오류 문자열을 찾아 해당 오류가 어디에서 발생했는지를 알아내기 위해 프로그램을 코드 편집기에서 열어야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 레벨 2: 에러 감싸기\n\n에러에 대한 컨텍스트를 추가하기 위해 fmt.Errorf를 사용하여 에러를 감싸줍니다.\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc A(x int) (int, error) {\n\tresult, err := B(x)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"A: %w\", err)\n\t}\n\treturn result * 3, nil\n}\n\nfunc B(x int) (int, error) {\n\tresult, err := C(x)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"B: %w\", err)\n\t}\n\treturn result + 2, nil\n}\n\nfunc C(x int) (int, error) {\n\tif x \u003c 0 {\n\t\treturn 0, fmt.Errorf(\"C: %w\", errors.New(\"음수 값은 허용되지 않습니다\"))\n\t}\n\treturn x * x, nil\n}\n\nfunc main() {\n\t// 잘못된 입력으로 함수 A를 호출합니다.\n\tresult, err := A(-2)\n\tif err == nil {\n\t\tfmt.Println(\"결과:\", result)\n\t} else {\n\t\tfmt.Println(\"에러:\", err)\n\t}\n}\n```\n\n이 프로그램을 실행하면 아래와 같은 출력을 얻게 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n오류: A: B: C: 음수 값은 허용되지 않습니다\n```\n\n이제 우리는 콜 스택을 이해했습니다.\n\n하지만 여전히 문제가 있습니다.\n\n## 이 방법의 문제\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n에러가 발생한 위치를 알게 되었지만 여전히 어떤 부분이 잘못되었는지는 알 수 없습니다.\n\n# Level 3: 세부적인 에러\n\n에러가 충분히 설명이 되지 않았습니다. 이것을 보다 복잡한 예제로 보여주기 위해 다음과 같이 조금 더 복잡한 예제가 필요합니다.\n\n```js\nimport (\n \"errors\"\n \"fmt\"\n)\n\nfunc DoSomething() (int, error) {\n result, err := DoSomethingElseWithTwoSteps()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomething: %w\", err)\n }\n return result * 3, nil\n}\n\nfunc DoSomethingElseWithTwoSteps() (int, error) {\n stepOne, err := StepOne()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomethingElseWithTwoSteps:%w\", err)\n }\n\n stepTwo, err := StepTwo()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomethingElseWithTwoSteps: %w\", err)\n }\n\n return stepOne + StepTwo, nil\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예시에서 오류가 반환되면 어떤 작업이 실패했는지 명확하지 않습니다. StepOne인지 StepTwo인지 알 수 없습니다. 동일한 오류인 Error: DoSomething: DoSomethingElseWithTwoSteps: UnderlyingError가 발생합니다.\n\n그 문제를 해결하려면 발생한 구체적인 문제에 대한 문맥을 추가해야 합니다.\n\n```js\nimport (\n \"errors\"\n \"fmt\"\n)\n\nfunc DoSomething() (int, error) {\n result, err := DoSomethingElseWithTwoSteps()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomething: %w\", err)\n }\n return result * 3, nil\n}\n\nfunc DoSomethingElseWithTwoSteps() (int, error) {\n stepOne, err := StepOne()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomethingElseWithTwoSteps: StepOne: %w\", err)\n }\n\n stepTwo, err := StepTwo()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomethingElseWithTwoSteps: StepTwo: %w\", err)\n }\n\n return stepOne + StepTwo, nil\n}\n```\n\n이제 StepOne이 실패하면 Error: DoSomething: DoSomethingElseWithTwoSteps: StepOne failed: UnderlyingError를 반환합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 이 방법의 문제점\n\n이 오류는 이제 함수 이름을 사용하여 호출 스택을 표현합니다. 그러나 오류의 본질을 표현하지는 않습니다. 오류는 이야기를 전달해야 합니다.\n\n좋은 예는 HTTP 상태 코드입니다. 404를 받으면 원하는 리소스가 존재하지 않음을 알 수 있습니다.\n\n# 레벨 4: 오류 표식\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n에러 센티널은 재사용할 수 있는 미리 정의된 오류 상수입니다.\n\n함수가 실패할 수 있는 원인은 다양할 수 있지만, 일반적으로 4가지 카테고리로 나눌 수 있습니다. \"찾을 수 없음\" 오류, \"이미 존재함\" 오류, \"실패한 전제조건\" 오류, 그리고 \"내부 오류\"입니다. 이는 gRPC 상태 코드에서 영감을 받았습니다. 각 카테고리를 한 문장으로 설명해 드릴게요.\n\n\"찾을 수 없음\" 오류: 호출자가 원하는 리소스가 존재하지 않습니다. 예시: 삭제된 게시물.\n\n\"이미 존재함\" 오류: 호출자가 생성하려는 리소스가 이미 존재합니다. 예시: 같은 이름을 가진 조직.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실패한 전제조건 오류: 작업 요청자가 실행하려는 작업이 실행 조건을 충족하지 않거나 나쁜 상태에 있습니다. 예시: 잔액이 0원인 계좌에서 출금을 시도하는 경우.\n\n내부 오류: 이러한 카테고리에 속하지 않는 다른 오류로 내부 오류가 발생한 경우입니다.\n\n이러한 종류의 오류만 가지고 있어도 충분하지 않습니다. 호출자에게 어떤 종류의 오류인지 알려주어야 합니다. 이를 위해 오류 센티널 및 errors.Is를 사용합니다.\n\n사용자가 지갑 잔액을 조회하고 업데이트할 수 있는 REST API가 있다고 상상해보세요. 데이터베이스에서 지갑을 조회할 때 오류 센티널을 활용하는 방법을 살펴봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport (\n \"fmt\"\n \"net/http\"\n \"errors\"\n)\n\n// 이것들은 에러를 표현하는 상수들입니다.\nvar (\n  WalletDoesNotExistErr = errors.New(\"지갑이 존재하지 않습니다\") // 발견되지 않은 에러 타입\n  CouldNotGetWalletErr = errors.New(\"지갑을 가져올 수 없습니다\") // 내부 에러 타입\n)\n\nfunc getWalletFromDB(id int) (int, error) {\n // 더미 구현: 데이터베이스에서 지갑을 검색하는 시뮬레이션\n balance, err := db.get(id)\n\n if err != nil {\n  if balance == nil {\n    return 0, fmt.Errorf(\"%w: Wallet(id:%s)가 존재하지 않습니다: %w\", WalletDoesNotExistErr, id, err)\n  } else {\n    return 0, fmt.Errorf(\"%w: 데이터베이스에서 Wallet(id:%s)를 가져올 수 없습니다: %w\", CouldNotGetWalletErr, id, err)\n  }\n }\n\n return *balance, nil\n}\n```\n\n이제 이제 REST 핸들러에서 다음과 같이 할 수 있는 것을 보여줍니다.\n\n```js\nfunc getWalletBalance() {\n wallet, err := getWalletFromDB(id)\n\n if errors.Is(err, WalletDoesNotExistErr) {\n  // 404 반환\n } else if errors.Is(err, CouldNotGetWalletErr) {\n  // 500 반환\n }\n}\n```\n\n다른 예제를 살펴보겠습니다. 사용자가 잔액을 업데이트하고자 하는 경우를 보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport (\n \"fmt\"\n \"net/http\"\n \"errors\"\n)\n\nvar (\n  WalletDoesNotExistErr = errors.New(\"Wallet does not exist\") // Not Found Error Type\n  CouldNotDebitWalletErr = errors.New(\"Could not debit Wallet\") // Internal Error Type\n  InsufficientWalletBalanceErr = errors.New(\"Insufficient balance in Wallet\") // Failed Precondition Error Type\n)\n\nfunc debitWalletInDB(id int, amount int) error {\n // Dummy implementation: simulate retrieving a wallet from a database\n balance, err := db.get(id)\n\n if err != nil {\n  if balance == nil {\n    return fmt.Errorf(\"%w: Wallet(id:%s) does not exist: %w\", WalletDoesNotExistErr, id, err)\n  } else {\n    return fmt.Errorf(\"%w: could not get Wallet(id:%s) from db: %w\", CouldNotDebitWalletErr, id, err)\n  }\n }\n\n if *balance \u003c= 0 {\n   return 0, fmt.Errorf(\"%w: Wallet(id:%s) balance is 0\", InsufficientWalletBalanceErr, id)\n }\n\n updatedBalance := *balance - amount\n\n // Dummy implementation: simulate updating a wallet in a database\n err := db.update(id, updatedBalance)\n\n if err != nil {\n   return fmt.Errorf(\"%w: could not update Wallet(id:%s) in db: %w\", CouldNotDebitWalletErr, id, err)\n }\n\n return nil\n}\n```\n\n## Using sentinels for better error messages\n\nYou might have noticed that I have a particular way of formatting errors. I prefer structuring an error message in one of two ways:\n\n- `fmt.Errorf(\"%w: description: %w\", Sentinel, err)` or\n- `fmt.Errorf(\"%w: description\", Sentinel)`\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 오류가 발생한 이유와 근본적인 원인을 알려주는 이야기를 만듭니다.\n\n이것은 중요합니다. 왜냐하면 위 예제에서 보는 바와 같이 동일한 유형의 오류가 두 가지 다른 근본적인 이슈로 인해 발생할 수 있기 때문입니다. 따라서 설명이 우리가 정확히 무엇이 잘못되었는지와 그 이유를 정확히 찾게 도와줍니다.\n\n# 보너스: 에러를 기록하는 곳\n\n당신이 발견한 모든 오류를 기록해서는 안 된다는 것에 놀랄지도 모릅니다. 왜냐하면 로그가 아래와 같이 보이기 때문입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n에러: C: 음수 값은 허용되지 않습니다\n에러: B: C: 음수 값은 허용되지 않습니다\n에러: A: B: C: 음수 값은 허용되지 않습니다\n```\n\n에러를 기록하는 곳은 반드시 \"처리\"할 수 있는 경우에만 해야 합니다. 여기서 처리란 호출자가 에러를 받아서 무언가 처리하고 계속 실행할 수 있도록 하는 것을 의미합니다.\n\n전형적인 예시는 다시 말해 REST 핸들러일 것입니다. REST 핸들러가 에러를 받으면 해당 에러의 타입을 살펴보고, 적절한 상태 코드로 응답을 보내고 에러 전파를 중단할 수 있습니다.\n\n```js\nfunc getWalletBalance() {\n wallet, err := getWalletFromDB(id)\n\n if err != nil {\n  fmt.Printf(\"%w\", err) // 여기에서는 오직 에러를 로깅합니다\n }\n\n if errors.Is(err, WalletDoesNotExistErr) {\n  // 404 반환\n } else if errors.Is(err, CouldNotGetWalletErr) {\n  // 500 반환\n }\n}\n```\n","ogImage":{"url":"/assets/img/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors_0.png"},"coverImage":"/assets/img/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors_0.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003eGo 오류 처리 마스터하기 위한 초보자 가이드\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e레벨 1: if err != nil\u003c/h1\u003e\n\u003cp\u003e이것은 오류를 반환하는 가장 간단한 방법입니다. 대부분의 사람들은 이 패턴에 익숙합니다. 오류를 반환할 수 있는 함수를 호출하고, 오류가 nil인지 확인하고, nil이 아니면 오류를 반환합니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-Go\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e (\n \u003cspan class=\"hljs-string\"\u003e\"errors\"\u003c/span\u003e\n \u003cspan class=\"hljs-string\"\u003e\"fmt\"\u003c/span\u003e\n)\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003edoSomething\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-type\"\u003efloat64\u003c/span\u003e, \u003cspan class=\"hljs-type\"\u003eerror\u003c/span\u003e) {\n result, err := mayReturnError();\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, err\n }\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result, \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e이 방식의 문제점\u003c/h2\u003e\n\u003cp\u003e이 방식이 가장 간단하고 사실상 가장 많이 사용되는 방법이지만 중대한 문제점이 있습니다: 컨텍스트 부족. 깊은 호출 스택이 있는 경우 어떤 함수가 오류를 발생시켰는지 알 수 없습니다.\u003c/p\u003e\n\u003cp\u003eA() 함수가 B()를 호출하고, B()가 C()를 호출하고, C()가 다음과 같은 오류를 반환하는 호출 스택을 상상해보십시오:\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epackage main\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e (\n \u003cspan class=\"hljs-string\"\u003e\"errors\"\u003c/span\u003e\n \u003cspan class=\"hljs-string\"\u003e\"fmt\"\u003c/span\u003e\n)\n\nfunc \u003cspan class=\"hljs-title function_\"\u003eA\u003c/span\u003e(x int) (int, error) {\n result, err := \u003cspan class=\"hljs-title function_\"\u003eB\u003c/span\u003e(x)\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != nil {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, err\n }\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result * \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, nil\n}\n\nfunc \u003cspan class=\"hljs-title function_\"\u003eB\u003c/span\u003e(x int) (int, error) {\n result, err := \u003cspan class=\"hljs-title function_\"\u003eC\u003c/span\u003e(x)\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != nil {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, err\n }\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result + \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, nil\n}\n\nfunc \u003cspan class=\"hljs-title function_\"\u003eC\u003c/span\u003e(x int) (int, error) {\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e x \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, errors.\u003cspan class=\"hljs-title class_\"\u003eNew\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"negative value not allowed\"\u003c/span\u003e)\n }\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e x * x, nil\n}\n\nfunc \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n \u003cspan class=\"hljs-comment\"\u003e// Call function A with invalid input\u003c/span\u003e\n result, err := \u003cspan class=\"hljs-title function_\"\u003eA\u003c/span\u003e(-\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err == nil {\n  fmt.\u003cspan class=\"hljs-title class_\"\u003ePrintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"결과:\"\u003c/span\u003e, result)\n } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n  fmt.\u003cspan class=\"hljs-title class_\"\u003ePrintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"에러:\"\u003c/span\u003e, err)\n }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 이 프로그램을 실행하면 다음과 같이 출력됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e에러: negative value not allowed\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 호출 스택에서 이 오류가 어디에서 발생했는지에 대한 컨텍스트가 없습니다. 특정 오류 문자열을 찾아 해당 오류가 어디에서 발생했는지를 알아내기 위해 프로그램을 코드 편집기에서 열어야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003e레벨 2: 에러 감싸기\u003c/h1\u003e\n\u003cp\u003e에러에 대한 컨텍스트를 추가하기 위해 fmt.Errorf를 사용하여 에러를 감싸줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-keyword\"\u003epackage\u003c/span\u003e main\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e (\n\t\u003cspan class=\"hljs-string\"\u003e\"errors\"\u003c/span\u003e\n\t\u003cspan class=\"hljs-string\"\u003e\"fmt\"\u003c/span\u003e\n)\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eA\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(x \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e, \u003cspan class=\"hljs-type\"\u003eerror\u003c/span\u003e) {\n\tresult, err := B(x)\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n\t\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, fmt.Errorf(\u003cspan class=\"hljs-string\"\u003e\"A: %w\"\u003c/span\u003e, err)\n\t}\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result * \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eB\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(x \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e, \u003cspan class=\"hljs-type\"\u003eerror\u003c/span\u003e) {\n\tresult, err := C(x)\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n\t\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, fmt.Errorf(\u003cspan class=\"hljs-string\"\u003e\"B: %w\"\u003c/span\u003e, err)\n\t}\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result + \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eC\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(x \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e, \u003cspan class=\"hljs-type\"\u003eerror\u003c/span\u003e) {\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e x \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n\t\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, fmt.Errorf(\u003cspan class=\"hljs-string\"\u003e\"C: %w\"\u003c/span\u003e, errors.New(\u003cspan class=\"hljs-string\"\u003e\"음수 값은 허용되지 않습니다\"\u003c/span\u003e))\n\t}\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e x * x, \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n\t\u003cspan class=\"hljs-comment\"\u003e// 잘못된 입력으로 함수 A를 호출합니다.\u003c/span\u003e\n\tresult, err := A(\u003cspan class=\"hljs-number\"\u003e-2\u003c/span\u003e)\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err == \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n\t\tfmt.Println(\u003cspan class=\"hljs-string\"\u003e\"결과:\"\u003c/span\u003e, result)\n\t} \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n\t\tfmt.Println(\u003cspan class=\"hljs-string\"\u003e\"에러:\"\u003c/span\u003e, err)\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 프로그램을 실행하면 아래와 같은 출력을 얻게 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e오류: \u003cspan class=\"hljs-attr\"\u003eA\u003c/span\u003e: \u003cspan class=\"hljs-attr\"\u003eB\u003c/span\u003e: \u003cspan class=\"hljs-attr\"\u003eC\u003c/span\u003e: 음수 값은 허용되지 않습니다\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 우리는 콜 스택을 이해했습니다.\u003c/p\u003e\n\u003cp\u003e하지만 여전히 문제가 있습니다.\u003c/p\u003e\n\u003ch2\u003e이 방법의 문제\u003c/h2\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e에러가 발생한 위치를 알게 되었지만 여전히 어떤 부분이 잘못되었는지는 알 수 없습니다.\u003c/p\u003e\n\u003ch1\u003eLevel 3: 세부적인 에러\u003c/h1\u003e\n\u003cp\u003e에러가 충분히 설명이 되지 않았습니다. 이것을 보다 복잡한 예제로 보여주기 위해 다음과 같이 조금 더 복잡한 예제가 필요합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e (\n \u003cspan class=\"hljs-string\"\u003e\"errors\"\u003c/span\u003e\n \u003cspan class=\"hljs-string\"\u003e\"fmt\"\u003c/span\u003e\n)\n\nfunc \u003cspan class=\"hljs-title class_\"\u003eDoSomething\u003c/span\u003e() (int, error) {\n result, err := \u003cspan class=\"hljs-title class_\"\u003eDoSomethingElseWithTwoSteps\u003c/span\u003e()\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != nil {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, fmt.\u003cspan class=\"hljs-title class_\"\u003eErrorf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"DoSomething: %w\"\u003c/span\u003e, err)\n }\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result * \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, nil\n}\n\nfunc \u003cspan class=\"hljs-title class_\"\u003eDoSomethingElseWithTwoSteps\u003c/span\u003e() (int, error) {\n stepOne, err := \u003cspan class=\"hljs-title class_\"\u003eStepOne\u003c/span\u003e()\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != nil {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, fmt.\u003cspan class=\"hljs-title class_\"\u003eErrorf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"DoSomethingElseWithTwoSteps:%w\"\u003c/span\u003e, err)\n }\n\n stepTwo, err := \u003cspan class=\"hljs-title class_\"\u003eStepTwo\u003c/span\u003e()\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != nil {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, fmt.\u003cspan class=\"hljs-title class_\"\u003eErrorf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"DoSomethingElseWithTwoSteps: %w\"\u003c/span\u003e, err)\n }\n\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e stepOne + \u003cspan class=\"hljs-title class_\"\u003eStepTwo\u003c/span\u003e, nil\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e이 예시에서 오류가 반환되면 어떤 작업이 실패했는지 명확하지 않습니다. StepOne인지 StepTwo인지 알 수 없습니다. 동일한 오류인 Error: DoSomething: DoSomethingElseWithTwoSteps: UnderlyingError가 발생합니다.\u003c/p\u003e\n\u003cp\u003e그 문제를 해결하려면 발생한 구체적인 문제에 대한 문맥을 추가해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e (\n \u003cspan class=\"hljs-string\"\u003e\"errors\"\u003c/span\u003e\n \u003cspan class=\"hljs-string\"\u003e\"fmt\"\u003c/span\u003e\n)\n\nfunc \u003cspan class=\"hljs-title class_\"\u003eDoSomething\u003c/span\u003e() (int, error) {\n result, err := \u003cspan class=\"hljs-title class_\"\u003eDoSomethingElseWithTwoSteps\u003c/span\u003e()\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != nil {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, fmt.\u003cspan class=\"hljs-title class_\"\u003eErrorf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"DoSomething: %w\"\u003c/span\u003e, err)\n }\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result * \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, nil\n}\n\nfunc \u003cspan class=\"hljs-title class_\"\u003eDoSomethingElseWithTwoSteps\u003c/span\u003e() (int, error) {\n stepOne, err := \u003cspan class=\"hljs-title class_\"\u003eStepOne\u003c/span\u003e()\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != nil {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, fmt.\u003cspan class=\"hljs-title class_\"\u003eErrorf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"DoSomethingElseWithTwoSteps: StepOne: %w\"\u003c/span\u003e, err)\n }\n\n stepTwo, err := \u003cspan class=\"hljs-title class_\"\u003eStepTwo\u003c/span\u003e()\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != nil {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, fmt.\u003cspan class=\"hljs-title class_\"\u003eErrorf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"DoSomethingElseWithTwoSteps: StepTwo: %w\"\u003c/span\u003e, err)\n }\n\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e stepOne + \u003cspan class=\"hljs-title class_\"\u003eStepTwo\u003c/span\u003e, nil\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 StepOne이 실패하면 Error: DoSomething: DoSomethingElseWithTwoSteps: StepOne failed: UnderlyingError를 반환합니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e이 방법의 문제점\u003c/h2\u003e\n\u003cp\u003e이 오류는 이제 함수 이름을 사용하여 호출 스택을 표현합니다. 그러나 오류의 본질을 표현하지는 않습니다. 오류는 이야기를 전달해야 합니다.\u003c/p\u003e\n\u003cp\u003e좋은 예는 HTTP 상태 코드입니다. 404를 받으면 원하는 리소스가 존재하지 않음을 알 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e레벨 4: 오류 표식\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e에러 센티널은 재사용할 수 있는 미리 정의된 오류 상수입니다.\u003c/p\u003e\n\u003cp\u003e함수가 실패할 수 있는 원인은 다양할 수 있지만, 일반적으로 4가지 카테고리로 나눌 수 있습니다. \"찾을 수 없음\" 오류, \"이미 존재함\" 오류, \"실패한 전제조건\" 오류, 그리고 \"내부 오류\"입니다. 이는 gRPC 상태 코드에서 영감을 받았습니다. 각 카테고리를 한 문장으로 설명해 드릴게요.\u003c/p\u003e\n\u003cp\u003e\"찾을 수 없음\" 오류: 호출자가 원하는 리소스가 존재하지 않습니다. 예시: 삭제된 게시물.\u003c/p\u003e\n\u003cp\u003e\"이미 존재함\" 오류: 호출자가 생성하려는 리소스가 이미 존재합니다. 예시: 같은 이름을 가진 조직.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e실패한 전제조건 오류: 작업 요청자가 실행하려는 작업이 실행 조건을 충족하지 않거나 나쁜 상태에 있습니다. 예시: 잔액이 0원인 계좌에서 출금을 시도하는 경우.\u003c/p\u003e\n\u003cp\u003e내부 오류: 이러한 카테고리에 속하지 않는 다른 오류로 내부 오류가 발생한 경우입니다.\u003c/p\u003e\n\u003cp\u003e이러한 종류의 오류만 가지고 있어도 충분하지 않습니다. 호출자에게 어떤 종류의 오류인지 알려주어야 합니다. 이를 위해 오류 센티널 및 errors.Is를 사용합니다.\u003c/p\u003e\n\u003cp\u003e사용자가 지갑 잔액을 조회하고 업데이트할 수 있는 REST API가 있다고 상상해보세요. 데이터베이스에서 지갑을 조회할 때 오류 센티널을 활용하는 방법을 살펴봅시다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e (\n \u003cspan class=\"hljs-string\"\u003e\"fmt\"\u003c/span\u003e\n \u003cspan class=\"hljs-string\"\u003e\"net/http\"\u003c/span\u003e\n \u003cspan class=\"hljs-string\"\u003e\"errors\"\u003c/span\u003e\n)\n\n\u003cspan class=\"hljs-comment\"\u003e// 이것들은 에러를 표현하는 상수들입니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e (\n  \u003cspan class=\"hljs-title class_\"\u003eWalletDoesNotExistErr\u003c/span\u003e = errors.\u003cspan class=\"hljs-title class_\"\u003eNew\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"지갑이 존재하지 않습니다\"\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// 발견되지 않은 에러 타입\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eCouldNotGetWalletErr\u003c/span\u003e = errors.\u003cspan class=\"hljs-title class_\"\u003eNew\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"지갑을 가져올 수 없습니다\"\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// 내부 에러 타입\u003c/span\u003e\n)\n\nfunc \u003cspan class=\"hljs-title function_\"\u003egetWalletFromDB\u003c/span\u003e(id int) (int, error) {\n \u003cspan class=\"hljs-comment\"\u003e// 더미 구현: 데이터베이스에서 지갑을 검색하는 시뮬레이션\u003c/span\u003e\n balance, err := db.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(id)\n\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != nil {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e balance == nil {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, fmt.\u003cspan class=\"hljs-title class_\"\u003eErrorf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"%w: Wallet(id:%s)가 존재하지 않습니다: %w\"\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eWalletDoesNotExistErr\u003c/span\u003e, id, err)\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, fmt.\u003cspan class=\"hljs-title class_\"\u003eErrorf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"%w: 데이터베이스에서 Wallet(id:%s)를 가져올 수 없습니다: %w\"\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eCouldNotGetWalletErr\u003c/span\u003e, id, err)\n  }\n }\n\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e *balance, nil\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 이제 REST 핸들러에서 다음과 같이 할 수 있는 것을 보여줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efunc \u003cspan class=\"hljs-title function_\"\u003egetWalletBalance\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n wallet, err := \u003cspan class=\"hljs-title function_\"\u003egetWalletFromDB\u003c/span\u003e(id)\n\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e errors.\u003cspan class=\"hljs-title class_\"\u003eIs\u003c/span\u003e(err, \u003cspan class=\"hljs-title class_\"\u003eWalletDoesNotExistErr\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 404 반환\u003c/span\u003e\n } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e errors.\u003cspan class=\"hljs-title class_\"\u003eIs\u003c/span\u003e(err, \u003cspan class=\"hljs-title class_\"\u003eCouldNotGetWalletErr\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 500 반환\u003c/span\u003e\n }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다른 예제를 살펴보겠습니다. 사용자가 잔액을 업데이트하고자 하는 경우를 보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e (\n \u003cspan class=\"hljs-string\"\u003e\"fmt\"\u003c/span\u003e\n \u003cspan class=\"hljs-string\"\u003e\"net/http\"\u003c/span\u003e\n \u003cspan class=\"hljs-string\"\u003e\"errors\"\u003c/span\u003e\n)\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e (\n  \u003cspan class=\"hljs-title class_\"\u003eWalletDoesNotExistErr\u003c/span\u003e = errors.\u003cspan class=\"hljs-title class_\"\u003eNew\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Wallet does not exist\"\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// Not Found Error Type\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eCouldNotDebitWalletErr\u003c/span\u003e = errors.\u003cspan class=\"hljs-title class_\"\u003eNew\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Could not debit Wallet\"\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// Internal Error Type\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eInsufficientWalletBalanceErr\u003c/span\u003e = errors.\u003cspan class=\"hljs-title class_\"\u003eNew\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Insufficient balance in Wallet\"\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// Failed Precondition Error Type\u003c/span\u003e\n)\n\nfunc \u003cspan class=\"hljs-title function_\"\u003edebitWalletInDB\u003c/span\u003e(id int, amount int) error {\n \u003cspan class=\"hljs-comment\"\u003e// Dummy implementation: simulate retrieving a wallet from a database\u003c/span\u003e\n balance, err := db.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(id)\n\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != nil {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e balance == nil {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e fmt.\u003cspan class=\"hljs-title class_\"\u003eErrorf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"%w: Wallet(id:%s) does not exist: %w\"\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eWalletDoesNotExistErr\u003c/span\u003e, id, err)\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e fmt.\u003cspan class=\"hljs-title class_\"\u003eErrorf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"%w: could not get Wallet(id:%s) from db: %w\"\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eCouldNotDebitWalletErr\u003c/span\u003e, id, err)\n  }\n }\n\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e *balance \u0026#x3C;= \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n   \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, fmt.\u003cspan class=\"hljs-title class_\"\u003eErrorf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"%w: Wallet(id:%s) balance is 0\"\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eInsufficientWalletBalanceErr\u003c/span\u003e, id)\n }\n\n updatedBalance := *balance - amount\n\n \u003cspan class=\"hljs-comment\"\u003e// Dummy implementation: simulate updating a wallet in a database\u003c/span\u003e\n err := db.\u003cspan class=\"hljs-title function_\"\u003eupdate\u003c/span\u003e(id, updatedBalance)\n\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != nil {\n   \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e fmt.\u003cspan class=\"hljs-title class_\"\u003eErrorf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"%w: could not update Wallet(id:%s) in db: %w\"\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eCouldNotDebitWalletErr\u003c/span\u003e, id, err)\n }\n\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e nil\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eUsing sentinels for better error messages\u003c/h2\u003e\n\u003cp\u003eYou might have noticed that I have a particular way of formatting errors. I prefer structuring an error message in one of two ways:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efmt.Errorf(\"%w: description: %w\", Sentinel, err)\u003c/code\u003e or\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efmt.Errorf(\"%w: description\", Sentinel)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e이것은 오류가 발생한 이유와 근본적인 원인을 알려주는 이야기를 만듭니다.\u003c/p\u003e\n\u003cp\u003e이것은 중요합니다. 왜냐하면 위 예제에서 보는 바와 같이 동일한 유형의 오류가 두 가지 다른 근본적인 이슈로 인해 발생할 수 있기 때문입니다. 따라서 설명이 우리가 정확히 무엇이 잘못되었는지와 그 이유를 정확히 찾게 도와줍니다.\u003c/p\u003e\n\u003ch1\u003e보너스: 에러를 기록하는 곳\u003c/h1\u003e\n\u003cp\u003e당신이 발견한 모든 오류를 기록해서는 안 된다는 것에 놀랄지도 모릅니다. 왜냐하면 로그가 아래와 같이 보이기 때문입니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e에러: \u003cspan class=\"hljs-attr\"\u003eC\u003c/span\u003e: 음수 값은 허용되지 않습니다\n에러: \u003cspan class=\"hljs-attr\"\u003eB\u003c/span\u003e: \u003cspan class=\"hljs-attr\"\u003eC\u003c/span\u003e: 음수 값은 허용되지 않습니다\n에러: \u003cspan class=\"hljs-attr\"\u003eA\u003c/span\u003e: \u003cspan class=\"hljs-attr\"\u003eB\u003c/span\u003e: \u003cspan class=\"hljs-attr\"\u003eC\u003c/span\u003e: 음수 값은 허용되지 않습니다\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e에러를 기록하는 곳은 반드시 \"처리\"할 수 있는 경우에만 해야 합니다. 여기서 처리란 호출자가 에러를 받아서 무언가 처리하고 계속 실행할 수 있도록 하는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e전형적인 예시는 다시 말해 REST 핸들러일 것입니다. REST 핸들러가 에러를 받으면 해당 에러의 타입을 살펴보고, 적절한 상태 코드로 응답을 보내고 에러 전파를 중단할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efunc \u003cspan class=\"hljs-title function_\"\u003egetWalletBalance\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n wallet, err := \u003cspan class=\"hljs-title function_\"\u003egetWalletFromDB\u003c/span\u003e(id)\n\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != nil {\n  fmt.\u003cspan class=\"hljs-title class_\"\u003ePrintf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"%w\"\u003c/span\u003e, err) \u003cspan class=\"hljs-comment\"\u003e// 여기에서는 오직 에러를 로깅합니다\u003c/span\u003e\n }\n\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e errors.\u003cspan class=\"hljs-title class_\"\u003eIs\u003c/span\u003e(err, \u003cspan class=\"hljs-title class_\"\u003eWalletDoesNotExistErr\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 404 반환\u003c/span\u003e\n } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e errors.\u003cspan class=\"hljs-title class_\"\u003eIs\u003c/span\u003e(err, \u003cspan class=\"hljs-title class_\"\u003eCouldNotGetWalletErr\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 500 반환\u003c/span\u003e\n }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors"},"buildId":"bb_yO9GbCvdfc_n71SfUf","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>